# 2019005陈皓的左耳听风R31.md

## 0300. 编程范式

1、编程范式，programming paradigm，范即模范之意，范式即模式、方法，是一类典型的编程风格，是指从事软件工程的一类典型的风格（可以对照「方法学」一词）。编程语言发展到今天，出现了好多不同的代码编写方式，但不同的方式解决的都是同一个问题，那就是如何写出更为通用、更具可重用性的代码或模块。

2、C++ 语言是如何通过泛型来解决 C 语言遇到的问题，其实这里面主要就是泛型编程和函数式编程的基本方法相关的细节。

## 0301编程范式游记1起源.md

程序 = 算法 + 数据，我觉得 C 语言会有这几个问题。1）一个通用的算法，需要对所处理的数据的数据类型进行适配。但在适配数据类型的过程中，C 语言只能使用 void* 或宏替换的方式，这两种方式导致了类型过于宽松，并带来很多其它问题。2）适配数据类型，需要 C 语言在泛型中加入一个类型的 size，这是因为我们识别不了被泛型后的数据类型，而 C 语言没有运行时的类型识别，所以，只能将这个工作抛给调用泛型算法的程序员来做了。3）算法其实是在操作数据结构，而数据则是放到数据结构中的。所以，真正的泛型除了适配数据类型外，还要适配数据结构。最后这个事情导致泛型算法的复杂急剧上升。比如容器内存的分配和释放，不同的数据体可能有非常不一样的内存分配和释放模型，再比如对象之间的复制，要把它存进来我需要有一个复制，这其中又涉及到是深拷贝，还是浅拷贝。4）最后，在实现泛型算法的时候，你会发现自己在纠结哪些东西应该抛给调用者处理，哪些又是可以封装起来。如何平衡和选择，并没有定论，也不好解决。

总体来说，C 语言设计目标是提供一种能以简易的方式编译、处理低层内存、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。C 语言也很适合搭配汇编语言来使用。C 语言把非常底层的控制权交给了程序员，它设计的理念是：1）相信程序员；2）不会阻止程序员做任何底层的事；3）保持语言的最小和最简的特性；4）保证 C 语言的最快的运行速度，那怕牺牲移值性。

从某种角度上来说，C 语言的伟大之处在于 —— 使用 C 语言的程序员在高级语言的特性之上还能简单地做任何底层上的微观控制。这是 C 语言的强大和优雅之处。也有人说，C 语言是高级语言中的汇编语言。不过，这只是在针对底层指令控制和过程式的编程方式。而对于更高阶更为抽象的编程模型来说，C 语言这种基于过程和底层的初衷设计方式就会成为它的短板。因为，在编程这个世界中，更多的编程工作是解决业务上的问题，而不是计算机的问题，所以，我们需要更为贴近业务更为抽象的语言。

说到这里，我想你会问，那 C 语言本会怎么去解决这些问题呢？简单点说，C 语言并没有解决这些问题，所以才有了后面的 C++ 等其他语言，下一篇文章中，我也会和你聊聊 C++ 是如何解决这些问题的。C 语言诞生于 1972 年，到现在已经有 45 年的历史，在它之后，C++、Java、C# 等语言前仆后继，一浪高过一浪，都在试图解决那个时代的那个特定问题，我们不能去否定某个语言，但可以确定的是，随着历史的发展，每一门语言都还在默默迭代，不断优化和更新。同时，也会有很多新的编程语言带着新的闪光耀眼的特性出现在我们面前。

再回过头来说，编程范式其实就是程序的指导思想，它也代表了这门语言的设计方向，我们并不能说哪种范式更为超前，只能说各有千秋。比如 C 语言就是过程式的编程语言，像 C 语言这样的过程式编程语言优点是底层灵活而且高效，特别适合开发运行较快且对系统资源利用率要求较高的程序，但我上面抛出的问题它在后来也没有试图去解决，因为编程范式的选择基本已经决定了它的「命运」。我们怎么解决上述 C 语言没有解决好的问题呢？

现在很多的文章和演讲都在谈架构，很少有人再会谈及编程范式。然而， 这些基础性和本质性的话题，却是非常非常重要的。一方面，我发现在一些语言争论上，有很多人对编程语言的认识其实并不深；另一方面，通过编程语言的范式，我们不但可以知道整个编程语言的发展史，而且还能提高自己的编程技能写出更好的代码。

我希望通过一系列的文章带大家漫游一下各式各样的编程范式。这一经历可能有些漫长，途中也会有各式各样的各种语言的代码。但是我保证这一历程对于一个程序员来说是非常有价值的，因为你不但可以对主流编程语言的一些特性有所了解，而且当我们到达终点的时候，你还能了解到编程的本质是什么。这一系列文章中有各种语言的代码，其中有 C、C++、Python、Java、Scheme、Go、JavaScript、Prolog 等。所以，如果要能跟上本文的前因后果，你要对这几门比较主流的语言多少有些了解。而且，你需要在一线编写一段时间（大概 5 年以上吧）的代码，可能才能体会到这一系列文章的内涵。

我根据每篇文章中所讲述的内容，将这一系列文章分为四个部分。第一部分：泛型编程，第 1-3 章，讨论了从 C 到 C++ 的泛型编程方法，并系统地总结了编程语言中的类型系统和泛型编程的本质。第二部分：函数式编程，第 4 章和第 5 章，讲述了函数式编程用到的技术，及其思维方式，并通过 Python 和 Go 修饰器的例子，展示了函数式编程下的代码扩展能力，以及函数的相互和随意拼装带来的好处。第三部分：面向对象编程，第 6-8 章，讲述与传统的编程思想相反，面向对象设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，列举了面向对象编程的优缺点，基于原型的编程范式，以及 Go 语言的委托模式。第四部分：编程本质和逻辑编程，第 9-11 章，先探讨了编程的本质：逻辑部分才是真正有意义的，控制部分只能影响逻辑部分的效率，然后结合 Prolog 语言介绍了逻辑编程范式，最后对程序世界里的编程范式进行了总结，对比了它们之间的不同。

下面我们来说说什么是编程范式。编程范式的英语是 programming paradigm，范即模范之意，范式即模式、方法，是一类典型的编程风格，是指从事软件工程的一类典型的风格（可以对照「方法学」一词）。编程语言发展到今天，出现了好多不同的代码编写方式，但不同的方式解决的都是同一个问题，那就是如何写出更为通用、更具可重用性的代码或模块。

1、先从 C 语言开始。为了讲清楚这个问题，我需要从 C 语言开始讲起。因为 C 语言历史悠久，而几乎现在看到的所有编程语言都是以 C 语言为基础来拓展的，不管是 C++、Java、C#、Go、Python、PHP、Perl、JavaScript、Lua，还是 Shell。自 C 语言问世 40 多年以来，其影响了太多太多的编程语言，到现在还一直被广泛使用，不得不佩服它的生命力。但是，我们也要清楚地知道，大多数 C Like 编程语言其实都是在改善 C 语言带来的问题。

那 C 语言有哪些特性呢？我简单来总结下：1）C 语言是一个静态弱类型语言，在使用变量时需要声明变量类型，但是类型间可以有隐式转换；2）不同的变量类型可以用结构体（struct）组合在一起，以此来声明新的数据类型；3）C 语言可以用 typedef 关键字来定义类型的别名，以此来达到变量类型的抽象；4）C 语言是一个有结构化程序设计、具有变量作用域以及递归功能的过程式语言；5）C 语言传递参数一般是以值传递，也可以传递指针；6）通过指针，C 语言可以容易地对内存进行低级控制，然而这引入了非常大的编程复杂度；7）编译预处理让 C 语言的编译更具有弹性，比如跨平台。

C 语言的这些特性，可以让程序员在微观层面写出非常精细和精确的编程操作，让程序员可以在底层和系统细节上非常自由、灵活和精准地控制代码。然而，在代码组织和功能编程上，C 语言的上述特性，却不那么美妙了。

2、从 C 语言的一个简单例子说起。我们从 C 语言最简单的交换两个变量的 swap 函数说起，参看下面的代码。

```c
void swap(int* x, int* y)
{
	int temp = *x;
	*x = *y;
	*y = tmp;
}
```

你可以想一想，这里为什么要传指针？这里是 C 语言指针，因为如果你不用指针的话，那么参数变成传值，即函数的形参是调用实参的一个拷贝，函数里面对形参的修改无法影响实参的结果。为了要达到调用完函数后，实参内容的交换，必须要把实参的地址传递进来，也就是传指针。这样在函数里面做交换，实际变量的值也被交换了。然而，这个函数最大的问题就是它只能给 int 值用，这个世界上还有很多类型包括 double、float，这就是静态语言最糟糕的一个问题。

3、数据类型与现实世界的类比。与现实世界类比一下，数据类型就好像螺帽一样，有多种接口方式：平口的、有十字的、有六角的等，而螺丝刀就像是函数，或是用来操作这些螺丝的算法或代码。我们发现，这些不同类型的螺帽（数据类型），需要我们为之适配一堆不同的螺丝刀。而且它们还有不同的尺寸（尺寸就代表它是单字节的，还是多字节的，比如整型的 int、long，浮点数的 float 和 double），这样复杂度一下就提高了，最终导致电工（程序员）工作的时候需要带下图这样的一堆工具。这就是类型为编程带来的问题。要解决这个问题，我们还是来看一下现实世界。

你应该见过下面图片中的这种经过优化的螺丝刀，上面手柄是一样的，拧螺丝的动作也是一样的，只是接口不一样。每次我看到这张图片的时候就在想，这密密麻麻的看着有 40 多种接口，不知道为什么人类世界要干出这么多的花样？你们这群人类究竟是要干什么啊。我们可以看到，无论是传统世界，还是编程世界，我们都在干一件事情，什么事呢？那就是通过使用一种更为通用的方式，用另外的话说就是抽象和隔离，让复杂的「世界」变得简单一些。

然而，要做到抽象，对于 C 语言这样的类型语言来说，首当其冲的就是抽象类型，这就是所谓的 —— 泛型编程。另外，我们还要注意到，在编程世界里，对于 C 语言来说，类型还可以转换。编译器会使用一切方式来做类型转换，因为类型转换有时候可以让我们编程更方便一些，也让相近的类型可以做到一点点的泛型。

然而，对于 C 语言的类型转换，是会出很多问题的。比如说，传给我一个数组，这个数组本来是 double 的，或者是 long 64 位的，但是如果把数组类型强转成 int，那么就会出现很多问题，因为这会导致程序遍历数组的步长不一样了。比如：一个 double a[10] 的数组，a[2] 意味着 a + sizeof(double) * 2。如果你把 a 强转成 int，那么 a[2] 就意味着 a + sizeof(int) * 2。我们知道 sizeof(double) 是 8，而 sizeof(int) 是 4。于是访问到了不同的地址和内存空间，这就导致程序出现严重的问题。

4、C 语言的泛型。一个泛型的示例 - swap 函数。我们再看下 C 语言是如何泛型的。C 语言的类型泛型基本上来说就是使用 void \*关键字或是使用宏定义。下面是一个使用了 void*泛型版本的 swap 函数。

```c
void swap(void* x, void* y, size_t size)
{
     char tmp[size];
     memcpy(tmp, y, size);
     memcpy(y, x, size);
     memcpy(x, tmp, size);
}
```

上面这个函数几乎完全改变了 int 版的函数的实现方式，这个实现方式有三个重点：1）函数接口中增加了一个 size 参数。为什么要这么干呢？因为，用了 void* 后，类型被「抽象」掉了，编译器不能通过类型得到类型的尺寸了，所以，需要我们手动地加上一个类型长度的标识。2）函数的实现中使用了 memcpy() 函数。为什么要这样干呢？还是因为类型被「抽象」掉了，所以不能用赋值表达式了，很有可能传进来的参数类型还是一个结构体，因此，为了要交换这些复杂类型的值，我们只能使用内存复制的方法了。3）函数的实现中使用了一个 temp[size] 数组。这就是交换数据时需要用的 buffer，用 buffer 来做临时的空间存储。

于是，新增的 size 参数，使用的 memcpy 内存拷贝以及一个 buffer，这增加了编程的复杂度。这就是 C 语言的类型抽象所带来的复杂度的提升。在提升复杂度的同时，我们发现还有问题，比如，我们想交换两个字符串数组，类型是：char\*，那么，我的 swap() 函数的 x 和 y 参数是不是要用 void**了？这样一来，接口就没法定义了。除了使用 void\* 来做泛型，在 C 语言中，还可以用宏定义来做泛型，如下所示：

```c
#define swap(x, y, size) {\
	char temp[size]; \
	memcpy(temp, &y, size); \
	memcpy(&y,   &x, size); \
	memcpy(&x, temp, size); \
}
```

但用宏带来的问题就是编译器做字符串替换，因为宏是做字符串替换，所以会导致代码膨胀，导致编译出的执行文件比较大。不过对于 swap 这个简单的函数来说，用 void* 和宏替换来说都可以达到泛型。但是，如果我们不是 swap，而是 min() 或 max() 函数，那么宏替换的问题就会暴露得更多一些。比如，对于下面的这个宏：

```c
#define min(x, y)  （(x)>(y) ? (y) : (x)）
```

其中一个最大的问题，就是有可能会有重复执行的问题。如：1）min(i++, j++) 对于这个案例来说，我们本意是比较完后，对变量做累加，但是，因为宏替换的缘故，这会导致变量 i 或 j 被累加两次。2）min(foo(), bar()) 对于这个示例来说，我们本意是比较 foo() 和 bar() 函数的返回值，然而，经过宏替换后，foo() 或 bar() 会被调用两次，这会带来很多问题。另外，你会不会觉得无论是用哪种方式，这种「泛型」是不是太宽松了一些，完全不做类型检查，就是在内存上对拷，直接操作内存的这种方式，感觉是不是比较危险，而且就像一个定时炸弹一样，不知道什么时候，在什么条件下就爆炸了。

从上面的两个例子，我们可以发现，无论哪种方式，接口都变得复杂了 —— 加入了 size，因为如果不加入 size 的话，那么我们的函数内部就需要自己检查 size。然而，void* 这种地址的方式是没法得到 size 的。而宏定义的那种方式，虽然不会把类型给隐藏掉，可以使用像 sizeof(x) 这样的方式得到 size。但是如果类型是 char*，那么，使用 sizeof 方式只能提到指针类型的 size，而不是值的 size。另外，对于不同的类型，比如说 double 和 int，那应该用谁的 size 呢？是不是先转一下型呢？这些都是问题。于是，这种泛型，让我们根本没有办法检查传入参数的 size，导致我们只能增加接口复杂度，加入一个 size 参数，然后把这个问题抛给调用者了。

一个更为复杂的泛型示例 - Search 函数。如果我们把这个事情变得更复杂，写个 search 函数，再传一个 int 数组，然后想搜索 target，搜到返回数组下标，搜不到返回 -1。

```c
int search(int* a, size_t size, int target) {
	for(int i=0; i<size; i++) {
		if (a[i] == target) {
			return i;
		}
	}
	return -1;
}
```

我们可以看到，这个函数是类型 int 版的。如果我们要把这个函数变成泛型的应该怎么变呢？就像上面 swap() 函数那样，如果要把它变成泛型，我们需要变更并复杂化函数接口。1）我们需要在函数接口上增加一个 element size，也就是数组里面每个元素的 size。这样，当我们遍历数组的时候，可以通过这个 size 正确地移动指针到下一个数组元素。2）我还要加个 cmpFn。因为我要去比较数组里的每个元素和 target 是否相等。因为不同数据类型的比较的实现不一样，比如，整型比较用 == 就好了。但是如果是一个字符串数组，那么比较就需要用 strcmp 这类的函数。而如果你传一个结构体数组（如 Account 账号），那么比较两个数据对象是否一样就比较复杂了。所以，必须要自定义一个比较函数。最终我们的 search 函数的泛型版如下所示：

```c
int search(void* a, size_t size, void* target, 
	size_t elem_size, int(*cmpFn)(void*, void*) )
{
	for(int i=0; i<size; i++) {
		// why not use memcmp()
		// use unsigned char * to calculate the address
		if ( cmpFn ((unsigned char *)a + elem_size * i, target) == 0 ) {
			return i;
		}
	}
	return -1;
}
```

在上面的代码中，我们没有使用 memcmp() 函数，这是因为，如果这个数组是一个指针数组，或是这个数组是一个结构体数组，而结构体数组中有指针成员。我们想比较的是指针指向的内容，而不是指针这个变量。所以，用 memcmp() 会导致我们在比较指针（内存地址），而不是指针所指向的值。而调用者需要提供如下的比较函数：

```c
int int_cmp(int* x, int* y)
{
	return *x - *y;
}
 
int string_cmp(char* x, char* y){
	return strcmp(x, y);
}
如果面对有业务类型的结构体，可能会是这样的比较函数：

typedef struct _account {
	char name[10];
	char id[20];
} Account;
 
int account_cmp(Account* x, Account* y) {
	int n = strcmp(x->name, y->name);
	if (n != 0) return n;
	return strcmp(x->id, y->id);
}
```

我们的 C 语言干成这个样子，看上去还行，但是，上面的这个 search 函数只能用于数组这样的顺序型的数据容器（数据结构）。如果这个 search 函数能支持一些非顺序型的数据容器（数据结构），比如：堆、栈、哈希表、树、图。那么，用 C 语言来干基本上干不下去了，对于像 search() 这样的算法来说，数据类型的自适应问题就已经把事情搞得很复杂了。然而，数据结构的自适应就会把这个事的复杂度搞上几个数量级。

### 黑板墙

关于编程范式，超级喜欢《冒号课堂》那本书，两年前读的，真是相见恨晚。跟读大神的文章一样收获满满。

2『已下载书籍「2020093冒号课堂」。』

斯坦福大学的编程范式公开课很好。

## 0302编程范式游记2泛型编程.md

在这篇文章中，我们聊到 C++ 语言是如何通过泛型来解决 C 语言遇到的问题，其实这里面主要就是泛型编程和函数式编程的基本方法相关的细节，虽然解决编程语言中类型带来的问题可能有多种方式，不一定就是 C++ 这种方式。而我之所以从 C/C++ 开始，目的只是因为 C/C++ 都是比较偏底层的编程语言。从底层的原理上，我们可以更透彻地了解，从 C 到 C++ 的演进这一过程中带来的编程方式的变化。这可以让你看到，在静态类型语言方面解决泛型编程的一些技术和方法，从而感受到其中的奥妙和原理。因为形式是多样的，但是原理是相通的。所以，这个过程会非常有助于你更深刻地了解后面会谈到的更多的编程范式。

上一篇文章中从 C 语言开始说起，聊了聊面向过程式的编程范式，相信从代码的角度你对这类型的语言已经有了一些理解。作为一门高级语言，C 语言绝对是编程语言历史发展中的一个重要里程碑，但随着认知的升级，面向过程的 C 语言已经无法满足更高层次的编程的需要。于是，C++ 出现了。

1、C++ 语言。1980 年，AT&T 贝尔实验室的 Bjarne Stroustrup 创建的 C++ 语言横空出世，它既可以全面兼容 C 语言，又巧妙揉和了一些面向对象的编程理念。现在来看，不得不佩服 Stroustrup 的魄力。在这里，我也向你推荐一本书，书名是《C++ 语言的设计和演化》。这本书系统介绍了 C++ 诞生的背景以及初衷，书的作者就是 Stroustrup 本人，所以你可以非常详细地从语言创建者的角度了解他的设计思路和创新之旅。当然，就是在今天，C++ 这门语言也还有很多争议，这里我不细说。如果你感兴趣的话，可以看看我几年前在酷壳上发表的文章《[C++的坑真的多吗？ | | 酷 壳 - CoolShell](https://coolshell.cn/articles/7992.html)》。

2『已下载书籍「2019016C++语言的设计和演化」。已下载「0321C-plus-plis的坑真的多吗」作为专栏附件。』

从语言角度来说，实际上早期 C++ 的许多工作是对 C 的强化和净化，并把完全兼容 C 作为强制性要求（这也是 C++ 复杂晦涩的原因，这点 Java 就干得比 C++ 彻底得多）。在 C89、C99 这两个 C 语言的标准中，有许多改进都是从 C++ 中引进的。可见，C++ 对 C 语言的贡献非常之大。是的，因为 C++ 很大程度就是用来解决 C 语言中的各种问题和各种不方便的。比如：1）用引用来解决指针的问题。2）用 namespace 来解决名字空间冲突的问题。3）通过 try-catch 来解决检查返回值编程的问题。4）用 class 来解决对象的创建、复制、销毁的问题，从而可以达到在结构体嵌套时可以深度复制的内存安全问题。5）通过重载操作符来达到操作上的泛型。（比如，消除上一篇文章中提到的比较函数 cmpFn，再比如用 >> 操作符消除 printf() 的数据类型不够泛型的问题。）6）通过模板 template 和虚函数的多态以及运行时识别来达到更高层次的泛型和多态。7）用 RAII、智能指针的方式，解决了 C 语言中因为需要释放资源而出现的那些非常 ugly 也很容易出错的代码的问题。8）用 STL 解决了 C 语言中算法和数据结构的 N 多种坑。

2、C++ 泛型编程。C++ 是支持编程范式最多的一门语言，它虽然解决了很多 C 语言的问题，但我个人觉得它最大的意义是解决了 C 语言泛型编程的问题。因为，我们可以看到一些 C++ 的标准规格说明书里，有一半以上都在说明 STL 的标准规格应该是什么样的，这说明泛型编程是 C++ 重点中的重点。理想情况下，算法应是和数据结构以及类型无关的，各种特殊的数据类型理应做好自己分内的工作。算法只关心一个标准的实现。而对于泛型的抽象，我们需要回答的问题是，如果我们的数据类型符合通用算法，那么对数据类型的最小需求又是什么呢？我们来看看 C++ 是如何有效解决程序泛型问题的，我认为有三点。

第一，它通过类的方式来解决。1）类里面会有构造函数、析构函数表示这个类的分配和释放。2）还有它的拷贝构造函数，表示了对内存的复制。3）还有重载操作符，像我们要去比较大于、等于、不等于。这样可以让一个用户自定义的数据类型和内建的那些数据类型就很一致了。

第二，通过模板达到类型和算法的妥协。1）模板有点像 DSL，模板的特化会根据使用者的类型在编译时期生成那个模板的代码。2）模板可以通过一个虚拟类型来做类型绑定，这样不会导致类型转换时的问题。模板很好地取代了 C 时代宏定义带来的问题。

第三，通过虚函数和运行时类型识别。1）虚函数带来的多态在语义上可以支持「同一类」的类型泛型。2）运行时类型识别技术可以做到在泛型时对具体类型的特殊处理。这样一来，就可以写出基于抽象接口的泛型。

拥有了这些 C++ 引入的技术，我们就可以做到 C 语言很难做到的泛型编程了。正如前面说过的，一个良好的泛型编程需要解决如下几个泛型编程的问题：1）算法的泛型；2）类型的泛型；3）数据结构（数据容器）的泛型。

3、C++ 泛型编程的示例 —— Search 函数。就像前面的 search() 函数，里面的 for(int i=0; i<len; i++) 这样的遍历方式，只能适用于顺序型的数据结构的方式迭代，如：array、set、queue、list 和 link 等。并不适用于非顺序型的数据结构。如哈希表 hash table，二叉树 binary tree、图 graph 等这样数据不是按顺序存放的数据结构（数据容器）。所以，如果找不到一种泛型的数据结构的操作方式（如遍历、查找、增加、删除、修改……），那么，任何的算法或是程序都不可能做到真正意义上的泛型。

除了 search() 函数的「遍历操作」之外，还有 search 函数的返回值，是一个整型的索引下标。这个整型的下标对于「顺序型的数据结构」是没有问题的，但是对于「非顺序的数据结构」，在语义上都存在问题。比如，如果我要在一个 hash table 中查找一个 key，返回什么呢？一定不是返回「索引下标」，因为在 hash table 这样的数据结构中，数据的存放位置不是顺序的，而且还会因为容量不够的问题被重新 hash 后改变，所以返回数组下标是没有意义的。对此，我们要把这个事做得泛型和通用一些。如果找到，返回找到的这个元素的一个指针（地址）会更靠谱一些。

所以，为了解决泛型的问题，我们需要动用以下几个 C++ 的技术。1）使用模板技术来抽象类型，这样可以写出类型无关的数据结构（数据容器）。2）使用一个迭代器来遍历或是操作数据结构内的元素。我们来看一下 C++ 版的 search() 函数是什么样的。先重温一下 C 语言版的代码：

```c
int search(void* a, size_t size, void* target, 
	size_t elem_size, int(*cmpFn)(void*, void*) )
{
	for(int i=0; i < size; i++) {
		if ( cmpFn (a + elem_size * i, target) == 0 ) {
			return i;
		}
	}
	return -1;
}
```

我们再来看一下 C++ 泛型版的代码：

```c
template<typename T, typename Iter>
Iter search(Iter pStart, Iter pEnd, T target) 
{
	for(Iter p = pStart; p != pEnd; p++) {
		if ( *p == target ) 
			return p;
	}
	return NULL;
}
```

在 C++ 的泛型版本中，我们可以看到：1）使用 typename T 抽象了数据结构中存储数据的类型。2）使用 typename Iter，这是不同的数据结构需要自己实现的「迭代器」，这样也就抽象掉了不同类型的数据结构。3）然后，我们对数据容器的遍历使用了 Iter 中的 ++ 方法，这是数据容器需要重载的操作符，这样通过操作符重载也就泛型掉了遍历。4）在函数的入参上使用了 pStart 和 pEnd 来表示遍历的起止。5）使用 *Iter 来取得这个「指针」的内容。这也是通过重载 * 取值操作符来达到的泛型。

当然，你可能会问，为什么我们不用标准接口 Iter.Next() 取代 ++， 用 Iter.GetValue() 来取代 *，而是通过重载操作符？其实这样做是为了兼容原有 C 语言的编程习惯。说明一下，所谓的 Iter，在实际代码中，就是像 vector\<int>::iterator 或 map\<int, string>::iterator 这样的东西。这是由相应的数据容器来实现和提供的。

注：下面是 C++ STL 中的 find() 函数的代码。

```c
template<class InputIterator, class T>
  InputIterator find (InputIterator first, InputIterator last, const T& val)
{
  while (first != last) {
    if (*first == val) return first;
    ++first;
  }
  return last;
}
```

4、C++ 泛型编程示例 - Sum 函数。也许你觉得到这一步，我们的泛型设计就完成了。其实，还远远不够。search 函数只是一个开始，我们还有很多别的算法会让问题变得更为复杂。我们再来看一个 sum() 函数。先看 C 语言版：

```c
long sum(int *a, size_t size) {
	long result = 0;
	for(int i=0; i < size; i++) {
		result += a[i];
	}
	return result;
}
```

再看一下 C++ 泛型的版本：

```c
template<typename T, typename Iter>
T sum(Iter pStart, Iter pEnd) {
	T result = 0;
	for(Iter p = pStart; p != pEnd; p++) {
		result += *p;
	}
	return result;	
}
```

你看到了什么样的问题？这个代码中最大的问题就是 T result = 0; 这条语句：1）那个 0 假设了类型是 int；2）那个 T 假设了 Iter 中出来的类型是 T。这样的假设是有问题的，如果类型不一样，就会导致转型的问题，这会带来非常 buggy 的代码。那么，我们怎么解决呢？

6、C++ 泛型编程的重要技术 —— 迭代器。我们知道 Iter 在实际调用者那会是一个具体的像 vector\<int>::iterator 这样的东西。在这个声明中，int 已经被传入 Iter 中了。所以，定义 result 的 T 应该可以从 Iter 中来。这样就可以保证类型是一样的，而且不会有被转型的问题。所以，我们需要精心地实现一个「迭代器」。下面是一个「精简版」的迭代器（我没有把 C++ STL 代码里的迭代器列出来，是因为代码太多太复杂，我这里只是为了说明问题）。

```c
template <class T>
class container {
public:
	class iterator {
	public:
		typedef iterator self_type;
		typedef T   value_type;
		typedef T*  pointer;
		typedef T& 	reference;
 
		reference operator*();
		pointer operator->();
		bool operator==(const self_type& rhs)；
		bool operator!=(const self_type& rhs)；
		self_type operator++() { self_type i = *this; ptr_++; return i; }
		self_type operator++(int junk) { ptr_++; return *this; }
		...
		...
	private:
		pointer _ptr;
	};
 
	iterator begin();
	iterator end();
	...
	...
};
```

上面的代码是我写的一个迭代器（这个迭代器在语义上是没有问题的），我没有把所有的代码列出来，而把它的一些基本思路列了出来。这里我说明一下几个关键点。1）首先，一个迭代器需要和一个容器在一起，因为里面是对这个容器的具体的代码实现。2）它需要重载一些操作符，比如：取值操作 \*、成员操作 ->、比较操作 == 和 !=，还有遍历操作 ++，等等。3）然后，还要 typedef 一些类型，比如 value_type，告诉我们容器内的数据的实际类型是什么样子。4）还有一些，如 begin() 和 end() 的基本操作。5）我们还可以看到其中有一个 pointer _ptr 的内部指针来指向当前的数据（注意，pointer 就是 T*）。

好了，有了这个迭代器后，我们还要解决 T result = 0 后面的这个 0 的问题。这个事，算法没有办法搞定，最好由用户传入。于是出现了下面最终泛型的 sum() 版函数。

```c
template <class Iter>
typename Iter::value_type
sum(Iter start, Iter end, T init) {
	typename Iter::value_type result = init;
	while (start != end) {
		result = result + *start;
		start++;
	}
	return result;
}
```

我们可以看到 typename Iter::value_type result = init 这条语句是关键。我们解决了所有的问题。我们如下使用：

```c
container<int> c;
container<int>::iterator it = c.begin();
sum(c.begin(), c.end(), 0);
```

这就是整个 STL 的泛型方法，其中包括：1）泛型的数据容器；2）泛型数据容器的迭代器；3）然后泛型的算法就很容易写了。

需要更多的抽象，更为复杂的需求。但是，还能不能做到更为泛型呢？比如：如果我们有这样的一个数据结构 Employee，里面有 vacation 就是休假多少天，以及工资。

2『「需要更多的抽象，更为复杂的需求。」做一张金句卡片。』

```c
struct Employee {
	string name;
	string id;
	int vacation;
	double salary；
};
```

现在我想计算员工的总薪水，或是总休假天数。

```c
vector<Employee> staff;
//total salary or total vacation days?
sum(staff.begin(), staff.end(), 0);
```

我们的 sum 完全不知道怎么搞了，因为要累加的是 Employee 类中的不同字段，即便我们的 Employee 中重载了 + 操作，也不知道要加哪个字段。另外，我们可能还会有：求平均值 average，求最小值 min，求最大值 max，求中位数 mean 等等。你会发现，算法写出来基本上都是一样的，只是其中的「累加」操作变成了另外一个操作。就这个例子而言，我想计算员工薪水里面最高的，和休假最少的，或者我想计算全部员工的总共休假多少天。那么面对这么多的需求，我们是否可以泛型一些呢？怎样解决这些问题呢？

6、更高维度的抽象。要解决这个问题，我希望我的这个算法只管遍历，具体要干什么，那是业务逻辑，由外面的调用方来定义我就好了，和我无关。这样一来，代码的重用度就更高了。下面是一个抽象度更高的版本，这个版本再叫 sum 就不太合适了。这个版本应该是 reduce —— 用于把一个数组 reduce 成一个值。

```c
template<class Iter, class T, class Op>
T reduce (Iter start, Iter end, T init, Op op) {
	T result = init;
	while ( start != end ) {
		result = op( result, *start );
		start++;
	}
	return result;
}
```
 
上面的代码中，我们需要传一个函数进来。在 STL 中，它是个函数对象，我们还是这套算法，但是 result 不是像前面那样去加，是把整个迭代器值给你一个 operation，然后由它来做。我把这个方法又拿出去了，所以就会变成这个样子。在 C++ STL 中，与我的这个 reduce 函数对应的函数名叫 accumulate()，其实际代码有两个版本。第一个版本就是上面的版本，只不过是用 for 语句而不是 while。

```c
template<class InputIt, class T>
T accumulate(InputIt first, InputIt last, T init)
{
    for (; first != last; ++first) {
        init = init + *first;
    }
    return init;
}
```

第二个版本，更为抽象，因为需要传入一个「二元操作函数」—— BinaryOperation op 来做 accumulate。accumulate 的语义比 sum 更抽象了。

```c
template<class InputIt, class T, class BinaryOperation>
T accumulate(InputIt first, InputIt last, T init, 
             BinaryOperation op)
{
    for (; first != last; ++first) {
        init = op(init, *first);
    }
    return init;
}
```

来看看我们在使用中是什么样子的：

```c
double sum_salaries = 
  reduce( staff.begin(), staff.end(), 0.0,
		  
		    {return s + e.salary;}  );
 
double max_salary =
  reduce( staff.begin(), staff.end(), 0.0,
		  
		    {return s > e.salary? s: e.salary; } );
```

注意：我这里用了 C++ 的 lambda 表达式。你可以很清楚地看到，reduce 这个函数就更通用了，具体要干什么样的事情呢？放在匿名函数里面，它会定义我，我只做一个 reduce。更抽象地来说，我就把一个数组，一个集合，变成一个值。怎么变成一个值呢？由这个函数来决定。

1『结合 JS 的 reduce() 去研读，有点这里是个切入口，可以帮自己弄清楚 reduce 函数的由来。（2020-09-12）』

7、Reduce 函数。我们来看看如何使用 reduce 和其它函数完成一个更为复杂的功能。下面这个示例中，我先定义了一个函数对象 counter。这个函数对象需要一个 Cond 的函数对象，它是个条件判断函数，如果满足条件，则加 1，否则加 0。

```c
template<class T, class Cond>
struct counter {
	size_t operator()(size_t c, T t) const {
		return c + (Cond(t) ? 1 : 0);
	}
};
```
然后，我用上面的 counter 函数对象和 reduce 函数共同来打造一个 counter_if 算法（当条件满足的时候我就记个数，也就是统计满足某个条件的个数），我们可以看到，就是一行代码的事。

```c
template<class Iter, class Cond>
size_t count_if(Iter begin, Iter end, Cond c){
	return reduce(begin, end, 0, 
				  counter<Iter::value_type, Cond>(c));
}
```

至于是什么样的条件，这个属于业务逻辑，不是我的流程控制，所以，这应该交给使用方。于是，当我需要统计薪资超过 1 万元的员工的数量时，一行代码就完成了。

```c
size_t cnt = count_if(staff.begin(), staff.end(), 
					{ return e.salary > 10000; });
```

Reduce 时可以只对结构体中的某些值做 Reduce，比如说只对 salary>10000 的人做，只选出这个里面的值，它用 Reduce 就可以达到这步，只要传不同的方式给它，你就可以又造出一个新的东西出来。说着说着，就到了函数式编程。函数式编程里面，我们可以用很多的像 reduce 这样的函数来完成更多的像 STL 里面的 count_if() 这样有具体意义的函数。关于函数式编程，我们会在后面继续具体聊。

### 黑板墙

《STL源码解析》，《inside c++model》，记得当时啃这两本时经常要感叹怎么设计的这么精妙，了解内部实现方式后，在使用的时候也更加心里有底。

泛型技术是静态系统所独有的特性，本质上我觉得还是为了兼顾执行效率和编程灵活性，实现零成本抽象这一刀尖上跳舞的巨大挑战。较新的语言标准还提炼了很多基础设施，比如大量使用 SFINAE 并泛化之，提供 enable if, constexpr if, 乃至自动类型推断和 concept check，和 Java 那边的套路是完全不一样的。可以说不深入理解泛型技术基本，就不能很好理解现代的 C++ 了。

C++ 通过范型消除了 C 语言中很多易出 bug 的代码，实现代码重用。其中关键在于：算法的泛型；类型的泛型；数据结构（数据容器）的泛型。C++ 通过类，在构造和析构函数中做资源的申请释放，通过引用解决了用指针来取值的问题。通过操作符的重载让算法代码忽略具体类型，可以有统一的表达。通过类似迭代器的范型容器来统一不同数据结构的统一算法表达。通过抽象算法中函数的操作，用函数式编程的方式，实现算法的泛型。总之，通过不同粒度的抽象，而让代码重用更容易，bug 更少，更好维护和扩展。

## 0303编程范式游记3类型系统和泛型的本质.md

编程语言本质上帮助程序员屏蔽底层机器代码的实现，而让我们可以更为关注于业务逻辑代码。但是因为，编程语言作为机器代码和业务逻辑的粘合层，是在让程序员可以控制更多底层的灵活性，还是屏蔽底层细节，让程序员可以更多地关注于业务逻辑，这是很难两全需要 trade-off 的事。所以，不同的语言在设计上都会做相应的取舍，比如：C 语言偏向于让程序员可以控制更多的底层细节，而 Java 和 Python 则让程序员更多地关注业务功能的实现。而 C++ 则是两者都想要，导致语言在设计上非常复杂。

在编程语言中，类型系统的出现主要是对容许混乱的操作加上了严格的限制，以避免代码以无效的数据使用方式编译或运行。例如，整数运算不可用于字符串；指针的操作不可用于整数上，等等。但是，类型的产生和限制，虽然对底层代码来说是安全的，但是对于更高层次的抽象产生了些负面因素。比如在 C++ 语言里，为了同时满足静态类型和抽象，就导致了模板技术的出现，带来了语言的复杂性。

我们讨论了从 C 到 C++ 的泛型编程方法，并且初探了更为抽象的函数式编程。正如在上一篇文章中所说的，泛型编程的方式并不只有 C++ 这一种类型，我们只是通过这个过程了解一下，底层静态类型语言的泛型编程原理。这样能够方便我们继续后面的历程。是的，除了 C++ 那样的泛型，如果你了解其它编程语言一定会发现，在动态类型语言或是某些有语法糖支持的语言中，那个 swap() 或 search() 函数的泛型其实可以很简单地就实现了。比如，你甚至可以把 swap() 函数简单地写成下面这个样子（包括 Go 语言也有这样的语法）：

```py
b, a = a, b;
```

在上一篇文章后面的 Reduce 函数中，可以看到，在编程世界中，我们需要处理好两件事：第一件事是编程语言中的类型问题。第二件事是对真实世界中业务代码的抽象、重用和拼装。所以，在这篇文章中，我们还是继续深入地讨论上面这两个问题，着重讨论一下编程语言中的类型系统和泛型编程的本质。

2『编程里要解决的 2 件事情：类型问题和代码的抽象、复用、拼装。做一张任意卡片。』——已完成

### 3.1 类型系统

在计算机科学中，类型系统用于定义如何将编程语言中的数值和表达式归类为许多不同的类型，以及如何操作这些类型，还有这些类型如何互相作用。类型可以确认一个值或者一组值，具有特定的意义和目的。一般来说，编程语言会有两种类型，一种是内建类型，如 int、float 和 char 等，一种是抽象类型，如 struct、class 和 function 等。抽象类型在程序运行中，可能不表示为值。类型系统在各种语言之间有非常大的不同，也许，最主要的差异存在于编译时期的语法，以及运行时期的操作实现方式。

编译器可能使用值的静态类型以最优化所需的存储区，并选取对数值运算时的最佳算法。例如，在许多 C 编译器中，「浮点数」数据类型是以 32 比特表示，与 IEEE 754 规格一致的单精度浮点数。因此，在数值运算上，C 应用了浮点数规范（浮点数加法、乘法等）。类型的约束程度以及评估方法，影响了语言的类型。更进一步讲，编程语言可能就类型多态性部分，对每一个类型都对应了一个针对于这个类型的算法运算。类型理论研究类型系统，尽管实际的编程语言类型系统，起源于计算机架构的实际问题、编译器实现，以及语言设计。

程序语言的类型系统主要提供如下的功能。1）程序语言的安全性。使用类型可以让编译器侦测一些代码的错误，例如：可以识别出一个错误无效的表达式，如 "Hello, World"+ 3 这样的不同数据类型间操作的问题。强类型语言提供更多的安全性，但是并不能保证绝对的安全。2）利于编译器的优化。静态类型语言的类型声明，可以让编译器明确地知道程序员的意图。因此，编译器就可以利用这一信息做很多代码优化工作。例如：如果我们指定一个类型是 int ，那么编译就知道，这个类型会以 4 个字节的倍数进行对齐，编译器就可以非常有效地利用更有效率的机器指令。3）代码的可读性。有类型的编程语言，可以让代码更易读和更易维护，代码的语义也更清楚，代码模块的接口（如函数）也更丰富和清楚。4）抽象化。类型允许程序设计者对程序以较高层次的方式思考，而不是烦人的低层次实现。例如，我们使用整型或是浮点型来取代底层的字节实现，我们可以将字符串设计成一个值，而不是底层字节的数组。从高层上来说，类型可以用来定义不同模块间的交互协议，比如函数的入参类型和返回类型，从而可以让接口更有语义，而且不同的模块数据交换更为直观和易懂。

但是，正如前面说的，类型带来的问题就是我们作用于不同类型的代码，虽然长得非常相似，但是由于类型的问题需要根据不同版本写出不同的算法，如果要做到泛型，就需要涉及比较底层的玩法。对此，这个世界出现了两类语言，一类是静态类型语言，如 C、C++、Java，一种是动态类型语言，如 Python、PHP、JavaScript 等。我们来看一下，一段动态类型语言的代码：

```c
x = 5;
x = "hello";
```

在这个示例中，我们可以看到变量 x 一开始好像是整型，然后又成了字符串型。如果在静态类型的语言中写出这样的代码，那么就会在编译期出错。而在动态类型的语言中，会以类型标记维持程序所有数值的「标记」，并在运算任何数值之前检查标记。所以，一个变量的类型是由运行时的解释器来动态标记的，这样就可以动态地和底层的计算机指令或内存布局对应起来。我们再来看一个示例，对于 JavaScript 这样的动态语言来说可以定义出下面这样的数据结构（一个数组的元素可以是各式各样的类型），这在静态类型的语言中是很难做到的。

```c
var a = new Array()
a[0] = 2017;
a[1] = "Hello";
a[2] = {name: "Hao Chen"};
```

注：其实，这并不是一个数组，而是一个 key:value。因为动态语言的类型是动态的，所以，key 和 value 的类型都可以随意。比如，对于 a 这个数据结构，还可以写成：a ["key"] = "value" 这样的方式。在弱类型或是动态类型的语言中，下面代码的执行会有不确定的结果。

```c
x = 5;
y = "37";
z = x + y;
```

有的像 Visual Basic 语言，给出的结果是 42：系统将字符串 "37" 转换成数字 37，以匹配运算上的直觉。而有的像 JavaScript 语言，给出的结果是 "537"：系统将数字 5 转换成字符串 "5" 并把两者串接起来。像 Python 这样的语言，则会产生一个运行时错误。但是，我们需要清楚地知道，无论哪种程序语言，都避免不了一个特定的类型系统。哪怕是可随意改变变量类型的动态类型的语言，我们在读代码的过程中也需要脑补某个变量在运行时的类型。

所以，每个语言都需要一个类型检查系统。1）静态类型检查是在编译器进行语义分析时进行的。如果一个语言强制实行类型规则（即通常只允许以不丢失信息为前提的自动类型转换），那么称此处理为强类型，反之称为弱类型。2）动态类型检查系统更多的是在运行时期做动态类型标记和相关检查。所以，动态类型的语言必然要给出一堆诸如：is_array(), is_int(), is_string() 或是 typeof() 这样的运行时类型检查函数。

2『强类型语言和弱类型语言，做一张术语卡片。』——已完成

总之，「类型」有时候是一个有用的事，有时候又是一件很讨厌的事情。因为类型是对底层内存布局的一个抽象，会让我们的代码要关注于这些非业务逻辑上的东西。而且，我们的代码需要在不同类型的数据间做处理。但是如果程序语言类型检查得过于严格，那么，我们写出来的代码就不能那么随意。所以，对于静态类型的语言也开了些「小后门」：比如，类型转换，还有 C++、Java 运行时期的类型测试。这些小后门也会带来相当讨厌的问题，比如下面这个 C 语言的示例。

```c
int x = 5;
char y[] = "37";
char* z = x + y;
```

在上面这个例子中，结果可能和你想的完全不一样。由于 C 语言的底层特性，这个例子中的 z 会指向一个超过 y 地址 5 个字节的内存地址，相当于指向 y 字符串的指针之后的两个空字符处。静态类型语言的支持者和动态类型自由形式的支持者，经常发生争执。前者主张，在编译的时候就可以较早发现错误，而且还可增进运行时期的性能。后者主张，使用更加动态的类型系统，分析代码更为简单，减少出错机会，才能更加轻松快速地编写程序。与此相关的是，后者还主张，考虑到在类型推断的编程语言中，通常不需要手动宣告类型，这部分的额外开销也就自动降低了。

在本系列内容的前两篇文章中，我们用 C/C++ 语言来做泛型编程的示例，似乎动态类型语言能够比较好地规避类型导致需要出现多个版本代码的问题，这样可以让我们更好地关注于业务。但是，我们需要清楚地明白，任何语言都有类型系统，只是动态类型语言在运行时做类型检查。动态语言的代码复杂度比较低，并可以更容易地关注业务，在某些场景下是对的，但有些情况下却并不见得。比如：在 JavaScript 中，我们需要做一个变量转型的函数，可能会是下面这个样子：

1『任何语言都有类型系统，只是动态语言是在运行时做的类型检验。』

```c
function ToNumber(x) {
    switch(typeof x) {
        case "number": return x;
        case "undefined": return NaN;
        case "boolean": return x ? 1 : 0;
        case "string": return Number(x); 
        case "object": return NaN;
        case "function": return NaN;    
    }
}
```

我相信，你在动态类型语言的代码中可以看到大量类似 typeof 这样的类型检查代码。是的，这是动态类型带来的另一个问题，就是运行时识别（这个是比较耗性能的）。如果你用过一段时间的动态类型语言，一旦代码量比较大了，我们就会发现，代码中出现「类型问题」而引发整个程序出错的情况实在是太多太多了。而且，这样的出错会让整个程序崩溃掉，太恐怖了。这个时候，我们就很希望提前发现这些类型的问题。静态语言的支持者会说编译器能帮我们找到这些问题，而动态语言的支持者则认为，静态语言的编译器也无法找到所有的问题，想真正提前找到问题只能通过测试来解决。其实他们都对。

1-2『如何用测试来找到类型问题呢？（2020-09-12）』

### 3.2 泛型的本质

要了解泛型的本质，就需要了解类型的本质。1）类型是对内存的一种抽象。不同的类型，会有不同的内存布局和内存分配的策略。2）不同的类型，有不同的操作。所以，对于特定的类型，也有特定的一组操作。

2『类型是对内存的抽象，做一张金句卡片。』——已完成

所以，要做到泛型，我们需要做下面的事情：1）标准化掉类型的内存分配、释放和访问。2）标准化掉类型的操作。比如：比较操作，I/O 操作，复制操作……3）标准化掉数据容器的操作。比如：查找算法、过滤算法、聚合算法……4）标准化掉类型上特有的操作。需要有标准化的接口来回调不同类型的具体操作……

所以，C++ 动用了非常繁多和复杂的技术来达到泛型编程的目标。1）通过类中的构造、析构、拷贝构造，重载赋值操作符，标准化（隐藏）了类型的内存分配、释放和复制的操作。2）通过重载操作符，可以标准化类型的比较等操作。3）通过 iostream，标准化了类型的输入、输出控制。4）通过模板技术（包括模板的特化），来为不同的类型生成类型专属的代码。5）通过迭代器来标准化数据容器的遍历操作。6）通过面向对象的接口依赖（虚函数技术），来标准化了特定类型在特定算法上的操作。7）通过函数式（函数对象），来标准化对于不同类型的特定操作。

通过学习 C++，我们可以看到一个比较完整的泛型编程里所涉及的编程范式，这些编程泛式在其它语言中都会或多或少地体现着。比如，JDK 5 引入的泛型类型，就源自 C++ 的模板。

泛型编程于 1985 年在论文 Generic Programming 中被这样定义：

Generic programming centers around the idea of abstracting from concrete, efficient algorithms to obtain generic algorithms that can be combined with different data representations to produce a wide variety of useful software. — Musser, David R.; Stepanov, Alexander A., Generic Programming

2『已下载原文「2020013Generic-programming」存入 zotero，并作为专栏附件「0322Generic-programming」。』

我理解其本质就是 —— 屏蔽掉数据和操作数据的细节，让算法更为通用，让编程者更多地关注算法的结构，而不是在算法中处理不同的数据类型。

### 黑板墙

这个系列除了了解不同的编程范式，最关注的是不同的编程范式如何设计，解决了什么问题。这些皓哥都点到了。我个人喜欢 Scala 这门语言，觉得它的设计非常优美，函数式编程和类型系统都是它的特点，希望皓哥这个系列或者答疑中能写写您的看法。

看到这一篇的时候，有点后悔当年没有仔细看一遍斯坦福的那个编程范式公开课了，似乎当时听了个开头，感觉比较简单，后来就放弃了。如果能早点梳理一下编程范式方面的内容，应该会对编程有很大的好处。即使经验不足的时候，能够有个大致的概念和方向，也会有相当大的方向。「类型是对内存的抽象」，这个可以算是本课金句了，让我能够更好的理解为什么会有类型系统这样的东西。以前可能更多的是隐隐约约的感性认识，这节课的内容算是捅破了窗户纸。「编程语言的本质是帮助程序员屏蔽机器代码的实现，而让我们可以更为关注于业务逻辑代码。」这句我也很认可。从另一个角度讲，因为不够熟悉编程语言，代码写的不够多，所以影响了我对于业务逻辑的实现。

之前看泛型这一块，什么类型系统，类型检查系统听起来模糊不理解，看了一下 JS 的相关文章，而且在项目中看到一个声明的变量，在由 null 变为 function 的一个操作过程中。结合动态语言，变量类型可以转换，而静态语言，声明了变量类型少了个类型检查系统，整个语言代码可以简洁不少。

## 0304编程范式游记4函数式编程.md

相对于计算机发展史，函数式编程是个非常古老的概念，它的核心思想是将运算过程尽量写成一系列嵌套的函数调用，关注的是做什么而不是怎么做，因而被称为声明式编程。以 Stateless（无状态）和 Immutable（不可变）为主要特点，代码简洁，易于理解，能便于进行并行执行，易于做代码重构，函数执行没有顺序上的问题，支持惰性求值，具有函数的确定性 —— 无论在什么场景下都会得到同样的结果。

本文结合递归、map 和 reduce，以及 pipeline 等技术，对比了非函数式编程和函数式编程在解决相同问题时的不同处理思路，让你对函数式编程范式有了清晰明确的认知。并在文末引入了 decorator（修饰器），使得将普通函数管道化成为一件轻而易举的事情。此时你可能有疑问，decorator 到底是什么呢？怎样使用它呢？敬请关注下一章中的内容，来得到这些答案。

从前三章内容中，我们了解到，虽然 C 语言简单灵活，能够让程序员在高级语言特性之上轻松进行底层上的微观控制，被誉为「高级语言中的汇编语言」，但其基于过程和底层的设计初衷又成了它的短板。在程序世界中，编程工作更多的是解决业务上的问题，而不是计算机的问题，我们需要更为贴近业务、更为抽象的语言，如典型的面向对象语言 C++ 和 Java 等。

C++ 很大程度上解决了 C 语言中的各种问题和不便，尤其是通过类、模板、虚函数和运行时识别等解决了 C 语言的泛型编程问题。然而，如何做更为抽象的泛型呢？答案就是函数式编程（Functional Programming）。

### 4.1 函数式编程

相对于计算机的历史而言，函数式编程其实是一个非常古老的概念。函数式编程的基础模型来源于 λ 演算，而 λ 演算并没有被设计在计算机上执行。它是由 Alonzo Church 和 Stephen Cole Kleene 在 20 世纪 30 年代引入的一套用于研究函数定义、函数应用和递归的形式系统。

Booleans, integers,  (and other  data structures) can be entirely replaced by functions.

如 Alonzo 所说，像 booleans、integers 或者其他的数据结构都可以被函数取代掉。我们来看一下函数式编程，它的理念就来自于数学中的代数。

```c
f(x)=5x^2+4x+3
g(x)=2f(x)+5=10x^2+8x+11
h(x)=f(x)+g(x)=15x^2+12x+14
```

假设 f(x) 是一个函数，g(x) 是第二个函数，把 f(x) 这个函数套下来，并展开。然后还可以定义一个由两个一元函数组合成的二元函数，还可以做递归，下面这个函数定义就是斐波那契数列。

```c
f(x)=f(x-1)+f(x-2)
```

对于函数式编程来说，它只关心定义输入数据和输出数据相关的关系，数学表达式里面其实是在做一种映射（mapping），输入的数据和输出的数据关系是什么样的，是用函数来定义的。

函数式编程有以下特点。

1、特征。1）stateless：函数不维护任何状态。函数式编程的核心精神是 stateless，简而言之就是它不能存在状态，打个比方，你给我数据我处理完扔出来。里面的数据是不变的。2）immutable：输入数据是不能动的，动了输入数据就有危险，所以要返回新的数据集。

2、优势。1）没有状态就没有伤害。2）并行执行无伤害。3）Copy-Paste 重构代码无伤害。4）函数的执行没有顺序上的问题。

函数式编程还带来了以下一些好处。

1、惰性求值。这需要编译器的支持，表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。也就是说，语句如 x:=expression;  （把一个表达式的结果赋值给一个变量）显式地调用这个表达式被计算并把结果放置到 x 中，但是先不管实际在 x 中的是什么，直到通过后面的表达式中到 x 的引用而有了对它的值的需求的时候，而后面表达式自身的求值也可以被延迟，最终为了生成让外界看到的某个符号而计算这个快速增长的依赖树。

2、确定性。所谓确定性，就是像在数学中那样，f(x) = y 这个函数无论在什么场景下，都会得到同样的结果，而不是像程序中的很多函数那样。同一个参数，在不同的场景下会计算出不同的结果，这个我们称之为函数的确定性。所谓不同的场景，就是我们的函数会根据运行中的状态信息的不同而发生变化。

我们知道，因为状态，在并行执行和 copy-paste 时引发 bug 的概率是非常高的，所以没有状态就没有伤害，就像没有依赖就没有伤害一样，并行执行无伤害，copy 代码无伤害，因为没有状态，代码怎样拷都行。

劣势：数据复制比较严重。

注：有一些人可能会觉得这会对性能造成影响。其实，这个劣势不见得会导致性能不好。因为没有状态，所以代码在并行上根本不需要锁（不需要对状态修改的锁），所以可以拼命地并发，反而可以让性能很不错。比如：Erlang 就是其中的代表。

对于纯函数式（也就是完全没有状态的函数）的编程来说，各个语言支持的程度如下：1）完全纯函数式 Haskell。2）容易写纯函数 F#, Ocaml, Clojure, Scala。3）纯函数需要花点精力 C#, Java, JavaScript。

完全纯函数的语言，很容易写成函数，纯函数需要花精力。只要所谓的纯函数的问题，传进来的数据不改，改完的东西复制一份拷出去，然后没有状态显示。但是很多人并不习惯函数式编程，因为函数式编程和过程式编程的思维方式完全不一样。过程式编程是在把具体的流程描述出来，所以可以不假思索，而函数式编程的抽象度更大，在实现方式上，有函数套函数、函数返回函数、函数里定义函数…… 把人搞得很糊涂。

### 4.2 函数式编程用到的技术

下面是函数式编程用到的一些技术。

1、first class function（头等函数） ：这个技术可以让你的函数就像变量一样来使用。也就是说，你的函数可以像变量一样被创建、修改，并当成变量一样传递、返回，或是在函数中嵌套函数。

2、tail recursion optimization（尾递归优化） ： 我们知道递归的害处，那就是如果递归很深的话，stack 受不了，并会导致性能大幅度下降。因此，我们使用尾递归优化技术 —— 每次递归时都会重用 stack，这样能够提升性能。当然，这需要语言或编译器的支持。Python 就不支持。

3、map & reduce ：这个技术不用多说了，函数式编程最常见的技术就是对一个集合做 Map 和 Reduce 操作。这比起过程式的语言来说，在代码上要更容易阅读。（传统过程式的语言需要使用 for/while 循环，然后在各种变量中把数据倒过来倒过去的）这个很像 C++ STL 中 foreach、find\_if、count\_if 等函数的玩法。

4、pipeline（管道）：这个技术的意思是，将函数实例成一个一个的 action，然后将一组 action 放到一个数组或是列表中，再把数据传给这个 action list，数据就像一个 pipeline 一样顺序地被各个函数所操作，最终得到我们想要的结果。

5、recursing（递归） ：递归最大的好处就简化代码，它可以把一个复杂的问题用很简单的代码描述出来。注意：递归的精髓是描述问题，而这正是函数式编程的精髓。

6、currying（柯里化） ：将一个函数的多个参数分解成多个函数，然后将函数多层封装起来，每层函数都返回一个函数去接收下一个参数，这可以简化函数的多个参数。在 C++ 中，这很像 STL 中的 bind1st 或是 bind2nd。

7、higher order function（高阶函数）：所谓高阶函数就是函数当参数，把传入的函数做一个封装，然后返回这个封装函数。现象上就是函数传进传出，就像面向对象对象满天飞一样。这个技术用来做 Decorator 很不错。

上面这些技术太抽象了，我们还是从一个最简单的例子开始。

```c
// 非函数式，不是pure funciton，有状态
int cnt;
void increment(){
    cnt++;
}
```

这里有个全局变量，调这个全局函数变量 ++，这里面是有状态的，这个状态在外部。所以，如果是多线程的话，这里面的代码是不安全的。如果写成纯函数，应该是下面这个样子。

```c
// 函数式，pure function， 无状态
int increment(int cnt){
    return cnt+1;
}
```

这个是你传给我什么，我就返回这个值的 +1 值，你会发现，代码随便拷，而且与线程无关，代码在并行时候不用锁，因为是复制了原有的数据，并返回了新的数据。我们再来看另一个例子：

```py
def inc(x):
    def incx(y):
        return x+y
    return incx
 
inc2 = inc(2)
inc5 = inc(5)
 
print inc2(5) # 输出 7
print inc5(5) # 输出 10
```

上面这段 Python 的代码，开始有点复杂了。我们可以看到上面那个例子 inc() 函数返回了另一个函数 incx()，于是可以用 inc() 函数来构造各种版本的 inc 函数，比如：inc2() 和 inc5()。这个技术其实就是上面所说的 currying 技术。从这个技术上，你可能体会到函数式编程的理念。

1、把函数当成变量来用，关注描述问题而不是怎么实现，这样可以让代码更易读。

2、因为函数返回里面的这个函数，所以函数关注的是表达式，关注的是描述这个问题，而不是怎么实现这个事情。

### 4.3 Lisp 语言介绍

要说函数式语言，不可避免地要说一下 Lisp。下面，我们再来看看 Scheme 语言（Lisp 的一个方言）的函数式玩法。在 Scheme 里，所有的操作都是函数，包括加减乘除这样的东西。所以，一个表达式是这样的形式 —— （函数名 参数 1 参数 1）

```c
(define (plus x y)  (+ x y))
(define (times x y) (* x y))
(define (square x)  (times x x))
```

上面三个函数：1）用内置的 + 函数定义了一个新的 plus 函数。2）用内置的 * 函数定义了一个新的 times 函数。3）用之前的 times 函数定义了一个 square 函数。

下面这个函数定义了： f (x) = 5 * x^2 +10

```
(define (f1 x) ;;; f(x) = 5 * x^2 + 10
    (plus 10 (times 5 (square x))))
```

也可以这样定义 —— 使用 lambda 匿名函数。

```c
(define f2
    (lambda (x)
        (define plus
            (lambda (a b) (+ a b)))
        (define times
            (lambda (a b) (* a b)))
        (plus 10 (times 5 (times x x)))))
```

在上面的这个代码里，我们使用 lambda 来定义函数 f2 ，然后也同样用 lambda 定义了两个函数 —— plus 和 times。最后，由 (plus 10 (times 5 (times x x))) 定义了 f2 。我们再来看一个阶乘的示例：

```c
;;; recursion
(define factoral (lambda (x)
    (if (<= x 1) 1
        (* x (factoral (- x 1))))))

(newline)
(display(factoral 6))
```

下面是另一个版本的，使用了尾递归。

```c
;;; another version of recursion
(define (factoral_x n)
    (define (iter product counter)
        (if (< counter n)
            product
            (iter (* counter product) (+ counter 1))))
    (iter 1 1))

(newline)
(display(factoral_x 5))
```

### 4.4 函数式编程的思维方式

前面提到过多次，函数式编程关注的是：describe what to do, rather than how to do it。于是，我们把以前的过程式编程范式叫做 Imperative Programming – 指令式编程，而把函数式编程范式叫做 Declarative Programming – 声明式编程。

#### 4.4.1 传统方式的写法

下面我们看一下相关的示例。比如，我们有 3 辆车比赛，简单起见，我们分别给这 3 辆车 70% 的概率让它们可以往前走一步，一共有 5 次机会，然后打出每一次这 3 辆车的前行状态。对于 Imperative Programming 来说，代码如下（Python）：

```py
from random import random
 
time = 5
car_positions = [1, 1, 1]
 
while time:
    # decrease time
    time -= 1
 
    print ''
    for i in range(len(car_positions)):
        # move car
        if random() > 0.3:
            car_positions[i] += 1
 
        # draw car
        print '-' * car_positions[i]
```

我们可以把这两重循环变成一些函数模块，这样有利于更容易地阅读代码：

```py
from random import random
 
def move_cars():
    for i, _ in enumerate(car_positions):
        if random() > 0.3:
            car_positions[i] += 1
 
def draw_car(car_position):
    print '-' * car_position
 
def run_step_of_race():
    global time
    time -= 1
    move_cars()
 
def draw():
    print ''
    for car_position in car_positions:
        draw_car(car_position)
 
time = 5
car_positions = [1, 1, 1]
 
while time:
    run_step_of_race()
    draw()
```

上面的代码，从主循环开始，我们可以很清楚地看到程序的主干，因为我们把程序的逻辑分成了几个函数。这样一来，代码逻辑就会变成几个小碎片，于是我们读代码时要考虑的上下文就少了很多，阅读代码也会更容易。不像第一个示例，如果没有注释和说明，你还是需要花些时间理解一下。而将代码逻辑封装成了函数后，我们就相当于给每个相对独立的程序逻辑取了个名字，于是代码成了自解释的。

但是，你会发现，封装成函数后，这些函数都会依赖于共享的变量来同步其状态。于是，在读代码的过程中，每当我们进入到函数里，读到访问了一个外部的变量时，我们马上要去查看这个变量的上下文，然后还要在大脑里推演这个变量的状态，才能知道程序的真正逻辑。也就是说，这些函数必须知道其它函数是怎么修改它们之间的共享变量的，所以，这些函数是有状态的。

#### 4.4.2 函数式的写法

我们知道，有状态并不是一件很好的事情，无论是对代码重用，还是对代码的并行来说，都是有副作用的。因此，要想个方法把这些状态搞掉，于是出现了函数式编程的编程范式。下面，我们来看看函数式的方式应该怎么写？

```py
from random import random
 
def move_cars(car_positions):
    return map(lambda x: x + 1 if random() > 0.3 else x,
               car_positions)
 
def output_car(car_position):
    return '-' * car_position
 
def run_step_of_race(state):
    return {'time': state['time'] - 1,
            'car_positions': move_cars(state['car_positions'])}
 
def draw(state):
    print ''
    print '\n'.join(map(output_car, state['car_positions']))
 
def race(state):
    draw(state)
    if state['time']:
        race(run_step_of_race(state))
 
race({'time': 5,
      'car_positions': [1, 1, 1]})
```

上面的代码依然把程序的逻辑分成了函数。不过这些函数都是函数式的，它们有三个特点：它们之间没有共享的变量；函数间通过参数和返回值来传递数据；在函数里没有临时变量。

我们还可以看到，for 循环被递归取代了（见 race 函数）—— 递归是函数式编程中常用到的技术，正如前面所说的，递归的本质就是描述问题是什么。

### 4.5 函数式语言的三套件

函数式语言有三套件，Map、Reduce 和 Filter。这在谈 C++ 的泛型编程时已经介绍过。下面我们来看一下 Python 语言中的一个示例。这个示例的需求是，我们想把一个字符串数组中的字符串都转成小写。用常规的面向过程的方式，代码如下所示：

```py
# 传统的非函数式
upname =['HAO', 'CHEN', 'COOLSHELL']
lowname =[] 
for i in range(len(upname)):
    lowname.append( upname[i].lower() )
```

如果写成函数式，用 map() 函数，是下面这个样子。

```py
# 函数式
def toUpper(item):
      return item.upper()
 
upper_name = map(toUpper, ["hao", "chen", "coolshell"])

print upper_name
# 输出 ['HAO', 'CHEN', 'COOLSHELL']
```

顺便说一下，上面的例子是不是和我们 C++ 语言中的 STL 的 transform () 函数有些像？

```py
string s="hello";
transform(s.begin(), s.end(), back_inserter(out), ::toupper);
```

在上面 Python 的那个例子中可以看到，我们定义了一个函数 toUpper，这个函数没有改变传进来的值，只是把传进来的值做个简单的操作，然后返回。然后，我们把它用在 map 函数中，就可以很清楚地描述出我们想要干什么，而不是去理解一个在循环中怎么实现的代码，最终在读了很多循环的逻辑后才发现是什么意思。

如果你觉得上面的代码在传统的非函数式的方式下还是很容易读的，那么我们再来看一个计算数组平均值的代码：

```py
# 计算数组中正数的平均值
num =  [2, -5, 9, 7, -2, 5, 3, 1, 0, -3, 8]
positive_num_cnt = 0
positive_num_sum = 0
for i in range(len(num)):
    if num[i] > 0:
        positive_num_cnt += 1
        positive_num_sum += num[i]
 
if positive_num_cnt > 0:
    average = positive_num_sum / positive_num_cnt
 
print average
```

上面的代码如果没有注释的话，你需要看一会儿才能明白，只是计算数组中正数的平均值。我们再来看看函数式下使用 filter/reduce 函数的玩法。

```py
#计算数组中正数的平均值
positive_num = filter(lambda x: x>0, num)
average = reduce(lambda x,y: x+y, positive_num) / len( positive_num )
```

首先，我们使用 filter 函数把正数过滤出来（注意： lambda x : x>0 这个 lambda 表达式），保存在一个新的数组中 —— positive_num。然后，我们使用 reduce 函数对数组 positive_num 求和后，再除以其个数，就得到正数的平均值了。

我们可以看到，隐藏了数组遍历并过滤数组控制流程的 filter 和 reduce，不仅让代码更为简洁，因为代码里只有业务逻辑了，而且让我们能更容易地理解代码。1）对 num 数组 filter 条件 x > 0 的数据。2）然后对 positive_num 进行  x + y 操作的 reduce，即求和……

感觉代码更亲切了，不是吗？因为：1）数据集、对数据的操作和返回值都放在了一起。2）没有了循环体，就可以少了些临时用来控制程序执行逻辑的变量，也少了把数据倒来倒去的控制逻辑。3）代码变成了在描述你要干什么，而不是怎么干。

当然，如果你是第一次见到 map/reduce/filter，那你可能还是会有点儿陌生和不解，这只是你不了解罢了。

对于函数式编程的思路，下图是一个比较形象的例子，面包和蔬菜 map 到切碎的操作上，再把结果给 reduce 成汉堡。在这个图中，我们可以看到 map 和 reduce 不关心源输入数据，它们只是控制，并不是业务。控制是描述怎么干，而业务是描述要干什么。

### 4.6 函数式的 pipeline 模式

pipeline（管道）借鉴于 Unix Shell 的管道操作 —— 把若干个命令串起来，前面命令的输出成为后面命令的输入，如此完成一个流式计算。（注：管道绝对是一个伟大的发明，它的设计哲学就是 KISS – 让每个功能就做一件事，并把这件事做到极致，软件或程序的拼装会变得更为简单和直观。这个设计理念影响非常深远，包括今天的 Web Service、云计算，以及大数据的流式计算等。）比如，我们如下的 shell 命令：

```
ps auwwx | awk '{print $2}' | sort -n | xargs echo
```

上面的例子是要查看一个用户执行的进程列表，列出来以后，然后取第二列，第二列是它的进程 ID，排个序，再把它显示出来。抽象成函数式的样子，我们就可以反过来，一层套一层。

```
xargs(  echo, sort(n, awk('print $2', ps(auwwx)))  )
```

我们也可以把函数放进数组里面，然后顺序执行一下。

```
pids = for_each(result, [ps_auwwx, awk_p2, sort_n, xargs_echo])
```

多说一句，如果我们把这些函数比作微服务，那么管道这个事是在干什么呢？其实就是在做服务的编排。像 Unix 这些经典的技术上的实践或理论，往往是可以反映到分布式架构的，所以，一般来说，一个好的分布式架构师，通常都是对这些传统的微观上的经典技术有非常深刻的认识，因为这些东西在方法论上都是相通的。

好了，还是让我们用一个简单的示例来看一下如何实现 pipeline。我们先来看一个程序，这个程序的 process() 有三个步骤：1）找出偶数；2）乘以 3；3）转成字符串返回。传统的非函数式的实现如下：

```py
def process(num):
    # filter out non-evens
    if num % 2 != 0:
        return
    num = num * 3
    num = 'The Number: %s' % num
    return num
 
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 
for num in nums:
    print process(num)
    
# 输出：
# None
# The Number: 6
# None
# The Number: 12
# None
# The Number: 18
# None
# The Number: 24
# None
# The Number: 30
```

我们可以看到，输出的结果并不够完美，另外，代码阅读上如果没有注释，你也会比较晕。下面，我们来看看函数式的 pipeline（第一种方式）应该怎么写？

第一步，我们先把三个「子需求」写成函数：

```py
def even_filter(nums):
    for num in nums:
        if num % 2 == 0:
            yield num
def multiply_by_three(nums):
    for num in nums:
        yield num * 3
def convert_to_string(nums):
    for num in nums:
        yield 'The Number: %s' % num
```

然后，我们再把这三个函数串起来：

```py
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
pipeline = convert_to_string(multiply_by_three(even_filter(nums)))
for num in pipeline:
    print num
# 输出：
# The Number: 6
# The Number: 12
# The Number: 18
# The Number: 24
# The Number: 30
```

上面，我们动用了 Python 的关键字 yield，它是一个类似 return 的关键字，只是这个函数返回的是 Generator（生成器）。所谓生成器，指的是 yield 返回的是一个可迭代的对象，并没有真正的执行函数。也就是说，只有其返回的迭代对象被迭代时，yield 函数才会真正运行，运行到 yield 语句时就会停住，然后等下一次的迭代。（ yield 是个比较诡异的关键字）这就是 lazy evluation（懒惰加载）。

好了，根据前面的原则 ——「使用 Map & Reduce，不要使用循环」（还记得吗？使用循环会让我们只能使用顺序型的数据结构），那我们用比较纯朴的 Map & Reduce 吧。

```py
def even_filter(nums):
    return filter(lambda x: x%2==0, nums)
 
def multiply_by_three(nums):
    return map(lambda x: x*3, nums)
 
def convert_to_string(nums):
    return map(lambda x: 'The Number: %s' % x,  nums)
 
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
pipeline = convert_to_string(
               multiply_by_three(
                   even_filter(nums)
               )
            )
for num in pipeline:
    print num
```

上面的代码是不是更容易读了，但需要嵌套使用函数，这个有点儿令人不爽，如果我们能像下面这个样子就好了（第二种方式）。

```py
pipeline_func(nums, [even_filter,
                     multiply_by_three,
                     convert_to_string])
```

可以看到，其实，就是对一堆函数做一个 reduce，于是，pipeline 函数可以实现成下面这样：

```py
def pipeline_func(data, fns):
    return reduce(lambda a, x: x(a),   fns,   data)
```

当然，使用 Python 的 force 函数以及 decorator 模式可以把上面的代码写得更像管道：

```py
class Pipe(object):
    def __init__(self, func):
        self.func = func
 
    def __ror__(self, other):
        def generator():
            for obj in other:
                if obj is not None:
                    yield self.func(obj)
        return generator()
 
@Pipe
def even_filter(num):
    return num if num % 2 == 0 else None
 
@Pipe
def multiply_by_three(num):
    return num*3
 
@Pipe
def convert_to_string(num):
    return 'The Number: %s' % num
 
@Pipe
def echo(item):
    print item
    return item
 
def force(sqs):
    for item in sqs: pass
 
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 
force(nums | even_filter | multiply_by_three | convert_to_string | echo)
```

### 黑板墙

了解了这么多函数式编程的知识，想请你深入思考一个问题：你是偏好在命令式编程语言中使用函数式编程风格呢，还是坚持使用函数式语言编程？原因是什么？

同样是业务代码的实现（抛开框架，中间件，基础设施的研发），前端更多的是声明式，函数式，反应式的编程，后端更多的是面向过程，事务，对象的编程，不知道皓叔怎么看这种差异的根源？2018-01-23

一直不太明白一点，函数式编程的特点之一就是就是 immutable，这就是说函数总是应该返回新的值而不是修改旧的值。但是，如果要处理一个很大的 list，深拷贝的代价是不是太大了？进一步说，在编程解决实际问题的时候，往往需要依赖第三方的库。一方面大多数的第三方的库往往不是函数式的，引入后就被传染，变成了有状态的，可变的；另一方面，很难找到多少维护良好的通用编程方面的函数式的库。初步学习过 common lisp，clojure，以及 prolog 和 erlang，感觉除了这些语言都被局限在了「学术研究」，「语言玩具」，以及由高手组成的小团体的内部「秘密」使用。（erlang 还好一些，但是被局限在了很小的领域）。最后还是感觉，一门语言，语言特性再好，还是得有杀手级应用，就像支柱产业能带动一大量上下游的发展。就像 clojure 过去要是没有 Storm，可能不会发展这么繁荣。个人现在最常用的跟函数式风格有关的还是 Java8 的 stream 操作，对于理清思路，减少代码，提高开发效率来说非常有帮助。2018-02-14

在我看来，面向对象编程和函数式编程他们的关注点不一样，面向对象编程帮助你设计更复杂的应用程序，函数式编程帮助你简化更复杂的计算，我身为 java 后端，一直都是面向对象为主，函数式只是帮助我简化代码。2018-07-13

整体设计面向对象，细节能用函数式就用函数式，算法相关过程式。稍微复杂点的场景想使用纯函数式，必然绕不过 monad，hkt 这样的概念。为了追求函数式风格而把程序写的艰深难懂，我觉得不是一件值得夸耀的事。2018-01-25

有幸得以做自己喜欢的事情。一路走来，先是过程式，后是面向对象式，现在则是函数式。每次转变都感觉焕然一新，思路上了一级台阶。函数式能帮我们更容易写出精简、易于复用的代码。优势耗子哥已经写的很详细了。我安利一下，学函数式，一定要了解一下 Elixir，会从新的角度理解编程。比如 Elixir 的 pipeline 的设计绝对会有所启发。语言不止是工具。语言和编程范式极大影响了我们的思维。2018-02-13

从过程式编程、面向对象编程、函数式编程一路走来，已经回不去了。对比机械化的过程式编程和层级结构复杂的面向对象编程，函数式编程能够很自然地描述现实世界。特别是用了 Elixir 之后，深感世界本应如此。其 pipeline 设计用起来比其他语言更灵活些，加上继承了 Erlang 的面向进程编程，可直接使用 OTP 开发分布式应用，语法更加人性化，还提供宏作为元编程手段，原生函数库也非常丰富。当然也要承认 Elixir 还是很小众。要从底层更多地考虑机器运作的思维向更多地考虑现实问题的思维转换对大部分人来说有难度，毕竟需要转变的还有世界观，而不仅仅是换个编程语言那么简单。2018-05-13

我做 web 前端开发的，我觉得面向对象和面向函数，应该结合一起，界面（对象）及对应的事件回调（对象的方法），但到了状态机的处理用 pipeline（函数式），所以我会选择在命令式编程语言中使用函数式编程风格。2018-09-08

我对这种现象的个人理解是，前端的业务特点是「单 App、单节点、UI 驱动」，后端的业务特点是「多 Service、分布式、数据驱动」，业务特点上的不同导致彼此适应的范式不同。2018-01-25

这篇不太容易看懂，拖延了很久。其中的代码能够看懂，但是的确没有在工作中使用过函数式编程的语言，很久以前看过一点点 Lisp。之前用过一段 C# 语言，大概是到 .NET Framework 4.0 之后提供了一些类似于 lamda 的语法糖，以及 LINQ 之类的查询，感觉和这里的函数式编程有点类似。不过当时只是在编辑器插件的帮助下，将命令式（过程式）的语言，转换成函数式的。看上去的确简洁了不少，但是感觉调试起来比较困难。后来转而使用 Ruby，Ruby 本身也提供了类似于 map、reduce 之类的函数，似乎有函数式编程的影子。感觉似乎命令式编程和函数式编程又相互借鉴、互相印证的地方。函数式编程可能更适合高性能计算、或分布式领域，因为更容易发挥其优势。2019-06-09

本来以为按编程语言的发展顺序，这一节应该是讲面向对象，结果是最不熟悉的函数式编程。曾经瞅过一眼 a little Lisp，括号实在太多，没有看下去。文中使用 Python 进行函数式的编程，看的眼花缭乱。函数式语言的 Map、Reduce 和 Filter 三件套，现在似乎在 C# 和 Java 里面也都有实现。我比较偏好在命令式编程语言中使用函数式编程风格，因为感觉上自己似乎更熟悉一些。函数式的代码看上去感觉不是很「熟悉」，可能还是因为自己见得太少。感觉上，面向过程和面向对象都比较容易和身边的世界联系起来，而面向函数似乎更多的是从计算的角度考虑，对这种思考的角度不是很熟练。2020-06-25

无状态，不可变。以函数为变量，基于 map reduce filter 来构造程序，更精确地描述做什么，而不是怎么做。函数式编程首先改变的是编程的思维，要理解它的优点，在实际编码工作中掌握并贯彻运行它是很困难的。go 最终也还是面向对象，最多语言层面对函数式提供支持。那么，函数式编程其实只是我们考虑问题的方式，实现是程序员看到的内容。自己能清晰看清楚自己的代码，也是程序员的一种幸福。2020-01-06

相对于过程式的编程方法，强调做的步骤和执行细节，函数式编程则更直观的表达业务，强调做什么而不是怎么做。函数式编程以 Stateless（无状态）和 Immutable（不可变）为主要特点。代码简洁，易于理解，能便于进行并行执行，易于做代码重构，函数执行没有顺序上的问题，支持惰性求值，具有函数的确定性 —— 无论在什么场景下都会得到同样的结果。2019-06-20

用函数存储运行状态，并且函数是幂等的。不过值之间的 copy 会占用大量内存。过程式和声明式各有适用场景！2019-01-14

## 0305编程范式游记5修饰器模式.md



