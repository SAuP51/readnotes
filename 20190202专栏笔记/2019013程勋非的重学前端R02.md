## 0103. JavaScript3

### 1. 逻辑脉络

9、JavaScript 的词法部分内容包括了空白符号、换行符、注释、标识符名称、符号、数字直接量、字符串直接量、正则表达式直接量、字符串模板。

10、通过一个小实验学习了编译原理的基本知识，通过实验，我们了解了产生式、词法分析、语法分析和解释执行的过程。

11、自动插入分号机制，又整理了 JavaScript 语法中的 no line terminator 规则，以及不写分号需要注意的一些常见的错误。

### 2. 摘录及评论

### 0109JavaScript词法为什么12.toString会报错.md

JavaScript 的词法部分，这部分的内容包括了空白符号、换行符、注释、标识符名称、符号、数字直接量、字符串直接量、正则表达式直接量、字符串模板。掌握词法对我们平时调试代码至关重要。

在前面的文章中，我们已经从运行时的角度了解过 JavaScript 的知识内容，在接下来的几节课，我们来了解一下 JavaScript 的文法部分。文法是编译原理中对语言的写法的一种规定，一般来说，文法分成词法和语法两种。词法规定了语言的最小语义单元：token，可以翻译成「标记」或者「词」，在我的专栏文章中，我统一把 token 翻译成词。从字符到词的整个过程是没有结构的，只要符合词的规则，就构成词，一般来说，词法设计不会包含冲突。词法分析技术上可以使用状态机或者正则表达式来进行，我们的课程主要是学习词法，关于它们实现的细节就不多谈了。

1、概述。我们先来看一看 JavaScript 的词法定义。JavaScript 源代码中的输入可以这样分类：1）WhiteSpace 空白字符。2）LineTerminator 换行符。3）Comment 注释。3）Token 词：IdentifierName 标识符名称，典型案例是我们使用的变量名，注意这里关键字也包含在内了；Punctuator 符号，我们使用的运算符和大括号等符号；NumericLiteral 数字直接量，就是我们写的数字；StringLiteral 字符串直接量，就是我们用单引号或者双引号引起来的直接量；Template 字符串模板，用反引号 ` 括起来的直接量。这个设计符合比较通用的编程语言设计方式，不过，JavaScript 中有一些特别之处，我下面就来讲讲特别在哪里。

首先是除法和正则表达式冲突问题。我们都知道，JavaScript 不但支持除法运算符「/」和「/=」，还支持用斜杠括起来的正则表达式「/abc/」。但是，这时候对词法分析来说，其实是没有办法处理的，所以 JavaScript 的解决方案是定义两组词法，然后靠语法分析传一个标志给词法分析器，让它来决定使用哪一套词法。JavaScript 词法的另一个特别设计是字符串模板，模板语法大概是这样的：

    `Hello, ${name}`

理论上，「\${} 」内部可以放任何 JavaScript 表达式代码，而这些代码是以 } 结尾的，也就是说，这部分词法不允许出现 } 运算符。是否允许 } 的两种情况，与除法和正则表达式的两种情况相乘就是四种词法定义，所以你在 JavaScript 标准中，可以看到四种定义：1）InputElementDiv；2）InputElementRegExp；3）InputElementRegExpOrTemplateTail；4）InputElementTemplateTail。

为了解决这两个问题，标准中还不得不把除法、正则表达式直接量和 } 从 token 中单独抽出来，用词上，也把原本的 Token 改为 CommonToken。但是我认为，从理解的角度上出发，我们不应该受到影响，所以在本课，我们依然把它们归类到 token 来理解。

对一般的语言的词法分析过程来说，都会丢弃除了 token 之外的输入，但是对 JavaScript 来说，不太一样，换行符和注释还会影响语法分析过程，这个我们将会在语法部分给你详细讲解（所以要实现 JavaScript 的解释器，词法分析和语法分析非常麻烦，需要来回传递信息）。

2、空白符号 Whitespace。说起空白符号，想必给大家留下的印象就是空格，但是实际上，JavaScript 可以支持更多空白符号。

1）\<HT>(或称 \< TAB>) 是 U+0009，是缩进 TAB 符，也就是字符串中写的 \t 。2）\<VT> 是 U+000B，也就是垂直方向的 TAB 符 \v，这个字符在键盘上很难打出来，所以很少用到。3）\<FF> 是 U+000C，Form Feed，分页符，字符串直接量中写作 \f ，现代已经很少有打印源程序的事情发生了，所以这个字符在 JavaScript 源代码中很少用到。4）\<SP> 是 U+0020，就是最普通的空格了。

5）\<NBSP> 是 U+00A0，非断行空格，它是 SP 的一个变体，在文字排版中，可以避免因为空格在此处发生断行，其它方面和普通空格完全一样。多数的 JavaScript 编辑环境都会把它当做普通空格（因为一般源代码编辑环境根本就不会自动折行……）。HTML 中，很多人喜欢用的 &nbsp; 最后生成的就是它了。6）\<ZWNBSP>(旧称 \< BOM>) 是 U+FEFF，这是 ES5 新加入的空白符，是 Unicode 中的零宽非断行空格，在以 UTF 格式编码的文件中，常常在文件首插入一个额外的 U+FEFF，解析 UTF 文件的程序可以根据 U+FEFF 的表示方法猜测文件采用哪种 UTF 编码方式。这个字符也叫做「bit order mark」。此外，JavaScript 支持所有的 Unicode 中的空格分类下的空格，我们可以看下表：

很多公司的编码规范要求 JavaScript 源代码控制在 ASCII 范围内，那么，就只有 \<TAB> \<VT> \<FF> \<SP> \<NBSP> 五种空白可用了。

3、换行符 LineTerminator。接下来我们来看看换行符，JavaScript 中只提供了 4 种字符作为换行符。其中，1）\<LF> 是 U+000A，就是最正常换行符，在字符串中的 \n。2）\<CR> 是 U+000D，这个字符真正意义上的「回车」，在字符串中是 \r，在一部分 Windows 风格文本编辑器中，换行是两个字符 \r\n。3）\<LS> 是 U+2028，是 Unicode 中的行分隔符。4）\<PS> 是 U+2029，是 Unicode 中的段落分隔符。大部分 LineTerminator 在被词法分析器扫描出之后，会被语法分析器丢弃，但是换行符会影响 JavaScript 的两个重要语法特性：自动插入分号和「no line terminator」规则。

4、注释 Comment。JavaScript 的注释分为单行注释和多行注释两种；多行注释中允许自由地出现 MultiLineNotAsteriskChar，也就是除了 * 之外的所有字符。而每一个 * 之后，不能出现正斜杠符 /。除了四种 LineTerminator 之外，所有字符都可以作为单行注释。我们需要注意，多行注释中是否包含换行符号，会对 JavaScript 语法产生影响，对于「no line terminator」规则来说，带换行的多行注释与换行符是等效的。

5、标识符名称 IdentifierName。IdentifierName 可以以美元符「\$」、下划线「_」或者 Unicode 字母开始，除了开始字符以外，IdentifierName 中还可以使用 Unicode 中的连接标记、数字、以及连接符号。IdentifierName 的任意字符可以使用 JavaScript 的 Unicode 转义写法，使用 Unicode 转义写法时，没有任何字符限制。IdentifierName 可以是 Identifier、NullLiteral、BooleanLiteral 或者 keyword，在 ObjectLiteral 中，IdentifierName 还可以被直接当做属性名称使用。

仅当不是保留字的时候，IdentifierName 会被解析为 Identifier。注意 \<ZWNJ> 和 \<ZWJ> 是 ES5 新加入的两个格式控制字符，它们都是 0 宽的。我在前面提到了，关键字也属于这个部分，在 JavaScript 中，关键字有:

    await break case catch class const continue debugger default delete do else export extends finally for function if import ininstance of new return super switch this throw try typeof var void while with yield

除了上述的内容之外，还有 1 个为了未来使用而保留的关键字:

    enum

在严格模式下，有一些额外的为未来使用而保留的关键字:

    implements package protected interface private public

除了这些之外，NullLiteral（null）和 BooleanLiteral（true false）也是保留字，不能用于 Identifier。

6、符号 Punctuator。因为前面提到的除法和正则问题，/ 和 /= 两个运算符被拆分为 DivPunctuator，因为前面提到的字符串模板问题，} 也被独立拆分。加在一起，所有符号为：

    { ( ) [ ] . ... ; , \< > \<= >= == != === !== + - * % ** ++ -- \<\< >> >>> & | ^ ! ~ && || ? : = += -= *= %= **= \<\<= >>= >>>= &= |= ^= => / /= }

7、数字直接量 NumericLiteral。我们来看看今天标题提出的问题，JavaScript 规范中规定的数字直接量可以支持四种写法：十进制数、二进制整数、八进制整数和十六进制整数。十进制的 Number 可以带小数，小数点前后部分都可以省略，但是不能同时省略，我们看几个例子：

```
.01
12.
12.01
```

这都是合法的数字直接量。这里就有一个问题，也是我们标题提出的问题，我们看一段代码：

    12.toString()

这时候 12. 会被当做省略了小数点后面部分的数字而看成一个整体，所以我们要想让点单独成为一个 token，就要加入空格，这样写：

    12 .toString()

数字直接量还支持科学计数法，例如：

```
10.24E+2
10.24e-2
10.24e2
```

这里 e 后面的部分，只允许使用整数。当以 0x 0b 或者 0o 开头时，表示特定进制的整数：

```
0xFA
0o73
0b10000
```

上面这几种进制都不支持小数，也不支持科学计数法。

8、字符串直接量 StringLiteral。JavaScript 中的 StringLiteral 支持单引号和双引号两种写法。

    " DoubleStringCharacters "
    ' SingleStringCharacters '

单双引号的区别仅仅在于写法，在双引号字符串直接量中，双引号必须转义，在单引号字符串直接量中，单引号必须转义。字符串中其他必须转义的字符是 \ 和所有换行符。JavaScript 中支持四种转义形式，还有一种虽然标准没有定义，但是大部分实现都支持的八进制转义。第一种是单字符转义。即一个反斜杠 \ 后面跟一个字符这种形式。有特别意义的字符包括有 SingleEscapeCharacter 所定义的 9 种，见下表：

除了这 9 种字符、数字、x 和 u 以及所有的换行符之外，其它字符经过 \ 转义后都是自身。

9、正则表达式直接量 RegularExpressionLiteral。正则表达式由 Body 和 Flags 两部分组成，例如：

    /RegularExpressionBody/g

其中 Body 部分至少有一个字符，第一个字符不能是 \*（因为 /* 跟多行注释有词法冲突）。

正则表达式有自己的语法规则，在词法阶段，仅会对它做简单解析。正则表达式并非机械地见到 / 就停止，在正则表达式 [ ] 中的 / 就会被认为是普通字符。我们可以看一个例子：

    /[/]/.test("/");

除了 \、/ 和 [ 三个字符之外，JavaScript 正则表达式中的字符都是普通字符。用 \ 和一个非换行符可以组成一个转义，[ ] 中也支持转义。正则表达式中的 flag 在词法阶段不会限制字符。虽然只有 ig 几个是有效的，但是任何 IdentifierPart（Identifier 中合法的字符）序列在词法阶段都会被认为是合法的。

10、字符串模板 Template。从语法结构上，Template 是个整体，其中的 \${ } 是并列关系。但是实际上，在 JavaScript 词法中，包含 \${ } 的 Template，是被拆开分析的，如：

    `a${b}c${d}e`

它在 JavaScript 中被认为是：

```
`a${
b
}c${
d
}e`
```

它被拆成了几个部分：

1）`a\${ 这个被称为模板头。2）} c\${ 被称为模板中段。

3）} e` 被称为模板尾。4）b 和 d 都是普通标识符。

实际上，这里的词法分析过程已经跟语法分析深度耦合了。不过我们学习的时候，大可不必按照标准和引擎工程师这样去理解，可以认为模板就是一个由反引号括起来的、可以在中间插入代码的字符串。模板支持添加处理函数的写法，这时模板的各段会被拆开，传递给函数当参数：

```
function f(){
    console.log(arguments);
}

var a = "world"
f`Hello ${a}!`; // [["Hello", "!"], world]
```

模板字符串不需要关心大多数字符的转义，但是至少 \${ 和 ` 还是需要处理的。模板中的转义跟字符串几乎完全一样，都是使用 \。

### 黑板墙

别忘了 JS 是允许直接写小数的，也就说 12.toString () 他无法分辨你是想要创建一个小数位为 toString () 的数 还是创建一个 12 然后调用 toString () 这种情况。也就说 JS 里面的。是拥有两种含义的 一种是小数点 一种是方法调用。你可以试试 12..toString () 这样就可以消除这种歧义。

十进制的 number 的小数点前后的内容可以省略，但是不能同时省略

        .01 = 0.01 10. = 10

12.toString () 12. 被当做了一个整体，所以会报错，加入空格 12 .toString () 这样。就成为了一个单独的 token。

js 中。有两种含义，一种是代表一个小数，一种是调用方法。12.toString () 中的 12. 会被浏览器解析为一个省略了小数后面部分的数字。一个数字后面直接写一个方法，就像 333toString 一样，肯定会报错。

### 0110理解编译原理一个四则运算的解释器.md

通过一个小实验学习了编译原理的基本知识，小实验的目的是帮助你理解 JavaScript 课程中涉及到的编译原理基本概念，它离真正的编译原理学习还有很大的差距。通过实验，我们了解了产生式、词法分析、语法分析和解释执行的过程。

如果我们从编译原理「龙书」等正规的资料中学习，就会耗费掉不少的时间，所以我在这里设计了一个小实验，帮助你快速理解编译原理相关的知识。

1、分析。按照编译原理相关的知识，我们来设计一下工作，这里我们分成几个步骤。1）定义四则运算：产出四则运算的词法定义和语法定义。2）词法分析：把输入的字符串流变成 token。3）语法分析：把 token 变成抽象语法树 AST。4）解释执行：后序遍历 AST，执行得出结果。

2、定义四则运算。四则运算就是加减乘除四种运算，例如：

    1 + 2 * 3

首先我们来定义词法，四则运算里面只有数字和运算符，所以定义很简单，但是我们还要注意空格和换行符，所以词法定义大概是下面这样的。1）Token。Number: 1 2 3 4 5 6 7 8 9 0 的组合；Operator: + 、-、 *、 / 之一。2）Whitespace: \<sp>。3）LineTerminator：\<LF> \<CR>

这里我们对空白和换行符没有任何的处理，所以词法分析阶段会直接丢弃。接下来我们来定义语法，语法定义多数采用 BNF，但是其实大家写起来都是乱写的，比如 JavaScript 标准里面就是一种跟 BNF 类似的自创语法。不过语法定义的核心思想不会变，都是几种结构的组合产生一个新的结构，所以语法定义也叫语法产生式。因为加减乘除有优先级，所以我们可以认为加法是由若干个乘法再由加号或者减号连接成的：

```
<Expression> ::= 
    <AdditiveExpression><EOF>

<AdditiveExpression> ::= 
    <MultiplicativeExpression>
    |<AdditiveExpression><+><MultiplicativeExpression>
    |<AdditiveExpression><-><MultiplicativeExpression>
```

这种 BNF 的写法类似递归的原理，你可以理解一下，它表示一个列表。为了方便，我们把普通数字也得当成乘法的一种特例了。

```
<MultiplicativeExpression> ::= 
    <Number>
    |<MultiplicativeExpression><*><Number>
    |<MultiplicativeExpression></><Number>
```

好了，这就是四则运算的定义了。

3、词法分析：状态机。词法分析部分，我们把字符流变成 token 流。词法分析有两种方案，一种是状态机，一种是正则表达式，它们是等效的，选择你喜欢的就好，这里我都会你介绍一下状态机。根据分析，我们可能产生四种输入元素，其中只有两种 token，我们状态机的第一个状态就是根据第一个输入字符来判断进入了哪种状态：

这个状态机非常简单，它只有两个状态，因为我们只有 Number 不是单字符的 token。这里我的状态机实现是非常经典的方式：用函数表示状态，用 if 表示状态的迁移关系，用 return 值表示下一个状态。下面我们来运行一下这个状态机试试看：

3、语法分析：LL。做完了词法分析，我们开始进行语法分析，LL 语法分析根据每一个产生式来写一个函数，首先我们来写好函数名：

为了便于理解，我们就不做流式处理了，实际上一般编译代码都应该支持流式处理。所以我们假设 token 已经都拿到了：

每个产生式对应着一个函数，例如：根据产生式，我们的 AdditiveExpression 需要处理三种情况：

那么 AddititveExpression 中就要写三个 if 分支，来处理三种情况。AdditiveExpression 的写法是根传入的节点，利用产生式合成新的节点。

那么下一步我们就把解析好的 token 传给我们的顶层处理函数 Expression。

    Expression(tokens);

接下来，我们看 Expression 该怎么处理它。我们 Expression 收到第一个 token，是个 Number，这个时候，Expression 就傻了，这是因为产生式只告诉我们，收到了 AdditiveExpression 怎么办。这个时候，我们就需要对产生式的首项层层展开，根据所有可能性调用相应的处理函数，这个过程在编译原理中称为求「closure」。

4、解释执行。得到了 AST 之后，最困难的一步我们已经解决了。这里我们就不对这颗树做任何的优化和精简了，那么接下来，直接进入执行阶段。我们只需要对这个树做遍历操作执行即可。我们根据不同的节点类型和其它信息，写 if 分别处理即可：

以前我只大概了解一般的做法是消除文法中的左递归，这一课让我知道原来还可以通过「层层展开」去处理。词法分析我尝试了正则的方式。括号的处理费了些时间，这里我是修改了文法（感觉我的 Expression 产生式 [在源码注释里] 怪怪的，希望 winter 老师有时间的话可以指点一下），另一种做法是，先把中缀表达式变成前缀表达式。学习一些编译原理的知识还是很有必要也很有趣的，可以去写一些 webpack 的 loader 啊，插件啊，vscode 的插件等等。（[Homework-of-Geekbang/arithmetic-executor](https://github.com/Homework-of-Geekbang/arithmetic-executor)）

### 0111JavaScript语法到底要不要写分号呢.md

首先介绍了自动插入分号机制，又对 JavaScript 语法中的 no line terminator 规则做了个整理，最后，我挑选了几种情况，为你介绍了不写分号需要注意的一些常见的错误。

先探讨一个语言风格问题：究竟要不要写分号。这是一个非常经典的口水问题，「加分号」党和「不写分号」党之间的战争，可谓是经久不息。实际上，行尾使用分号的风格来自于 Java，也来自于 C 语言和 C++，这一设计最初是为了降低编译器的工作负担。但是，从今天的角度来看，行尾使用分号其实是一种语法噪音，恰好 JavaScript 语言又提供了相对可用的分号自动补全规则，所以，很多 JavaScript 的程序员都是倾向于不写分号。我们首先来了解一下自动插入分号的规则。

1、自动插入分号规则。自动插入分号规则其实独立于所有的语法产生式定义，它的规则说起来非常简单，只有三条。1）要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。2）有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。3）源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。

这样描述是比较难以理解的，我们一起看一些实际的例子进行分析：

```
let a = 1
void function(a){
    console.log(a);
}(a);
```

在这个例子中，第一行的结尾处有换行符，接下来 void 关键字接在 1 之后是不合法的，这命中了我们的第一条规则，因此会在 void 前插入换行符。

```
var a = 1, b = 1, c = 1;
a
++
b
++
c
```

这也是个著名的例子，我们看第二行的 a 之后，有换行符，后面遇到了 ++ 运算符，a 后面跟 ++ 是合法的语法，但是我们看看 JavaScript 标准定义中，有 [no LineTerminator here] 这个字样，这是一个语法定义中的规则，你可以感受一下这个规则的内容（下一小节，我会给你详细介绍 no LineTerminator here ）：

```
UpdateExpression[Yield, Await]:
    LeftHandSideExpression[?Yield, ?Await]
    LeftHandSideExpression[?Yield, ?Await][no LineTerminator here]++
    LeftHandSideExpression[?Yield, ?Await][no LineTerminator here]--
    ++UnaryExpression[?Yield, ?Await]
    --UnaryExpression[?Yield, ?Await]
```

于是，这里 a 的后面就要插入一个分号了。所以这段代码最终的结果，b 和 c 都变成了 2，而 a 还是 1。

```
(function(a){
    console.log(a);
})()
(function(a){
    console.log(a);
})()
```

这个例子是比较有实际价值的例子，这里两个 function 调用的写法被称作 IIFE（立即执行的函数表达式），是个常见技巧。这段代码意图上显然是形成两个 IIFE。我们来看第三行结束的位置，JavaScript 引擎会认为函数返回的可能是个函数，那么，在后面再跟括号形成函数调用就是合理的，因此这里不会自动插入分号。这是一些鼓励不写分号的编码风格会要求大家写 IIFE 时必须在行首加分号的原因。

```
function f(){
    return/*
        This is a return value.
    */1;
}
f();
```

在这个例子中，return 和 1 被用注释分隔开了。根据 JavaScript 自动插入分号规则，带换行符的注释也被认为是有换行符，而恰好的是，return 也有 [no LineTerminator here] 规则的要求。所以这里会自动插入分号，f 执行的返回值是 undefined。

2、no LineTerminator here 规则。到这里我们已经讲清楚了分号自动插入的规则，但是我们要想彻底掌握分号的奥秘，就必须要对 JavaScript 的语法定义做一些数据挖掘工作。no LineTerminator here 规则表示它所在的结构中的这一位置不能插入换行符。自动插入分号规则的第二条：有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。跟 no LineTerminator here 规则强相关，那么我们就找出 JavaScript 语法定义中的这些规则。

为了方便你理解，我把产生式换成了实际的代码。下面一段代码展示了，带标签的 continue 语句，不能在 continue 后插入换行。

```
outer:for(var j = 0; j < 10; j++)
    for(var i = 0; i < j; i++)
        continue /*no LineTerminator here*/ outter
```

break 跟 continue 是一样的，break 后也不能插入换行：

```
outer:for(var j = 0; j < 10; j++)
    for(var i = 0; i < j; i++)
        break /*no LineTerminator here*/ outter
```

我们前面已经提到过 return 和后自增、后自减运算符。

```
function f(){
    return /*no LineTerminator here*/1;
}
```

```
i/*no LineTerminator here*/++
i/*no LineTerminator here*/--
```

以及，throw 和 Exception 之间也不能插入换行符：

```
throw/*no LineTerminator here*/new Exception("error")
```

凡是 async 关键字，后面都不能插入换行符：

```
async/*no LineTerminator here*/function f(){

}
const f = async/*no LineTerminator here*/x => x*x
```

箭头函数的箭头前，也不能插入换行：

    const f = x/*no LineTerminator here*/=> x*x

yield 之后，不能插入换行：

```
function *g(){
    var i = 0;
    while(true)
        yield/*no LineTerminator here*/i++;
}
```

到这里，我已经整理了所有标准中的 no LineTerminator here 规则，实际上，no LineTerminator here 规则的存在，多数情况是为了保证自动插入分号行为是符合预期的，但是令人遗憾的是，JavaScript 在设计的最初，遗漏了一些重要的情况，所以有一些不符合预期的情况出现，需要我们格外注意。

3、不写分号需要注意的情况。下面我们来看几种不写分号容易造成错误的情况，你可以稍微注意一下，避免发生同样的问题。

以括号开头的语句。我们在前面的案例中，已经展示了一种情况，那就是以括号开头的语句：

```
(function(a){
    console.log(a);
})()/*这里没有被自动插入分号*/
(function(a){
    console.log(a);
})()
```

这段代码看似两个独立执行的函数表达式，但是其实第三组括号被理解为传参，导致抛出错误。

以数组开头的语句。除了括号，以数组开头的语句也十分危险：

```
var a = [[]]/*这里没有被自动插入分号*/
[3, 2, 1, 0].forEach(e => console.log(e))
```

这段代码本意是一个变量 a 赋值，然后对一个数组执行 forEach，但是因为没有自动插入分号，被理解为下标运算符和逗号表达式，我这个例子展示的情况，甚至不会抛出错误，这对于代码排查问题是个噩梦。

以正则表达式开头的语句。正则表达式开头的语句也值得你去多注意一下。我们来看这个例子。

```
var x = 1, g = {test:()=>0}, b = 1/* 这里没有被自动插入分号 */
/(a)/g.test("abc")
console.log(RegExp.$1)
```

这段代码本意是声明三个变量，然后测试一个字符串中是否含有字母 a，但是因为没有自动插入分号，正则的第一个斜杠被理解成了除号，后面的意思就都变了。注意，我构造的这个例子跟上面的例子一样，同样不会抛错，凡是这一类情况，都非常致命。

以 Template 开头的语句。以 Template 开头的语句比较少见，但是跟正则配合时，仍然不是不可能出现：

```
var f = function(){
  return "";
}
var g = f/*这里没有被自动插入分号*/
`Template`.match(/(a)/);
console.log(RegExp.$1)
```

这段代码本意是声明函数 f，然后赋值给 g，再测试 Template 中是否含有字母 a。但是因为没有自动插入分号，函数 f 被认为跟 Template 一体的，进而被莫名其妙地执行了一次。

### 黑板墙

几年前，各种各样的书大致上都推荐你加分号。几年前，曾经由于构建工具有一些问题，导致不加分号可能会出问题。jquery 依然留着分号，vue 源码不用分号。尤雨溪曾经在知乎说：真正会导致上下行解析出问题的 token 有 5 个：括号，方括号，正则开头的斜杠，加号，减号。我还从没见过实际代码中用正则、加号、减号作为行首的情况，所以总结下来就是一句话：一行开头是括号或者方括号的时候加上分号就可以了，其他时候全部不需要。当然再加个反引号。可是写分号已经习惯了，又何必花力气改习惯去掉它。不加只要不写出 bug，也很好。反正分号有和没有，对 eslint fix 来说，只是瞬间的事。

## 0104. JavaScript4

### 1. 逻辑脉络

12、JavaScript 语法的全局结构，JavaScript 有两种源文件，一种叫做脚本，一种叫做模块。介绍完脚本和模块的基础概念，我们再来把它们往下分，脚本中可以包含语句。模块中可以包含三种内容：import 声明，export 声明和语句；两个 JavaScript 语法的全局机制：预处理和指令序言。


### 2. 摘录及评论

### 0112JavaScript语法1在script标签写export为什么会抛错.md

JavaScript 的语法部分，在开始学习之前，我先介绍了一部分语法的基本规则。我们首先介绍了 JavaScript 语法的全局结构，JavaScript 有两种源文件，一种叫做脚本，一种叫做模块。介绍完脚本和模块的基础概念，我们再来把它们往下分，脚本中可以包含语句。模块中可以包含三种内容：import 声明，export 声明和语句。最后，我介绍了两个 JavaScript 语法的全局机制：预处理和指令序言。
















