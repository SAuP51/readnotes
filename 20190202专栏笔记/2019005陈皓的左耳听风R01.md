# 2019005陈皓的左耳听风R01.md

## 记忆时间

## 卡片

### 0101. 反常识卡——

这本书的主题核心，就是最大的反常识卡，并且注意时间脉络。

#### 01. 常识

#### 02. 反常识

#### 03. 知识来源

比如提出者，如何演化成型的；书或专栏具体出现的地方。

#### 04. 例子

### 0201. 术语卡 —— 类型

泛型的本质。要了解泛型的本质，就需要了解类型的本质。1）类型是对内存的一种抽象。不同的类型，会有不同的内存布局和内存分配的策略。2）不同的类型，有不同的操作。所以，对于特定的类型，也有特定的一组操作。

### 0202. 术语卡——

### 0203. 术语卡——

### 0301. 人名卡——

根据这些证据和案例，找出源头和提出术语的人是谁——产生一张人名卡，并且分析他为什么牛，有哪些作品，生平经历是什么。

维基百科链接：有的话。

#### 01. 基本信息

用一句话描述你对这个大牛的印象。

#### 02. 贡献及著作

### 0401. 金句卡 —— 需要更多的抽象，更为复杂的需求

### 0402. 金句卡 —— 类型是对内存的抽象

### 0501. 行动卡——

行动卡是能够指导自己的行动的卡。

### 0601. 任意卡——

最后还有一张任意卡，记录个人阅读感想。

## 模板

### 1. 逻辑脉络

用自己的话总结主题，梳理逻辑脉络，也就是在这个专栏的整个地图里，这一章节所在的节点。

### 2. 摘录及评论

1『自己的观点』

2『行动指南』

3『与其他知识的连接』

## 发刊词

陈皓，网名左耳朵耗子，目前在创业，MegaEase 公司，致力于为企业提供高可用、高并发、高性能的分布式技术产品，同时也提供物联网（IoT）方向的技术产品。之前在阿里巴巴、亚马逊、汤森路透等公司任职，职业背景是金融和电子商务行业，主要研究的技术方向是一些大规模分布式系统的基础架构。

从大学毕业一直做技术工作，到今天有 20 年了，还在写代码，因为对技术有很大的热情。从 2002 年开始写技术博客，到 2009 年左右开始在独立的域名 CoolShell.cn（酷壳）上分享我对技术的一些见解和心得。从 2003 年就开始为很多企业做内部的培训和分享了。这些培训涵盖了很多方面，如软件团队管理、架构技术、编程语言、操作系统等，以及一些为企业量身定制的咨询或软件开发，这些都是收费的。

1、技术。对于技术方面，我不会写太多关于知识点的东西，因为这些知识点你可以自行 Google 可以 RTFM。我要写的一定是以体系化的，而且要能直达技术的本质。入行这 20 年来，我最擅长的就是架构和开发各种大规模的系统，所以，我会有 2-3 个和分布式系统相关的系列文章。我学过也用过好多编程语言，所以，也会有一系列的关于编程本质的文章。而我对一些基础知识研究得也比较多，所以，还会有一系列与基础知识相关的文章。当然，其中还会穿插一些其它的技术文章，比如一些热点事件，还有一些经验之谈，包括我会把我的《程序员技术练级攻略》在这个专栏里重新再写一遍。这些东西一定会让你有醍醐灌顶的感觉。

2、成长。在过去这 20 年中，我感觉到，很多人都非常在意自己的成长。所以，我会分享一堆我亲身经历的，也是我自己实验的与个人发展相关的文章。比如，如何利用技术变现、如何面试、如何选择新的技术、如何学习、如何管理自己的时间、如何管理自己的老板和工作、如何成为一个 Leader……这些东西一定会对你有用。（但是，我这里一定不会有速成的东西。一切都是要花时间和精力的。如果你想要速成，你不应该来订阅我的专栏。）

3、管理。这 20 年，我觉得做好技术工作的前提是，得做好技术的管理工作。只有管理好了软件工程和技术团队，技术才能发挥出最大的潜力。大多数的技术问题都是管理上的问题。所以，我会写上一系列的和管理相关的文章，涵盖管理三个要素：团队、项目和管理者自己。比如，人员招聘、绩效考核、提升士气、解决冲突、面对变化、沟通说服、项目管理、任务排期、会议、远程管理，等等。这些内容都是我在外企工作时，接受到的世界顶级管理培训机构培训内容，我会把我的实践写出来分享给你。这其中一定少不了亚马逊相关的各种实践。这些东西，我和很多公司和大佬都讲过，到目前为止还没有人不赞的。

## 0301. 编程范式1

1、编程范式，programming paradigm，范即模范之意，范式即模式、方法，是一类典型的编程风格，是指从事软件工程的一类典型的风格（可以对照「方法学」一词）。编程语言发展到今天，出现了好多不同的代码编写方式，但不同的方式解决的都是同一个问题，那就是如何写出更为通用、更具可重用性的代码或模块。

2、C++ 语言是如何通过泛型来解决 C 语言遇到的问题，其实这里面主要就是泛型编程和函数式编程的基本方法相关的细节。

### 0301编程范式游记1起源.md

程序 = 算法 + 数据，我觉得 C 语言会有这几个问题。1）一个通用的算法，需要对所处理的数据的数据类型进行适配。但在适配数据类型的过程中，C 语言只能使用 void* 或宏替换的方式，这两种方式导致了类型过于宽松，并带来很多其它问题。2）适配数据类型，需要 C 语言在泛型中加入一个类型的 size，这是因为我们识别不了被泛型后的数据类型，而 C 语言没有运行时的类型识别，所以，只能将这个工作抛给调用泛型算法的程序员来做了。3）算法其实是在操作数据结构，而数据则是放到数据结构中的。所以，真正的泛型除了适配数据类型外，还要适配数据结构。最后这个事情导致泛型算法的复杂急剧上升。比如容器内存的分配和释放，不同的数据体可能有非常不一样的内存分配和释放模型，再比如对象之间的复制，要把它存进来我需要有一个复制，这其中又涉及到是深拷贝，还是浅拷贝。4）最后，在实现泛型算法的时候，你会发现自己在纠结哪些东西应该抛给调用者处理，哪些又是可以封装起来。如何平衡和选择，并没有定论，也不好解决。

总体来说，C 语言设计目标是提供一种能以简易的方式编译、处理低层内存、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。C 语言也很适合搭配汇编语言来使用。C 语言把非常底层的控制权交给了程序员，它设计的理念是：1）相信程序员；2）不会阻止程序员做任何底层的事；3）保持语言的最小和最简的特性；4）保证 C 语言的最快的运行速度，那怕牺牲移值性。

从某种角度上来说，C 语言的伟大之处在于 —— 使用 C 语言的程序员在高级语言的特性之上还能简单地做任何底层上的微观控制。这是 C 语言的强大和优雅之处。也有人说，C 语言是高级语言中的汇编语言。不过，这只是在针对底层指令控制和过程式的编程方式。而对于更高阶更为抽象的编程模型来说，C 语言这种基于过程和底层的初衷设计方式就会成为它的短板。因为，在编程这个世界中，更多的编程工作是解决业务上的问题，而不是计算机的问题，所以，我们需要更为贴近业务更为抽象的语言。

说到这里，我想你会问，那 C 语言本会怎么去解决这些问题呢？简单点说，C 语言并没有解决这些问题，所以才有了后面的 C++ 等其他语言，下一篇文章中，我也会和你聊聊 C++ 是如何解决这些问题的。C 语言诞生于 1972 年，到现在已经有 45 年的历史，在它之后，C++、Java、C# 等语言前仆后继，一浪高过一浪，都在试图解决那个时代的那个特定问题，我们不能去否定某个语言，但可以确定的是，随着历史的发展，每一门语言都还在默默迭代，不断优化和更新。同时，也会有很多新的编程语言带着新的闪光耀眼的特性出现在我们面前。

再回过头来说，编程范式其实就是程序的指导思想，它也代表了这门语言的设计方向，我们并不能说哪种范式更为超前，只能说各有千秋。比如 C 语言就是过程式的编程语言，像 C 语言这样的过程式编程语言优点是底层灵活而且高效，特别适合开发运行较快且对系统资源利用率要求较高的程序，但我上面抛出的问题它在后来也没有试图去解决，因为编程范式的选择基本已经决定了它的「命运」。我们怎么解决上述 C 语言没有解决好的问题呢？

现在很多的文章和演讲都在谈架构，很少有人再会谈及编程范式。然而， 这些基础性和本质性的话题，却是非常非常重要的。一方面，我发现在一些语言争论上，有很多人对编程语言的认识其实并不深；另一方面，通过编程语言的范式，我们不但可以知道整个编程语言的发展史，而且还能提高自己的编程技能写出更好的代码。

我希望通过一系列的文章带大家漫游一下各式各样的编程范式。这一经历可能有些漫长，途中也会有各式各样的各种语言的代码。但是我保证这一历程对于一个程序员来说是非常有价值的，因为你不但可以对主流编程语言的一些特性有所了解，而且当我们到达终点的时候，你还能了解到编程的本质是什么。这一系列文章中有各种语言的代码，其中有 C、C++、Python、Java、Scheme、Go、JavaScript、Prolog 等。所以，如果要能跟上本文的前因后果，你要对这几门比较主流的语言多少有些了解。而且，你需要在一线编写一段时间（大概 5 年以上吧）的代码，可能才能体会到这一系列文章的内涵。

我根据每篇文章中所讲述的内容，将这一系列文章分为四个部分。第一部分：泛型编程，第 1-3 章，讨论了从 C 到 C++ 的泛型编程方法，并系统地总结了编程语言中的类型系统和泛型编程的本质。第二部分：函数式编程，第 4 章和第 5 章，讲述了函数式编程用到的技术，及其思维方式，并通过 Python 和 Go 修饰器的例子，展示了函数式编程下的代码扩展能力，以及函数的相互和随意拼装带来的好处。第三部分：面向对象编程，第 6-8 章，讲述与传统的编程思想相反，面向对象设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，列举了面向对象编程的优缺点，基于原型的编程范式，以及 Go 语言的委托模式。第四部分：编程本质和逻辑编程，第 9-11 章，先探讨了编程的本质：逻辑部分才是真正有意义的，控制部分只能影响逻辑部分的效率，然后结合 Prolog 语言介绍了逻辑编程范式，最后对程序世界里的编程范式进行了总结，对比了它们之间的不同。

下面我们来说说什么是编程范式。编程范式的英语是 programming paradigm，范即模范之意，范式即模式、方法，是一类典型的编程风格，是指从事软件工程的一类典型的风格（可以对照「方法学」一词）。编程语言发展到今天，出现了好多不同的代码编写方式，但不同的方式解决的都是同一个问题，那就是如何写出更为通用、更具可重用性的代码或模块。

1、先从 C 语言开始。为了讲清楚这个问题，我需要从 C 语言开始讲起。因为 C 语言历史悠久，而几乎现在看到的所有编程语言都是以 C 语言为基础来拓展的，不管是 C++、Java、C#、Go、Python、PHP、Perl、JavaScript、Lua，还是 Shell。自 C 语言问世 40 多年以来，其影响了太多太多的编程语言，到现在还一直被广泛使用，不得不佩服它的生命力。但是，我们也要清楚地知道，大多数 C Like 编程语言其实都是在改善 C 语言带来的问题。

那 C 语言有哪些特性呢？我简单来总结下：1）C 语言是一个静态弱类型语言，在使用变量时需要声明变量类型，但是类型间可以有隐式转换；2）不同的变量类型可以用结构体（struct）组合在一起，以此来声明新的数据类型；3）C 语言可以用 typedef 关键字来定义类型的别名，以此来达到变量类型的抽象；4）C 语言是一个有结构化程序设计、具有变量作用域以及递归功能的过程式语言；5）C 语言传递参数一般是以值传递，也可以传递指针；6）通过指针，C 语言可以容易地对内存进行低级控制，然而这引入了非常大的编程复杂度；7）编译预处理让 C 语言的编译更具有弹性，比如跨平台。

C 语言的这些特性，可以让程序员在微观层面写出非常精细和精确的编程操作，让程序员可以在底层和系统细节上非常自由、灵活和精准地控制代码。然而，在代码组织和功能编程上，C 语言的上述特性，却不那么美妙了。

2、从 C 语言的一个简单例子说起。我们从 C 语言最简单的交换两个变量的 swap 函数说起，参看下面的代码。

```
void swap(int* x, int* y)
{
	int temp = *x;
	*x = *y;
	*y = tmp;
}
```

你可以想一想，这里为什么要传指针？这里是 C 语言指针，因为如果你不用指针的话，那么参数变成传值，即函数的形参是调用实参的一个拷贝，函数里面对形参的修改无法影响实参的结果。为了要达到调用完函数后，实参内容的交换，必须要把实参的地址传递进来，也就是传指针。这样在函数里面做交换，实际变量的值也被交换了。然而，这个函数最大的问题就是它只能给 int 值用，这个世界上还有很多类型包括 double、float，这就是静态语言最糟糕的一个问题。

3、数据类型与现实世界的类比。与现实世界类比一下，数据类型就好像螺帽一样，有多种接口方式：平口的、有十字的、有六角的等，而螺丝刀就像是函数，或是用来操作这些螺丝的算法或代码。我们发现，这些不同类型的螺帽（数据类型），需要我们为之适配一堆不同的螺丝刀。而且它们还有不同的尺寸（尺寸就代表它是单字节的，还是多字节的，比如整型的 int、long，浮点数的 float 和 double），这样复杂度一下就提高了，最终导致电工（程序员）工作的时候需要带下图这样的一堆工具。这就是类型为编程带来的问题。要解决这个问题，我们还是来看一下现实世界。

你应该见过下面图片中的这种经过优化的螺丝刀，上面手柄是一样的，拧螺丝的动作也是一样的，只是接口不一样。每次我看到这张图片的时候就在想，这密密麻麻的看着有 40 多种接口，不知道为什么人类世界要干出这么多的花样？你们这群人类究竟是要干什么啊。我们可以看到，无论是传统世界，还是编程世界，我们都在干一件事情，什么事呢？那就是通过使用一种更为通用的方式，用另外的话说就是抽象和隔离，让复杂的「世界」变得简单一些。

然而，要做到抽象，对于 C 语言这样的类型语言来说，首当其冲的就是抽象类型，这就是所谓的 —— 泛型编程。另外，我们还要注意到，在编程世界里，对于 C 语言来说，类型还可以转换。编译器会使用一切方式来做类型转换，因为类型转换有时候可以让我们编程更方便一些，也让相近的类型可以做到一点点的泛型。

然而，对于 C 语言的类型转换，是会出很多问题的。比如说，传给我一个数组，这个数组本来是 double 的，或者是 long 64 位的，但是如果把数组类型强转成 int，那么就会出现很多问题，因为这会导致程序遍历数组的步长不一样了。比如：一个 double a[10] 的数组，a[2] 意味着 a + sizeof(double) * 2。如果你把 a 强转成 int，那么 a[2] 就意味着 a + sizeof(int) * 2。我们知道 sizeof(double) 是 8，而 sizeof(int) 是 4。于是访问到了不同的地址和内存空间，这就导致程序出现严重的问题。

4、C 语言的泛型。一个泛型的示例 - swap 函数。我们再看下 C 语言是如何泛型的。C 语言的类型泛型基本上来说就是使用 void \*关键字或是使用宏定义。下面是一个使用了 void*泛型版本的 swap 函数。

```
void swap(void* x, void* y, size_t size)
{
     char tmp[size];
     memcpy(tmp, y, size);
     memcpy(y, x, size);
     memcpy(x, tmp, size);
}
```

上面这个函数几乎完全改变了 int 版的函数的实现方式，这个实现方式有三个重点：1）函数接口中增加了一个 size 参数。为什么要这么干呢？因为，用了 void* 后，类型被「抽象」掉了，编译器不能通过类型得到类型的尺寸了，所以，需要我们手动地加上一个类型长度的标识。2）函数的实现中使用了 memcpy() 函数。为什么要这样干呢？还是因为类型被「抽象」掉了，所以不能用赋值表达式了，很有可能传进来的参数类型还是一个结构体，因此，为了要交换这些复杂类型的值，我们只能使用内存复制的方法了。3）函数的实现中使用了一个 temp[size] 数组。这就是交换数据时需要用的 buffer，用 buffer 来做临时的空间存储。

于是，新增的 size 参数，使用的 memcpy 内存拷贝以及一个 buffer，这增加了编程的复杂度。这就是 C 语言的类型抽象所带来的复杂度的提升。在提升复杂度的同时，我们发现还有问题，比如，我们想交换两个字符串数组，类型是：char\*，那么，我的 swap() 函数的 x 和 y 参数是不是要用 void**了？这样一来，接口就没法定义了。除了使用 void\* 来做泛型，在 C 语言中，还可以用宏定义来做泛型，如下所示：

```
#define swap(x, y, size) {\
	char temp[size]; \
	memcpy(temp, &y, size); \
	memcpy(&y,   &x, size); \
	memcpy(&x, temp, size); \
}
```

但用宏带来的问题就是编译器做字符串替换，因为宏是做字符串替换，所以会导致代码膨胀，导致编译出的执行文件比较大。不过对于 swap 这个简单的函数来说，用 void* 和宏替换来说都可以达到泛型。但是，如果我们不是 swap，而是 min() 或 max() 函数，那么宏替换的问题就会暴露得更多一些。比如，对于下面的这个宏：

	#define min(x, y)  （(x)>(y) ? (y) : (x)）

其中一个最大的问题，就是有可能会有重复执行的问题。如：1）min(i++, j++) 对于这个案例来说，我们本意是比较完后，对变量做累加，但是，因为宏替换的缘故，这会导致变量 i 或 j 被累加两次。2）min(foo(), bar()) 对于这个示例来说，我们本意是比较 foo() 和 bar() 函数的返回值，然而，经过宏替换后，foo() 或 bar() 会被调用两次，这会带来很多问题。另外，你会不会觉得无论是用哪种方式，这种「泛型」是不是太宽松了一些，完全不做类型检查，就是在内存上对拷，直接操作内存的这种方式，感觉是不是比较危险，而且就像一个定时炸弹一样，不知道什么时候，在什么条件下就爆炸了。

从上面的两个例子，我们可以发现，无论哪种方式，接口都变得复杂了 —— 加入了 size，因为如果不加入 size 的话，那么我们的函数内部就需要自己检查 size。然而，void* 这种地址的方式是没法得到 size 的。而宏定义的那种方式，虽然不会把类型给隐藏掉，可以使用像 sizeof(x) 这样的方式得到 size。但是如果类型是 char*，那么，使用 sizeof 方式只能提到指针类型的 size，而不是值的 size。另外，对于不同的类型，比如说 double 和 int，那应该用谁的 size 呢？是不是先转一下型呢？这些都是问题。于是，这种泛型，让我们根本没有办法检查传入参数的 size，导致我们只能增加接口复杂度，加入一个 size 参数，然后把这个问题抛给调用者了。

一个更为复杂的泛型示例 - Search 函数。如果我们把这个事情变得更复杂，写个 search 函数，再传一个 int 数组，然后想搜索 target，搜到返回数组下标，搜不到返回 -1。

```
int search(int* a, size_t size, int target) {
	for(int i=0; i<size; i++) {
		if (a[i] == target) {
			return i;
		}
	}
	return -1;
}
```

我们可以看到，这个函数是类型 int 版的。如果我们要把这个函数变成泛型的应该怎么变呢？就像上面 swap() 函数那样，如果要把它变成泛型，我们需要变更并复杂化函数接口。1）我们需要在函数接口上增加一个 element size，也就是数组里面每个元素的 size。这样，当我们遍历数组的时候，可以通过这个 size 正确地移动指针到下一个数组元素。2）我还要加个 cmpFn。因为我要去比较数组里的每个元素和 target 是否相等。因为不同数据类型的比较的实现不一样，比如，整型比较用 == 就好了。但是如果是一个字符串数组，那么比较就需要用 strcmp 这类的函数。而如果你传一个结构体数组（如 Account 账号），那么比较两个数据对象是否一样就比较复杂了。所以，必须要自定义一个比较函数。最终我们的 search 函数的泛型版如下所示：

```
int search(void* a, size_t size, void* target, 
	size_t elem_size, int(*cmpFn)(void*, void*) )
{
	for(int i=0; i<size; i++) {
		// why not use memcmp()
		// use unsigned char * to calculate the address
		if ( cmpFn ((unsigned char *)a + elem_size * i, target) == 0 ) {
			return i;
		}
	}
	return -1;
}
```

在上面的代码中，我们没有使用 memcmp() 函数，这是因为，如果这个数组是一个指针数组，或是这个数组是一个结构体数组，而结构体数组中有指针成员。我们想比较的是指针指向的内容，而不是指针这个变量。所以，用 memcmp() 会导致我们在比较指针（内存地址），而不是指针所指向的值。而调用者需要提供如下的比较函数：

```
int int_cmp(int* x, int* y)
{
	return *x - *y;
}
 
int string_cmp(char* x, char* y){
	return strcmp(x, y);
}
如果面对有业务类型的结构体，可能会是这样的比较函数：

typedef struct _account {
	char name[10];
	char id[20];
} Account;
 
int account_cmp(Account* x, Account* y) {
	int n = strcmp(x->name, y->name);
	if (n != 0) return n;
	return strcmp(x->id, y->id);
}
```

我们的 C 语言干成这个样子，看上去还行，但是，上面的这个 search 函数只能用于数组这样的顺序型的数据容器（数据结构）。如果这个 search 函数能支持一些非顺序型的数据容器（数据结构），比如：堆、栈、哈希表、树、图。那么，用 C 语言来干基本上干不下去了，对于像 search() 这样的算法来说，数据类型的自适应问题就已经把事情搞得很复杂了。然而，数据结构的自适应就会把这个事的复杂度搞上几个数量级。

### 黑板墙

关于编程范式，超级喜欢《冒号课堂》那本书，两年前读的，真是相见恨晚。跟读大神的文章一样收获满满。

2『已下载书籍「2020093冒号课堂」。』

斯坦福大学的编程范式公开课很好。

### 0302编程范式游记2泛型编程.md

在这篇文章中，我们聊到 C++ 语言是如何通过泛型来解决 C 语言遇到的问题，其实这里面主要就是泛型编程和函数式编程的基本方法相关的细节，虽然解决编程语言中类型带来的问题可能有多种方式，不一定就是 C++ 这种方式。而我之所以从 C/C++ 开始，目的只是因为 C/C++ 都是比较偏底层的编程语言。从底层的原理上，我们可以更透彻地了解，从 C 到 C++ 的演进这一过程中带来的编程方式的变化。这可以让你看到，在静态类型语言方面解决泛型编程的一些技术和方法，从而感受到其中的奥妙和原理。因为形式是多样的，但是原理是相通的。所以，这个过程会非常有助于你更深刻地了解后面会谈到的更多的编程范式。

上一篇文章中从 C 语言开始说起，聊了聊面向过程式的编程范式，相信从代码的角度你对这类型的语言已经有了一些理解。作为一门高级语言，C 语言绝对是编程语言历史发展中的一个重要里程碑，但随着认知的升级，面向过程的 C 语言已经无法满足更高层次的编程的需要。于是，C++ 出现了。

1、C++ 语言。1980 年，AT&T 贝尔实验室的 Bjarne Stroustrup 创建的 C++ 语言横空出世，它既可以全面兼容 C 语言，又巧妙揉和了一些面向对象的编程理念。现在来看，不得不佩服 Stroustrup 的魄力。在这里，我也向你推荐一本书，书名是《C++ 语言的设计和演化》。这本书系统介绍了 C++ 诞生的背景以及初衷，书的作者就是 Stroustrup 本人，所以你可以非常详细地从语言创建者的角度了解他的设计思路和创新之旅。当然，就是在今天，C++ 这门语言也还有很多争议，这里我不细说。如果你感兴趣的话，可以看看我几年前在酷壳上发表的文章《[C++的坑真的多吗？ | | 酷 壳 - CoolShell](https://coolshell.cn/articles/7992.html)》。

2『已下载书籍「2019016C++语言的设计和演化」。已下载「0321C-plus-plis的坑真的多吗」作为专栏附件。』

从语言角度来说，实际上早期 C++ 的许多工作是对 C 的强化和净化，并把完全兼容 C 作为强制性要求（这也是 C++ 复杂晦涩的原因，这点 Java 就干得比 C++ 彻底得多）。在 C89、C99 这两个 C 语言的标准中，有许多改进都是从 C++ 中引进的。可见，C++ 对 C 语言的贡献非常之大。是的，因为 C++ 很大程度就是用来解决 C 语言中的各种问题和各种不方便的。比如：1）用引用来解决指针的问题。2）用 namespace 来解决名字空间冲突的问题。3）通过 try-catch 来解决检查返回值编程的问题。4）用 class 来解决对象的创建、复制、销毁的问题，从而可以达到在结构体嵌套时可以深度复制的内存安全问题。5）通过重载操作符来达到操作上的泛型。（比如，消除上一篇文章中提到的比较函数 cmpFn，再比如用 >> 操作符消除 printf() 的数据类型不够泛型的问题。）6）通过模板 template 和虚函数的多态以及运行时识别来达到更高层次的泛型和多态。7）用 RAII、智能指针的方式，解决了 C 语言中因为需要释放资源而出现的那些非常 ugly 也很容易出错的代码的问题。8）用 STL 解决了 C 语言中算法和数据结构的 N 多种坑。

2、C++ 泛型编程。C++ 是支持编程范式最多的一门语言，它虽然解决了很多 C 语言的问题，但我个人觉得它最大的意义是解决了 C 语言泛型编程的问题。因为，我们可以看到一些 C++ 的标准规格说明书里，有一半以上都在说明 STL 的标准规格应该是什么样的，这说明泛型编程是 C++ 重点中的重点。理想情况下，算法应是和数据结构以及类型无关的，各种特殊的数据类型理应做好自己分内的工作。算法只关心一个标准的实现。而对于泛型的抽象，我们需要回答的问题是，如果我们的数据类型符合通用算法，那么对数据类型的最小需求又是什么呢？我们来看看 C++ 是如何有效解决程序泛型问题的，我认为有三点。

第一，它通过类的方式来解决。1）类里面会有构造函数、析构函数表示这个类的分配和释放。2）还有它的拷贝构造函数，表示了对内存的复制。3）还有重载操作符，像我们要去比较大于、等于、不等于。这样可以让一个用户自定义的数据类型和内建的那些数据类型就很一致了。

第二，通过模板达到类型和算法的妥协。1）模板有点像 DSL，模板的特化会根据使用者的类型在编译时期生成那个模板的代码。2）模板可以通过一个虚拟类型来做类型绑定，这样不会导致类型转换时的问题。模板很好地取代了 C 时代宏定义带来的问题。

第三，通过虚函数和运行时类型识别。1）虚函数带来的多态在语义上可以支持「同一类」的类型泛型。2）运行时类型识别技术可以做到在泛型时对具体类型的特殊处理。这样一来，就可以写出基于抽象接口的泛型。

拥有了这些 C++ 引入的技术，我们就可以做到 C 语言很难做到的泛型编程了。正如前面说过的，一个良好的泛型编程需要解决如下几个泛型编程的问题：1）算法的泛型；2）类型的泛型；3）数据结构（数据容器）的泛型。

3、C++ 泛型编程的示例 —— Search 函数。就像前面的 search() 函数，里面的 for(int i=0; i<len; i++) 这样的遍历方式，只能适用于顺序型的数据结构的方式迭代，如：array、set、queue、list 和 link 等。并不适用于非顺序型的数据结构。如哈希表 hash table，二叉树 binary tree、图 graph 等这样数据不是按顺序存放的数据结构（数据容器）。所以，如果找不到一种泛型的数据结构的操作方式（如遍历、查找、增加、删除、修改……），那么，任何的算法或是程序都不可能做到真正意义上的泛型。

除了search()函数的「遍历操作」之外，还有 search 函数的返回值，是一个整型的索引下标。这个整型的下标对于「顺序型的数据结构」是没有问题的，但是对于「非顺序的数据结构」，在语义上都存在问题。比如，如果我要在一个 hash table 中查找一个 key，返回什么呢？一定不是返回「索引下标」，因为在 hash table 这样的数据结构中，数据的存放位置不是顺序的，而且还会因为容量不够的问题被重新 hash 后改变，所以返回数组下标是没有意义的。对此，我们要把这个事做得泛型和通用一些。如果找到，返回找到的这个元素的一个指针（地址）会更靠谱一些。

所以，为了解决泛型的问题，我们需要动用以下几个 C++ 的技术。1）使用模板技术来抽象类型，这样可以写出类型无关的数据结构（数据容器）。2）使用一个迭代器来遍历或是操作数据结构内的元素。我们来看一下 C++ 版的 search() 函数是什么样的。先重温一下 C 语言版的代码：

```
int search(void* a, size_t size, void* target, 
	size_t elem_size, int(*cmpFn)(void*, void*) )
{
	for(int i=0; i<size; i++) {
		if ( cmpFn (a + elem_size * i, target) == 0 ) {
			return i;
		}
	}
	return -1;
}
```

我们再来看一下 C++ 泛型版的代码：

```
template<typename T, typename Iter>
Iter search(Iter pStart, Iter pEnd, T target) 
{
	for(Iter p = pStart; p != pEnd; p++) {
		if ( *p == target ) 
			return p;
	}
	return NULL;
}
```

在 C++ 的泛型版本中，我们可以看到：1）使用 typename T 抽象了数据结构中存储数据的类型。2）使用 typename Iter，这是不同的数据结构需要自己实现的「迭代器」，这样也就抽象掉了不同类型的数据结构。3）然后，我们对数据容器的遍历使用了 Iter 中的 ++ 方法，这是数据容器需要重载的操作符，这样通过操作符重载也就泛型掉了遍历。4）在函数的入参上使用了 pStart 和 pEnd 来表示遍历的起止。5）使用 *Iter 来取得这个「指针」的内容。这也是通过重载 * 取值操作符来达到的泛型。

当然，你可能会问，为什么我们不用标准接口 Iter.Next() 取代 ++， 用 Iter.GetValue() 来取代 *，而是通过重载操作符？其实这样做是为了兼容原有 C 语言的编程习惯。说明一下，所谓的 Iter，在实际代码中，就是像 vector\<int>::iterator 或 map\<int, string>::iterator 这样的东西。这是由相应的数据容器来实现和提供的。

注：下面是 C++ STL 中的 find() 函数的代码。

```
template<class InputIterator, class T>
  InputIterator find (InputIterator first, InputIterator last, const T& val)
{
  while (first!=last) {
    if (*first==val) return first;
    ++first;
  }
  return last;
}
```

4、C++ 泛型编程示例 - Sum 函数。也许你觉得到这一步，我们的泛型设计就完成了。其实，还远远不够。search 函数只是一个开始，我们还有很多别的算法会让问题变得更为复杂。我们再来看一个 sum() 函数。先看 C 语言版：

```
long sum(int *a, size_t size) {
	long result = 0;
	for(int i=0; i<size; i++) {
		result += a[i];
	}
	return result;
}
```

再看一下 C++ 泛型的版本：

```
template<typename T, typename Iter>
T sum(Iter pStart, Iter pEnd) {
	T result = 0;
	for(Iter p=pStart; p!=pEnd; p++) {
		result += *p;
	}
	return result;	
}
```

你看到了什么样的问题？这个代码中最大的问题就是 T result = 0; 这条语句：1）那个 0 假设了类型是 int；2）那个 T 假设了 Iter 中出来的类型是 T。这样的假设是有问题的，如果类型不一样，就会导致转型的问题，这会带来非常 buggy 的代码。那么，我们怎么解决呢？

6、C++ 泛型编程的重要技术 —— 迭代器。我们知道 Iter 在实际调用者那会是一个具体的像 vector\<int>::iterator 这样的东西。在这个声明中，int 已经被传入 Iter 中了。所以，定义 result 的 T 应该可以从 Iter 中来。这样就可以保证类型是一样的，而且不会有被转型的问题。所以，我们需要精心地实现一个「迭代器」。下面是一个「精简版」的迭代器（我没有把 C++ STL 代码里的迭代器列出来，是因为代码太多太复杂，我这里只是为了说明问题）。

```
template <class T>
class container {
public:
	class iterator {
	public:
		typedef iterator self_type;
		typedef T   value_type;
		typedef T*  pointer;
		typedef T& 	reference;
 
		reference operator*();
		pointer operator->();
		bool operator==(const self_type& rhs)；
		bool operator!=(const self_type& rhs)；
		self_type operator++() { self_type i = *this; ptr_++; return i; }
		self_type operator++(int junk) { ptr_++; return *this; }
		...
		...
	private:
		pointer _ptr;
	};
 
	iterator begin();
	iterator end();
	...
	...
};
```

上面的代码是我写的一个迭代器（这个迭代器在语义上是没有问题的），我没有把所有的代码列出来，而把它的一些基本思路列了出来。这里我说明一下几个关键点。1）首先，一个迭代器需要和一个容器在一起，因为里面是对这个容器的具体的代码实现。2）它需要重载一些操作符，比如：取值操作 \*、成员操作 ->、比较操作 == 和 !=，还有遍历操作 ++，等等。3）然后，还要 typedef 一些类型，比如 value_type，告诉我们容器内的数据的实际类型是什么样子。4）还有一些，如 begin() 和 end() 的基本操作。5）我们还可以看到其中有一个 pointer _ptr 的内部指针来指向当前的数据（注意，pointer 就是 T*）。

好了，有了这个迭代器后，我们还要解决 T result = 0 后面的这个 0 的问题。这个事，算法没有办法搞定，最好由用户传入。于是出现了下面最终泛型的 sum() 版函数。

```
template <class Iter>
typename Iter::value_type
sum(Iter start, Iter end, T init) {
	typename Iter::value_type result = init;
	while (start != end) {
		result = result + *start;
		start++;
	}
	return result;
}
```

我们可以看到 typename Iter::value_type result = init 这条语句是关键。我们解决了所有的问题。我们如下使用：

```
container<int> c;
container<int>::iterator it = c.begin();
sum(c.begin(), c.end(), 0);
```

这就是整个 STL 的泛型方法，其中包括：1）泛型的数据容器；2）泛型数据容器的迭代器；3）然后泛型的算法就很容易写了。

需要更多的抽象，更为复杂的需求。但是，还能不能做到更为泛型呢？比如：如果我们有这样的一个数据结构 Employee，里面有 vacation 就是休假多少天，以及工资。

2『「需要更多的抽象，更为复杂的需求。」做一张金句卡片。』

```
struct Employee {
	string name;
	string id;
	int vacation;
	double salary；
};
```

现在我想计算员工的总薪水，或是总休假天数。

```
vector<Employee> staff;
//total salary or total vacation days?
sum(staff.begin(), staff.end(), 0);
```

我们的 sum 完全不知道怎么搞了，因为要累加的是 Employee 类中的不同字段，即便我们的 Employee 中重载了 + 操作，也不知道要加哪个字段。另外，我们可能还会有：求平均值 average，求最小值 min，求最大值 max，求中位数 mean 等等。你会发现，算法写出来基本上都是一样的，只是其中的「累加」操作变成了另外一个操作。就这个例子而言，我想计算员工薪水里面最高的，和休假最少的，或者我想计算全部员工的总共休假多少天。那么面对这么多的需求，我们是否可以泛型一些呢？怎样解决这些问题呢？

6、更高维度的抽象。要解决这个问题，我希望我的这个算法只管遍历，具体要干什么，那是业务逻辑，由外面的调用方来定义我就好了，和我无关。这样一来，代码的重用度就更高了。下面是一个抽象度更高的版本，这个版本再叫 sum 就不太合适了。这个版本应该是 reduce —— 用于把一个数组 reduce 成一个值。

```
template<class Iter, class T, class Op>
T reduce (Iter start, Iter end, T init, Op op) {
	T result = init;
	while ( start != end ) {
		result = op( result, *start );
		start++;
	}
	return result;
}
```
 
上面的代码中，我们需要传一个函数进来。在 STL 中，它是个函数对象，我们还是这套算法，但是 result 不是像前面那样去加，是把整个迭代器值给你一个 operation，然后由它来做。我把这个方法又拿出去了，所以就会变成这个样子。在 C++ STL 中，与我的这个 reduce 函数对应的函数名叫 accumulate()，其实际代码有两个版本。第一个版本就是上面的版本，只不过是用 for 语句而不是 while。

```
template<class InputIt, class T>
T accumulate(InputIt first, InputIt last, T init)
{
    for (; first != last; ++first) {
        init = init + *first;
    }
    return init;
}
```

第二个版本，更为抽象，因为需要传入一个「二元操作函数」—— BinaryOperation op 来做 accumulate。accumulate 的语义比 sum 更抽象了。

```
template<class InputIt, class T, class BinaryOperation>
T accumulate(InputIt first, InputIt last, T init, 
             BinaryOperation op)
{
    for (; first != last; ++first) {
        init = op(init, *first);
    }
    return init;
}
```

来看看我们在使用中是什么样子的：

```
double sum_salaries = 
  reduce( staff.begin(), staff.end(), 0.0,
		  
		    {return s + e.salary;}  );
 
double max_salary =
  reduce( staff.begin(), staff.end(), 0.0,
		  
		    {return s > e.salary? s: e.salary; } );
```

注意：我这里用了 C++ 的 lambda 表达式。你可以很清楚地看到，reduce 这个函数就更通用了，具体要干什么样的事情呢？放在匿名函数里面，它会定义我，我只做一个 reduce。更抽象地来说，我就把一个数组，一个集合，变成一个值。怎么变成一个值呢？由这个函数来决定。

7、Reduce 函数。我们来看看如何使用 reduce 和其它函数完成一个更为复杂的功能。下面这个示例中，我先定义了一个函数对象 counter。这个函数对象需要一个 Cond 的函数对象，它是个条件判断函数，如果满足条件，则加 1，否则加 0。

```
template<class T, class Cond>
struct counter {
	size_t operator()(size_t c, T t) const {
		return c + (Cond(t) ? 1 : 0);
	}
};
```
然后，我用上面的 counter 函数对象和 reduce 函数共同来打造一个 counter_if 算法（当条件满足的时候我就记个数，也就是统计满足某个条件的个数），我们可以看到，就是一行代码的事。

```
template<class Iter, class Cond>
size_t count_if(Iter begin, Iter end, Cond c){
	return reduce(begin, end, 0, 
				  counter<Iter::value_type, Cond>(c));
}
```

至于是什么样的条件，这个属于业务逻辑，不是我的流程控制，所以，这应该交给使用方。于是，当我需要统计薪资超过 1 万元的员工的数量时，一行代码就完成了。

```
size_t cnt = count_if(staff.begin(), staff.end(), 
					{ return e.salary > 10000; });
```

Reduce 时可以只对结构体中的某些值做 Reduce，比如说只对 salary>10000 的人做，只选出这个里面的值，它用 Reduce 就可以达到这步，只要传不同的方式给它，你就可以又造出一个新的东西出来。说着说着，就到了函数式编程。函数式编程里面，我们可以用很多的像 reduce 这样的函数来完成更多的像 STL 里面的 count_if() 这样有具体意义的函数。关于函数式编程，我们会在后面继续具体聊。

### 黑板墙

《STL源码解析》，《inside c++model》，记得当时啃这两本时经常要感叹怎么设计的这么精妙，了解内部实现方式后，在使用的时候也更加心里有底。

泛型技术是静态系统所独有的特性，本质上我觉得还是为了兼顾执行效率和编程灵活性，实现零成本抽象这一刀尖上跳舞的巨大挑战。较新的语言标准还提炼了很多基础设施，比如大量使用 SFINAE 并泛化之，提供 enable if, constexpr if, 乃至自动类型推断和 concept check，和 Java 那边的套路是完全不一样的。可以说不深入理解泛型技术基本，就不能很好理解现代的 C++ 了。

C++ 通过范型消除了 C 语言中很多易出 bug 的代码，实现代码重用。其中关键在于：算法的泛型；类型的泛型；数据结构（数据容器）的泛型。C++ 通过类，在构造和析构函数中做资源的申请释放，通过引用解决了用指针来取值的问题。通过操作符的重载让算法代码忽略具体类型，可以有统一的表达。通过类似迭代器的范型容器来统一不同数据结构的统一算法表达。通过抽象算法中函数的操作，用函数式编程的方式，实现算法的泛型。总之，通过不同粒度的抽象，而让代码重用更容易，bug 更少，更好维护和扩展。

## 0303编程范式游记3类型系统和泛型的本质.md

3、编程语言本质上帮助程序员屏蔽底层机器代码的实现，而让我们可以更为关注于业务逻辑代码。但是因为，编程语言作为机器代码和业务逻辑的粘合层，是在让程序员可以控制更多底层的灵活性，还是屏蔽底层细节，让程序员可以更多地关注于业务逻辑，这是很难两全需要 trade-off 的事。所以，不同的语言在设计上都会做相应的取舍，比如：C 语言偏向于让程序员可以控制更多的底层细节，而 Java 和 Python 则让程序员更多地关注业务功能的实现。而 C++ 则是两者都想要，导致语言在设计上非常复杂。


在编程语言中，类型系统的出现主要是对容许混乱的操作加上了严格的限制，以避免代码以无效的数据使用方式编译或运行。例如，整数运算不可用于字符串；指针的操作不可用于整数上，等等。但是，类型的产生和限制，虽然对底层代码来说是安全的，但是对于更高层次的抽象产生了些负面因素。比如在 C++ 语言里，为了同时满足静态类型和抽象，就导致了模板技术的出现，带来了语言的复杂性。

我们需要清楚地明白，编程语言本质上帮助程序员屏蔽底层机器代码的实现，而让我们可以更为关注于业务逻辑代码。但是因为，编程语言作为机器代码和业务逻辑的粘合层，是在让程序员可以控制更多底层的灵活性，还是屏蔽底层细节，让程序员可以更多地关注于业务逻辑，这是很难两全需要 trade-off 的事。所以，不同的语言在设计上都会做相应的取舍，比如：C 语言偏向于让程序员可以控制更多的底层细节，而 Java 和 Python 则让程序员更多地关注业务功能的实现。而 C++ 则是两者都想要，导致语言在设计上非常复杂。

我们讨论了从 C 到 C++ 的泛型编程方法，并且初探了更为抽象的函数式编程。正如在上一篇文章中所说的，泛型编程的方式并不只有 C++ 这一种类型，我们只是通过这个过程了解一下，底层静态类型语言的泛型编程原理。这样能够方便我们继续后面的历程。是的，除了 C++ 那样的泛型，如果你了解其它编程语言一定会发现，在动态类型语言或是某些有语法糖支持的语言中，那个 swap () 或 search () 函数的泛型其实可以很简单地就实现了。比如，你甚至可以把 swap () 函数简单地写成下面这个样子（包括 Go 语言也有这样的语法）：

    b, a = a, b;

在上一篇文章后面的 Reduce 函数中，可以看到，在编程世界中，我们需要处理好两件事：第一件事是编程语言中的类型问题。第二件事是对真实世界中业务代码的抽象、重用和拼装。所以，在这篇文章中，我们还是继续深入地讨论上面这两个问题，着重讨论一下编程语言中的类型系统和泛型编程的本质。

1、类型系统。在计算机科学中，类型系统用于定义如何将编程语言中的数值和表达式归类为许多不同的类型，以及如何操作这些类型，还有这些类型如何互相作用。类型可以确认一个值或者一组值，具有特定的意义和目的。一般来说，编程语言会有两种类型，一种是内建类型，如 int、float 和 char 等，一种是抽象类型，如 struct、class 和 function 等。抽象类型在程序运行中，可能不表示为值。类型系统在各种语言之间有非常大的不同，也许，最主要的差异存在于编译时期的语法，以及运行时期的操作实现方式。

编译器可能使用值的静态类型以最优化所需的存储区，并选取对数值运算时的最佳算法。例如，在许多 C 编译器中，「浮点数」数据类型是以 32 比特表示，与 IEEE 754 规格一致的单精度浮点数。因此，在数值运算上，C 应用了浮点数规范（浮点数加法、乘法等）。类型的约束程度以及评估方法，影响了语言的类型。更进一步讲，编程语言可能就类型多态性部分，对每一个类型都对应了一个针对于这个类型的算法运算。类型理论研究类型系统，尽管实际的编程语言类型系统，起源于计算机架构的实际问题、编译器实现，以及语言设计。

程序语言的类型系统主要提供如下的功能。1）程序语言的安全性。使用类型可以让编译器侦测一些代码的错误，例如：可以识别出一个错误无效的表达式，如 "Hello, World"+ 3 这样的不同数据类型间操作的问题。强类型语言提供更多的安全性，但是并不能保证绝对的安全。2）利于编译器的优化。静态类型语言的类型声明，可以让编译器明确地知道程序员的意图。因此，编译器就可以利用这一信息做很多代码优化工作。例如：如果我们指定一个类型是 int ，那么编译就知道，这个类型会以 4 个字节的倍数进行对齐，编译器就可以非常有效地利用更有效率的机器指令。3）代码的可读性。有类型的编程语言，可以让代码更易读和更易维护，代码的语义也更清楚，代码模块的接口（如函数）也更丰富和清楚。4）抽象化。类型允许程序设计者对程序以较高层次的方式思考，而不是烦人的低层次实现。例如，我们使用整型或是浮点型来取代底层的字节实现，我们可以将字符串设计成一个值，而不是底层字节的数组。从高层上来说，类型可以用来定义不同模块间的交互协议，比如函数的入参类型和返回类型，从而可以让接口更有语义，而且不同的模块数据交换更为直观和易懂。

但是，正如前面说的，类型带来的问题就是我们作用于不同类型的代码，虽然长得非常相似，但是由于类型的问题需要根据不同版本写出不同的算法，如果要做到泛型，就需要涉及比较底层的玩法。对此，这个世界出现了两类语言，一类是静态类型语言，如 C、C++、Java，一种是动态类型语言，如 Python、PHP、JavaScript 等。我们来看一下，一段动态类型语言的代码：

```
x = 5;
x = "hello";
```

在这个示例中，我们可以看到变量 x 一开始好像是整型，然后又成了字符串型。如果在静态类型的语言中写出这样的代码，那么就会在编译期出错。而在动态类型的语言中，会以类型标记维持程序所有数值的「标记」，并在运算任何数值之前检查标记。所以，一个变量的类型是由运行时的解释器来动态标记的，这样就可以动态地和底层的计算机指令或内存布局对应起来。我们再来看一个示例，对于 JavaScript 这样的动态语言来说可以定义出下面这样的数据结构（一个数组的元素可以是各式各样的类型），这在静态类型的语言中是很难做到的。

```
var a = new Array()
a[0] = 2017;
a[1] = "Hello";
a[2] = {name: "Hao Chen"};
```

注：其实，这并不是一个数组，而是一个 key:value。因为动态语言的类型是动态的，所以，key 和 value 的类型都可以随意。比如，对于 a 这个数据结构，还可以写成：a ["key"] = "value" 这样的方式。在弱类型或是动态类型的语言中，下面代码的执行会有不确定的结果。

```
x = 5;
y = "37";
z = x + y;
```

有的像 Visual Basic 语言，给出的结果是 42：系统将字符串 "37" 转换成数字 37，以匹配运算上的直觉。而有的像 JavaScript 语言，给出的结果是 "537"：系统将数字 5 转换成字符串 "5" 并把两者串接起来。像 Python 这样的语言，则会产生一个运行时错误。但是，我们需要清楚地知道，无论哪种程序语言，都避免不了一个特定的类型系统。哪怕是可随意改变变量类型的动态类型的语言，我们在读代码的过程中也需要脑补某个变量在运行时的类型。

所以，每个语言都需要一个类型检查系统。1）静态类型检查是在编译器进行语义分析时进行的。如果一个语言强制实行类型规则（即通常只允许以不丢失信息为前提的自动类型转换），那么称此处理为强类型，反之称为弱类型。2）动态类型检查系统更多的是在运行时期做动态类型标记和相关检查。所以，动态类型的语言必然要给出一堆诸如：is_array (), is_int (), is_string () 或是 typeof () 这样的运行时类型检查函数。

总之，「类型」有时候是一个有用的事，有时候又是一件很讨厌的事情。因为类型是对底层内存布局的一个抽象，会让我们的代码要关注于这些非业务逻辑上的东西。而且，我们的代码需要在不同类型的数据间做处理。但是如果程序语言类型检查得过于严格，那么，我们写出来的代码就不能那么随意。所以，对于静态类型的语言也开了些「小后门」：比如，类型转换，还有 C++、Java 运行时期的类型测试。这些小后门也会带来相当讨厌的问题，比如下面这个 C 语言的示例。

```
int x = 5;
char y[] = "37";
char* z = x + y;
```

在上面这个例子中，结果可能和你想的完全不一样。由于 C 语言的底层特性，这个例子中的 z 会指向一个超过 y 地址 5 个字节的内存地址，相当于指向 y 字符串的指针之后的两个空字符处。静态类型语言的支持者和动态类型自由形式的支持者，经常发生争执。前者主张，在编译的时候就可以较早发现错误，而且还可增进运行时期的性能。后者主张，使用更加动态的类型系统，分析代码更为简单，减少出错机会，才能更加轻松快速地编写程序。与此相关的是，后者还主张，考虑到在类型推断的编程语言中，通常不需要手动宣告类型，这部分的额外开销也就自动降低了。

在本系列内容的前两篇文章中，我们用 C/C++ 语言来做泛型编程的示例，似乎动态类型语言能够比较好地规避类型导致需要出现多个版本代码的问题，这样可以让我们更好地关注于业务。但是，我们需要清楚地明白，任何语言都有类型系统，只是动态类型语言在运行时做类型检查。动态语言的代码复杂度比较低，并可以更容易地关注业务，在某些场景下是对的，但有些情况下却并不见得。比如：在 JavaScript 中，我们需要做一个变量转型的函数，可能会是下面这个样子：

```
function ToNumber(x) {
    switch(typeof x) {
        case "number": return x;
        case "undefined": return NaN;
        case "boolean": return x ? 1 : 0;
        case "string": return Number(x); 
        case "object": return NaN;
        case "function": return NaN;    
    }
}
```

我相信，你在动态类型语言的代码中可以看到大量类似 typeof 这样的类型检查代码。是的，这是动态类型带来的另一个问题，就是运行时识别（这个是比较耗性能的）。如果你用过一段时间的动态类型语言，一旦代码量比较大了，我们就会发现，代码中出现「类型问题」而引发整个程序出错的情况实在是太多太多了。而且，这样的出错会让整个程序崩溃掉，太恐怖了。这个时候，我们就很希望提前发现这些类型的问题。静态语言的支持者会说编译器能帮我们找到这些问题，而动态语言的支持者则认为，静态语言的编译器也无法找到所有的问题，想真正提前找到问题只能通过测试来解决。其实他们都对。

2、泛型的本质。要了解泛型的本质，就需要了解类型的本质。1）类型是对内存的一种抽象。不同的类型，会有不同的内存布局和内存分配的策略。2）不同的类型，有不同的操作。所以，对于特定的类型，也有特定的一组操作。

2『类型是对内存的一种抽象。不同的类型，会有不同的内存布局和内存分配的策略。类型的概念做一张术语卡片。「类型是对内存的抽象」做一张金句卡片。』

所以，要做到泛型，我们需要做下面的事情：1）标准化掉类型的内存分配、释放和访问。2）标准化掉类型的操作。比如：比较操作，I/O 操作，复制操作……3）标准化掉数据容器的操作。比如：查找算法、过滤算法、聚合算法……4）标准化掉类型上特有的操作。需要有标准化的接口来回调不同类型的具体操作……

所以，C++ 动用了非常繁多和复杂的技术来达到泛型编程的目标。1）通过类中的构造、析构、拷贝构造，重载赋值操作符，标准化（隐藏）了类型的内存分配、释放和复制的操作。2）通过重载操作符，可以标准化类型的比较等操作。3）通过 iostream，标准化了类型的输入、输出控制。4）通过模板技术（包括模板的特化），来为不同的类型生成类型专属的代码。5）通过迭代器来标准化数据容器的遍历操作。6）通过面向对象的接口依赖（虚函数技术），来标准化了特定类型在特定算法上的操作。7）通过函数式（函数对象），来标准化对于不同类型的特定操作。

通过学习 C++，我们可以看到一个比较完整的泛型编程里所涉及的编程范式，这些编程泛式在其它语言中都会或多或少地体现着。比如，JDK 5 引入的泛型类型，就源自 C++ 的模板。

泛型编程于 1985 年在论文 Generic Programming 中被这样定义：Generic programming centers around the idea of abstracting from concrete, efficient algorithms to obtain generic algorithms that can be combined with different data representations to produce a wide variety of useful software. — Musser, David R.; Stepanov, Alexander A., Generic Programming

2『已下载原文「2020013Generic-programming」存入 zotero，并作为专栏附件「0322Generic-programming」。』

我理解其本质就是 —— 屏蔽掉数据和操作数据的细节，让算法更为通用，让编程者更多地关注算法的结构，而不是在算法中处理不同的数据类型。

### 黑板墙

这个系列除了了解不同的编程范式，最关注的是不同的编程范式如何设计，解决了什么问题。这些皓哥都点到了。我个人喜欢 Scala 这门语言，觉得它的设计非常优美，函数式编程和类型系统都是它的特点，希望皓哥这个系列或者答疑中能写写您的看法。

看到这一篇的时候，有点后悔当年没有仔细看一遍斯坦福的那个编程范式公开课了，似乎当时听了个开头，感觉比较简单，后来就放弃了。如果能早点梳理一下编程范式方面的内容，应该会对编程有很大的好处。即使经验不足的时候，能够有个大致的概念和方向，也会有相当大的方向。「类型是对内存的抽象」，这个可以算是本课金句了，让我能够更好的理解为什么会有类型系统这样的东西。以前可能更多的是隐隐约约的感性认识，这节课的内容算是捅破了窗户纸。「编程语言的本质是帮助程序员屏蔽机器代码的实现，而让我们可以更为关注于业务逻辑代码。」这句我也很认可。从另一个角度讲，因为不够熟悉编程语言，代码写的不够多，所以影响了我对于业务逻辑的实现。

之前看泛型这一块，什么类型系统，类型检查系统听起来模糊不理解，看了一下 JS 的相关文章，而且在项目中看到一个声明的变量，在由 null 变为 function 的一个操作过程中。结合动态语言，变量类型可以转换，而静态语言，声明了变量类型少了个类型检查系统，整个语言代码可以简洁不少。










