# 0101. A Pragmatic Philosophy

This book is about you.

Make no mistake, it is your career, and more importantly, Topic 1, It's Your Life. You own it. You're here because you know you can become a better developer and help others become better as well. You can become a Pragmatic Programmer.

What distinguishes Pragmatic Programmers? We feel it's an attitude, a style, a philosophy of approaching problems and their solutions. They think beyond the immediate problem, placing it in its larger context and seeking out the bigger picture. After all, without this larger context, how can you be pragmatic? How can you make intelligent compromises and informed decisions?

Another key to their success is that Pragmatic Programmers take responsibility for everything they do, which we discuss in Topic 2, The Cat Ate My Source Code. Being responsible, Pragmatic Programmers won't sit idly by and watch their projects fall apart through neglect. In Topic 3, Software Entropy, we tell you how to keep your projects pristine.

Most people find change difficult, sometimes for good reasons, sometimes because of plain old inertia. In Topic 4, Stone Soup and Boiled Frogs, we look at a strategy for instigating change and (in the interests of balance) present the cautionary tale of an amphibian that ignored the dangers of gradual change.

One of the benefits of understanding the context in which you work is that it becomes easier to know just how good your software has to be. Sometimes near-perfection is the only option, but often there are trade-offs involved. We explore this in Topic 5, Good-Enough Software.

Of course, you need to have a broad base of knowledge and experience to pull all of this off. Learning is a continuous and ongoing process. In Topic 6, Your Knowledge Portfolio, we discuss some strategies for keeping the momentum up.

Finally, none of us works in a vacuum. We all spend a large amount of time interacting with others. Topic 7, Communicate! lists ways we can do this better.

Pragmatic programming stems from a philosophy of pragmatic thinking. This chapter sets the basis for that philosophy.

Topic 1

It's Your Life

I'm not in this world to live up to your expectations and you're not in this world to live up to mine.

Bruce Lee

It is your life. You own it. You run it. You create it.

Many developers we talk to are frustrated. Their concerns are varied. Some feel they're stagnating in their job, others that technology has passed them by. Folks feel they are under appreciated, or underpaid, or that their teams are toxic. Maybe they want to move to Asia, or Europe, or work from home.

And the answer we give is always the same.

"Why can't you change it?"

Software development must appear close to the top of any list of careers where you have control. Our skills are in demand, our knowledge crosses geographic boundaries, we can work remotely. We're paid well. We really can do just about anything we want.

But, for some reason, developers seem to resist change. They hunker down, and hope things will get better. They look on, passively, as their skills become dated and complain that their companies don't train them. They look at ads for exotic locations on the bus, then step off into the chilling rain and trudge into work.

So here's the most important tip in the book.

Tip 3

You Have Agency

Does your work environment suck? Is your job boring? Try to fix it. But don't try forever. As Martin Fowler says, "you can change your organization or change your organization."[3] 

If technology seems to be passing you by, make time (in your own time) to study new stuff that looks interesting. You're investing in yourself, so doing it while you're off-the-clock is only reasonable.

Want to work remotely? Have you asked? If they say no, then find someone who says yes.

This industry gives you a remarkable set of opportunities. Be proactive, and take them.

RELATED SECTIONS INCLUDE

Topic 4, Stone Soup and Boiled Frogs Topic 6, Your Knowledge Portfolio Topic 2

The Cat Ate My Source Code

One of the cornerstones of the pragmatic philosophy is the idea of taking responsibility for yourself and your actions in terms of your career advancement, your learning and education, your project, and your day-to-day work. Pragmatic Programmers take charge of their own career, and aren't afraid to admit ignorance or error. It's not the most pleasant aspect of programming, to be sure, but it will happen — even on the best of projects. Despite thorough testing, good documentation, and solid automation, things go wrong. Deliveries are late. Unforeseen technical problems come up.

The greatest of all weaknesses is the fear of appearing weak.

J.B. Bossuet, Politics from Holy Writ, 1709

These things happen, and we try to deal with them as professionally as we can. This means being honest and direct. We can be proud of our abilities, but we must own up to our shortcomings — our ignorance and our mistakes.

TEAM TRUST

Above all, your team needs to be able to trust and rely on youand you need to be comfortable relying on each of them as well. Trust in a team is absolutely essential for creativity and collaboration according to the research literature. [4] In a healthy environment based in trust, you can safely speak your mind, present your ideas, and rely on your team members who can in turn rely on you. Without trust, well…

Imagine a high-tech, stealth ninja team infiltrating the villain's evil lair. After months of planning and delicate execution, you've made it on site. Now it's your turn to set up the laser guidance grid: "Sorry, folks, I don't have the laser. The cat was playing with the red dot and I left it at home."

That sort of breach of trust might be hard to repair.

TAKE RESPONSIBILITY

Responsibility is something you actively agree to. You make a commitment to ensure that something is done right, but you don't necessarily have direct control over every aspect of it. In addition to doing your own personal best, you must analyze the situation for risks that are beyond your control. You have the right not to take on a responsibility for an impossible situation, or one in which the risks are too great, or the ethical implications too sketchy. You'll have to make the call based on your own values and judgment.

When you do accept the responsibility for an outcome, you should expect to be held accountable for it. When you make a mistake (as we all do) or an error in judgment, admit it honestly and try to offer options.

Don't blame someone or something else, or make up an excuse. Don't blame all the problems on a vendor, a programming language, management, or your coworkers. Any and all of these may play a role, but it is up to you to provide solutions, not excuses.

If there was a risk that the vendor wouldn't come through for you, then you should have had a contingency plan. If your mass storage melts — taking all of your source code with it — and you don't have a backup, it's your fault. Telling your boss "the cat ate my source code'' just won't cut it.

Tip 4

Provide Options, Don't Make Lame Excuses

Before you approach anyone to tell them why something can't be done, is late, or is broken, stop and listen to yourself. Talk to the rubber duck on your monitor, or the cat. Does your excuse sound reasonable, or stupid? How's it going to sound to your boss?

Run through the conversation in your mind. What is the other person likely to say? Will they ask, "Have you tried this…" or "Didn't you consider that?" How will you respond? Before you go and tell them the bad news, is there anything else you can try? Sometimes, you just know what they are going to say, so save them the trouble.

Instead of excuses, provide options. Don't say it can't be done; explain what can be done to salvage the situation. Does code have to be deleted? Tell them so, and explain the value of refactoring (see Topic 40, Refactoring).

Do you need to spend time prototyping to determine the best way to proceed (see Topic 13, Prototypes and Post-it Notes)? Do you need to introduce better testing (see Topic 41, Test to Code, and Ruthless and Continuous Testing) or automation to prevent it from happening again?

Perhaps you need additional resources to complete this task. Or maybe you need to spend more time with the users? Or maybe it's just you: do you need to learn some technique or technology in greater depth? Would a book or a course help? Don't be afraid to ask, or to admit that you need help.

Try to flush out the lame excuses before voicing them aloud. If you must, tell your cat first. After all, if little Tiddles is going to take the blame….

RELATED SECTIONS INCLUDE

Topic 49, Pragmatic Teams

CHALLENGES

How do you react when someone — such as a bank teller, an auto mechanic, or a clerk — comes to you with a lame excuse? What do you think of them and their company as a result?

When you find yourself saying, "I don't know," be sure to follow it up with " — but I'll find out." It's a great way to admit what you don't know, but then take responsibility like a pro.

Topic 3

Software Entropy

While software development is immune from almost all physical laws, the inexorable increase in entropy hits us hard. Entropy is a term from physics that refers to the amount of "disorder" in a system. Unfortunately, the laws of thermodynamics guarantee that the entropy in the universe tends toward a maximum. When disorder increases in software, we call it "software rot." Some folks might call it by the more optimistic term, "technical debt," with the implied notion that they'll pay it back someday. They probably won't.

Whatever the name, though, both debt and rot can spread uncontrollably.

There are many factors that can contribute to software rot. The most important one seems to be the psychology, or culture, at work on a project. Even if you are a team of one, your project's psychology can be a very delicate thing. Despite the best-laid plans and the best people, a project can still experience ruin and decay during its lifetime. Yet there are other projects that, despite enormous difficulties and constant setbacks, successfully fight nature's tendency toward disorder and manage to come out pretty well.

What makes the difference?

In inner cities, some buildings are beautiful and clean, while others are rotting hulks. Why? Researchers in the field of crime and urban decay discovered a fascinating trigger mechanism, one that very quickly turns a clean, intact, inhabited building into a smashed and abandoned derelict.[5] 

A broken window.

One broken window, left unrepaired for any substantial length of time, instills in the inhabitants of the building a sense of abandonment — a sense that the powers that be don't care about the building. So another window gets broken. People start littering. Graffiti appears. Serious structural damage begins. In a relatively short span of time, the building becomes damaged beyond the owner's desire to fix it, and the sense of abandonment becomes reality.

Why would that make a difference? Psychologists have done studies [6] that show hopelessness can be contagious. Think of the flu virus in close quarters. Ignoring a clearly broken situation reinforces the ideas that perhaps nothing can be fixed, that no one cares, all is doomed; all negative thoughts which can spread among team members, creating a vicious spiral.

Tip 5

Don't Live with Broken Windows

Don't leave "broken windows'' (bad designs, wrong decisions, or poor code) unrepaired. Fix each one as soon as it is discovered. If there is insufficient time to fix it properly, then board it up. Perhaps you can comment out the offending code, or display a "Not Implemented" message, or substitute dummy data instead. Take some action to prevent further damage and to show that you're on top of the situation.

We've seen clean, functional systems deteriorate pretty quickly once windows start breaking. There are other factors that can contribute to software rot, and we'll touch on some of them elsewhere, but neglect accelerates the rot faster than any other factor.

You may be thinking that no one has the time to go around cleaning up all the broken glass of a project. If so, then you'd better plan on getting a dumpster, or moving to another neighborhood. Don't let entropy win.

FIRST, DO NO HARM

Andy once had an acquaintance who was obscenely rich. His house was immaculate, loaded with priceless antiques, objets d'art, and so on. One day, a tapestry that was hanging a little too close to a fireplace caught on fire. The fire department rushed in to save the day — and his house. But before they dragged their big, dirty hoses into the house, they stopped — with the fire raging — to roll out a mat between the front door and the source of the fire.

They didn't want to mess up the carpet.

Now that sounds pretty extreme. Surely the fire department's first priority is to put out the fire, collateral damage be damned. But they clearly had assessed the situation, were confident of their ability to manage the fire, and were careful not to inflict unnecessary damage to the property. That's the way it must be with software: don't cause collateral damage just because there's a crisis of some sort. One broken window is one too many.

One broken window — a badly designed piece of code, a poor management decision that the team must live with for the duration of the project — is all it takes to start the decline. If you find yourself working on a project with quite a few broken windows, it's all too easy to slip into the mindset of "All the rest of this code is crap, I'll just follow suit." It doesn't matter if the project has been fine up to this point. In the original experiment leading to the "Broken Window Theory," an abandoned car sat for a week untouched. But once a single window was broken, the car was stripped and turned upside down within hours.

By the same token, if you find yourself on a project where the code is pristinely beautiful — cleanly written, well designed, and elegant — you will likely take extra special care not to mess it up, just like the firefighters. Even if there's a fire raging (deadline, release date, trade show demo, etc.), you don't want to be the first one to make a mess and inflict additional damage.

Just tell yourself, "No broken windows."

RELATED SECTIONS INCLUDE

Topic 10, Orthogonality

Topic 40, Refactoring

Topic 44, Naming Things

CHALLENGES

Help strengthen your team by surveying your project neighborhood. Choose two or three broken windows and discuss with your colleagues what the problems are and what could be done to fix them.

Can you tell when a window first gets broken? What is your reaction? If it was the result of someone else's decision, or a management edict, what can you do about it?

Topic 4

Stone Soup and Boiled Frogs

The three soldiers returning home from war were hungry. When they saw the village ahead their spirits lifted — they were sure the villagers would give them a meal. But when they got there, they found the doors locked and the windows closed. After many years of war, the villagers were short of food, and hoarded what they had.

Undeterred, the soldiers boiled a pot of water and carefully placed three stones into it. The amazed villagers came out to watch.

"This is stone soup," the soldiers explained. "Is that all you put in it?" asked the villagers. "Absolutely — although some say it tastes even better with a few carrots…" A villager ran off, returning in no time with a basket of carrots from his hoard.

A couple of minutes later, the villagers again asked "Is that it?"

"Well," said the soldiers, "a couple of potatoes give it body." Off ran another villager.

Over the next hour, the soldiers listed more ingredients that would enhance the soup: beef, leeks, salt, and herbs. Each time a different villager would run off to raid their personal stores.

Eventually they had produced a large pot of steaming soup. The soldiers removed the stones, and they sat down with the entire village to enjoy the first square meal any of them had eaten in months.

There are a couple of morals in the stone soup story. The villagers are tricked by the soldiers, who use the villagers' curiosity to get food from them. But more importantly, the soldiers act as a catalyst, bringing the village together so they can jointly produce something that they couldn't have done by themselves — a synergistic result. Eventually everyone wins.

Every now and then, you might want to emulate the soldiers.

You may be in a situation where you know exactly what needs doing and how to do it. The entire system just appears before your eyes — you know it's right. But ask permission to tackle the whole thing and you'll be met with delays and blank stares. People will form committees, budgets will need approval, and things will get complicated. Everyone will guard their own resources. Sometimes this is called "start-up fatigue.''

It's time to bring out the stones. Work out what you can reasonably ask for. Develop it well. Once you've got it, show people, and let them marvel. Then say "of course, it would be better if we added…'' Pretend it's not important. Sit back and wait for them to start asking you to add the functionality you originally wanted. People find it easier to join an ongoing success. Show them a glimpse of the future and you'll get them to rally around.[7] 

Tip 6

Be a Catalyst for Change

THE VILLAGERS' SIDE

On the other hand, the stone soup story is also about gentle and gradual deception. It's about focusing too tightly. The villagers think about the stones and forget about the rest of the world. We all fall for it, every day. Things just creep up on us.

We've all seen the symptoms. Projects slowly and inexorably get totally out of hand. Most software disasters start out too small to notice, and most project overruns happen a day at a time. Systems drift from their specifications feature by feature, while patch after patch gets added to a piece of code until there's nothing of the original left. It's often the accumulation of small things that breaks morale and teams.

Tip 7

Remember the Big Picture

We've never tried this — honest. But "they" say that if you take a frog and drop it into boiling water, it will jump straight back out again. However, if you place the frog in a pan of cold water, then gradually heat it, the frog won't notice the slow increase in temperature and will stay put until cooked.

Note that the frog's problem is different from the broken windows issue discussed in Topic 3, Software Entropy. In the Broken Window Theory, people lose the will to fight entropy because they perceive that no one else cares. The frog just doesn't notice the change.

Don't be like the fabled frog. Keep an eye on the big picture. Constantly review what's happening around you, not just what you personally are doing.

RELATED SECTIONS INCLUDE

Topic 1, It's Your Life

Topic 38, Programming by Coincidence

CHALLENGES

While reviewing a draft of the first edition, John Lakos raised the following issue: The soldiers progressively deceive the villagers, but the change they catalyze does them all good. However, by progressively deceiving the frog, you're doing it harm. Can you determine whether you're making stone soup or frog soup when you try to catalyze change? Is the decision subjective or objective?

Quick, without looking, how many lights are in the ceiling above you? How many exits in the room? How many people? Is there anything out of context, anything that looks like it doesn't belong? This is an exercise in situational awareness, a technique practiced by folks ranging from Boy and Girl Scouts to Navy SEALs. Get in the habit of really looking and noticing your surroundings. Then do the same for your project.

Topic 5

Good-Enough Software

There's an old(ish) joke about a company that places an order for 100,000 ICs with a Japanese manufacturer. Part of the specification was the defect rate: one chip in 10,000. A few weeks later the order arrived: one large box containing thousands of ICs, and a small one containing just ten. Attached to the small box was a label that read: "These are the faulty ones.''

Striving to better, oft we mar what's well.

Shakespeare, King Lear 1.4

If only we really had this kind of control over quality. But the real world just won't let us produce much that's truly perfect, particularly not bug-free software. Time, technology, and temperament all conspire against us.

However, this doesn't have to be frustrating. As Ed Yourdon described in an article in IEEE Software, When good-enough software is best [You95], you can discipline yourself to write software that's good enough — good enough for your users, for future maintainers, for your own peace of mind. You'll find that you are more productive and your users are happier. And you may well find that your programs are actually better for their shorter incubation.

Before we go any further, we need to qualify what we're about to say. The phrase "good enough'' does not imply sloppy or poorly produced code. All systems must meet their users' requirements to be successful, and meet basic performance, privacy, and security standards. We are simply advocating that users be given an opportunity to participate in the process of deciding when what you've produced is good enough for their needs.

INVOLVE YOUR USERS IN THE TRADE-OFF

Normally you're writing software for other people. Often you'll remember to find out what they want. [8] But do you ever ask them how good they want their software to be? Sometimes there'll be no choice. If you're working on pacemakers, an autopilot, or a low-level library that will be widely disseminated, the requirements will be more stringent and your options more limited.

However, if you're working on a brand-new product, you'll have different constraints. The marketing people will have promises to keep, the eventual end users may have made plans based on a delivery schedule, and your company will certainly have cashflow constraints. It would be unprofessional to ignore these users' requirements simply to add new features to the program, or to polish up the code just one more time. We're not advocating panic: it is equally unprofessional to promise impossible time scales and to cut basic engineering corners to meet a deadline.

The scope and quality of the system you produce should be discussed as part of that system's requirements.

Tip 8

Make Quality a Requirements Issue

Often you'll be in situations where trade-offs are involved.

Surprisingly, many users would rather use software with some rough edges today than wait a year for the shiny, bells-and-whistles version (and in fact what they will need a year from now may be completely different anyway). Many IT departments with tight budgets would agree. Great software today is often preferable to the fantasy of perfect software tomorrow. If you give your users something to play with early, their feedback will often lead you to a better eventual solution (see Topic 12, Tracer Bullets).

KNOW WHEN TO STOP

In some ways, programming is like painting. You start with a blank canvas and certain basic raw materials. You use a combination of science, art, and craft to determine what to do with them. You sketch out an overall shape, paint the underlying environment, then fill in the details. You constantly step back with a critical eye to view what you've done. Every now and then you'll throw a canvas away and start again.

But artists will tell you that all the hard work is ruined if you don't know when to stop. If you add layer upon layer, detail over detail, the painting becomes lost in the paint.

Don't spoil a perfectly good program by overembellishment and overrefinement. Move on, and let your code stand in its own right for a while. It may not be perfect. Don't worry: it could never be perfect. (In Chapter 7, While You Are Coding, we'll discuss philosophies for developing code in an imperfect world.)

RELATED SECTIONS INCLUDE

Topic 45, The Requirements Pit

Topic 46, Solving Impossible Puzzles

CHALLENGES

Look at the software tools and operating systems that you use regularly. Can you find any evidence that these organizations and/or developers are comfortable shipping software they know is not perfect? As a user, would you rather (1) wait for them to get all the bugs out, (2) have complex software and accept some bugs, or (3) opt for simpler software with fewer defects?

Consider the effect of modularization on the delivery of software. Will it take more or less time to get a tightly coupled monolithic block of software to the required quality compared with a system designed as very loosely coupled modules or microservices? What are the advantages or disadvantages of each approach?

Can you think of popular software that suffers from feature bloat? That is, software containing far more features than you would ever use, each feature introducing more opportunity for bugs and security vulnerabilities, and making the features you do use harder to find and manage. Are you in danger of falling into this trap yourself?

Topic 6

Your Knowledge Portfolio

An investment in knowledge always pays the best interest.

Benjamin Franklin

Ah, good old Ben Franklin — never at a loss for a pithy homily. Why, if we could just be early to bed and early to rise, we'd be great programmers — right? The early bird might get the worm, but what happens to the early worm?

In this case, though, Ben really hit the nail on the head. Your knowledge and experience are your most important day-to-day professional assets.

Unfortunately, they're expiring assets. [9] Your knowledge becomes out of date as new techniques, languages, and environments are developed. Changing market forces may render your experience obsolete or irrelevant. Given the everincreasing pace of change in our technological society, this can happen pretty quickly.

As the value of your knowledge declines, so does your value to your company or client. We want to prevent this from ever happening.

Your ability to learn new things is your most important strategic asset. But how do you learn how to learn, and how do you know what to learn?

YOUR KNOWLEDGE PORTFOLIO

We like to think of all the facts programmers know about computing, the application domains they work in, and all their experience as their knowledge portfolios. Managing a knowledge portfolio is very similar to managing a financial portfolio:

1. Serious investors invest regularly — as a habit.

2. Diversification is the key to long-term success.

3. Smart investors balance their portfolios between conservative and high-risk, high-reward investments.

4. Investors try to buy low and sell high for maximum return.

5. Portfolios should be reviewed and rebalanced periodically.

To be successful in your career, you must invest in your knowledge portfolio using these same guidelines.

The good news is that managing this kind of investment is a skill just like any other — it can be learned. The trick is to make yourself do it initially and form a habit. Develop a routine which you follow until your brain internalizes it. At that point, you'll find yourself sucking up new knowledge automatically.

BUILDING YOUR PORTFOLIO

Invest regularly

Just as in financial investing, you must invest in your knowledge portfolio regularly, even if it's just a small amount. The habit is as important as the sums, so plan to use a consistent time and place, away from interruptions. A few sample goals are listed in the next section.

Diversify

The more different things you know, the more valuable you are. As a baseline, you need to know the ins and outs of the particular technology you are working with currently. But don't stop there. The face of computing changes rapidly — hot technology today may well be close to useless (or at least not in demand) tomorrow. The more technologies you are comfortable with, the better you will be able to adjust to change. And don't forget all the other skills you need, including those in nontechnical areas.

Manage risk

Technology exists along a spectrum from risky, potentially high-reward to low-risk, low-reward standards. It's not a good idea to invest all of your money in high-risk stocks that might collapse suddenly, nor should you invest all of it conservatively and miss out on possible opportunities. Don't put all your technical eggs in one basket.

Buy low, sell high

Learning an emerging technology before it becomes popular can be just as hard as finding an undervalued stock, but the payoff can be just as rewarding. Learning Java back when it was first introduced and unknown may have been risky at the time, but it paid off handsomely for the early adopters when it became an industry mainstay later.

Review and rebalance

This is a very dynamic industry. That hot technology you started investigating last month might be stone cold by now. Maybe you need to brush up on that database technology that you haven't used in a while. Or perhaps you could be better positioned for that new job opening if you tried out that other language….

Of all these guidelines, the most important one is the simplest to do:

Tip 9

Invest Regularly in Your Knowledge Portfolio

GOALS

Now that you have some guidelines on what and when to add to your knowledge portfolio, what's the best way to go about acquiring intellectual capital with which to fund your portfolio? Here are a few suggestions:

Learn at least one new language every year

Different languages solve the same problems in different ways. By learning several different approaches, you can help broaden your thinking and avoid getting stuck in a rut. Additionally, learning many languages is easy thanks to the wealth of freely available software.

Read a technical book each month

While there's a glut of short-form essays and occasionally reliable answers on the web, for deep understanding you need long-form books. Browse the booksellers for technical books on interesting topics related to your current project. [10] Once you're in the habit, read a book a month. After you've mastered the technologies you're currently using, branch out and study some that don't relate to your project.

Read nontechnical books, too It is important to remember that computers are used by people — people whose needs you are trying to satisfy. You work with people, are employed by people, and get hacked by people. Don't forget the human side of the equation, as that requires an entirely different skill set (we ironically call these soft skills, but they are actually quite hard to master).

Take classes

Look for interesting courses at a local or online college or university, or perhaps at the next nearby trade show or conference.

Participate in local user groups and meetups

Isolation can be deadly to your career; find out what people are working on outside of your company. Don't just go and listen: actively participate.

Experiment with different environments

If you've worked only in Windows, spend some time with Linux. If you've used only makefiles and an editor, try a sophisticated IDE with cutting-edge features, and vice versa.

Stay current

Read news and posts online on technology different from that of your current project. It's a great way to find out what experiences other people are having with it, the particular jargon they use, and so on.

It's important to continue investing. Once you feel comfortable with some new language or bit of technology, move on. Learn another one.

It doesn't matter whether you ever use any of these technologies on a project, or even whether you put them on your resume. The process of learning will expand your thinking, opening you to new possibilities and new ways of doing things. The crosspollination of ideas is important; try to apply the lessons you've learned to your current project. Even if your project doesn't use that technology, perhaps you can borrow some ideas. Get familiar with object orientation, for instance, and you'll write procedural programs differently. Understand the functional programming paradigm and you'll write object-oriented code differently, and so on.

OPPORTUNITIES FOR LEARNING

So you're reading voraciously, you're on top of all the latest breaking developments in your field (not an easy thing to do), and somebody asks you a question. You don't have the faintest idea what the answer is, and freely admit as much.

Don't let it stop there. Take it as a personal challenge to find the answer. Ask around. Search the web — the scholarly parts too, not just the consumer parts.

If you can't find the answer yourself, find out who can. Don't let it rest. Talking to other people will help build your personal network, and you may surprise yourself by finding solutions to other, unrelated problems along the way. And that old portfolio just keeps getting bigger….

All of this reading and researching takes time, and time is already in short supply. So you need to plan ahead. Always have something to read in an otherwise dead moment. Time spent waiting for doctors and dentists can be a great opportunity to catch up on your reading — but be sure to bring your own e-reader with you, or you might find yourself thumbing through a dog-eared 1973 article about Papua New Guinea.

CRITICAL THINKING

The last important point is to think critically about what you read and hear. You need to ensure that the knowledge in your portfolio is accurate and unswayed by either vendor or media hype. Beware of the zealots who insist that their dogma provides the only answer — it may or may not be applicable to you and your project.

Never underestimate the power of commercialism. Just because a web search engine lists a hit first doesn't mean that it's the best match; the content provider can pay to get top billing. Just because a bookstore features a book prominently doesn't mean it's a good book, or even popular; they may have been paid to place it there.

Tip 10

Critically Analyze What You Read and Hear

Critical thinking is an entire discipline unto itself, and we encourage you to read and study all you can about it. In the meantime, here's a head start with a few questions to ask and think about.

Ask the "Five Whys"

A favorite consulting trick: ask "why?" at least five times. Ask a question, and get an answer. Dig deeper by asking "why?" Repeat as if you were a petulant four-year old (but a polite one). You might be able to get closer to a root cause this way.

Who does this benefit?

It may sound cynical, but follow the money can be a very helpful path to analyze. The benefits to someone else or another organization may be aligned with your own, or not.

What's the context?

Everything occurs in its own context, which is why "one size fits all" solutions often don't. Consider an article or book touting a "best practice." Good questions to consider are "best for who?" What are the prerequisites, what are the consequences, short and long term?

When or Where would this work?

Under what circumstances? Is it too late? Too early? Don't stop with first-order thinking (what will happen next), but use second-order thinking: what will happen after that?

Why is this a problem?

Is there an underlying model? How does the underlying model work?

Unfortunately, there are very few simple answers anymore. But with your extensive portfolio, and by applying some critical analysis to the torrent of technical articles you will read, you can understand the complex answers.

RELATED SECTIONS INCLUDE

Topic 1, It's Your Life Topic 22, Engineering Daybooks CHALLENGES

Start learning a new language this week. Always programmed in the same old language? Try Clojure, Elixir, Elm, F#, Go, Haskell, Python, R, ReasonML, Ruby, Rust, Scala, Swift, TypeScript, or anything else that appeals and/or looks as if you might like it.[11] 

Start reading a new book (but finish this one first!). If you are doing very detailed implementation and coding, read a book on design and architecture. If you are doing high-level design, read a book on coding techniques.

Get out and talk technology with people who aren't involved in your current project, or who don't work for the same company. Network in your company cafeteria, or maybe seek out fellow enthusiasts at a local meetup.

Topic 7

Communicate!

I believe that it is better to be looked over than it is to be overlooked.

Mae West, Belle of the Nineties, 1934

Maybe we can learn a lesson from Ms. West. It's not just what you've got, but also how you package it. Having the best ideas, the finest code, or the most pragmatic thinking is ultimately sterile unless you can communicate with other people. A good idea is an orphan without effective communication.

As developers, we have to communicate on many levels. We spend hours in meetings, listening and talking. We work with end users, trying to understand their needs. We write code, which communicates our intentions to a machine and documents our thinking for future generations of developers. We write proposals and memos requesting and justifying resources, reporting our status, and suggesting new approaches. And we work daily within our teams to advocate our ideas, modify existing practices, and suggest new ones. A large part of our day is spent communicating, so we need to do it well.

Treat English (or whatever your native tongue may be) as just another programming language. Write natural language as you would write code: honor the DRY principle, ETC, automation, and so on. (We discuss the DRY and ETC design principles in the next chapter.)

Tip 11

English is Just Another Programming Language

We've put together a list of additional ideas that we find useful.

KNOW YOUR AUDIENCE

You're communicating only if you're conveying what you mean to convey — just talking isn't enough. To do that, you need to understand the needs, interests, and capabilities of your audience. We've all sat in meetings where a development geek glazes over the eyes of the vice president of marketing with a long monologue on the merits of some arcane technology. This isn't communicating: it's just talking, and it's annoying.[12] 

Say you want to change your remote monitoring system to use a third-party message broker to disseminate status notifications. You can present this update in many different ways, depending on your audience. End users will appreciate that their systems can now interoperate with other services that use the broker. Your marketing department will be able to use this fact to boost sales. Development and operations managers will be happy because the care and maintenance of that part of the system is now someone else's problem. Finally, developers may enjoy getting experience with new APIs, and may even be able to find new uses for the message broker. By making the appropriate pitch to each group, you'll get them all excited about your project.

As with all forms of communication, the trick here is to gather feedback. Don't just wait for questions: ask for them. Look at body language, and facial expressions. One of the Neuro Linguistic Programming presuppositions is "The meaning of your communication is the response you get." Continuously improve your knowledge of your audience as you communicate.

KNOW WHAT YOU WANT TO SAY

Probably the most difficult part of the more formal styles of communication used in business is working out exactly what it is you want to say. Fiction writers often plot out their books in detail before they start, but people writing technical documents are often happy to sit down at a keyboard, enter:

1. Introduction

and start typing whatever comes into their heads next.

Plan what you want to say. Write an outline. Then ask yourself, "Does this communicate what I want to express to my audience in a way that works for them?" Refine it until it does.

This approach works for more than just documents. When you're faced with an important meeting or a chat with a major client, jot down the ideas you want to communicate, and plan a couple of strategies for getting them across.

Now that you know what your audience wants, let's deliver it.

CHOOSE YOUR MOMENT

It's six o'clock on Friday afternoon, following a week when the auditors have been in. Your boss's youngest is in the hospital, it's pouring rain outside, and the commute home is guaranteed to be a nightmare. This probably isn't a good time to ask her for a memory upgrade for your laptop.

As part of understanding what your audience needs to hear, you need to work out what their priorities are. Catch a manager who's just been given a hard time by her boss because some source code got lost, and you'll have a more receptive listener to your ideas on source code repositories. Make what you're saying relevant in time, as well as in content. Sometimes all it takes is the simple question, "Is this a good time to talk about…?''

CHOOSE A STYLE

Adjust the style of your delivery to suit your audience. Some people want a formal "just the facts'' briefing. Others like a long, wide-ranging chat before getting down to business. What is their skill level and experience in this area? Are they experts? Newbies? Do they need hand-holding or just a quick tl;dr? If in doubt, ask.

Remember, however, that you are half of the communication transaction. If someone says they need a paragraph describing something and you can't see any way of doing it in less than several pages, tell them so. Remember, that kind of feedback is a form of communication, too.

MAKE IT LOOK GOOD

Your ideas are important. They deserve a good-looking vehicle to convey them to your audience.

Too many developers (and their managers) concentrate solely on content when producing written documents. We think this is a mistake. Any chef (or watcher of the Food Network) will tell you that you can slave in the kitchen for hours only to ruin your efforts with poor presentation.

There is no excuse today for producing poor-looking printed documents. Modern software can produce stunning output, regardless of whether you're writing using Markdown or using a word processor. You need to learn just a few basic commands. If you're using a word processor, use its style sheets for consistency. (Your company may already have defined style sheets that you can use.) Learn how to set page headers and footers. Look at the sample documents included with your package to get ideas on style and layout. Check the spelling, first automatically and then by hand. After awl, their are spelling miss steaks that the chequer can knot ketch.

INVOLVE YOUR AUDIENCE

We often find that the documents we produce end up being less important than the process we go through to produce them. If possible, involve your readers with early drafts of your document. Get their feedback, and pick their brains. You'll build a good working relationship, and you'll probably produce a better document in the process.

BE A LISTENER

There's one technique that you must use if you want people to listen to you: listen to them. Even if this is a situation where you have all the information, even if this is a formal meeting with you standing in front of 20 suits — if you don't listen to them, they won't listen to you.

Encourage people to talk by asking questions, or ask them to restate the discussion in their own words. Turn the meeting into a dialog, and you'll make your point more effectively. Who knows, you might even learn something.

GET BACK TO PEOPLE

If you ask someone a question, you feel they're impolite if they don't respond. But how often do you fail to get back to people when they send you an email or a memo asking for information or requesting some action? In the rush of everyday life, it's easy to forget. Always respond to emails and voicemails, even if the response is simply "I'll get back to you later.'' Keeping people informed makes them far more forgiving of the occasional slip, and makes them feel that you haven't forgotten them.

Tip 12

It's Both What You Say and the Way You Say It

Unless you work in a vacuum, you need to be able to communicate. The more effective that communication, the more influential you become.

DOCUMENTATION

Finally, there's the matter of communicating via documentation. Typically, developers don't give much thought to documentation. At best it is an unfortunate necessity; at worst it is treated as a low-priority task in the hope that management will forget about it at the end of the project.

Pragmatic Programmers embrace documentation as an integral part of the overall development process. Writing documentation can be made easier by not duplicating effort or wasting time, and by keeping documentation close at hand — in the code itself. In fact, we want to apply all of our pragmatic principles to documentation as well as to code.

Tip 13

Build Documentation In, Don't Bolt It On

It's easy to produce good-looking documentation from the comments in source code, and we recommend adding comments to modules and exported functions to give other developers a leg up when they come to use it.

However, this doesn't mean we agree with the folks who say that every function, data structure, type declaration, etc., needs its own comment. This kind of mechanical comment writing actually makes it more difficult to maintain code: now there are two things to update when you make a change. So restrict your non-API commenting to discussing why something is done, its purpose and its goal. The code already shows how it is done, so commenting on this is redundant — and is a violation of the DRY principle.

Commenting source code gives you the perfect opportunity to document those elusive bits of a project that can't be documented anywhere else: engineering trade-offs, why decisions were made, what other alternatives were discarded, and so on.

SUMMARY

Know what you want to say.

Know your audience.

Choose your moment.

Choose a style.

Make it look good.

Involve your audience.

Be a listener.

Get back to people.

Keep code and documentation together.

RELATED SECTIONS INCLUDE

Topic 15, Estimating Topic 18, Power Editing Topic 45, The Requirements Pit Topic 49, Pragmatic Teams

Online Communication

Everything we've said about communicating in writing applies equally to email, social media posts, blogs, and so on. Email in particular has evolved to the point where it is a mainstay of corporate communications; it's used to discuss contracts, to settle disputes, and as evidence in court. But for some reason, people who would never send out a shabby paper document are happy to fling nasty-looking, incoherent emails around the world.

Our tips are simple:

Proofread before you hit

SEND

.

Check your spelling and look for any accidental auto-correct mishaps.

Keep the format simple and clear.

Keep quoting to a minimum. No one likes to receive back their own 100-line email with "I agree" tacked on.

If you're quoting other people's email, be sure to attribute it, and quote it inline (rather than as an attachment). Same when quoting on social media platforms.

Don't flame or act like a troll unless you want it to come back and haunt you later. If you wouldn't say it to someone's face, don't say it online.

Check your list of recipients before sending. It's become a cliché to criticize the boss over departmental email without realizing that the boss is on the cc list. Better yet, don't criticize the boss over email.

As countless large corporations and politicians have discovered, email and social media posts are forever. Try to give the same attention and care to email as you would to any written memo or report.

CHALLENGES

There are several good books that contain sections on communications within teams, including The Mythical ManMonth: Essays on Software Engineering [Bro96] and Peopleware:

Productive Projects and Teams [DL13]. Make it a point to try to read these over the next 18 months. In addition, Dinosaur Brains: Dealing with All Those Impossible People at Work [BR89]

discusses the emotional baggage we all bring to the work environment.

The next time you have to give a presentation, or write a memo advocating some position, try working through the advice in this section before you start. Explicitly identify the audience and what you need to communicate. If appropriate, talk to your audience afterward and see how accurate your assessment of their needs was.

Footnotes

[3] http://wiki.c2.com/?ChangeYourOrganization

[4] See, for example, a good meta-analysis at Trust and team performance: A metaanalysis of main effects, moderators, and covariates, http://dx.doi.org/10.1037/apl0000110

[Trust and team performance: A meta-analysis of main effects, moderators, and covariates. - PsycNET](https://doi.apa.org/doiLanding?doi=10.1037%2Fapl0000110)

[5] See The police and neighborhood safety [WH82]

[6] See Contagious depression: Existence, specificity to depressed symptoms, and the role of reassurance seeking [Joi94]

[7] While doing this, you may be comforted by the line attributed to Rear Admiral Dr. Grace Hopper: "It's easier to ask forgiveness than it is to get permission.''

[8] That was supposed to be a joke!

[9] An expiring asset is something whose value diminishes over time. Examples include a warehouse full of bananas and a ticket to a ball game.

[10] We may be biased, but there's a fine selection available at https://pragprog.com.

[11] Never heard of any of these languages? Remember, knowledge is an expiring asset, and so is popular technology. The list of hot new and experimental languages was very different for the first edition, and is probably different again by the time you read this. All the more reason to keep learning.

[12] The word annoy comes from the Old French enui, which also means "to bore.''





务实的哲学

这是一本和你有关的书。

毫无疑问，你的事业是你自己的，更重要的是，你的人生是你的 —— 都是你自己所拥有的。之所以有必要读这本书，是因为我们相信自己可以成为一个更好的开发者，并能帮助其他人变得更好 —— 也就是说，可以成为一个务实的程序员。

务实的程序员的特质是什么？是他们面临问题时，在解决方案中透出的态度、风格及理念。他们总是越过问题的表面，试着将问题放在更宽泛的上下文中综合考虑，从大局着想。毕竟，若不去了解来龙去脉，结合实际如何谈起？又怎能做出明智的妥协和合理的决策？

他们的另一个成功点是他们为所做的一切负责。关于这一点，我们会在我的源码被猫吃了中讨论。责任感驱使务实派程序员不会在他们的项目分崩离析时坐视不管。在软件的熵中，我们将告诉你如何让项目保持清爽。

大多数人很难接受改变，这或许有充分的理由，也有可能仅仅是旧有的惰性使然。在石头做的汤和煮熟的青蛙中，我们会看到一个推动变革的策略（考虑利益平衡），了解一个两栖动物忽视了渐进变化中风险的寓言故事。

了解所做工作的来龙去脉有一个好处，那就是更容易把握软件必须做到多好。接近完美往往才是唯一的选项，这通常需要做许多折衷方案。我们将在够好即可的软件中展开。

当然，你需要大量的基础知识和经验，才可能实现以上这些。学习是一个持续不断的过程。在知识组合中，我们会讨论一些保持学习劲头的方法。

最后，没有与世隔绝的工作。我们总是在花大量的时间和其他人打交道。交流！列出了让我们做得更好的一系列方法。

务实的编程源于务实思考的哲学。这一章描述了这种哲学的基调

1

人生是你的

我活着不是为了满足你的期望，正如你也不是因为我的期望而活着。

—— 李小龙

人生是你自己的，是你在拥有、经营和创造。

我们和很多沮丧的开发者交谈过。他们的担忧多种多样。一些人感觉自己的工作停滞不前。还有一些人认为自己的技术已经过时了。有人觉得自己没有得到应有的重视，有人觉得薪水过低，有人觉得团队已经一团糟。一些人想去亚洲或是欧洲工作，一些人想在家工作。

对此，我们总是给出相同的答案。

「为什么你不考虑改变一下呢？」

软件开发在任何职业列表中，绝对是你自己最能掌控的职业之一。我们的技能供不应求，我们的知识不限于地域，我们可以远程工作。我们收入颇丰。我们真的能做我们想做的任何事情。

但是，总有一些原因导致开发者拒绝改变。他们缩在那里，期盼着事情会自己变好。他们眼睁睁地看着自己的技能过时，却抱怨公司没有给予培训。他们乘着公交车，路过广告林立的街道，顶着凄雨寒风，钻入写字楼工作。

因此，这里给出本书最重要的提示。

提示 3 你有权选择

你的工作环境很糟糕？你的工作很无聊？尝试纠正它。不过，不要一直试下去。正如 Martin Fowler 说的，「你可以去改变组织，或是让自己换一个组织。」如果你的技术过时了，安排时间（你自己的时间）学习一些看起来有趣的新东西。这是一种自我投资，只有为此而加班才是合理的。

想远程工作？要求过了吗？如果他们说不行，就去找个说行的人。

这个行业给了你一系列非凡的机遇。积极主动点，掌控这些机遇。

相关部分包括：

·话题 4：石头做的汤和煮熟的青蛙，位于第 9 页

·话题 6：知识组合，位于第 14 页

2

我的源码被猫吃了

在所有弱点中，最大的弱点就是害怕出现弱点。

—— J.B.Bossuet，Politics from Holy Writ，1709

在你的职业发展、学习教育，以及你的项目、每天的工作等各方面对你自己负责，对你的行为负责，这是务实哲学的基石之一。一个务实的程序员能完全掌握自己的职业生涯，从不害怕承认无知和错误。有些事在编程中会令人不快，但却必然会发生 —— 即使最好的项目也无法幸免。尽管有彻底的测试，有优秀的文档，有完备的自动化，结果还是出了问题 —— 交付被推迟，未曾预料的技术问题出现。

一旦这些事情发生，尝试依靠我们的专业性去解决问题。这意味着要诚实和坦率。我们固然会为我们的能力而骄傲，但面对缺点时也必须诚实 —— 承认我们犯了错误，而且是因为我们的无知而犯下的。

团队信任

首先，你的团队需要能信赖和依赖你 —— 你也应该同样地放心依赖他们每个人。有研究文献表明，团队信任对于创造力和协作至关重要。在一个以信任为基础的健康环境中，你可以安全地说出你的想法，表达你的思想。学会依赖你的团队成员，他们也会依赖你。如果缺少信任，那么……

假设有支高科技的秘密忍者小队正潜入反派的邪恶巢穴。经过几个月的细致规划、精确执行，最终成功抵达现场。当轮到你来设置激光导栅时，传来：「兄弟们，不好意思，我忘带激光器了。我拿去逗猫玩，落在了家里。」

这种对信任的破坏可能难以修复。

承担责任

责任意味着你对某事积极认同。你保证事情能搞定，并为之做出承诺，但你不必直接掌控事情的每个方面。除了个人尽力做好，你必须分析超出你控制范围的风险情况。如果责任的伦理内涵过于含糊，或是面对无法实现的情况，抑或风险过大，你都有权不承担责任。你必须根据自己的价值观和判断做出决定。

当你决定对一个结果承担责任时，要明白这意味着你将承接相关的义务。当你犯了错误（就像我们所有人一样），或是做出了错误的判断时，诚实地承认它，并尝试给出选择。

不要把问题归咎于别人或其他什么事情上，也不要寻找借口。不要把所有问题都归咎于供应商、编程语言、管理或是同事。这些因素都可能是问题的一部分。它们的确会对解决方案造成影响，但不是给你的借口。

如果你面临供应商帮不上忙这样的风险，就应该制订一个应急方案。如果磁盘挂起 —— 你所有的源码都在里面 —— 而你没有备份，这就是你的错。跟你的老板说「我的源码被猫吃了」解决不了问题。

提示 4 提供选择，别找借口

如果你打算跟别人解释为什么做不完、为什么延期、为什么搞砸，在此之前先等等，听一下自己的内心。讲给你显示器上的橡皮鸭听听，或是先对着猫说一遍。你的那些借口听起来合理吗？还是很愚蠢？你的老板听到会怎样？

把谈话在心里过一遍。其他人可能说什么？他们会问，「你试过这样做吗……」「为什么你不考虑一下那样做？」而你怎么回答？在你跑去告诉他们坏消息前，还有什么你可以再试试的？有时，你已经知道他们会说什么，那么就直接帮他们搞定。

给出选择，而不是找借口。不要说搞不定；解释一下要做些什么才能挽回这个局面。是否必须扔掉这些代码呢？给他们讲讲重构的价值（参见第 216 页的话题 40：重构）。你是否需要一点时间来做原型？因为只有这样才能决定后面怎么做最好（参见第 57 页的话题 13：原型与便签）。为了防止错误再次发生，你是否需要引入更好的测试（参见第 220 页的话题 41：为编码测试和第 288 页的无情的持续测试）或增加自动化流程？

也许你需要额外的资源才能完成这项任务。或许你需要花更多的时间和用户打交道？也可能仅仅是你自己需要时间：你需要学习一些技能吗？需要对某项技能学习得更深入一些？读一本书或许有用？或是学习一门课程？别害怕请教别人，别害怕承认自己需要帮助。

打算敷衍搪塞前，试着驱走这些念头。如果实在做不到，那么就先和你的猫通个气。毕竟你想让这只可怜的小猫背锅……

相关部分包括：

·话题 49：务实的团队，位于第 277 页

挑战

·当某人 —— 比如银行职员、汽车修理工、店员 —— 敷衍搪塞你时，你的反应是什么？你会怎么看他们和他们的公司？

·当你意识到自己在说「我不知道」时，一定要接着说「—— 但是我会去搞清楚」。用这样的方式来表达你不知道是非常好的，因为接着你就可以像一个专家一样承担起责任。

3

软件的熵

虽然软件开发不受绝大多数物理法则的约束，但我们无法躲避来自熵的增加的重击。熵是一个物理学术语，它定义了一个系统的「无序」总量。不幸的是，热力学法则决定了宇宙中的熵会趋向最大化。当软件中的无序化增加时，程序员会说「软件在腐烂」。有些人可能会用更乐观的术语来称呼它，即「技术债」，潜台词是说他们总有一天会偿还的 —— 恐怕不会还了。

不过不管叫什么名字，债务和腐烂都可能失控地蔓延开。

有很多因素会导致软件腐烂。最重要的一个似乎是项目工作中的心理性状态，或者说文化。即使是一个单人团队，你的项目的心理性状态也是个非常脆弱的东西。即使有最合理的计划和最佳的人员，项目还是可能在生命周期中逐步荒废、腐烂。但也有一些项目在经历了巨大的困难、持续不断的挫折之后，成功地对抗了天然的无序化倾向，走出了困境。

是什么造成了差异？

在城市中心，有些建筑干净漂亮，而另一些则破落不堪。为什么会这样？一些犯罪和城市衰败领域的研究人员发现了一个有趣的触发机制，只需一样东西就能非常迅速地把一幢干净完好的宜居建筑变成一个破败的废弃物。一扇破窗。

一扇破损的窗户，只要一段时间不去修理，建筑中的居民就会潜移默化地产生一种被遗弃的感觉 —— 当权者不关心这幢建筑的感觉。然后，其他的窗户也开始损坏，居民开始乱丢废物，墙上开始出现涂鸦，建筑开始出现严重的结构性损坏。在一段看上去很短的时间内，建筑的损坏程度就足以打消业主们想修好它的期望，被遗弃的感觉最终变成了现实。

为何造成这样的影响？心理学家的研究表明，绝望是会传染的，就像狭窄空间中的流感病毒。无视一个明显损坏的东西，会强化这样一种观念：看来没有什么是能修好的，也没人在乎，一切都命中注定了。所有的负面情绪会在团队成员间蔓延，变成恶性循环。

提示 5 不要放任破窗

不要搁置「破窗」（糟糕的设计、错误的决定、低劣的代码）不去修理。每发现一个就赶紧修一个。如果没有足够的时间完全修好，那么就把它钉起来。也许你可以注释掉那些糟糕的代码，显示一行「尚未实现」的信息，或用假数据先替代一下。采取行动，预防进一步的损害发生，表明一切尽在你的掌握中。

现在我们了解了一旦窗户开始破裂，运转良好的干净系统会迅速恶化。还有一些其他因素会导致软件腐烂，我们将在别处探讨，但与其他任何因素相比，漠视会加速腐烂的过程。

你或许会觉得，没人有时间来来回回清理项目中所有的碎玻璃。如果你真这么想，劝你还是趁早多想想怎么料理这个项目的后事，或是直接离开是非之地。不要让熵赢得胜利。

先勿伤害

多年以前，Andy 认识一个土豪。他的房子富丽堂皇，屋子里摆满了无价的古董，到处陈列着精美的艺术品。有一天，一张挂毯因为离客厅壁炉太近而着火了。消防员奋勇冲进去救民于水火，当然主要是火。但是在把巨大的水管拖进屋子前，他们停了下来 —— 尽管里面火势紧急 —— 毅然选择先在前门和火源之间铺上垫子，因为觉得水管太脏。

他们不想弄坏地毯。

现在听起来这很偏激。消防部门的首要任务当然是灭火，何必管过程中的那些附带损害呢？但是他们在清醒地评估了形势后，出于对自己控制这场火势能力的绝对自信，还是尽力兼顾了不对财物造成不必要的毁害。这也是软件开发中应该遵循的方法：不要只是因为一些东西非常危急，就去造成附带损害。破窗一扇都嫌太多。

一扇破窗 —— 一段设计糟糕的代码，一个让团队在整个项目周期内都必须要遵守的糟糕管理决定 —— 就是一切衰退的开始。如果你发现自己正处在有几扇破窗的项目中，就非常容易陷入这样的想法 ——「反正代码所有其他部分都是一坨屎，我只是随大流而已。」项目运作在这个时间点前是不是一直良好并不重要。在最初启发「破窗理论」的实验中，一辆废弃的汽车完好无损地停放了一个星期。但是一旦有一块玻璃被打破，这辆车在几个小时内就会被扒光并翻了个底朝天。

出于同样原因，如果身处一个健康团队，你们项目的代码如此完美 —— 编写清晰、设计优良、简洁优雅 —— 你就会倾向于格外地小心，不把它弄糟。就像那些消防员一样，即使屋内火势熊熊（截止时限、发行日期、销售演示，等等），你也不想成为第一个弄乱它、造成附带损害的人。

一定要告诉自己，「不要打破窗户。」

相关部分包括：

·话题 10：正交性，位于第 40 页

·话题 40：重构，位于第 216 页

·话题 44：事物命名，位于第 245 页

挑战

·通过在项目的社区中做调研来帮助团队变强。选择两三个破掉的窗户，与你的同事讨论问题是什么，以及可以做些什么来修复。

·你能说出第一扇破窗是何时产生的吗？你对此有何反应？如果这是别人决定的结果，或者是一个管理命令，那你能做点什么吗？

4

石头做的汤和煮熟的青蛙

有三个战场归途中的士兵饥肠辘辘。他们看到前方有一座村庄，顿时重整精神 —— 他们觉得村民们会给口饭吃。可是当他们抵达那里时，却发现四处门窗紧闭。多年战乱下，村民们食物短缺，仅有的存粮都藏了起来。

士兵们没有气馁，他们烧了一锅水，小心翼翼地在里面放了三块石头。诧异的村民们都跑出来围观。

「这叫石头汤。」士兵们解释道。「你们在汤里只放这个？」村民们问道。「对 —— 不过有人说如果加点胡萝卜味道会好一些……」一个村民转身跑回了家，从自己的窖藏中拎来了一筐胡萝卜。

几分钟之后，村民们又问道「这就可以了吗？」

「可以了，」士兵们说道，「加几个土豆或许更有味道。」另一个村民听到后跑开了。

在接下来的一个小时内，士兵们列出了更多食材：牛肉、韭菜、盐及各种香料，说能让汤做得更加鲜美。每次都有不同的村民跑回去取来自己的私藏。

最后，他们煮了一大锅热气腾腾的汤。士兵们把汤里的石头扔掉，和整个村子的村民一起分享了一顿美餐，这是他们所有人几个月以来吃的第一顿饱餐。

石头汤这个故事讲述了很多道理。村民被士兵骗了，士兵利用了村民的好奇心来获取食物。不过更重要的是，士兵充当了催化剂的角色，将村民们组织了起来。这样他们才能聚在一起做出他们无法单独做到的事情 —— 一项协作的成果。最后所有人都是赢家。

从现在开始，你要考虑仿效这些士兵。

你可能处在这样一种状况下 —— 清楚地知道需要做些什么，以及怎样去做。整个系统就在你的眼前 —— 你知道这样做就对了。但当你为做整件事去征求意见的时候，见到的往往是推脱和茫然的眼神。人们想成立一个委员会，然后申请预算，之后事情会变得异常繁杂。每个人都会守着自己的一亩三分田。有时我们称之为「筹备期的劳累」。这个时候，就该拿出石头了 —— 找出你合理的请求，然后不断完善。一旦有成果产出，展示给人们看，让他们大吃一惊。现在可以用上「当然了，它还可以更好，只要我们再加点……」这句话，而且要假装你并不在意。这时先坐下来，等他们开始问你要不要加些你原本想要的功能。人们都觉得，加入一个推进中的成功项目更容易一些。因为只要一窥未来，大家就能团结在一起。提示 6 做推动变革的催化剂

村民们的角度

换个角度来看，石头汤的故事讲述的是一个温和渐进的骗局。因为过于将注意力集中在石头上，村民们忘却了石头外的世界，这很像我们每天陷入俗事缠身的状态。

项目进展缓慢，完全失去了控制 —— 这是很常见的症状。大多数软件灾难都始于微不足道的小事，项目的拖延也是一天天累积而成的。系统一个特性接一个特性地偏离规范，一个接一个的补丁加到代码上，最终原始代码无影无踪。往往就是一件件小事的累积破坏了团队和士气。

提示 7 牢记全景

老实说，下面这件事其实我们从来都没试过。只是听「有人」说过，如果你抓住一只青蛙，把它扔进沸水中，它立刻就会跳出来。但是，如果你把青蛙放在一锅冷水中，然后缓慢地加热，青蛙就不会意识到水温在缓慢上升，直到它们被煮熟。

注意，青蛙的案例和第 6 页的话题 3：软件的熵讨论的破窗问题不同。破窗理论中，人们失去打败熵的斗志是因为他们觉得没其他人在乎。而青蛙仅仅只是未察觉到变化。

不要学寓言里的青蛙，永远留意着大局，持续不断地审视你身边发生的事情，而不要只专注于你个人在做的事情。

相关部分包括：

·话题 1：人生是你的，位于第 2 页

·话题 38：巧合式编程，位于第 204 页

挑战

·在审阅第一版的草稿时，John Lakos 提出了这样一个问题：士兵们一步步地欺骗着村民，但他们作为催化剂促成的变化对大家都好。然而，你一步步地欺骗青蛙，却是在伤害它。你在催生变化的时候，能判别是在做石头汤还是青蛙汤吗？这个决定是出于主观还是客观？

·不要看，马上回答，你头顶的天花板上有几盏灯？屋子里一共有几盏灯？有多少人？有没有发现什么东西有违和感，感觉它们不应该属于这里？这是一个情景感知的练习，从童子军到海豹突击队，人们都在练习这种技巧。先养成仔细观察周围环境的习惯，然后在项目中这样做。

5

够好即可的软件

为了追求更好，我们毁损了原已够好的。

—— 莎士比亚《李尔王 1.4》

有个（有点）老的笑话是这样的：一家美国公司向一家日本制造商下了一个 100，000 片集成电路的订单。规格书上指定了次品率：10，000 片中只能有一片。几周后，订单完成，货也送到了。只是一大箱的芯片外，还有一个小盒子里装有十片芯片，盒子上贴着的标签写着「这些是次品」。

要是我们真能这样控制质量就好了。但现实世界不会让我们生产出太多真正完美的产品，尤其是完全没有 Bug 的软件。时间、技术、急躁合力对抗着我们。

然而，莫要太沮丧。如《IEEE 软件》杂志上一篇由爱德华·尤登写的文章《够好即可的软件就是最好的》[You95]

所述，你能训练自己写出够好即可的软件 —— 对用户、未来的维护者来说够好即可，只要好的程度能让你自己内心平静就可以。你会发现，你变得更有效率，用户也更快乐。而且，可能让你更开心的是，更短的孵化期促使你的程序实际上更好了。

在进一步讨论之前，我们需要对将要讨论的内容做一些限定。「够好即可」这个词并不意味着草率或糟糕的代码。所有系统必须达到用户的需求才算完成，需要达到基本的性能、隐私和安全标准。你做的东西，从用户需求角度来说是否足够好？最好还是留给用户一个机会，让他们能亲自参与评判。

让用户参与权衡

通常你是为别人开发软件，总能记得找出他们的需求。但你是否经常询问他们，到底希望软件好到什么程度？事实上很多时候根本没有选择。如果你的软件用于起搏器、航天飞机，或是被广泛使用的底层库，需求会更苛刻，而且能做的选择也很有限。

不过，如果你正在开发一个全新的产品，面临的约束条件将有所不同 —— 市场人员要信守他们的承诺，最终用户可能也已经基于交付时间表制订好了计划，公司更是肯定会受现金流的约束。无视来自用户方面的需求，一味地向程序中堆砌功能，一次又一次打磨代码，这是很不专业的表现。心浮气躁当然不值得提倡，比如承诺一个无法兑现的时间尺度，然后为了赶上截止期而去删减必要的边角工程，这同样是不专业的做法。

对于你创建的系统，其应用领域和要达到的质量，必须作为系统需求的一部分加以讨论。

提示 8 将质量要求视为需求问题

人们经常会遇到需要权衡利弊的情况。令人惊讶的是，许多用户宁愿今天就用上一个毛糙的软件，也不愿意多等上一年再用那个打磨光亮、功能齐备的版本（而且，实际上他们一年后真正需要的东西可能完全不同）。许多预算紧张的 IT 部门会同意这样的说法。与构想中的明天那个完美的软件相比，今天就还不错的软件通常更讨人喜欢。如果你早点给用户一点东西玩，他们的反馈常常能引领你做出更好的最终方案（参见第 51 页的话题 12：曳光弹）。

知道何时止步

在某些方面，编程就像绘画。你从一张空白的画布开始，只有一些非常基础的原料。你糅合了科学、艺术、工艺手段来决定用这些原料做点什么。你勾勒出一个整体的形状，绘制出潜在的基调，然后再装点细节。你不断地带着批判的眼光回顾自己已完成的部分。你会时不时地扔掉一张画布，然后重新开始。

不过艺术家会告诉你，如果你不知道什么时候该停止，那么所有的努力就都白费了。如果你不断地一层叠一层，细节盖细节，绘画将迷失在颜料中。

不要让过度的修饰和精炼侵蚀掉一个完好的程序。继续前行，让代码在它该有的位置驻留一段时间。它或许并不完美，不要紧的 —— 它就算永不完美也没关系。（在第 198 页第 7 章当你在编码时中我们将讨论在不完美的世界中开发代码的哲学。）

相关部分包括：

·话题 45：需求之坑，位于第 252 页

·话题 46：处理无法解决的难题，位于第 260 页

挑战

·看一看经常使用的软件工具和操作系统，能不能找到一些迹象，表明开发它们的组织及开发者在知道其不完美的情况下，还是心安理得地发布了。作为用户，你是更想（1）等所有的 Bug 都修复了再用，还是（2）想要一个复杂的软件并接受它有一些 Bug，或是在可选的情况下（3）使用一个更简单但是瑕疵更少的软件？

·考虑模块化对软件交付的影响。一个单块软件和一个按模块设计的系统相比，满足质量要求所需的开发时间，是多还是少？你能找到商业案例吗？

·你能想到哪些受功能膨胀所累的流行软件？就是说，软件包含的特性远远超过了你每次使用时所需。每个特性都有机会引入新的 Bug 和安全漏洞，而且使你很难找到并掌握你真正想用的那些特性。你自己有没有落入这个陷阱的危险？

6

知识组合

投资知识，收益最佳。

—— 本杰明·富兰克林

啊哈，富兰克林那家伙老是滔滔不绝地讲些大道理。呃，我们只要早起早睡，就能成为伟大的程序员 —— 真的吗？早起的鸟儿或许有虫吃，但是早起的虫儿会怎样？

不过，开头那句话富兰克林还真是说到了点子上，知识和经验的确是你最重要的专业资产。

可惜的是，它们是一种时效资产。随着新技术的出现，以及语言和环境的发展，你的知识会变得过时。不断变化的市场力量可能会使经验变得陈旧而无关紧要。鉴于技术社会变化的速度越来越快，这种事情可能会发生得特别迅速。

当你的知识价值下降时，你对于公司或客户的价值也在下降。我们想阻止这一切的发生。

学习新事物的能力是你最重要的战略资产。但是如何获取学习方法，又如何知道该学什么呢？

知识组合

我们可以将程序员所了解的一切有关计算过程的事实、工作的应用领域，以及所有经验，视为他们拥有的知识组合。管理知识组合和管理金融投资组合非常的类似：

1. 正规投资者有定期投资的习惯。

2. 多样化是长线成功的关键。

3. 聪明的投资者会平衡保守型和高风险高回报型投资的组合。

4. 投资者用低买高卖来获得最大的回报。

5. 应定期审查和重新平衡投资组合。

要想事业成功，你必须用同样的指导方针管理你的知识组合。

好消息是，管理这类投资是一项技能，就像其他技能一样 —— 可以学会。诀窍是让自己一开始就这样做，并养成习惯。制定一个你能遵循的例行规程，照此去做，直到大脑将其内化。做到这个程度后，你会发现自己会自动吸收新知识。

构建知识组合

定期投资

就像金融投资一样，你必须定期为你的知识组合投资，即使数量有限。习惯本身就和总数量一样重要，所以要安排一个固定的时间和地点，这有助于撇开常见的干扰。下一部分将列出一些示例目标。

多样化

你知道的东西越多，你的价值就越大。起码要知道目前工作中特定技术的来龙去脉，但不要就此打住。计算机技术变化迅猛 —— 今天的技术热点可能到了明天就接近无用（至少不那么受欢迎）。熟悉的技能越多，越能适应变化。

风险管理

不同技术在从高风险高回报到低风险低回报的区间均匀分布。把所有的钱都投在高风险股票中绝非明智，因为有可能突然崩盘，同样你也不应该把所有的钱都投资在保守的领域，那样可能错失良机。不要把所有的技术鸡蛋都放在一个篮子里。

低买高卖

在一项新兴技术变得流行之前就开始学习，可能和发现一只被低估的股票一样困难，但是所得到的收获会和此类股票的收益一样好。在 Java 刚发明的时候就去学习，可能有很大风险，不过当 Java 流行后，那些早期用户都获得了相当丰厚的回报。

重新评估调整

这是一个充满活力的行业。你上个月开始研究的热门技术现在可能已经凉下来了。也许你需要刷新一下有段时间没用过的数据库技术。或者，不妨去尝试另一种语言，它可能会让你在新的工作中处于更有利的地位……

在所有这些指导方针中，最重要的下面这条做起来反而最简单。

提示 9 对知识组合做定期投资

目标

现在你已经有了一些指导方针，知道什么时候添加什么内容到知识组合中。对于那些构成知识组合的智力资产，获取它们的最佳途径是什么？这里有一些建议：

每年学习一门新语言

不同的语言以不同的方式解决相同的问题。多学习几种不同的解决方法，能帮助自己拓宽思维，避免陷入陈规。此外，要感谢丰富的免费软件，让我们学习多种语言非常容易。

每月读一本技术书

虽然网络上有大量的短文和偶尔可靠的答案，但深入理解还是需要去读长篇的书。浏览书店页面后挑选和你当前项目主题相关的技术图书。一旦你养成习惯，就一个月读一本。在你掌握了当前正在使用的所有技术后，扩展你的领域，学习一些和你的项目不相关的东西。

还要读非技术书

记住，计算机是由人来使用的，你做的事情是为了满足人的需要，这非常重要。和你一起工作的是人，雇佣你的也是人，黑你的还是人。不要忘记方程式中人的那一面，它需要完全不同的技能集（我们称这些为软技能，听起来很容易，但实际上它们很硬核，难以掌握）。

上课

在本地大学或是网上找一些有趣的课程，或许也能在下一场商业会展或是技术会议上找到。

加入本地的用户组和交流群

不要只是去当听众，要主动参与。独来独往对你的职业生涯是致命的；了解一下公司之外的人们都在做什么。

尝试不同的环境

如果你只在 Windows 下工作，那么就花点时间在 Linux 上。如果你只使用简单的编辑器和 Makefile，那就试试最新的炫酷复杂的 IDE，反之亦然。

与时俱进关心一下和你当前项目不同的技术，阅读相关的新闻和技术帖。这是一种很好的方式，可以了解用到那些不同技术的人的经验及他们所用的特殊术语，等等。

持续投资非常重要。一旦你进入了对某个新语言或新技术的舒适期，向前走，再学一个。

你是否在项目中使用过这些技术并不重要，甚至要不要把它们放在你的简历中也不重要。学习的过程将会扩展你的思维，为你打开全新可能性的大门，让你领悟新的做事方式。想法的交叉传授是很重要的；试着把你领悟到的东西应用到你当前的项目中。即使项目没有用到某项技术，你也可以借鉴一些想法。例如，熟悉面向对象，你就可以用不同的方式来编写朴素的 C 程序，理解函数式编程范式，就能用不同的方式来写 Java，等等。

学习的机会

你如饥似渴地阅读，已站在你所在领域的最新突破性进展前沿（这可不是件容易的事）。尽管如此，当有人问你问题时，如你的确毫无思路，也只能坦率地承认自己无法作答。

但不要停在这里，把找到答案作为一项个人挑战。问问周围的人，或是上网搜索 —— 不要仅限于大众领域，还要试试在学术领域找一下。

如果你无法自己找到答案，去寻觅有能力找到答案的人，而不要让问题沉寂下去。和其他人交谈有助于构建你的人际网络，而且你还会惊奇地发现，在这个过程中你会找到一些其他不相关问题的解决方案 —— 旧有的知识组合会不断地扩大……

所有阅读和研究都需要时间，而时间总是不够用的。所以你需要提前准备好，确保在无聊的时候有东西可读。在医院排队往往是把书读完的好机会 —— 不过一定要记得带上自己的电子阅读器。不然可能只好去翻医院里的旧年刊，里面折起的那页讲的是 1973 年的巴布亚新几内亚。

批判性思维

最后一个要点是要批判性地思考读到的和听到的东西。你需要确保组合中的知识是精准的，未受供应商或媒体炒作的影响。当心坚持教条的狂热者，他们将其视为唯一答案 —— 而那些教条未必适合你和项目。

永远不要低估商业主义的力量。网络搜索引擎有时仅仅是把热门的东西列在最前面而已，并不能说明这是你的最佳选择，而且内容提供商也可以花钱把它们的东西排到前列。书店有时仅仅是把一本书摆在显著的位置而已，并不能说明这是一本好书，甚至不能说明这本书很流行，可能只是有人花钱把它摆在了那里。

提示 10 批判性地分析你读到和听到的东西

批判性思维本身就是一门完整的学科，我们鼓励你仔细研究和学习这门学科。现在先在这里起个头，问几个值得思考的问题。

问「五个为什么」

我最喜欢的咨询技巧是：至少问五次「为什么」。就是说，每当有了答案后，还要追问「为什么」。像个烦人的四岁小孩那样经常性重复提问，不过记得要比小朋友更有礼貌。这样做可以让你更接近本源。

谁从中受益

虽然听起来有点世俗，不过追踪钱的流动更容易理清脉络。其他人或其他组织的利益可能和你自己的一致，也可能不一致。

有什么背景

每件事都发生在它自己的背景下，这也是为何「能解决所有问题」的方案通常不存在，而那些兜售「最佳实践」的书或文章实际上经不起推敲。「最适合谁」是一个值得考虑的好问题，类似的还有先决条件是什么、后果是什么，以及是短期的还是长期的。

什么时候在哪里可以工作起来

是在什么情况下？太晚了吗？太早了吗？不要停留在一阶思维下（接下来会发生什么），要进行二阶思考：当它结束后还会发生什么？

为什么这是个问题

是否存在一个基础模型？这个基础模型是怎么工作的？

很不幸，现在很难再找到简单的答案。但借助广泛的知识组合，在你将读到的海量技术出版物上加一点批判性分析，你就能理解那些复杂的答案。

相关部分包括：

·话题 1：人生是你的，位于第 2 页

·话题 22：工程日记，位于第 101 页

挑战

·本周就开始学习一门新语言。你是不是一直在用同一门古老的语言编程？试试 Clojure、Elixir、Elm、F#、Go、Haskell、Python、R、ReasonML、Ruby、Rust、Scala、Swift、Typescript，或是其他你看过去感觉会喜欢的语言。·开始读一本新的书（不过一定要先把我们这本书读完！）。如果你正在做非常细致的实现和编码工作，就去读一本讲设计和构架的书。如果你正在较高的层次做设计工作，就去读一本讲编码技术的书。

·走出去和那些与你当前项目无关的人谈谈技术，和别的公司的人聊聊。试着在公司餐厅建立你的人脉，或是去参加本地的聚会，找一些志同道合的人。

7

交流！

我认为被人从头打量到脚总比被人视而不见要好。

—— 梅·韦斯特 电影：《九十岁的美女》，1934

也许我们可以向韦斯特女士学习。只拥有是不够的，还要看你如何包装它。即使拥有最好的想法、漂亮的代码、最务实的思想，如果不能和他人交流，最终都无法孕育出果实。缺乏有效的沟通，好点子就成了一个孤儿。

作为开发人员，我们必须在多个层次上进行交流。我们会花数个小时开会，倾听和交谈。我们会和最终用户一起合作，去理解他们的需求。我们编写代码，代码将我们的意图传达给机器；我们编写文档，文档为下一代开发者记录了我们的想法。我们写建议和备忘录，用于解释资源申请、报告现状及提出新的方案。我们每天都在团队中工作 —— 倡导想法、修改实践或提出建议。我们每天的大部分时间都花在了交流上，所以需要把它做好。

把英语（或者你的母语是别的什么语言）看成另一门编程语言。像写代码一样用自然语言写文章：尊重 DRY 原则、ETC、自动化，等等。（我们会在下一章讨论 DRY 和 ETC 设计原则。）

提示 11 英语就是另一门编程语言

这里汇总了其他我们认为有用的想法。

了解听众

传达信息的过程才算是交流。为了把信息送达，你需要了解受众的需求、兴趣和能力。我们都曾参加过这样的会议：一个开发极客滔滔不绝地讲述一项晦涩难懂的技术的诸多优点，把营销副总裁弄得目光呆滞。这不是在交流，只是在空谈，而且很烦人。假设你想提出建议，用一个基于网页的系统让最终用户提交错误报告。根据听众的不同，你可以用很多不同的方式来描述这个系统。最终用户更喜欢每天 24 小时都能随时提交错误报告，而不用在电话里等着。市场部门能够利用这个功能来促进销售。支持部门的经理们有两个理由感到高兴：少雇员工，问题报告可以自动化。最后，开发人员可能乐于积累一些基于网页的架构技术的经验，或是尝试一下新的数据库引擎。通过对每个小组进行适当的游说，你能让他们都为你的项目感到兴奋。

与所有的沟通形式一样，这里的窍门是收集反馈。不要只是等待问题的出现：把它问出来。注意看肢体语言和面部表情。神经语言规划有一个预设假定，「所获对方的反应即沟通的意义。」在交流的过程中，不断提高对听众的了解。

明白自己想说什么

在更正式的商务沟通方式中，最困难的部分可能是捋出你到底想说什么。小说作家常常在一开始就用许多细节来勾勒出书的框架，但技术文档的编写者更喜欢坐在键盘前 —— 输入：

1. 介绍

接着输入脑海中想到的东西。

计划好你想说什么，写一个大纲，然后问自己：「这是否用正确的方式向我的听众传达了我想表达的东西？」精炼到不能更精炼为止。

这种方法不仅适用于编写文档。当你要参加一个重要的会议或给一个大客户打电话时，记下你想要沟通的想法，并准备多个让对方理解的策略。

既然你已经知道了听众想要什么，那么是时候计划如何去做了。

选择时机

现在是星期五下午六点，审计人员已经进驻了一周。你老板的小儿子正在住院，外面下着瓢泼大雨，下班回家道路上的经历肯定会变成一场噩梦。这时候请她给你的笔记本电脑升级内存，可能不是个好时机。理解听众想听什么的一个角度，就是搞清楚他们的优先事项是什么。当经理因为丢了一些源码而刚被老板教训了一通时，抓住机会找他谈有关代码仓库的想法，他更容易听得进去。你说的东西不仅要内容合适，说的时间也要合适。有时只需要问一个简单的问题「现在是讨论…… 的好时机吗？」

挑选风格

根据听众调整你的表达方式。有些人想要一份正式的「只含事实」的简报。另一些人则喜欢在谈正事之前高谈阔论一番。他们在这个领域的技能水平和经验如何？是专家还是新手？他们需要手把手教，还是只想要一个「太长就不看」版的简介？如果有疑虑，开口问。

不过，还是要记住，相互沟通这件事你占了其中的一半。如果有人想让你用一段话谈谈某件事，而你发现那不是三两句就讲得清楚的，那么如实告之。记住，这样的反馈也是一种交流方式。

让它看起来不错

想法很重要。但听众还希望有个好看的包装。

太多的开发人员（包括他们的经理）在编写书面文档时只关注内容。我们认为这不对。随便一个厨师（或者是美食频道的主持人）都会告诉你，仅仅是糟糕的外观就能毁掉你在厨房里埋头苦干几个小时的成果。

今天，我们已找不到借口制作出版式丑陋的文档。无论你是用 Markdown 还是字处理软件编写，现代软件都能输出精美的结果。你需要学习的东西只是一些基本的命令而已。如果你正在使用字处理软件，请使用它的样式表以保持一致性。（你的公司应该已经准备好了样式表，你可以直接使用。）学习如何设置页眉和页脚。看看软件包里的实例文档，学习一下样式和布局。打开拼写检查，先依靠自动检查修正拼写错误，然后再手工检查一遍。毕竟总有些错别字会漏掉检察不出来。让听众参与

我们常常发现，相对最终定稿的文档，编写出文档这个过程更为重要。只要有可能，让读者参与到文档的初稿中来。听取他们的反馈，汲取他们的智慧。这样能建立良好的工作关系，而且通过这个过程，能编写出更好的文档。

做倾听者

如果想让别人听你说话，有一个技巧必须掌握：听他们说。即使你掌握了全部信息，甚至是在一个正式的会议上站在 20 个西装革履的人面前 —— 如果你不听他们的，他们也不会听你的。

通过提问鼓励人们交谈，试着让他们总结你的发言。把会议变成一场对话，你将更有效地表达你的观点。说不定你还可以学到一些东西。

回应别人

当你问别人一个问题时，如果他们不回答，你会觉得他们不礼貌。那么，当别人发电子邮件或备忘录给你，问你一些信息，请你做一些事情时，你有多少次没有回应？日常生活忙忙碌碌，忘点事情太常见了。一定要记得回复邮件，就算简单地说一句「我稍后答复你」都好。随时知会别人，能让人更容易原谅你偶然的疏忽，让人觉得你并没有忘记他们。

提示 12 说什么和怎么说同样重要

除非你与世隔绝，否则必须学会交流。越是有效的交流，影响力就越大。

文档

最后，还有一个通过文档进行交流的问题。通常，开发人员不会在文档上花太多心思，充其量视其为一项不得已而为之的任务，最糟糕的情况是把它当成一个低优先级任务 —— 最好项目经理在项目结束的时候忘了它。

务实的程序员将文档视为整个开发过程的一个组成部分。为了让编写文档变得更容易一点，我们要避免重复劳动和浪费时间，让文档总是在手边 —— 直接写在代码里。实际上，我们想把所有用于编码的务实原则全部用于文档。

提示 13 把文档嵌进去，而不要栓在表面

用源码中的注释生成好看的文档非常容易，建议给模块和导出函数都加上注释，这能在其他开发者使用的时候，给他们很大的助力。

不过，有人说必须给每个函数、数据结构、类型声明等都分别加上注释，我们并不赞同这种做法。这种机械的注释方式实际上会导致代码更难维护：一旦你想改点什么，就需要改变两个东西。因此，将非 API 的注释限制在只用来讨论其为何存在及其意图、目标。当代码已经展示了事情怎样完成时，注释是多余的 —— 因为这违反了 DRY 原则。

注释源码是一个绝佳的机会，可以用来记录那些在其他地方无法记录的项目细节：工程上的权衡，为什么要做决定，放弃了哪些替代方案，等等。

总结

·明白自己想说什么。

·了解听众。

·选择时机。

·挑选风格。

·让它看起来不错。

·让听众参与。

·做倾听者。

·回应别人。

·把代码和文档绑在一起。

相关部分包括：

·话题 15：估算，位于第 67 页

·话题 18：加强编辑能力，位于第 82 页

·话题 45：需求之坑，位于第 252 页

·话题 49：务实的团队，位于第 272 页

挑战

·有几本好书中有涉及开发团队内部交流的章节，包括《人月神话：软件项目管理之道》[Bro95]

和《人件》[DL99]

。务必在未来 18 个月尽力读完这些书。另外，有一本 Dinosaur Brains： Dealing with All Those Impossible People at Work [BR89]

，讨论了我们都会带入工作环境的情感包袱。

·下次你要做一个演讲或是写一个备忘录支持某个立场的时候，试着先把本部分中的建议都过一遍。要搞清听众是谁，以及需要沟通的内容。如有可能，事后再找当事人谈谈，看看你的预估和他们本来的需求之间的匹配程度。

网上交流

我们所说的关于书面交流的一切，同样适用于电子邮件、社交媒体帖子和博客，等等。特别是电子邮件，已经发展成为公司内交流的主要方式；它被用来讨论合同、解决争端，以及作为法庭上的证据。可是因为某些原因，人们不愿意发送一份破旧的纸质文件，却喜欢满世界散发一些看起来乱七八糟、语无伦次的电子邮件。

我们的建议很简单：

·点击发送按钮前先校对一遍。

·检查一遍拼写，找到有可能是自动纠错没做对的地方。

·用简单的格式。并不是所有的电子邮件客户端都能像现代浏览器那样擅长渲染，你那美丽的排版可能会变得乱七八糟。很多网站的评论和回复中不允许带 HTML 标签。

·尽可能少地引用原文。没有人喜欢在收到一封回复邮件时，看到里面上百行文字都是他自己写的，只是在最后加了一行「我同意」。

·如果你要引用别人的邮件，一定要注明出处，并做内联引用（而不是放在附件里）。在社交媒体平台上进行引用也应遵守此道。

·不要在网上侮辱别人，不要做喷子，除非你就喜欢被喷，喜欢受虐。一些话如果当着对方的面你不会说出口，那么也不要在网上说。

·在点发送前检查一下收件人列表。这已经是老生常谈 —— 你若在部门邮件中批评老板，小心不要把老板也加到转发列表中。当然，最好不要在邮件里批评老板。

电子邮件和社交媒体帖子一旦发出去就无法抹去，无数大公司和政治家都被坑过。所以要像对待任何书面备忘录或报告一样对待电子邮件。