Getting Clean via Emergent Design

What if there were four simple rules that you could follow that would help you create good designs as you worked? What if by following these rules you gained insights into the structure and design of your code, making it easier to apply principles such as SRP and DIP? What if these four rules facilitated the emergence of good designs?

Many of us feel that Kent Beck's four rules of Simple Design 1 are of significant help in creating well-designed software.

1. [ XPE ].

According to Kent, a design is「simple」if it follows these rules:

• Runs all the tests

• Contains no duplication

• Expresses the intent of the programmer

• Minimizes the number of classes and methods

The rules are given in order of importance.

Simple Design Rule 1: Runs All the Tests

First and foremost, a design must produce a system that acts as intended. A system might have a perfect design on paper, but if there is no simple way to verify that the system actually works as intended, then all the paper effort is questionable.

A system that is comprehensively tested and passes all of its tests all of the time is a testable system. That's an obvious statement, but an important one. Systems that aren't testable aren't verifiable. Arguably, a system that cannot be verified should never be deployed.

Fortunately, making our systems testable pushes us toward a design where our classes are small and single purpose. It's just easier to test classes that conform to the SRP. The more tests we write, the more we'll continue to push toward things that are simpler to test. So making sure our system is fully testable helps us create better designs.

Tight coupling makes it difficult to write tests. So, similarly, the more tests we write, the more we use principles like DIP and tools like dependency injection, interfaces, and abstraction to minimize coupling. Our designs improve even more.

Remarkably, following a simple and obvious rule that says we need to have tests and run them continuously impacts our system's adherence to the primary OO goals of low coupling and high cohesion. Writing tests leads to better designs.

Simple Design Rules 2–4: Refactoring

Once we have tests, we are empowered to keep our code and classes clean. We do this by incrementally refactoring the code. For each few lines of code we add, we pause and reflect on the new design. Did we just degrade it? If so, we clean it up and run our tests to demonstrate that we haven't broken anything. The fact that we have these tests eliminates the fear that cleaning up the code will break it!

During this refactoring step, we can apply anything from the entire body of knowledge about good software design. We can increase cohesion, decrease coupling, separate concerns, modularize system concerns, shrink our functions and classes, choose better names, and so on. This is also where we apply the final three rules of simple design: Eliminate duplication, ensure expressiveness, and minimize the number of classes and methods.

No Duplication

Duplication is the primary enemy of a well-designed system. It represents additional work, additional risk, and additional unnecessary complexity. Duplication manifests itself in many forms. Lines of code that look exactly alike are, of course, duplication. Lines of code that are similar can often be massaged to look even more alike so that they can be more easily refactored. And duplication can exist in other forms such as duplication of implementation. For example, we might have two methods in a collection class:

int size() {}    boolean isEmpty() {}

We could have separate implementations for each method. The isEmpty method could track a boolean, while size could track a counter. Or, we can eliminate this duplication by tying isEmpty to the definition of size:

boolean isEmpty() {       return 0 == size();    }

Creating a clean system requires the will to eliminate duplication, even in just a few lines of code. For example, consider the following code:

public void scaleToOneDimension(         float desiredDimension, float imageDimension) {      if (Math.abs(desiredDimension - imageDimension) < errorThreshold)         return;      float scalingFactor = desiredDimension / imageDimension;      scalingFactor = (float)(Math.floor(scalingFactor * 100) * 0.01f);      RenderedOp newImage = ImageUtilities.getScaledImage(         image, scalingFactor, scalingFactor);      image.dispose();      System.gc();      image = newImage;    }    public synchronized void rotate(int degrees) {       RenderedOp newImage = ImageUtilities.getRotatedImage(          image, degrees);       image.dispose();       System.gc();       image = newImage;    }

To keep this system clean, we should eliminate the small amount of duplication between the scaleToOneDimension and rotate methods:

public void scaleToOneDimension(         float desiredDimension, float imageDimension) {      if (Math.abs(desiredDimension - imageDimension) < errorThreshold)         return;      float scalingFactor = desiredDimension / imageDimension;      scalingFactor = (float)(Math.floor(scalingFactor * 100) * 0.01f);       replaceImage(ImageUtilities.getScaledImage(         image, scalingFactor, scalingFactor));    }    public synchronized void rotate(int degrees) {        replaceImage(ImageUtilities.getRotatedImage(image, degrees));    }     privatex void replaceImage(RenderedOp newImage) {        image.dispose();        System.gc();        image = newImage;    }

As we extract commonality at this very tiny level, we start to recognize violations of SRP. So we might move a newly extracted method to another class. That elevates its visibility. Someone else on the team may recognize the opportunity to further abstract the new method and reuse it in a different context. This「reuse in the small」can cause system complexity to shrink dramatically. Understanding how to achieve reuse in the small is essential to achieving reuse in the large.

The T EMPLATE M ETHOD 2 pattern is a common technique for removing higher-level duplication. For example:

public class VacationPolicy {       public void accrueUSDivisionVacation() {          // code to calculate vacation based on hours worked to date          // …          // code to ensure vacation meets US minimums          // …          // code to apply vaction to payroll record          // …       }       public void accrueEUDivisionVacation() {          // code to calculate vacation based on hours worked to date          // …          // code to ensure vacation meets EU minimums          // …          // code to apply vaction to payroll record          // …       }    }

The code across accrueUSDivisionVacation and accrueEuropeanDivisionVacation is largely the same, with the exception of calculating legal minimums. That bit of the algorithm changes based on the employee type.

We can eliminate the obvious duplication by applying the T EMPLATE M ETHOD pattern.

abstract public class VacationPolicy {       public void accrueVacation() {           calculateBaseVacationHours();

alterForLegalMinimums();           applyToPayroll();       }       private void calculateBaseVacationHours() { /* … */ };       abstract protected void alterForLegalMinimums();       private void applyToPayroll() { /* … */ };    }    public class USVacationPolicy extends VacationPolicy {       @Override protected void alterForLegalMinimums() {           // US specific logic       }    }    public class EUVacationPolicy extends VacationPolicy {       @Override protected void alterForLegalMinimums() {           // EU specific logic       }    }

The subclasses fill in the「hole」in the accrueVacation algorithm, supplying the only bits of information that are not duplicated.

Expressive

Most of us have had the experience of working on convoluted code. Many of us have produced some convoluted code ourselves. It's easy to write code that we understand, because at the time we write it we're deep in an understanding of the problem we're trying to solve. Other maintainers of the code aren't going to have so deep an understanding.

The majority of the cost of a software project is in long-term maintenance. In order to minimize the potential for defects as we introduce change, it's critical for us to be able to understand what a system does. As systems become more complex, they take more and more time for a developer to understand, and there is an ever greater opportunity for a misunderstanding. Therefore, code should clearly express the intent of its author. The clearer the author can make the code, the less time others will have to spend understanding it. This will reduce defects and shrink the cost of maintenance.

You can express yourself by choosing good names. We want to be able to hear a class or function name and not be surprised when we discover its responsibilities.

You can also express yourself by keeping your functions and classes small. Small classes and functions are usually easy to name, easy to write, and easy to understand.

You can also express yourself by using standard nomenclature. Design patterns, for example, are largely about communication and expressiveness. By using the standard pattern names, such as C OMMAND or V ISITOR , in the names of the classes that implement those patterns, you can succinctly describe your design to other developers.

Well-written unit tests are also expressive. A primary goal of tests is to act as documentation by example. Someone reading our tests should be able to get a quick understanding of what a class is all about.

But the most important way to be expressive is to try . All too often we get our code working and then move on to the next problem without giving sufficient thought to making that code easy for the next person to read. Remember, the most likely next person to read the code will be you.

So take a little pride in your workmanship. Spend a little time with each of your functions and classes. Choose better names, split large functions into smaller functions, and generally just take care of what you've created. Care is a precious resource.

Minimal Classes and Methods

Even concepts as fundamental as elimination of duplication, code expressiveness, and the SRP can be taken too far. In an effort to make our classes and methods small, we might create too many tiny classes and methods. So this rule suggests that we also keep our function and class counts low.

High class and method counts are sometimes the result of pointless dogmatism. Consider, for example, a coding standard that insists on creating an interface for each and every class. Or consider developers who insist that fields and behavior must always be separated into data classes and behavior classes. Such dogma should be resisted and a more pragmatic approach adopted.

Our goal is to keep our overall system small while we are also keeping our functions and classes small. Remember, however, that this rule is the lowest priority of the four rules of Simple Design. So, although it's important to keep class and function count low, it's more important to have tests, eliminate duplication, and express yourself.

Conclusion

Is there a set of simple practices that can replace experience? Clearly not. On the other hand, the practices described in this chapter and in this book are a crystallized form of the many decades of experience enjoyed by the authors. Following the practice of simple design can and does encourage and enable developers to adhere to good principles and patterns that otherwise take years to learn.

Bibliography

[ XPE ]:

Extreme Programming Explained: Embrace Change , Kent Beck, Addison-Wesley, 1999.

[GOF]:

Design Patterns: Elements of Reusable Object Oriented Software , Gamma et al., Addison-Wesley, 1996.

13 Concurrency

by Brett L. Schuchert

「Objects are abstractions of processing. Threads are abstractions of schedule.」

—James O. Coplien 1

1. Private correspondence.

Writing clean concurrent programs is hard—very hard. It is much easier to write code that executes in a single thread. It is also easy to write multithreaded code that looks fine on the surface but is broken at a deeper level. Such code works fine until the system is placed under stress.

In this chapter we discuss the need for concurrent programming, and the difficulties it presents. We then present several recommendations for dealing with those difficulties, and writing clean concurrent code. Finally, we conclude with issues related to testing concurrent code.

Clean Concurrency is a complex topic, worthy of a book by itself. Our strategy in this book is to present an overview here and provide a more detailed tutorial in「Concurrency II」on page 317 . If you are just curious about concurrency, then this chapter will suffice for you now. If you have a need to understand concurrency at a deeper level, then you should read through the tutorial as well.

Why Concurrency?

Concurrency is a decoupling strategy. It helps us decouple what gets done from when it gets done. In single-threaded applications what and when are so strongly coupled that the state of the entire application can often be determined by looking at the stack backtrace. A programmer who debugs such a system can set a breakpoint, or a sequence of breakpoints, and know the state of the system by which breakpoints are hit.

Decoupling what from when can dramatically improve both the throughput and structures of an application. From a structural point of view the application looks like many little collaborating computers rather than one big main loop. This can make the system easier to understand and offers some powerful ways to separate concerns.

Consider, for example, the standard「Servlet」model of Web applications. These systems run under the umbrella of a Web or EJB container that partially manages concurrency for you. The servlets are executed asynchronously whenever Web requests come in. The servlet programmer does not have to manage all the incoming requests. In principle , each servlet execution lives in its own little world and is decoupled from all the other servlet executions.

Of course if it were that easy, this chapter wouldn't be necessary. In fact, the decoupling provided by Web containers is far less than perfect. Servlet programmers have to be very aware, and very careful, to make sure their concurrent programs are correct. Still, the structural benefits of the servlet model are significant.

But structure is not the only motive for adopting concurrency. Some systems have response time and throughput constraints that require hand-coded concurrent solutions. For example, consider a single-threaded information aggregator that acquires information from many different Web sites and merges that information into a daily summary. Because this system is single threaded, it hits each Web site in turn, always finishing one before starting the next. The daily run needs to execute in less than 24 hours. However, as more and more Web sites are added, the time grows until it takes more than 24 hours to gather all the data. The single-thread involves a lot of waiting at Web sockets for I/O to complete. We could improve the performance by using a multithreaded algorithm that hits more than one Web site at a time.

Or consider a system that handles one user at a time and requires only one second of time per user. This system is fairly responsive for a few users, but as the number of users increases, the system's response time increases. No user wants to get in line behind 150 others! We could improve the response time of this system by handling many users concurrently.

Or consider a system that interprets large data sets but can only give a complete solution after processing all of them. Perhaps each data set could be processed on a different computer, so that many data sets are being processed in parallel.

Myths and Misconceptions

And so there are compelling reasons to adopt concurrency. However, as we said before, concurrency is hard . If you aren't very careful, you can create some very nasty situations. Consider these common myths and misconceptions:

• Concurrency always improves performance. Concurrency can sometimes improve performance, but only when there is a lot of wait time that can be shared between multiple threads or multiple processors. Neither situation is trivial.

• Design does not change when writing concurrent programs. In fact, the design of a concurrent algorithm can be remarkably different from the design of a single-threaded system. The decoupling of what from when usually has a huge effect on the structure of the system.

• Understanding concurrency issues is not important when working with a container such as a Web or EJB container. In fact, you'd better know just what your container is doing and how to guard against the issues of concurrent update and deadlock described later in this chapter.

Here are a few more balanced sound bites regarding writing concurrent software:

• Concurrency incurs some overhead , both in performance as well as writing additional code.

• Correct concurrency is complex , even for simple problems.

• Concurrency bugs aren't usually repeatable, so they are often ignored as one-offs 2 instead of the true defects they are.

2. Cosmic-rays, glitches, and so on.

• Concurrency often requires a fundamental change in design strategy .

Challenges

What makes concurrent programming so difficult? Consider the following trivial class:

public class X {       private int lastIdUsed;       public int getNextId() {            return ++lastIdUsed;        }    }

Let's say we create an instance of X , set the lastIdUsed field to 42, and then share the instance between two threads. Now suppose that both of those threads call the method getNextId(); there are three possible outcomes:

• Thread one gets the value 43, thread two gets the value 44, lastIdUsed is 44.

• Thread one gets the value 44, thread two gets the value 43, lastIdUsed is 44.

• Thread one gets the value 43, thread two gets the value 43, lastIdUsed is 43.

The surprising third result 3 occurs when the two threads step on each other. This happens because there are many possible paths that the two threads can take through that one line of Java code, and some of those paths generate incorrect results. How many different paths are there? To really answer that question, we need to understand what the Just-In-Time Compiler does with the generated byte-code, and understand what the Java memory model considers to be atomic.

3. See「 Digging Deeper 」on page 323 .

A quick answer, working with just the generated byte-code, is that there are 12,870 different possible execution paths 4 for those two threads executing within the getNextId method. If the type of lastIdUsed is changed from int to long , the number of possible paths increases to 2,704,156. Of course most of those paths generate valid results. The problem is that some of them don't .

4. See「 Possible Paths of Execution 」on page 321 .

Concurrency Defense Principles

What follows is a series of principles and techniques for defending your systems from the problems of concurrent code.

Single Responsibility Principle

The SRP 5 states that a given method/class/component should have a single reason to change. Concurrency design is complex enough to be a reason to change in it's own right and therefore deserves to be separated from the rest of the code. Unfortunately, it is all too common for concurrency implementation details to be embedded directly into other production code. Here are a few things to consider:

5. [ PPP ]

• Concurrency-related code has its own life cycle of development , change, and tuning.

• Concurrency-related code has its own challenges , which are different from and often more difficult than nonconcurrency-related code.

• The number of ways in which miswritten concurrency-based code can fail makes it challenging enough without the added burden of surrounding application code.

Recommendation : Keep your concurrency-related code separate from other code . 6

6. See「 Client/Server Example 」on page 317 .

Corollary: Limit the Scope of Data

As we saw, two threads modifying the same field of a shared object can interfere with each other, causing unexpected behavior. One solution is to use the synchronized keyword to protect a critical section in the code that uses the shared object. It is important to restrict the number of such critical sections. The more places shared data can get updated, the more likely:

• You will forget to protect one or more of those places—effectively breaking all code that modifies that shared data.

• There will be duplication of effort required to make sure everything is effectively guarded (violation of DRY 7 ).

7. [ PRAG ].

• It will be difficult to determine the source of failures, which are already hard enough to find.

Recommendation : Take data encapsulation to heart; severely limit the access of any data that may be shared.

Corollary: Use Copies of Data

A good way to avoid shared data is to avoid sharing the data in the first place. In some situations it is possible to copy objects and treat them as read-only. In other cases it might be possible to copy objects, collect results from multiple threads in these copies and then merge the results in a single thread.

If there is an easy way to avoid sharing objects, the resulting code will be far less likely to cause problems. You might be concerned about the cost of all the extra object creation. It is worth experimenting to find out if this is in fact a problem. However, if using copies of objects allows the code to avoid synchronizing, the savings in avoiding the intrinsic lock will likely make up for the additional creation and garbage collection overhead.

Corollary: Threads Should Be as Independent as Possible

Consider writing your threaded code such that each thread exists in its own world, sharing no data with any other thread. Each thread processes one client request, with all of its required data coming from an unshared source and stored as local variables. This makes each of those threads behave as if it were the only thread in the world and there were no synchronization requirements.

For example, classes that subclass from HttpServlet receive all of their information as parameters passed in to the doGet and doPost methods. This makes each Servlet act as if it has its own machine. So long as the code in the Servlet uses only local variables, there is no chance that the Servlet will cause synchronization problems. Of course, most applications using Servlets eventually run into shared resources such as database connections.

Recommendation : Attempt to partition data into independent subsets than can be operated on by independent threads, possibly in different processors.

Know Your Library

Java 5 offers many improvements for concurrent development over previous versions. There are several things to consider when writing threaded code in Java 5:

• Use the provided thread-safe collections.

• Use the executor framework for executing unrelated tasks.

• Use nonblocking solutions when possible.

• Several library classes are not thread safe.

Thread-Safe Collections

When Java was young, Doug Lea wrote the seminal book 8 Concurrent Programming in Java . Along with the book he developed several thread-safe collections, which later became part of the JDK in the java.util.concurrent package. The collections in that package are safe for multithreaded situations and they perform well. In fact, the ConcurrentHashMap implementation performs better than HashMap in nearly all situations. It also allows for simultaneous concurrent reads and writes, and it has methods supporting common composite operations that are otherwise not thread safe. If Java 5 is the deployment environment, start with ConcurrentHashMap .

8. [ Lea99 ].

There are several other kinds of classes added to support advanced concurrency design. Here are a few examples:

Recommendation : Review the classes available to you. In the case of Java, become familiar with java.util.concurrent, java.util.concurrent.atomic, java.util.concurrent.locks.

Know Your Execution Models

There are several different ways to partition behavior in a concurrent application. To discuss them we need to understand some basic definitions.

Given these definitions, we can now discuss the various execution models used in concurrent programming.

Producer-Consumer 9

9. http://en.wikipedia.org/wiki/Producer-consumer

One or more producer threads create some work and place it in a buffer or queue. One or more consumer threads acquire that work from the queue and complete it. The queue between the producers and consumers is a bound resource . This means producers must wait for free space in the queue before writing and consumers must wait until there is something in the queue to consume. Coordination between the producers and consumers via the queue involves producers and consumers signaling each other. The producers write to the queue and signal that the queue is no longer empty. Consumers read from the queue and signal that the queue is no longer full. Both potentially wait to be notified when they can continue.

Readers-Writers 10

10. http://en.wikipedia.org/wiki/Readers-writers_problem

When you have a shared resource that primarily serves as a source of information for readers, but which is occasionally updated by writers, throughput is an issue. Emphasizing throughput can cause starvation and the accumulation of stale information. Allowing updates can impact throughput. Coordinating readers so they do not read something a writer is updating and vice versa is a tough balancing act. Writers tend to block many readers for a long period of time, thus causing throughput issues.

The challenge is to balance the needs of both readers and writers to satisfy correct operation, provide reasonable throughput and avoiding starvation. A simple strategy makes writers wait until there are no readers before allowing the writer to perform an update. If there are continuous readers, however, the writers will be starved. On the other hand, if there are frequent writers and they are given priority, throughput will suffer. Finding that balance and avoiding concurrent update issues is what the problem addresses.

Dining Philosophers 11

11. http://en.wikipedia.org/wiki/Dining_philosophers_problem

Imagine a number of philosophers sitting around a circular table. A fork is placed to the left of each philosopher. There is a big bowl of spaghetti in the center of the table. The philosophers spend their time thinking unless they get hungry. Once hungry, they pick up the forks on either side of them and eat. A philosopher cannot eat unless he is holding two forks. If the philosopher to his right or left is already using one of the forks he needs, he must wait until that philosopher finishes eating and puts the forks back down. Once a philosopher eats, he puts both his forks back down on the table and waits until he is hungry again.

Replace philosophers with threads and forks with resources and this problem is similar to many enterprise applications in which processes compete for resources. Unless carefully designed, systems that compete in this way can experience deadlock, livelock, throughput, and efficiency degradation.

Most concurrent problems you will likely encounter will be some variation of these three problems. Study these algorithms and write solutions using them on your own so that when you come across concurrent problems, you'll be more prepared to solve the problem.

Recommendation : Learn these basic algorithms and understand their solutions.

Beware Dependencies Between Synchronized Methods

Dependencies between synchronized methods cause subtle bugs in concurrent code. The Java language has the notion of synchronized , which protects an individual method. However, if there is more than one synchronized method on the same shared class, then your system may be written incorrectly. 12

12. See「 Dependencies Between Methods Can Break Concurrent Code 」on page 329 .

Recommendation : Avoid using more than one method on a shared object.

There will be times when you must use more than one method on a shared object. When this is the case, there are three ways to make the code correct:

• Client-Based Locking —Have the client lock the server before calling the first method and make sure the lock's extent includes code calling the last method.

• Server-Based Locking —Within the server create a method that locks the server, calls all the methods, and then unlocks. Have the client call the new method.

• Adapted Server —create an intermediary that performs the locking. This is an example of server-based locking, where the original server cannot be changed.

Keep Synchronized Sections Small

The synchronized keyword introduces a lock. All sections of code guarded by the same lock are guaranteed to have only one thread executing through them at any given time. Locks are expensive because they create delays and add overhead. So we don't want to litter our code with synchronized statements. On the other hand, critical sections 13 must be guarded. So we want to design our code with as few critical sections as possible.

13. A critical section is any section of code that must be protected from simultaneous use for the program to be correct.

Some naive programmers try to achieve this by making their critical sections very large. However, extending synchronization beyond the minimal critical section increases contention and degrades performance. 14

14. See「 Increasing Throughput 」on page 333 .

Recommendation : Keep your synchronized sections as small as possible.

Writing Correct Shut-Down Code Is Hard

Writing a system that is meant to stay live and run forever is different from writing something that works for awhile and then shuts down gracefully.

Graceful shutdown can be hard to get correct. Common problems involve deadlock, 15 with threads waiting for a signal to continue that never comes.

15. See「 Deadlock 」on page 335 .

For example, imagine a system with a parent thread that spawns several child threads and then waits for them all to finish before it releases its resources and shuts down. What if one of the spawned threads is deadlocked? The parent will wait forever, and the system will never shut down.

Or consider a similar system that has been instructed to shut down. The parent tells all the spawned children to abandon their tasks and finish. But what if two of the children were operating as a producer/consumer pair. Suppose the producer receives the signal from the parent and quickly shuts down. The consumer might have been expecting a message from the producer and be blocked in a state where it cannot receive the shutdown signal. It could get stuck waiting for the producer and never finish, preventing the parent from finishing as well.

Situations like this are not at all uncommon. So if you must write concurrent code that involves shutting down gracefully, expect to spend much of your time getting the shutdown to happen correctly.

Recommendation : Think about shut-down early and get it working early. It's going to take longer than you expect. Review existing algorithms because this is probably harder than you think.

Testing Threaded Code

Proving that code is correct is impractical. Testing does not guarantee correctness. However, good testing can minimize risk. This is all true in a single-threaded solution. As soon as there are two or more threads using the same code and working with shared data, things get substantially more complex.

Recommendation : Write tests that have the potential to expose problems and then run them frequently, with different programatic configurations and system configurations and load. If tests ever fail, track down the failure. Don't ignore a failure just because the tests pass on a subsequent run.

That is a whole lot to take into consideration. Here are a few more fine-grained recommendations:

• Treat spurious failures as candidate threading issues.

• Get your nonthreaded code working first.

• Make your threaded code pluggable.

• Make your threaded code tunable.

• Run with more threads than processors.

• Run on different platforms.

• Instrument your code to try and force failures.

Treat Spurious Failures as Candidate Threading Issues

Threaded code causes things to fail that「simply cannot fail.」Most developers do not have an intuitive feel for how threading interacts with other code (authors included). Bugs in threaded code might exhibit their symptoms once in a thousand, or a million, executions. Attempts to repeat the systems can be frustratingly. This often leads developers to write off the failure as a cosmic ray, a hardware glitch, or some other kind of「one-off.」It is best to assume that one-offs do not exist. The longer these「one-offs」are ignored, the more code is built on top of a potentially faulty approach.

Recommendation : Do not ignore system failures as one-offs.

Get Your Nonthreaded Code Working First

This may seem obvious, but it doesn't hurt to reinforce it. Make sure code works outside of its use in threads. Generally, this means creating POJOs that are called by your threads. The POJOs are not thread aware, and can therefore be tested outside of the threaded environment. The more of your system you can place in such POJOs, the better.

Recommendation : Do not try to chase down nonthreading bugs and threading bugs at the same time. Make sure your code works outside of threads .

Make Your Threaded Code Pluggable

Write the concurrency-supporting code such that it can be run in several configurations:

• One thread, several threads, varied as it executes

• Threaded code interacts with something that can be both real or a test double.

• Execute with test doubles that run quickly, slowly, variable.

• Configure tests so they can run for a number of iterations.

Recommendation : Make your thread-based code especially pluggable so that you can run it in various configurations.

Make Your Threaded Code Tunable

Getting the right balance of threads typically requires trial an error. Early on, find ways to time the performance of your system under different configurations. Allow the number of threads to be easily tuned. Consider allowing it to change while the system is running. Consider allowing self-tuning based on throughput and system utilization.

Run with More Threads Than Processors

Things happen when the system switches between tasks. To encourage task swapping, run with more threads than processors or cores. The more frequently your tasks swap, the more likely you'll encounter code that is missing a critical section or causes deadlock.

Run on Different Platforms

In the middle of 2007 we developed a course on concurrent programming. The course development ensued primarily under OS X. The class was presented using Windows XP running under a VM. Tests written to demonstrate failure conditions did not fail as frequently in an XP environment as they did running on OS X.

In all cases the code under test was known to be incorrect. This just reinforced the fact that different operating systems have different threading policies, each of which impacts the code's execution. Multithreaded code behaves differently in different environments. 16 You should run your tests in every potential deployment environment.

16. Did you know that the threading model in Java does not guarantee preemptive threading? Modern OS's support preemptive threading, so you get that「for free.」Even so, it not guaranteed by the JVM.

Recommendation : Run your threaded code on all target platforms early and often.

Instrument Your Code to Try and Force Failures

It is normal for flaws in concurrent code to hide. Simple tests often don't expose them. Indeed, they often hide during normal processing. They might show up once every few hours, or days, or weeks!

The reason that threading bugs can be infrequent, sporadic, and hard to repeat, is that only a very few pathways out of the many thousands of possible pathways through a vulnerable section actually fail. So the probability that a failing pathway is taken can be star-tlingly low. This makes detection and debugging very difficult.

How might you increase your chances of catching such rare occurrences? You can instrument your code and force it to run in different orderings by adding calls to methods like Object.wait() , Object.sleep() , Object.yield() and Object.priority() .

Each of these methods can affect the order of execution, thereby increasing the odds of detecting a flaw. It's better when broken code fails as early and as often as possible.

There are two options for code instrumentation:

• Hand-coded

• Automated

Hand-Coded

You can insert calls to wait(), sleep(), yield() , and priority() in your code by hand. It might be just the thing to do when you're testing a particularly thorny piece of code.

Here is an example of doing just that:

public synchronized String nextUrlOrNull() {         if(hasNext()) {             String url = urlGenerator.next();             Thread.yield(); // inserted for testing.             updateHasNext();             return url;         }         return null;     }

The inserted call to yield() will change the execution pathways taken by the code and possibly cause the code to fail where it did not fail before. If the code does break, it was not because you added a call to yield() . 17 Rather, your code was broken and this simply made the failure evident.

17. This is not strictly the case. Since the JVM does not guarantee preemptive threading, a particular algorithm might always work on an OS that does not preempt threads. The reverse is also possible but for different reasons.

There are many problems with this approach:

• You have to manually find appropriate places to do this.

• How do you know where to put the call and what kind of call to use?

• Leaving such code in a production environment unnecessarily slows the code down.

• It's a shotgun approach. You may or may not find flaws. Indeed, the odds aren't with you.

What we need is a way to do this during testing but not in production. We also need to easily mix up configurations between different runs, which results in increased chances of finding errors in the aggregate.

Clearly, if we divide our system up into POJOs that know nothing of threading and classes that control the threading, it will be easier to find appropriate places to instrument the code. Moreover, we could create many different test jigs that invoke the POJOs under different regimes of calls to sleep, yield , and so on.

Automated

You could use tools like an Aspect-Oriented Framework, CGLIB, or ASM to programmatically instrument your code. For example, you could use a class with a single method:

public class ThreadJigglePoint {        public static void jiggle() {        }    }

You can add calls to this in various places within your code:

public synchronized String nextUrlOrNull() {      if(hasNext()) {          ThreadJiglePoint.jiggle();          String url = urlGenerator.next();          ThreadJiglePoint.jiggle();          updateHasNext();          ThreadJiglePoint.jiggle();          return url;      }      return null;    }

Now you use a simple aspect that randomly selects among doing nothing, sleeping, or yielding.

Or imagine that the ThreadJigglePoint class has two implementations. The first implements jiggle to do nothing and is used in production. The second generates a random number to choose between sleeping, yielding, or just falling through. If you run your tests a thousand times with random jiggling, you may root out some flaws. If the tests pass, at least you can say you've done due diligence. Though a bit simplistic, this could be a reasonable option in lieu of a more sophisticated tool.

There is a tool called ConTest, 18 developed by IBM that does something similar, but it does so with quite a bit more sophistication.

18. http://www.alphaworks.ibm.com/tech/contest

The point is to jiggle the code so that threads run in different orderings at different times. The combination of well-written tests and jiggling can dramatically increase the chance finding errors.

Recommendation : Use jiggling strategies to ferret out errors.

Conclusion

Concurrent code is difficult to get right. Code that is simple to follow can become nightmarish when multiple threads and shared data get into the mix. If you are faced with writing concurrent code, you need to write clean code with rigor or else face subtle and infrequent failures.

First and foremost, follow the Single Responsibility Principle. Break your system into POJOs that separate thread-aware code from thread-ignorant code. Make sure when you are testing your thread-aware code, you are only testing it and nothing else. This suggests that your thread-aware code should be small and focused.

Know the possible sources of concurrency issues: multiple threads operating on shared data, or using a common resource pool. Boundary cases, such as shutting down cleanly or finishing the iteration of a loop, can be especially thorny.

Learn your library and know the fundamental algorithms. Understand how some of the features offered by the library support solving problems similar to the fundamental algorithms.

Learn how to find regions of code that must be locked and lock them. Do not lock regions of code that do not need to be locked. Avoid calling one locked section from another. This requires a deep understanding of whether something is or is not shared. Keep the amount of shared objects and the scope of the sharing as narrow as possible. Change designs of the objects with shared data to accommodate clients rather than forcing clients to manage shared state.

Issues will crop up. The ones that do not crop up early are often written off as a onetime occurrence. These so-called one-offs typically only happen under load or at seemingly random times. Therefore, you need to be able to run your thread-related code in many configurations on many platforms repeatedly and continuously. Testability, which comes naturally from following the Three Laws of TDD, implies some level of plug-ability, which offers the support necessary to run code in a wider range of configurations.

You will greatly improve your chances of finding erroneous code if you take the time to instrument your code. You can either do so by hand or using some kind of automated technology. Invest in this early. You want to be running your thread-based code as long as possible before you put it into production.

If you take a clean approach, your chances of getting it right increase drastically.

Bibliography

[ Lea99 ]:

Concurrent Programming in Java: Design Principles and Patterns , 2d. ed., Doug Lea, Prentice Hall, 1999.

[ PPP ]:

Agile Software Development: Principles, Patterns, and Practices , Robert C. Martin, Prentice Hall, 2002.

[ PRAG ]:

The Pragmatic Programmer , Andrew Hunt, Dave Thomas, Addison-Wesley, 2000.

14 Successive Refinement

Case Study of a Command-Line Argument Parser

This chapter is a case study in successive refinement. You will see a module that started well but did not scale. Then you will see how the module was refactored and cleaned.

Most of us have had to parse command-line arguments from time to time. If we don't have a convenient utility, then we simply walk the array of strings that is passed into the main function. There are several good utilities available from various sources, but none of them do exactly what I want. So, of course, I decided to write my own. I call it: Args .

Args is very simple to use. You simply construct the Args class with the input arguments and a format string, and then query the Args instance for the values of the arguments. Consider the following simple example:

Listing 14-1 Simple use of Args

public static void main(String[] args)   {      try {        Args arg = new Args(「l,p#,d*」, args);        boolean logging = arg.getBoolean('l');        int port = arg.getInt('p');        String directory = arg.getString('d');        executeApplication(logging, port, directory);      }  catch (ArgsException e) {          System.out.printf(「Argument error: %s\n」, e.errorMessage());      }    }

You can see how simple this is. We just create an instance of the Args class with two parameters. The first parameter is the format, or schema, string: 「l,p#,d*.」 It defines three command-line arguments. The first, -l, is a boolean argument. The second, -p, is an integer argument. The third, -d, is a string argument. The second parameter to the Args constructor is simply the array of command-line argument passed into main .

If the constructor returns without throwing an ArgsException, then the incoming command-line was parsed, and the Args instance is ready to be queried. Methods like getBoolean, getInteger, and getString allow us to access the values of the arguments by their names.

If there is a problem, either in the format string or in the command-line arguments themselves, an ArgsException will be thrown. A convenient description of what went wrong can be retrieved from the errorMessage method of the exception.

Args Implementation

Listing 14-2 is the implementation of the Args class. Please read it very carefully. I worked hard on the style and structure and hope it is worth emulating.

Listing 14-2 Args.java

package com.objectmentor.utilities.args;    import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;    import java.util.*;    public class Args {      private Map<Character, ArgumentMarshaler> marshalers;    private Set<Character> argsFound;    private ListIterator<String> currentArgument;       public Args(String schema, String[] args) throws ArgsException {      marshalers = new HashMap<Character, ArgumentMarshaler>();      argsFound = new HashSet<Character>();           parseSchema(schema);      parseArgumentStrings(Arrays.asList(args));    }        private void parseSchema(String schema) throws ArgsException {      for (String element : schema.split(「,」))        if (element.length() > 0)          parseSchemaElement(element.trim());    }    private void parseSchemaElement(String element) throws ArgsException {      char elementId = element.charAt(0);      String elementTail = element.substring(1);      validateSchemaElementId(elementId);      if (elementTail.length() == 0)        marshalers.put(elementId, new BooleanArgumentMarshaler());      else if (elementTail.equals(「*」))        marshalers.put(elementId, new StringArgumentMarshaler());      else if (elementTail.equals(「#」))        marshalers.put(elementId, new IntegerArgumentMarshaler());      else if (elementTail.equals(「##」))        marshalers.put(elementId, new DoubleArgumentMarshaler());      else if (elementTail.equals(「[*]」))        marshalers.put(elementId, new StringArrayArgumentMarshaler());      else        throw new ArgsException(INVALID_ARGUMENT_FORMAT, elementId, elementTail);    }    private void validateSchemaElementId(char elementId) throws ArgsException {      if (!Character.isLetter(elementId))        throw new ArgsException(INVALID_ARGUMENT_NAME, elementId, null);    }    private void parseArgumentStrings(List<String> argsList) throws ArgsException    {      for (currentArgument = argsList.listIterator(); currentArgument.hasNext();)      {        String argString = currentArgument.next();        if (argString.startsWith(「-」)) {          parseArgumentCharacters(argString.substring(1));        } else {          currentArgument.previous();          break;        }      }    }      private void parseArgumentCharacters(String argChars) throws ArgsException {        for (int i = 0; i < argChars.length(); i++)          parseArgumentCharacter(argChars.charAt(i));      }      private void parseArgumentCharacter(char argChar) throws ArgsException {        ArgumentMarshaler m = marshalers.get(argChar);        if (m == null) {          throw new ArgsException(UNEXPECTED_ARGUMENT, argChar, null);        } else {          argsFound.add(argChar);          try {            m.set(currentArgument);          } catch (ArgsException e) {            e.setErrorArgumentId(argChar);            throw e;          }        }     }     public boolean has(char arg) {       return argsFound.contains(arg);     }     public int nextArgument() {       return currentArgument.nextIndex();     }     public boolean getBoolean(char arg) {       return BooleanArgumentMarshaler.getValue(marshalers.get(arg));     }     public String getString(char arg) {       return StringArgumentMarshaler.getValue(marshalers.get(arg));     }     public int getInt(char arg) {       return IntegerArgumentMarshaler.getValue(marshalers.get(arg));     }     public double getDouble(char arg) {       return DoubleArgumentMarshaler.getValue(marshalers.get(arg));     }     public String[] getStringArray(char arg) {       return StringArrayArgumentMarshaler.getValue(marshalers.get(arg));     }    }

Notice that you can read this code from the top to the bottom without a lot of jumping around or looking ahead. The one thing you may have had to look ahead for is the definition of ArgumentMarshaler, which I left out intentionally. Having read this code carefully, you should understand what the ArgumentMarshaler interface is and what its derivatives do. I'll show a few of them to you now ( Listing 14-3 through Listing 14-6 ).

Listing 14-3 ArgumentMarshaler.java

public interface ArgumentMarshaler {      void set(Iterator<String> currentArgument) throws ArgsException;    }

Listing 14-4 BooleanArgumentMarshaler.java

public class BooleanArgumentMarshaler implements ArgumentMarshaler {   private boolean booleanValue = false;      public void set(Iterator<String> currentArgument) throws ArgsException {     booleanValue = true;   }   public static boolean getValue(ArgumentMarshaler am) {     if (am != null && am instanceof BooleanArgumentMarshaler)       return ((BooleanArgumentMarshaler) am).booleanValue;     else       return false;   } }

Listing 14-5 StringArgumentMarshaler.java

import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*; public class StringArgumentMarshaler implements ArgumentMarshaler {   private String stringValue =   public void set(Iterator<String> currentArgument) throws ArgsException {     try {       stringValue = currentArgument.next();     } catch (NoSuchElementException e) {       throw new ArgsException(MISSING_STRING);     }   }   public static String getValue(ArgumentMarshaler am) {     if (am != null && am instanceof StringArgumentMarshaler)       return ((StringArgumentMarshaler) am).stringValue;     else       return 」」;   } }

The other ArgumentMarshaler derivatives simply replicate this pattern for doubles and String arrays and would serve to clutter this chapter. I'll leave them to you as an exercise.

One other bit of information might be troubling you: the definition of the error code constants. They are in the ArgsException class ( Listing 14-7 ).

Listing 14-6 IntegerArgumentMarshaler.java

import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;    public class IntegerArgumentMarshaler implements ArgumentMarshaler {      private int intValue = 0;         public void set(Iterator<String> currentArgument) throws ArgsException {        String parameter = null;        try {          parameter = currentArgument.next();          intValue = Integer.parseInt(parameter);        } catch (NoSuchElementException e) {          throw new ArgsException(MISSING_INTEGER);        } catch (NumberFormatException e) {          throw new ArgsException(INVALID_INTEGER, parameter);        }      }         public static int getValue(ArgumentMarshaler am) {        if (am != null && am instanceof IntegerArgumentMarshaler)          return ((IntegerArgumentMarshaler) am).intValue;        else          return 0;      }    }

Listing 14-7 ArgsException.java

import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*; public class ArgsException extends Exception {   private char errorArgumentId = '\0';   private String errorParameter = null;   private ErrorCode errorCode = OK;   public ArgsException() {}   public ArgsException(String message) {super(message);}      public ArgsException(ErrorCode errorCode) {     this.errorCode = errorCode;   }      public ArgsException(ErrorCode errorCode, String errorParameter) {     this.errorCode = errorCode;     this.errorParameter = errorParameter;   }   public ArgsException(ErrorCode errorCode,                        char errorArgumentId, String errorParameter) {     this.errorCode = errorCode;     this.errorParameter = errorParameter;     this.errorArgumentId = errorArgumentId;   }   public char getErrorArgumentId() {     return errorArgumentId;   }   public void setErrorArgumentId(char errorArgumentId) {     this.errorArgumentId = errorArgumentId;   }       public String getErrorParameter() {     return errorParameter;   }   public void setErrorParameter(String errorParameter) {     this.errorParameter = errorParameter;   }      public ErrorCode getErrorCode() {     return errorCode;   }      public void setErrorCode(ErrorCode errorCode) {     this.errorCode = errorCode;   }      public String errorMessage() {     switch (errorCode) {       case OK:         return「TILT: Should not get here.」;       case UNEXPECTED_ARGUMENT:         return String.format(「Argument -%c unexpected.」, errorArgumentId);       case MISSING_STRING:         return String.format(「Could not find string parameter for -%c.」,                               errorArgumentId);       case INVALID_INTEGER:         return String.format(「Argument -%c expects an integer but was '%s'.」,                               errorArgumentId, errorParameter);       case MISSING_INTEGER:         return String.format(「Could not find integer parameter for -%c.」,                               errorArgumentId);       case INVALID_DOUBLE:         return String.format(「Argument -%c expects a double but was '%s'.」,                               errorArgumentId, errorParameter);       case MISSING_DOUBLE:         return String.format(「Could not find double parameter for -%c.」,                               errorArgumentId);       case INVALID_ARGUMENT_NAME:         return String.format(「'%c」is not a valid argument name.」,                               errorArgumentId);       case INVALID_ARGUMENT_FORMAT:         return String.format(「'%s」is not a valid argument format.」,                               errorParameter);     }     return 」」;   }   public enum ErrorCode {     OK, INVALID_ARGUMENT_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME,     MISSING_STRING,     MISSING_INTEGER, INVALID_INTEGER,     MISSING_DOUBLE, INVALID_DOUBLE} }

It's remarkable how much code is required to flesh out the details of this simple concept. One of the reasons for this is that we are using a particularly wordy language. Java, being a statically typed language, requires a lot of words in order to satisfy the type system. In a language like Ruby, Python, or Smalltalk, this program is much smaller. 1

1. I recently rewrote this module in Ruby. It was 1/7th the size and had a subtly better structure.

Please read the code over one more time. Pay special attention to the way things are named, the size of the functions, and the formatting of the code. If you are an experienced programmer, you may have some quibbles here and there with various parts of the style or structure. Overall, however, I hope you conclude that this program is nicely written and has a clean structure.

For example, it should be obvious how you would add a new argument type, such as a date argument or a complex number argument, and that such an addition would require a trivial amount of effort. In short, it would simply require a new derivative of Argument-Marshaler , a new getXXX function, and a new case statement in the parseSchemaElement function. There would also probably be a new ArgsException.ErrorCode and a new error message.

How Did I Do This?

Let me set your mind at rest. I did not simply write this program from beginning to end in its current form. More importantly, I am not expecting you to be able to write clean and elegant programs in one pass. If we have learned anything over the last couple of decades, it is that programming is a craft more than it is a science. To write clean code, you must first write dirty code and then clean it .

This should not be a surprise to you. We learned this truth in grade school when our teachers tried (usually in vain) to get us to write rough drafts of our compositions. The process, they told us, was that we should write a rough draft, then a second draft, then several subsequent drafts until we had our final version. Writing clean compositions, they tried to tell us, is a matter of successive refinement.

Most freshman programmers (like most grade-schoolers) don't follow this advice particularly well. They believe that the primary goal is to get the program working. Once it's「working,」they move on to the next task, leaving the「working」program in whatever state they finally got it to「work.」Most seasoned programmers know that this is professional suicide.

Args: The Rough Draft

Listing 14-8 shows an earlier version of the Args class. It「works.」And it's messy.

Listing 14-8 Args.java (first draft)

import java.text.ParseException; import java.util.*; public class Args {   private String schema;   private String[] args;   private boolean valid = true;   private Set<Character> unexpectedArguments = new TreeSet<Character>();   private Map<Character, Boolean> booleanArgs =     new HashMap        <Character, Boolean>();   private Map<Character, String> stringArgs = new HashMap        <Character, String>();   private Map<Character, Integer> intArgs = new HashMap<Character, Integer>();   private Set<Character> argsFound = new HashSet<Character>();   private int currentArgument;   private char errorArgumentId = '\0';   private String errorParameter =「TILT」;   private ErrorCode errorCode = ErrorCode.OK;   private enum ErrorCode {     OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT}   public Args(String schema, String[] args) throws ParseException {     this.schema = schema;     this.args = args;     valid = parse();   }   private boolean parse() throws ParseException {     if (schema.length() == 0 && args.length == 0)       return true;     parseSchema();     try {       parseArguments();     } catch (ArgsException e) {     }     return valid;   }   private boolean parseSchema() throws ParseException {     for (String element : schema.split(「,」)) {       if (element.length() > 0) {         String trimmedElement = element.trim();         parseSchemaElement(trimmedElement);       }     }     return true;   }   private void parseSchemaElement(String element) throws ParseException {     char elementId = element.charAt(0);     String elementTail = element.substring(1);     validateSchemaElementId(elementId);     if (isBooleanSchemaElement(elementTail))       parseBooleanSchemaElement(elementId);     else if (isStringSchemaElement(elementTail))       parseStringSchemaElement(elementId);     else if (isIntegerSchemaElement(elementTail)) {       parseIntegerSchemaElement(elementId);     } else {       throw new ParseException(         String.format(「Argument: %c has invalid format: %s.」,                      elementId, elementTail), 0);     }   }   private void validateSchemaElementId(char elementId) throws ParseException {     if (!Character.isLetter(elementId)) {       throw new ParseException(         「Bad character:」+ elementId +「in Args format: 」+ schema, 0);     }   }   private void parseBooleanSchemaElement(char elementId) {     booleanArgs.put(elementId, false);   }   private void parseIntegerSchemaElement(char elementId) {     intArgs.put(elementId, 0);   }   private void parseStringSchemaElement(char elementId) {     stringArgs.put(elementId, 」」);   }   private boolean isStringSchemaElement(String elementTail) {     return elementTail.equals(」*」);   }   private boolean isBooleanSchemaElement(String elementTail) {     return elementTail.length() == 0;   }   private boolean isIntegerSchemaElement(String elementTail) {     return elementTail.equals(」#」); }   private boolean parseArguments() throws ArgsException {     for (currentArgument = 0; currentArgument < args.length; currentArgument++)     {       String arg = args[currentArgument];       parseArgument(arg);     }     return true;   }      private void parseArgument(String arg) throws ArgsException {     if (arg.startsWith(」-」))       parseElements(arg);   }   private void parseElements(String arg) throws ArgsException {     for (int i = 1; i < arg.length(); i++)       parseElement(arg.charAt(i));   }   private void parseElement(char argChar) throws ArgsException {     if (setArgument(argChar))       argsFound.add(argChar);     else {       unexpectedArguments.add(argChar);       errorCode = ErrorCode.UNEXPECTED_ARGUMENT;       valid = false;     }   }   private boolean setArgument(char argChar) throws ArgsException {     if (isBooleanArg(argChar))       setBooleanArg(argChar, true);     else if (isStringArg(argChar))       setStringArg(argChar);     else if (isIntArg(argChar))       setIntArg(argChar);     else       return false;     return true;   }   private boolean isIntArg(char argChar) {return intArgs.containsKey(argChar);}      private void setIntArg(char argChar) throws ArgsException {     currentArgument++;     String parameter = null;     try {       parameter = args[currentArgument];       intArgs.put(argChar, new Integer(parameter));     } catch (ArrayIndexOutOfBoundsException e) {       valid = false;       errorArgumentId = argChar;       errorCode = ErrorCode.MISSING_INTEGER;       throw new ArgsException();     } catch (NumberFormatException e) {       valid = false;       errorArgumentId = argChar;       errorParameter = parameter;       errorCode = ErrorCode.INVALID_INTEGER;       throw new ArgsException();     }   }   private void setStringArg(char argChar) throws ArgsException {     currentArgument++;     try {       stringArgs.put(argChar, args[currentArgument]);     } catch (ArrayIndexOutOfBoundsException e) {       valid = false;       errorArgumentId = argChar;       errorCode = ErrorCode.MISSING_STRING;       throw new ArgsException();     }   }   private boolean isStringArg(char argChar) {     return stringArgs.containsKey(argChar);   }   private void setBooleanArg(char argChar, boolean value) {     booleanArgs.put(argChar, value);   }   private boolean isBooleanArg(char argChar) {     return booleanArgs.containsKey(argChar);   }   public int cardinality() {     return argsFound.size();   }   public String usage() {     if (schema.length() > 0)       return「-[」+ schema +「]」;     else       return 」」;   }   public String errorMessage() throws Exception {     switch (errorCode) {       case OK:         throw new Exception(「TILT: Should not get here.」);       case UNEXPECTED_ARGUMENT:         return unexpectedArgumentMessage();       case MISSING_STRING:         return String.format(「Could not find string parameter for -%c.」,                             errorArgumentId);       case INVALID_INTEGER:         return String.format(「Argument -%c expects an integer but was '%s'.」,                             errorArgumentId, errorParameter);       case MISSING_INTEGER:         return String.format(「Could not find integer parameter for -%c.」,                             errorArgumentId);     }     return 」」;   }   private String unexpectedArgumentMessage() {     StringBuffer message = new StringBuffer(「Argument(s) -」);     for (char c : unexpectedArguments) {       message.append(c);     }     message.append(「 unexpected.」);     return message.toString();   }   private boolean falseIfNull(Boolean b) {     return b != null && b;   }   private int zeroIfNull(Integer i) {     return i == null ? 0 : i;   }   private String blankIfNull(String s) {     return s == null ? 」」: s;   }   public String getString(char arg) {     return blankIfNull(stringArgs.get(arg));   }   public int getInt(char arg) {     return zeroIfNull(intArgs.get(arg));   }   public boolean getBoolean(char arg) {     return falseIfNull(booleanArgs.get(arg));   }   public boolean has(char arg) {     return argsFound.contains(arg);   }      public boolean isValid() {     return valid;   }   private class ArgsException extends Exception {   } }

I hope your initial reaction to this mass of code is「I'm certainly glad he didn't leave it like that!」If you feel like this, then remember that's how other people are going to feel about code that you leave in rough-draft form.

Actually「rough draft」is probably the kindest thing you can say about this code. It's clearly a work in progress. The sheer number of instance variables is daunting. The odd strings like「 TILT ,」the HashSets and TreeSets , and the try-catch-catch blocks all add up to a festering pile.

I had not wanted to write a festering pile. Indeed, I was trying to keep things reasonably well organized. You can probably tell that from my choice of function and variable names and the fact that there is a crude structure to the program. But, clearly, I had let the problem get away from me.

The mess built gradually. Earlier versions had not been nearly so nasty. For example, Listing 14-9 shows an earlier version in which only Boolean arguments were working.

Listing 14-9 Args.java (Boolean only)

package com.objectmentor.utilities.getopts; import java.util.*; public class Args {   private String schema;   private String[] args;   private boolean valid;   private Set<Character> unexpectedArguments = new TreeSet<Character>();   private Map<Character, Boolean> booleanArgs =     new HashMap<Character, Boolean>();   private int numberOfArguments = 0;   public Args(String schema, String[] args) {     this.schema = schema;     this.args = args;     valid = parse();   }   public boolean isValid() {     return valid;   }   private boolean parse() {     if (schema.length() == 0 && args.length == 0)       return true;     parseSchema();     parseArguments();     return unexpectedArguments.size() == 0;   }   private boolean parseSchema() {     for (String element : schema.split(」,」)) {       parseSchemaElement(element);     }     return true;   }      private void parseSchemaElement(String element) {     if (element.length() == 1) {       parseBooleanSchemaElement(element);     }   }      private void parseBooleanSchemaElement(String element) {     char c = element.charAt(0);     if (Character.isLetter(c)) {       booleanArgs.put(c, false);     }   }   private boolean parseArguments() {     for (String arg : args)       parseArgument(arg);     return true;   }   private void parseArgument(String arg) {     if (arg.startsWith(」-」))       parseElements(arg);   }   private void parseElements(String arg) {     for (int i = 1; i < arg.length(); i++)       parseElement(arg.charAt(i));   }      private void parseElement(char argChar) {     if (isBoolean(argChar)) {       numberOfArguments++;       setBooleanArg(argChar, true);     } else       unexpectedArguments.add(argChar);   }      private void setBooleanArg(char argChar, boolean value) {     booleanArgs.put(argChar, value);   }      private boolean isBoolean(char argChar) {     return booleanArgs.containsKey(argChar);   }      public int cardinality() {     return numberOfArguments;   }   public String usage() {     if (schema.length() > 0)        return 」-[「+schema+」]」;     else       return 」」;   }      public String errorMessage() {     if (unexpectedArguments.size() > 0) {       return unexpectedArgumentMessage();     } else       return 」」;   }      private String unexpectedArgumentMessage() {     StringBuffer message = new StringBuffer(「Argument(s) -」);     for (char c : unexpectedArguments) {       message.append(c);     }     message.append(「 unexpected.」);     return message.toString();   }   public boolean getBoolean(char arg) {     return booleanArgs.get(arg);   } }

Although you can find plenty to complain about in this code, it's really not that bad. It's compact and simple and easy to understand. However, within this code it is easy to see the seeds of the later festering pile. It's quite clear how this grew into the latter mess.

Notice that the latter mess has only two more argument types than this: String and integer . The addition of just two more argument types had a massively negative impact on the code. It converted it from something that would have been reasonably maintainable into something that I would expect to become riddled with bugs and warts.

I added the two argument types incrementally. First, I added the String argument, which yielded this:

Listing 14-10 Args.java (Boolean and String)

package com.objectmentor.utilities.getopts;    import java.text.ParseException;    import java.util.*;    public class Args {      private String schema;      private String[] args;      private boolean valid = true;      private Set<Character> unexpectedArguments = new TreeSet<Character>();      private Map<Character, Boolean> booleanArgs =        new HashMap<Character, Boolean>();      private Map<Character, String> stringArgs =        new HashMap<Character, String>();      private Set<Character> argsFound = new HashSet<Character>();      private int currentArgument;      private char errorArgument = '\0';      enum ErrorCode {        OK, MISSING_STRING}      private ErrorCode errorCode = ErrorCode.OK;      public Args(String schema, String[] args) throws ParseException {        this.schema = schema;        this.args = args;        valid = parse();      }      private boolean parse() throws ParseException {        if (schema.length() == 0 && args.length == 0)          return true;        parseSchema();        parseArguments();        return valid;      }      private boolean parseSchema() throws ParseException {        for (String element : schema.split(「,」)) {          if (element.length() > 0) {            String trimmedElement = element.trim();            parseSchemaElement(trimmedElement);          }        }        return true;      }      private void parseSchemaElement(String element) throws ParseException {        char elementId = element.charAt(0);        String elementTail = element.substring(1);        validateSchemaElementId(elementId);        if (isBooleanSchemaElement(elementTail))          parseBooleanSchemaElement(elementId);        else if (isStringSchemaElement(elementTail))          parseStringSchemaElement(elementId);      }      private void validateSchemaElementId(char elementId) throws ParseException {        if (!Character.isLetter(elementId)) {          throw new ParseException(            「Bad character:」+ elementId +「in Args format: 」+ schema, 0);        }      }      private void parseStringSchemaElement(char elementId) {        stringArgs.put(elementId,「 」);      }      private boolean isStringSchemaElement(String elementTail) {        return elementTail.equals(「*」);      }      private boolean isBooleanSchemaElement(String elementTail) {        return elementTail.length() == 0;      }      private void parseBooleanSchemaElement(char elementId) {        booleanArgs.put(elementId, false);      }      private boolean parseArguments() {        for (currentArgument = 0; currentArgument < args.length; currentArgument++)        {          String arg = args[currentArgument];          parseArgument(arg);        }        return true;      }      private void parseArgument(String arg) {        if (arg.startsWith(「-」))          parseElements(arg);      }      private void parseElements(String arg) {        for (int i = 1; i < arg.length(); i++)          parseElement(arg.charAt(i));      }      private void parseElement(char argChar) {        if (setArgument(argChar))          argsFound.add(argChar);        else {          unexpectedArguments.add(argChar);          valid = false;        }      }      private boolean setArgument(char argChar) {        boolean set = true;        if (isBoolean(argChar))          setBooleanArg(argChar, true);        else if (isString(argChar))          setStringArg(argChar,「 」);        else          set = false;        return set;      }      private void setStringArg(char argChar, String s) {        currentArgument++;        try {          stringArgs.put(argChar, args[currentArgument]);        } catch (ArrayIndexOutOfBoundsException e) {          valid = false;          errorArgument = argChar;          errorCode = ErrorCode.MISSING_STRING;        }      }      private boolean isString(char argChar) {        return stringArgs.containsKey(argChar);      }      private void setBooleanArg(char argChar, boolean value) {        booleanArgs.put(argChar, value);      }      private boolean isBoolean(char argChar) {        return booleanArgs.containsKey(argChar);      }      public int cardinality() {        return argsFound.size();      }      public String usage() {        if (schema.length() > 0)          return「-[「 + schema + 」]」;        else          return「 」;      }      public String errorMessage() throws Exception {        if (unexpectedArguments.size() > 0) {          return unexpectedArgumentMessage();        } else          switch (errorCode) {            case MISSING_STRING:              return String.format(「Could not find string parameter for -%c.」, errorArgument);            case OK:              throw new Exception(「TILT: Should not get here.」);          }        return「 」;      }      private String unexpectedArgumentMessage() {        StringBuffer message = new StringBuffer(「Argument(s) -」);        for (char c : unexpectedArguments) {          message.append(c);        }        message.append(「 unexpected.」);        return message.toString();      }      public boolean getBoolean(char arg) {        return falseIfNull(booleanArgs.get(arg));      }      private boolean falseIfNull(Boolean b) {        return b == null ? false : b;      }      public String getString(char arg) {        return blankIfNull(stringArgs.get(arg));      }      private String blankIfNull(String s) {        return s == null ?「 」: s;      }      public boolean has(char arg) {        return argsFound.contains(arg);      }      public boolean isValid() {        return valid;      }    }

You can see that this is starting to get out of hand. It's still not horrible, but the mess is certainly starting to grow. It's a pile, but it's not festering quite yet. It took the addition of the integer argument type to get this pile really fermenting and festering.

So I Stopped

I had at least two more argument types to add, and I could tell that they would make things much worse. If I bulldozed my way forward, I could probably get them to work, but I'd leave behind a mess that was too large to fix. If the structure of this code was ever going to be maintainable, now was the time to fix it.

So I stopped adding features and started refactoring. Having just added the String and integer arguments, I knew that each argument type required new code in three major places. First, each argument type required some way to parse its schema element in order to select the HashMap for that type. Next, each argument type needed to be parsed in the command-line strings and converted to its true type. Finally, each argument type needed a getXXX method so that it could be returned to the caller as its true type.

Many different types, all with similar methods—that sounds like a class to me. And so the ArgumentMarshaler concept was born.

On Incrementalism

One of the best ways to ruin a program is to make massive changes to its structure in the name of improvement. Some programs never recover from such「improvements.」The problem is that it's very hard to get the program working the same way it worked before the「improvement.」

Args: The Rough Draft

To avoid this, I use the discipline of Test-Driven Development (TDD). One of the central doctrines of this approach is to keep the system running at all times. In other words, using TDD, I am not allowed to make a change to the system that breaks that system. Every change I make must keep the system working as it worked before.

To achieve this, I need a suite of automated tests that I can run on a whim and that verifies that the behavior of the system is unchanged. For the Args class I had created a suite of unit and acceptance tests while I was building the festering pile. The unit tests were written in Java and administered by JUnit . The acceptance tests were written as wiki pages in FitNesse . I could run these tests any time I wanted, and if they passed, I was confident that the system was working as I specified.

So I proceeded to make a large number of very tiny changes. Each change moved the structure of the system toward the ArgumentMarshaler concept. And yet each change kept the system working. The first change I made was to add the skeleton of the ArgumentMarshaller to the end of the festering pile ( Listing 14-11 ).

Listing 14-11 ArgumentMarshaller appended to Args.java

private class ArgumentMarshaler }        private boolean booleanValue = false;        public void setBoolean(boolean value) {          booleanValue = value;        }        public boolean getBoolean() {return booleanValue;}      }      private class BooleanArgumentMarshaler extends ArgumentMarshaler {      }      private class StringArgumentMarshaler extends ArgumentMarshaler {      }      private class IntegerArgumentMarshaler extends ArgumentMarshaler {      }    }

Clearly, this wasn't going to break anything. So then I made the simplest modification I could, one that would break as little as possible. I changed the HashMap for the Boolean arguments to take an ArgumentMarshaler .

private Map<Character, ArgumentMarshaler > booleanArgs =      new HashMap<Character, ArgumentMarshaler >();

This broke a few statements, which I quickly fixed.

…      private void parseBooleanSchemaElement(char elementId) {        booleanArgs.put(elementId, new BooleanArgumentMarshaler() );      }    ..      private void setBooleanArg(char argChar, boolean value) {        booleanArgs. get (argChar) .setBoolean (value);      }    …      public boolean getBoolean(char arg) {        return falseIfNull(booleanArgs.get(arg). getBoolean() );    }

Notice how these changes are in exactly the areas that I mentioned before: the parse, set , and get for the argument type. Unfortunately, small as this change was, some of the tests started failing. If you look carefully at getBoolean , you'll see that if you call it with ' y ,' but there is no y argument, then booleanArgs.get('y') will return null , and the function will throw a NullPointerException . The falseIfNull function had been used to protect against this, but the change I made caused that function to become irrelevant.

Incrementalism demanded that I get this working quickly before making any other changes. Indeed, the fix was not too difficult. I just had to move the check for null . It was no longer the boolean being null that I needed to check; it was the ArgumentMarshaller .

First, I removed the falseIfNull call in the getBoolean function. It was useless now, so I also eliminated the function itself. The tests still failed in the same way, so I was confident that I hadn't introduced any new errors.

public boolean getBoolean(char arg) {      return booleanArgs.get(arg).getBoolean();    }

Next, I split the function into two lines and put the ArgumentMarshaller into its own variable named argumentMarshaller . I didn't care for the long variable name; it was badly redundant and cluttered up the function. So I shortened it to am [N5].

public boolean getBoolean(char arg) {      Args.ArgumentMarshaler am = booleanArgs.get(arg);      return am .getBoolean();    }

And then I put in the null detection logic.

public boolean getBoolean(char arg) {      Args.ArgumentMarshaler am = booleanArgs.get(arg);      return am != null && am.getBoolean();    }

String Arguments

Addin_g String arguments was very similar to adding boolean arguments. I had to change the HashMap and get the parse , set , and get functions working. There shouldn't be any surprises in what follows except, perhaps, that I seem to be putting all the marshalling implementation in the ArgumentMarshaller base class instead of distributing it to the derivatives.

private Map<Character, ArgumentMarshaler > stringArgs =        new HashMap<Character, ArgumentMarshaler >();   …    private void parseStringSchemaElement(char elementId) {      stringArgs.put(elementId , new StringArgumentMarshaler() );    }   …    private void setStringArg(char argChar) throws ArgsException {     currentArgument++;     try {       stringArgs .get (argChar) .setString (args[currentArgument]);     } catch (ArrayIndexOutOfBoundsException e) {       valid = false;       errorArgumentId = argChar;       errorCode = ErrorCode.MISSING_STRING;       throw new ArgsException();     }    }   …    public String getString(char arg) {       Args.ArgumentMarshaler am = stringArgs.get(arg);      return am == null ?「 」 : am.getString();    }   …   private class ArgumentMarshaler {     private boolean booleanValue = false;      private String stringValue;     public void setBoolean(boolean value) {       booleanValue = value;     }     public boolean getBoolean() {       return booleanValue;     }      public void setString(String s) {        stringValue = s;     }      public String getString() {        return stringValue == null ?「 」: stringValue;      }   }

Again, these changes were made one at a time and in such a way that the tests kept running, if not passing. When a test broke, I made sure to get it passing again before continuing with the next change.

By now you should be able to see my intent. Once I get all the current marshalling behavior into the ArgumentMarshaler base class, I'm going to start pushing that behavior down into the derivatives. This will allow me to keep everything running while I gradually change the shape of this program.

The obvious next step was to move the int argument functionality into the ArgumentMarshaler . Again, there weren't any surprises.

private Map<Character, ArgumentMarshaler > intArgs =         new HashMap<Character, ArgumentMarshaler >();    …    private void parseIntegerSchemaElement(char elementId) {      intArgs.put(elementId, new IntegerArgumentMarshaler() );    }   …    private void setIntArg(char argChar) throws ArgsException {      currentArgument++;      String parameter = null;      try {        parameter = args[currentArgument];        intArgs .get (argChar) .setInteger (Integer.parseInt(parameter));      } catch (ArrayIndexOutOfBoundsException e) {        valid = false;        errorArgumentId = argChar;        errorCode = ErrorCode.MISSING_INTEGER;        throw new ArgsException();      } catch (NumberFormatException e) {        valid = false;        errorArgumentId = argChar;        errorParameter = parameter;        errorCode = ErrorCode.INVALID_INTEGER;        throw new ArgsException();      }    } …    public int getInt(char arg) {       Args.ArgumentMarshaler am = intArgs.get(arg);      return am == null ? 0 : am.getInteger();    }   …    private class ArgumentMarshaler {      private boolean booleanValue = false;      private String stringValue;       private int integerValue;      public void setBoolean(boolean value) {        booleanValue = value;      }      public boolean getBoolean() {       return booleanValue;      }      public void setString(String s) {        stringValue = s;      }         public String getString() {        return stringValue == null ?「 」: stringValue;      }       public void setInteger(int i) {         integerValue = i;       }       public int getInteger() {         return integerValue;       }    }

With all the marshalling moved to the ArgumentMarshaler , I started pushing functionality into the derivatives. The first step was to move the setBoolean function into the BooleanArgumentMarshaller and make sure it got called correctly. So I created an abstract set method.

private abstract class ArgumentMarshaler {       protected boolean booleanValue = false;      private String stringValue;      private int integerValue;      public void setBoolean(boolean value) {        booleanValue = value;      }      public boolean getBoolean() {        return booleanValue;      }      public void setString(String s) {        stringValue = s;      }      public String getString() {        return stringValue == null ?「 」: stringValue;      }      public void setInteger(int i) {        integerValue = i;      }      public int getInteger() {        return integerValue;      }       public abstract void set(String s);     }

Then I implemented the set method in BooleanArgumentMarshaller .

private class BooleanArgumentMarshaler extends ArgumentMarshaler {       public void set(String s) {         booleanValue = true;       }    }

And finally I replaced the call to setBoolean with a call to set .

private void setBooleanArg(char argChar, boolean value) {        booleanArgs.get(argChar) .set(「true」);       }

The tests all still passed. Because this change caused set to be deployed to the Boolean-ArgumentMarshaler , I removed the setBoolean method from the ArgumentMarshaler base class.

Notice that the abstract set function takes a String argument, but the implementation in the BooleanArgumentMarshaller does not use it. I put that argument in there because I knew that the StringArgumentMarshaller and IntegerArgumentMarshaller

would use it.

Next, I wanted to deploy the get method into BooleanArgumentMarshaler . Deploying get functions is always ugly because the return type has to be Object , and in this case needs to be cast to a Boolean .

public boolean getBoolean(char arg) {        Args.ArgumentMarshaler am = booleanArgs.get(arg);        return am != null && (Boolean) am. get ();      }

Just to get this to compile, I added the get function to the ArgumentMarshaler .

private abstract class ArgumentMarshaler {        …         public Object get() {           return null;         }    }

This compiled and obviously failed the tests. Getting the tests working again was simply a matter of making get abstract and implementing it in BooleanAgumentMarshaler .

private abstract class ArgumentMarshaler {        protected boolean booleanValue = false;        …        public abstract Object get();      }      private class BooleanArgumentMarshaler extends ArgumentMarshaler {        public void set(String s) {          booleanValue = true;        }         public Object get() {           return booleanValue;         }    }

Once again the tests passed. So both get and set deploy to the BooleanArgumentMarshaler ! This allowed me to remove the old getBoolean function from ArgumentMarshaler , move the protected booleanValue variable down to BooleanArgumentMarshaler , and make it private .

I did the same pattern of changes for Strings . I deployed both set and get , deleted the unused functions, and moved the variables.

private void setStringArg(char argChar) throws ArgsException {      currentArgument++;      try {        stringArgs.get(argChar). set (args[currentArgument]);      } catch (ArrayIndexOutOfBoundsException e) {        valid = false;        errorArgumentId = argChar;        errorCode = ErrorCode.MISSING_STRING;        throw new ArgsException();      }    }    …      public String getString(char arg) {        Args.ArgumentMarshaler am = stringArgs.get(arg);        return am == null ?「 」: (String) am. get ();      }    …      private abstract class ArgumentMarshaler {        private int integerValue;        public void setInteger(int i) {          integerValue = i;        }        public int getInteger() {          return integerValue;        }        public abstract void set(String s);        public abstract Object get();      }      private class BooleanArgumentMarshaler extends ArgumentMarshaler {         private boolean booleanValue = false;        public void set(String s) {          booleanValue = true;        }        public Object get() {          return booleanValue;        }      }      private class StringArgumentMarshaler extends ArgumentMarshaler {         private String stringValue =「 」;        public void set(String s) {           stringValue = s;        }        public Object get() {           return stringValue;        }      }      private class IntegerArgumentMarshaler extends ArgumentMarshaler {        public void set(String s) {        }        public Object get() {          return null;        }      }    }

Finally, I repeated the process for integers . This was just a little more complicated because integers needed to be parsed, and the parse operation can throw an exception. But the result is better because the whole concept of NumberFormatException got buried in the IntegerArgumentMarshaler .

private boolean isIntArg(char argChar) {return intArgs.containsKey(argChar);}      private void setIntArg(char argChar) throws ArgsException {        currentArgument++;        String parameter = null;        try {          parameter = args[currentArgument];          intArgs.get(argChar). set (parameter);        } catch (ArrayIndexOutOfBoundsException e) {          valid = false;          errorArgumentId = argChar;          errorCode = ErrorCode.MISSING_INTEGER;          throw new ArgsException();        } catch ( ArgsException e) {          valid = false;          errorArgumentId = argChar;          errorParameter = parameter;          errorCode = ErrorCode.INVALID_INTEGER;          throw e ;        }      }    …      private void setBooleanArg(char argChar) {         try {                  booleanArgs.get(argChar).set(「true」);         } catch (ArgsException e) {         }      }    …      public int getInt(char arg) {        Args.ArgumentMarshaler am = intArgs.get(arg);        return am == null ? 0 : (Integer) am. get ();      }    …      private abstract class ArgumentMarshaler {        public abstract void set(String s) throws ArgsException;        public abstract Object get();      }    …      private class IntegerArgumentMarshaler extends ArgumentMarshaler {         private int intValue = 0;        public void set(String s) throws ArgsException {           try {             intValue = Integer.parseInt(s);           } catch (NumberFormatException e) {             throw new ArgsException();           }        }        public Object get() {           return intValue;        }      }

Of course, the tests continued to pass. Next, I got rid of the three different maps up at the top of the algorithm. This made the whole system much more generic. However, I couldn't get rid of them just by deleting them because that would break the system. Instead, I added a new Map for the ArgumentMarshaler and then one by one changed the methods to use it instead of the three original maps.

public class Args {    …      private Map<Character, ArgumentMarshaler> booleanArgs =        new HashMap<Character, ArgumentMarshaler>();      private Map<Character, ArgumentMarshaler> stringArgs =        new HashMap<Character, ArgumentMarshaler>();      private Map<Character, ArgumentMarshaler> intArgs =        new HashMap<Character, ArgumentMarshaler>();       private Map<Character, ArgumentMarshaler> marshalers =         new HashMap<Character, ArgumentMarshaler>();    …      private void parseBooleanSchemaElement(char elementId) {         ArgumentMarshaler m = new BooleanArgumentMarshaler();        booleanArgs.put(elementId, m);         marshalers.put(elementId, m);      }      private void parseIntegerSchemaElement(char elementId) {         ArgumentMarshaler m = new IntegerArgumentMarshaler();        intArgs.put(elementId, m);         marshalers.put(elementId, m);      }      private void parseStringSchemaElement(char elementId) {         ArgumentMarshaler m = new StringArgumentMarshaler();        stringArgs.put(elementId, m);         marshalers.put(elementId, m);      }

Of course the tests all still passed. Next, I changed isBooleanArg from this:

private boolean isBooleanArg(char argChar) {      return booleanArgs.containsKey(argChar);    }

to this:

private boolean isBooleanArg(char argChar) {       ArgumentMarshaler m = marshalers.get(argChar);       return m instanceof BooleanArgumentMarshaler;    }

The tests still passed. So I made the same change to isIntArg and isStringArg .

private boolean isIntArg(char argChar) {       ArgumentMarshaler m = marshalers.get(argChar);       return m instanceof IntegerArgumentMarshaler;    }    private boolean isStringArg(char argChar) {       ArgumentMarshaler m = marshalers.get(argChar);       return m instanceof StringArgumentMarshaler;    }

The tests still passed. So I eliminated all the duplicate calls to marshalers.get as follows:

private boolean setArgument(char argChar) throws ArgsException {       ArgumentMarshaler m = marshalers.get(argChar);      if (isBooleanArg( m ))        setBooleanArg(argChar);      else if (isStringArg( m ))        setStringArg(argChar);      else if (isIntArg( m ))        setIntArg(argChar);      else        return false;      return true;    }    private boolean isIntArg( ArgumentMarshaler m ) {      return m instanceof IntegerArgumentMarshaler;    }    private boolean isStringArg( ArgumentMarshaler m ) {      return m instanceof StringArgumentMarshaler;    }    private boolean isBooleanArg( ArgumentMarshaler m ) {      return m instanceof BooleanArgumentMarshaler;    }

This left no good reason for the three isxxxArg methods. So I inlined them:

private boolean setArgument(char argChar) throws ArgsException {      ArgumentMarshaler m = marshalers.get(argChar);      if ( m instanceof BooleanArgumentMarshaler )        setBooleanArg(argChar);      else if ( m instanceof StringArgumentMarshaler )        setStringArg(argChar);      else if ( m instanceof IntegerArgumentMarshaler )        setIntArg(argChar);      else        return false;      return true;    }

Next, I started using the marshalers map in the set functions, breaking the use of the other three maps. I started with the booleans .

private boolean setArgument(char argChar) throws ArgsException {      ArgumentMarshaler m = marshalers.get(argChar);      if (m instanceof BooleanArgumentMarshaler)        setBooleanArg( m );      else if (m instanceof StringArgumentMarshaler)        setStringArg(argChar);      else if (m instanceof IntegerArgumentMarshaler)        setIntArg(argChar);      else        return false;        return true;      }    …      private void setBooleanArg( ArgumentMarshaler m ) {        try {           m .set(「true」); // was: booleanArgs.get(argChar).set(「true」);        } catch (ArgsException e) {        }      }

The tests still passed, so I did the same with Strings and Integers . This allowed me to integrate some of the ugly exception management code into the setArgument function.

private boolean setArgument(char argChar) throws ArgsException {      ArgumentMarshaler m = marshalers.get(argChar);       try {        if (m instanceof BooleanArgumentMarshaler)          setBooleanArg(m);        else if (m instanceof StringArgumentMarshaler)          setStringArg( m );        else if (m instanceof IntegerArgumentMarshaler)          setIntArg( m );        else          return false;       } catch (ArgsException e) {         valid = false;         errorArgumentId = argChar;         throw e;       }      return true;    }    private void setIntArg( ArgumentMarshaler m ) throws ArgsException {      currentArgument++;      String parameter = null;      try {        parameter = args[currentArgument];         m .set(parameter);      } catch (ArrayIndexOutOfBoundsException e) {        errorCode = ErrorCode.MISSING_INTEGER;        throw new ArgsException();      } catch (ArgsException e) {        errorParameter = parameter;        errorCode = ErrorCode.INVALID_INTEGER;        throw e;      }    }    private void setStringArg( ArgumentMarshaler m ) throws ArgsException {      currentArgument++;      try {         m .set(args[currentArgument]);      } catch (ArrayIndexOutOfBoundsException e) {        errorCode = ErrorCode.MISSING_STRING;        throw new ArgsException();      }    }

I was close to being able to remove the three old maps. First, I needed to change the getBoolean function from this:

public boolean getBoolean(char arg) {      Args.ArgumentMarshaler am = booleanArgs.get(arg);      return am != null && (Boolean) am.get();    }

to this:

public boolean getBoolean(char arg) {        Args.ArgumentMarshaler am = marshalers.get(arg);         boolean b = false;         try {           b =    am != null && (Boolean) am.get();         } catch (ClassCastException e) {           b = false;         }         return b;    }

This last change might have been a surprise. Why did I suddenly decide to deal with the ClassCastException ? The reason is that I have a set of unit tests and a separate set of acceptance tests written in FitNesse. It turns out that the FitNesse tests made sure that if you called getBoolean on a nonboolean argument, you got a false . The unit tests did not. Up to this point I had only been running the unit tests. 2

2. To prevent further surprises of this kind, I added a new unit test that invoked all the FitNesse tests.

This last change allowed me to pull out another use of the boolean map :

private void parseBooleanSchemaElement(char elementId) {      ArgumentMarshaler m = new BooleanArgumentMarshaler();       booleanArgs.put(elementId, m);      marshalers.put(elementId, m);    }

And now we can delete the boolean map.

public class Args {    …       private Map<Character, ArgumentMarshaler> booleanArgs      = new HashMap<Character, ArgumentMarshaler>();      private Map<Character, ArgumentMarshaler> stringArgs =      new HashMap<Character, ArgumentMarshaler>();      private Map<Character, ArgumentMarshaler> intArgs =      new HashMap<Character, ArgumentMarshaler>();      private Map<Character, ArgumentMarshaler> marshalers =      new HashMap<Character, ArgumentMarshaler>();    …

Next, I migrated the String and Integer arguments in the same manner and did a little cleanup with the booleans .

private void parseBooleanSchemaElement(char elementId) {      marshalers.put(elementId, new BooleanArgumentMarshaler() );    }    private void parseIntegerSchemaElement(char elementId) {      marshalers.put(elementId, new IntegerArgumentMarshaler() );    }    private void parseStringSchemaElement(char elementId) {      marshalers.put(elementId, new StringArgumentMarshaler() );    }   …    public String getString(char arg) {      Args.ArgumentMarshaler am = marshalers .get(arg);       try {        return am == null ?「 」: (String) am.get();       } catch (ClassCastException e) {         return「 」;       }    }    public int getInt(char arg) {      Args.ArgumentMarshaler am = marshalers .get(arg);       try {        return am == null ? 0 : (Integer) am.get();       } catch (Exception e) {         return 0;       }    } … public class Args { …     private Map<Character, ArgumentMarshaler> stringArgs =     new HashMap<Character, ArgumentMarshaler>();     private Map<Character, ArgumentMarshaler> intArgs =     new HashMap<Character, ArgumentMarshaler>();    private Map<Character, ArgumentMarshaler> marshalers =    new HashMap<Character, ArgumentMarshaler>();   …

Next, I inlined the three parse methods because they didn't do much anymore:

private void parseSchemaElement(String element) throws ParseException {      char elementId = element.charAt(0);      String elementTail = element.substring(1);      validateSchemaElementId(elementId);      if (isBooleanSchemaElement(elementTail))         marshalers.put(elementId, new BooleanArgumentMarshaler());      else if (isStringSchemaElement(elementTail))         marshalers.put(elementId, new StringArgumentMarshaler());      else if (isIntegerSchemaElement(elementTail)) {         marshalers.put(elementId, new IntegerArgumentMarshaler());      } else {        throw new ParseException(String.format(        「Argument: %c has invalid format: %s.」, elementId, elementTail), 0);      }    }

Okay, so now let's look at the whole picture again. Listing 14-12 shows the current form of the Args class.

Listing 14-12 Args.java (After first refactoring)

package com.objectmentor.utilities.getopts;    import java.text.ParseException;    import java.util.*;    public class Args {      private String schema;      private String[] args;      private boolean valid = true;      private Set<Character> unexpectedArguments = new TreeSet<Character>();      private Map<Character, ArgumentMarshaler> marshalers =       new HashMap<Character, ArgumentMarshaler>();      private Set<Character> argsFound = new HashSet<Character>();      private int currentArgument;      private char errorArgumentId = '\0';      private String errorParameter =「TILT」;      private ErrorCode errorCode = ErrorCode.OK;      private enum ErrorCode {        OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER,          UNEXPECTED_ARGUMENT}      public Args(String schema, String[] args) throws ParseException {        this.schema = schema;        this.args = args;        valid = parse();      }    private boolean parse() throws ParseException {      if (schema.length() == 0 && args.length == 0)        return true;      parseSchema();      try {        parseArguments();      } catch (ArgsException e) {      }      return valid;    }    private boolean parseSchema() throws ParseException {      for (String element : schema.split(「,」)) {        if (element.length() > 0) {          String trimmedElement = element.trim();          parseSchemaElement(trimmedElement);        }      }      return true;    }    private void parseSchemaElement(String element) throws ParseException {      char elementId = element.charAt(0);      String elementTail = element.substring(1);      validateSchemaElementId(elementId);      if (isBooleanSchemaElement(elementTail))        marshalers.put(elementId, new BooleanArgumentMarshaler());      else if (isStringSchemaElement(elementTail))        marshalers.put(elementId, new StringArgumentMarshaler());      else if (isIntegerSchemaElement(elementTail)) {        marshalers.put(elementId, new IntegerArgumentMarshaler());      } else {        throw new ParseException(String.format(        「Argument: %c has invalid format: %s.」, elementId, elementTail), 0);      }    }    private void validateSchemaElementId(char elementId) throws ParseException {      if (!Character.isLetter(elementId)) {        throw new ParseException(        「Bad character:」+ elementId +「in Args format: 」+ schema, 0);      }    }    private boolean isStringSchemaElement(String elementTail) {      return elementTail.equals(「*」);    }    private boolean isBooleanSchemaElement(String elementTail) {      return elementTail.length() == 0;    }    private boolean isIntegerSchemaElement(String elementTail) {      return elementTail.equals(「-」);    }    private boolean parseArguments() throws ArgsException {      for (currentArgument=0; currentArgument<args.length; currentArgument++) {        String arg = args[currentArgument];        parseArgument(arg);      }      return true;    }    private void parseArgument(String arg) throws ArgsException {      if (arg.startsWith(「-」))        parseElements(arg);    }    private void parseElements(String arg) throws ArgsException {      for (int i = 1; i < arg.length(); i++)        parseElement(arg.charAt(i));    }    private void parseElement(char argChar) throws ArgsException {      if (setArgument(argChar))        argsFound.add(argChar);      else {        unexpectedArguments.add(argChar);        errorCode = ErrorCode.UNEXPECTED_ARGUMENT;        valid = false;      }    }    private boolean setArgument(char argChar) throws ArgsException {      ArgumentMarshaler m = marshalers.get(argChar);      try {        if (m instanceof BooleanArgumentMarshaler)          setBooleanArg(m);        else if (m instanceof StringArgumentMarshaler)           setStringArg(m);        else if (m instanceof IntegerArgumentMarshaler)           setIntArg(m);        else           return false;      } catch (ArgsException e) {        valid = false;        errorArgumentId = argChar;        throw e;      }      return true;    }    private void setIntArg(ArgumentMarshaler m) throws ArgsException {      currentArgument++;      String parameter = null;      try {        parameter = args[currentArgument];        m.set(parameter);      } catch (ArrayIndexOutOfBoundsException e) {        errorCode = ErrorCode.MISSING_INTEGER;        throw new ArgsException();      } catch (ArgsException e) {        errorParameter = parameter;        errorCode = ErrorCode.INVALID_INTEGER;        throw e;      }    }    private void setStringArg(ArgumentMarshaler m) throws ArgsException {      currentArgument++;      try {        m.set(args[currentArgument]);      } catch (ArrayIndexOutOfBoundsException e) {        errorCode = ErrorCode.MISSING_STRING;        throw new ArgsException();      }    }    private void setBooleanArg(ArgumentMarshaler m) {      try {        m.set(「true」);      } catch (ArgsException e) {      }    }    public int cardinality() {      return argsFound.size();    }    public String usage() {      if (schema.length() > 0)        return「-[「 + schema + 」]」;      else        return「 」;    }    public String errorMessage() throws Exception {      switch (errorCode) {        case OK:          throw new Exception(「TILT: Should not get here.」);        case UNEXPECTED_ARGUMENT:          return unexpectedArgumentMessage();        case MISSING_STRING:          return String.format(「Could not find string parameter for -%c.」,      errorArgumentId);        case INVALID_INTEGER:          return String.format(「Argument -%c expects an integer but was '%s'.」,      errorArgumentId, errorParameter);        case MISSING_INTEGER:          return String.format(「Could not find integer parameter for -%c.」,      errorArgumentId);      }      return「 」;    }    private String unexpectedArgumentMessage() {      StringBuffer message = new StringBuffer(「Argument(s) -」);      for (char c : unexpectedArguments) {        message.append(c);      }      message.append(「 unexpected.」);      return message.toString();    }    public boolean getBoolean(char arg) {      Args.ArgumentMarshaler am = marshalers.get(arg);      boolean b = false;      try {        b = am != null && (Boolean) am.get();      } catch (ClassCastException e) {        b = false;      }      return b;    }    public String getString(char arg) {      Args.ArgumentMarshaler am = marshalers.get(arg);      try {        return am == null ?「 」: (String) am.get();      } catch (ClassCastException e) {        return「 」;      }    }    public int getInt(char arg) {      Args.ArgumentMarshaler am = marshalers.get(arg);      try {        return am == null ? 0 : (Integer) am.get();      } catch (Exception e) {        return 0;      }    }    public boolean has(char arg) {      return argsFound.contains(arg);    }    public boolean isValid() {      return valid;    }    private class ArgsException extends Exception {    }    private abstract class ArgumentMarshaler {      public abstract void set(String s) throws ArgsException;      public abstract Object get();    }    private class BooleanArgumentMarshaler extends ArgumentMarshaler {      private boolean booleanValue = false;          public void set(String s) {        booleanValue = true;      }      public Object get() {        return booleanValue;      }    }    private class StringArgumentMarshaler extends ArgumentMarshaler {      private String stringValue =「 」;      public void set(String s) {        stringValue = s;      }      public Object get() {        return stringValue;      }    }    private class IntegerArgumentMarshaler extends ArgumentMarshaler {      private int intValue = 0;      public void set(String s) throws ArgsException {        try {          intValue = Integer.parseInt(s);          } catch (NumberFormatException e) {              throw new ArgsException();          }        }        public Object get() {          return intValue;        }      }    }

After all that work, this is a bit disappointing. The structure is a bit better, but we still have all those variables up at the top; there's still a horrible type-case in setArgument ; and all those set functions are really ugly. Not to mention all the error processing. We still have a lot of work ahead of us.

I'd really like to get rid of that type-case up in setArgument [ G23 ]. What I'd like in setArgument is a single call to ArgumentMarshaler.set . This means I need to push setIntArg , setStringArg , and setBooleanArg down into the appropriate ArgumentMarshaler derivatives. But there is a problem.

If you look closely at setIntArg , you'll notice that it uses two instance variables: args and currentArg . To move setIntArg down into BooleanArgumentMarshaler , I'll have to pass both args and currentArgs as function arguments. That's dirty [F1]. I'd rather pass one argument instead of two. Fortunately, there is a simple solution. We can convert the args array into a list and pass an Iterator down to the set functions. The following took me ten steps, passing all the tests after each. But I'll just show you the result. You should be able to figure out what most of the tiny little steps were.

public class Args {   private String schema;    private String[] args;   private boolean valid = true;   private Set<Character> unexpectedArguments = new TreeSet<Character>();   private Map<Character, ArgumentMarshaler> marshalers =    new HashMap<Character, ArgumentMarshaler>();   private Set<Character> argsFound = new HashSet<Character>();   private Iterator<String> currentArgument;   private char errorArgumentId = '\0';   private String errorParameter =「TILT」;   private ErrorCode errorCode = ErrorCode.OK;    private List<String> argsList;   private enum ErrorCode {     OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER,               UNEXPECTED_ARGUMENT}   public Args(String schema, String[] args) throws ParseException {     this.schema = schema;      argsList = Arrays.asList(args);     valid = parse();   }   private boolean parse() throws ParseException {     if (schema.length() == 0 && argsList.size() == 0)       return true;     parseSchema();     try {       parseArguments();     } catch (ArgsException e) {     }     return valid;   } ---   private boolean parseArguments() throws ArgsException {     for (currentArgument = argsList.iterator() ; currentArgument. hasNext() ;) {       String arg = currentArgument. next() ;       parseArgument(arg);     }     return true;    } ---   private void setIntArg(ArgumentMarshaler m) throws ArgsException {     String parameter = null;     try {       parameter = currentArgument. next() ;       m.set(parameter);     } catch ( NoSuchElementException e) {       errorCode = ErrorCode.MISSING_INTEGER;       throw new ArgsException();     } catch (ArgsException e) {       errorParameter = parameter;       errorCode = ErrorCode.INVALID_INTEGER;       throw e;     }   }   private void setStringArg(ArgumentMarshaler m) throws ArgsException {     try {       m.set(currentArgument .next() );     } catch ( NoSuchElementException e) {       errorCode = ErrorCode.MISSING_STRING;       throw new ArgsException();     }   }

These were simple changes that kept all the tests passing. Now we can start moving the set functions down into the appropriate derivatives. First, I need to make the following change in setArgument :

private boolean setArgument(char argChar) throws ArgsException {      ArgumentMarshaler m = marshalers.get(argChar);       if (m == null)         return false;      try {        if (m instanceof BooleanArgumentMarshaler)          setBooleanArg(m);        else if (m instanceof StringArgumentMarshaler)          setStringArg(m);        else if (m instanceof IntegerArgumentMarshaler)          setIntArg(m);         else           return false;      } catch (ArgsException e) {        valid = false;        errorArgumentId = argChar;        throw e;      }      return true;    }

This change is important because we want to completely eliminate the if-else chain. Therefore, we needed to get the error condition out of it.

Now we can start to move the set functions. The setBooleanArg function is trivial, so we'll prepare that one first. Our goal is to change the setBooleanArg function to simply forward to the BooleanArgumentMarshaler .

private boolean setArgument(char argChar) throws ArgsException {        ArgumentMarshaler m = marshalers.get(argChar);        if (m == null)          return false;        try {          if (m instanceof BooleanArgumentMarshaler)            setBooleanArg(m, currentArgument );          else if (m instanceof StringArgumentMarshaler)            setStringArg(m);          else if (m instanceof IntegerArgumentMarshaler)            setIntArg(m);        } catch (ArgsException e) {          valid = false;          errorArgumentId = argChar;          throw e;        }        return true;      }    ---      private void setBooleanArg(ArgumentMarshaler m,                                  Iterator<String> currentArgument)                                 throws ArgsException {       try {         m.set(」true」);       catch (ArgsException e) {     }    }

Didn't we just put that exception processing in? Putting things in so you can take them out again is pretty common in refactoring. The smallness of the steps and the need to keep the tests running means that you move things around a lot. Refactoring is a lot like solving a Rubik's cube. There are lots of little steps required to achieve a large goal. Each step enables the next.

Why did we pass that iterator when setBooleanArg certainly doesn't need it? Because setIntArg and setStringArg will! And because I want to deploy all three of these functions through an abstract method in ArgumentMarshaller , I need to pass it to setBooleanArg .

So now setBooleanArg is useless. If there were a set function in ArgumentMarshaler , we could call it directly. So it's time to make that function! The first step is to add the new abstract method to ArgumentMarshaler .

private abstract class ArgumentMarshaler {       public abstract void set(Iterator<String> currentArgument)                            throws ArgsException;      public abstract void set(String s) throws ArgsException;      public abstract Object get();    }

Of course this breaks all the derivatives. So let's implement the new method in each.

private class BooleanArgumentMarshaler extends ArgumentMarshaler {      private boolean booleanValue = false;       public void set(Iterator<String> currentArgument) throws ArgsException {         booleanValue = true;      }      public void set(String s) {        booleanValue = true;      }      public Object get() {        return booleanValue;      }    }    private class StringArgumentMarshaler extends ArgumentMarshaler {      private String stringValue = 」」;       public void set(Iterator<String> currentArgument) throws ArgsException {      }            public void set(String s) {        stringValue = s;      }      public Object get() {        return stringValue;      }    }    private class IntegerArgumentMarshaler extends ArgumentMarshaler {      private int intValue = 0;       public void set(Iterator<String> currentArgument) throws ArgsException {       }      public void set(String s) throws ArgsException {        try {          intValue = Integer.parseInt(s);        } catch (NumberFormatException e) {          throw new ArgsException();        }      }      public Object get() {        return intValue;      }    }

And now we can eliminate setBooleanArg !

private boolean setArgument(char argChar) throws ArgsException {        ArgumentMarshaler m = marshalers.get(argChar);        if (m == null)          return false;        try {          if (m instanceof BooleanArgumentMarshaler)             m.set (currentArgument);          else if (m instanceof StringArgumentMarshaler)            setStringArg(m);          else if (m instanceof IntegerArgumentMarshaler)            setIntArg(m);        } catch (ArgsException e) {          valid = false;          errorArgumentId = argChar;          throw e;        }        return true;    }

The tests all pass, and the set function is deploying to BooleanArgumentMarshaler ! Now we can do the same for Strings and Integers .

private boolean setArgument(char argChar) throws ArgsException {      ArgumentMarshaler m = marshalers.get(argChar);      if (m == null)        return false;      try {        if (m instanceof BooleanArgumentMarshaler)          m.set(currentArgument);        else if (m instanceof StringArgumentMarshaler)           m.set(currentArgument);        else if (m instanceof IntegerArgumentMarshaler)           m.set(currentArgument);         } catch (ArgsException e) {        valid = false;        errorArgumentId = argChar;        throw e;      }      return true;    } ---    private class StringArgumentMarshaler extends ArgumentMarshaler {      private String stringValue = 」」;      public void set(Iterator<String> currentArgument) throws ArgsException {         try {           stringValue = currentArgument.next();         } catch (NoSuchElementException e) {           errorCode = ErrorCode.MISSING_STRING;           throw new ArgsException();         }      }      public void set(String s) {      }      public Object get() {        return stringValue;      }    }    private class IntegerArgumentMarshaler extends ArgumentMarshaler {      private int intValue = 0;    public void set(Iterator<String> currentArgument) throws ArgsException {       String parameter = null;       try {         parameter = currentArgument.next();         set(parameter);       } catch (NoSuchElementException e) {         errorCode = ErrorCode.MISSING_INTEGER;         throw new ArgsException();       } catch (ArgsException e) {         errorParameter = parameter;         errorCode = ErrorCode.INVALID_INTEGER;         throw e;       }    }      public void set(String s) throws ArgsException {        try {          intValue = Integer.parseInt(s);        } catch (NumberFormatException e) {          throw new ArgsException();        }      }      public Object get() {        return intValue;      }    }

And so the coup de grace : The type-case can be removed! Touche!

private boolean setArgument(char argChar) throws ArgsException {      ArgumentMarshaler m = marshalers.get(argChar);      if (m == null)        return false;      try {        m.set(currentArgument);        return true;      } catch (ArgsException e) {        valid = false;        errorArgumentId = argChar;        throw e;      }    }

Now we can get rid of some crufty functions in IntegerArgumentMarshaler and clean it up a bit.

private class IntegerArgumentMarshaler extends ArgumentMarshaler {      private int intValue = 0      public void set(Iterator<String> currentArgument) throws ArgsException {        String parameter = null;        try {          parameter = currentArgument.next();           intValue = Integer.parseInt (parameter);        } catch (NoSuchElementException e) {          errorCode = ErrorCode.MISSING_INTEGER;          throw new ArgsException();        } catch ( NumberFormatException e) {          errorParameter = parameter;          errorCode = ErrorCode.INVALID_INTEGER;          throw new ArgsException();        }      }      public Object get() {        return intValue;      }    }

We can also turn ArgumentMarshaler into an interface.

private interface ArgumentMarshaler {      void set(Iterator<String> currentArgument) throws ArgsException;      Object get();    }

So now let's see how easy it is to add a new argument type to our structure. It should require very few changes, and those changes should be isolated. First, we begin by adding a new test case to check that the double argument works correctly.

public void testSimpleDoublePresent() throws Exception {      Args args = new Args(」x##」, new String[] {」-x」,」42.3」});      assertTrue(args.isValid());      assertEquals(1, args.cardinality());      assertTrue(args.has('x'));      assertEquals(42.3, args.getDouble('x'), .001);    }

Now we clean up the schema parsing code and add the ## detection for the double argument type.

private void parseSchemaElement(String element) throws ParseException {      char elementId = element.charAt(0);      String elementTail = element.substring(1);      validateSchemaElementId(elementId);      if (elementTail. length() == 0 )        marshalers.put(elementId, new BooleanArgumentMarshaler());      else if (elementTail. equals(」*」) )        marshalers.put(elementId, new StringArgumentMarshaler());      else if (elementTail. equals(」#」) )        marshalers.put(elementId, new IntegerArgumentMarshaler());       else if (elementTail.equals(」##」))         marshalers.put(elementId, new DoubleArgumentMarshaler());      else        throw new ParseException(String.format(          」Argument: %c has invalid format: %s.」, elementId, elementTail), 0);    }

Next, we write the DoubleArgumentMarshaler class.

private class DoubleArgumentMarshaler implements ArgumentMarshaler {       private double doubleValue = 0;       public void set(Iterator<String> currentArgument) throws ArgsException {         String parameter = null;         try {           parameter = currentArgument.next();           doubleValue = Double.parseDouble(parameter);         } catch (NoSuchElementException e) {           errorCode = ErrorCode.MISSING_DOUBLE;           throw new ArgsException();         } catch (NumberFormatException e) {           errorParameter = parameter;           errorCode = ErrorCode.INVALID_DOUBLE;           throw new ArgsException();         }       }       public Object get() {         return doubleValue;       }     }

This forces us to add a new ErrorCode .

private enum ErrorCode {        OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT,         MISSING_DOUBLE, INVALID_DOUBLE }

And we need a getDouble function.

public double getDouble(char arg) {       Args.ArgumentMarshaler am = marshalers.get(arg);       try {         return am == null ? 0 : (Double) am.get();       } catch (Exception e) {         return 0.0;       }     }

And all the tests pass! That was pretty painless. So now let's make sure all the error processing works correctly. The next test case checks that an error is declared if an unparseable string is fed to a ## argument.

public void testInvalidDouble() throws Exception {      Args args = new Args(」x##」, new String[] {」-x」,」Forty two」});      assertFalse(args.isValid());      assertEquals(0, args.cardinality());      assertFalse(args.has('x'));      assertEquals(0, args.getInt('x'));        assertEquals(」Argument -x expects a double but was ‘Forty two'.」,                     args.errorMessage());    } ---    public String errorMessage() throws Exception {      switch (errorCode) {        case OK:          throw new Exception(」TILT: Should not get here.」);        case UNEXPECTED_ARGUMENT:          return unexpectedArgumentMessage();        case MISSING_STRING:          return String.format(」Could not find string parameter for -%c.」,                               errorArgumentId);        case INVALID_INTEGER:          return String.format(」Argument -%c expects an integer but was ‘%s'.」,                               errorArgumentId, errorParameter);        case MISSING_INTEGER:          return String.format(」Could not find integer parameter for -%c.」,                               errorArgumentId);         case INVALID_DOUBLE:           return String.format(」Argument -%c expects a double but was ‘%s'.」,                                errorArgumentId, errorParameter);         case MISSING_DOUBLE:           return String.format(」Could not find double parameter for -%c.」,                                errorArgumentId);      }      return」」;    }

And the tests pass. The next test makes sure we detect a missing double argument properly.

public void testMissingDouble() throws Exception {       Args args = new Args(」x##」, new String[]{」-x」});       assertFalse(args.isValid());       assertEquals(0, args.cardinality());       assertFalse(args.has('x'));       assertEquals(0.0, args.getDouble('x'), 0.01);       assertEquals(」Could not find double parameter for -x.」,                    args.errorMessage());     }

This passes as expected. We wrote it simply for completeness.

The exception code is pretty ugly and doesn't really belong in the Args class. We are also throwing out ParseException , which doesn't really belong to us. So let's merge all the exceptions into a single ArgsException class and move it into its own module.

public class ArgsException extends Exception {       private char errorArgumentId = '\0';       private String errorParameter = 」TILT」;       private ErrorCode errorCode = ErrorCode.OK;       public ArgsException() {}       public ArgsException(String message) {super(message);}       public enum ErrorCode {         OK, MISSING_STRING, MISSING_INTEGER,            INVALID_INTEGER, UNEXPECTED_ARGUMENT,           MISSING_DOUBLE, INVALID_DOUBLE}    }    ---    public class Args {      …      private char errorArgumentId = '\0';      private String errorParameter = 」TILT」;      private ArgsException .ErrorCode errorCode = ArgsException .ErrorCode.OK;      private List<String> argsList;      public Args(String schema, String[] args) throws ArgsException {        this.schema = schema;        argsList = Arrays.asList(args);        valid = parse();      }      private boolean parse() throws ArgsException {        if (schema.length() == 0 && argsList.size() == 0)          return true;        parseSchema();        try {          parseArguments();        } catch ( ArgsException e) {        }        return valid;      }      private boolean parseSchema() throws ArgsException {        …      }      private void parseSchemaElement(String element) throws ArgsException {        …        else          throw new ArgsException (            String.format(」Argument: %c has invalid format: %s.」,                          elementId,elementTail));      }      private void validateSchemaElementId(char elementId) throws ArgsException {        if (!Character.isLetter(elementId)) {          throw new ArgsException (            」Bad character:」+ elementId + 」in Args format: 」+ schema);        }      }      …      private void parseElement(char argChar) throws ArgsException {        if (setArgument(argChar))          argsFound.add(argChar);        else {          unexpectedArguments.add(argChar);          errorCode = ArgsException .ErrorCode.UNEXPECTED_ARGUMENT;          valid = false;        }      }      …      private class StringArgumentMarshaler implements ArgumentMarshaler {        private String stringValue = 」」;        public void set(Iterator<String> currentArgument) throws ArgsException {          try {            stringValue = currentArgument.next();          } catch (NoSuchElementException e) {            errorCode = ArgsException .ErrorCode.MISSING_STRING;            throw new ArgsException();          }        }        public Object get() {          return stringValue;        }      }      private class IntegerArgumentMarshaler implements ArgumentMarshaler {        private int intValue = 0;        public void set(Iterator<String> currentArgument) throws ArgsException {          String parameter = null;          try {            parameter = currentArgument.next();            intValue = Integer.parseInt(parameter);          } catch (NoSuchElementException e) {            errorCode = ArgsException.ErrorCode.MISSING_INTEGER;            throw new ArgsException ();          } catch (NumberFormatException e) {            errorParameter = parameter;            errorCode = ArgsException .ErrorCode.INVALID_INTEGER;            throw new ArgsException ();          }        }        public Object get() {          return intValue;        }      }      private class DoubleArgumentMarshaler implements ArgumentMarshaler {        private double doubleValue = 0;        public void set(Iterator<String> currentArgument) throws ArgsException {          String parameter = null;          try {            parameter = currentArgument.next();            doubleValue = Double.parseDouble(parameter);          } catch (NoSuchElementException e) {            errorCode = ArgsException .ErrorCode.MISSING_DOUBLE;            throw new ArgsException();          } catch (NumberFormatException e) {            errorParameter = parameter;            errorCode = ArgsException .ErrorCode.INVALID_DOUBLE;            throw new ArgsException();          }        }        public Object get() {          return doubleValue;        }      }    }

This is nice. Now the only exception thrown by Args is ArgsException . Moving ArgsException into its own module means that we can move a lot of the miscellaneous error support code into that module and out of the Args module. It provides a natural and obvious place to put all that code and will really help us clean up the Args module going forward.

So now we have completely separated the exception and error code from the Args module. (See Listing 14-13 through Listing 14-16 .) This was achieved through a series of about 30 tiny steps, keeping the tests passing between each step.

Listing 14-13 ArgsTest.java

package com.objectmentor.utilities.args;    import junit.framework.TestCase;    public class ArgsTest extends TestCase {      public void testCreateWithNoSchemaOrArguments() throws Exception {        Args args = new Args(「」, new String[0]);        assertEquals(0, args.cardinality());      }      public void testWithNoSchemaButWithOneArgument() throws Exception {        try {          new Args(「」, new String[]{「-x」});          fail();        } catch (ArgsException e) {          assertEquals(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,                       e.getErrorCode());          assertEquals(‘x', e.getErrorArgumentId());        }      }      public void testWithNoSchemaButWithMultipleArguments() throws Exception {        try {          new Args(「」, new String[]{「-x」,「-y」});          fail();        } catch (ArgsException e) {          assertEquals(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,                       e.getErrorCode());          assertEquals(‘x', e.getErrorArgumentId());        }      }      public void testNonLetterSchema() throws Exception {        try {          new Args(「*」, new String[]{});          fail(「Args constructor should have thrown exception」);        } catch (ArgsException e) {          assertEquals(ArgsException.ErrorCode.INVALID_ARGUMENT_NAME,                       e.getErrorCode());          assertEquals(‘*', e.getErrorArgumentId());        }      }      public void testInvalidArgumentFormat() throws Exception {        try {          new Args(「f~」, new String[]{});          fail(「Args constructor should have throws exception」);        } catch (ArgsException e) {          assertEquals(ArgsException.ErrorCode.INVALID_FORMAT, e.getErrorCode());          assertEquals(‘f', e.getErrorArgumentId());        }      }      public void testSimpleBooleanPresent() throws Exception {        Args args = new Args(「x」, new String[]{「-x」});        assertEquals(1, args.cardinality());        assertEquals(true, args.getBoolean(‘x'));      }      public void testSimpleStringPresent() throws Exception {        Args args = new Args(「x*」, new String[]{「-x」,「param」});        assertEquals(1, args.cardinality());        assertTrue(args.has(‘x'));        assertEquals(「param」, args.getString(‘x'));      }      public void testMissingStringArgument() throws Exception {        try {          new Args(「x*」, new String[]{「-x」});          fail();        } catch (ArgsException e) {          assertEquals(ArgsException.ErrorCode.MISSING_STRING, e.getErrorCode());          assertEquals(‘x', e.getErrorArgumentId());        }      }      public void testSpacesInFormat() throws Exception {        Args args = new Args(「x, y」, new String[]{「-xy」});        assertEquals(2, args.cardinality());        assertTrue(args.has(‘x'));        assertTrue(args.has(‘y'));      }      public void testSimpleIntPresent() throws Exception {        Args args = new Args(「x#」, new String[]{「-x」,「42」});        assertEquals(1, args.cardinality());        assertTrue(args.has(‘x'));        assertEquals(42, args.getInt(‘x'));      }      public void testInvalidInteger() throws Exception {        try {          new Args(「x#」, new String[]{「-x」,「Forty two」});          fail();        } catch (ArgsException e) {          assertEquals(ArgsException.ErrorCode.INVALID_INTEGER, e.getErrorCode());          assertEquals(‘x', e.getErrorArgumentId());          assertEquals(」Forty two」, e.getErrorParameter());        }      }      public void testMissingInteger() throws Exception {        try {          new Args(「x#」, new String[]{「-x」});          fail();        } catch (ArgsException e) {          assertEquals(ArgsException.ErrorCode.MISSING_INTEGER, e.getErrorCode());          assertEquals(‘x', e.getErrorArgumentId());        }      }      public void testSimpleDoublePresent() throws Exception {        Args args = new Args(「x##」, new String[]{「-x」,「42.3」});        assertEquals(1, args.cardinality());        assertTrue(args.has(‘x'));        assertEquals(42.3, args.getDouble(‘x'), .001);      }      public void testInvalidDouble() throws Exception {        try {          new Args(「x##」, new String[]{「-x」,「Forty two」});          fail();        } catch (ArgsException e) {          assertEquals(ArgsException.ErrorCode.INVALID_DOUBLE, e.getErrorCode());          assertEquals(‘x', e.getErrorArgumentId());          assertEquals(「Forty two」, e.getErrorParameter());        }      }      public void testMissingDouble() throws Exception {        try {          new Args(「x##」, new String[]{「-x」});          fail();        } catch (ArgsException e) {          assertEquals(ArgsException.ErrorCode.MISSING_DOUBLE, e.getErrorCode());          assertEquals(‘x', e.getErrorArgumentId());        }      }    }

Listing 14-14 ArgsExceptionTest.java

public class ArgsExceptionTest extends TestCase {      public void testUnexpectedMessage() throws Exception {        ArgsException e =          new ArgsException(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,                            ‘x', null);        assertEquals(「Argument -x unexpected.」, e.errorMessage());      }      public void testMissingStringMessage() throws Exception {        ArgsException e = new ArgsException(ArgsException.ErrorCode.MISSING_STRING,                                            ‘x', null);        assertEquals(「Could not find string parameter for -x.」, e.errorMessage());      }      public void testInvalidIntegerMessage() throws Exception {        ArgsException e =          new ArgsException(ArgsException.ErrorCode.INVALID_INTEGER,                            ‘x',「Forty two」);        assertEquals(「Argument -x expects an integer but was ‘Forty two'.「,                     e.errorMessage());      }      public void testMissingIntegerMessage() throws Exception {        ArgsException e =          new ArgsException(ArgsException.ErrorCode.MISSING_INTEGER, ‘x', null);        assertEquals(「Could not find integer parameter for -x.」, e.errorMessage());      }      public void testInvalidDoubleMessage() throws Exception {        ArgsException e = new ArgsException(ArgsException.ErrorCode.INVALID_DOUBLE,                                            ‘x',「Forty two」);        assertEquals(「Argument -x expects a double but was ‘Forty two'.」,                     e.errorMessage());      }      public void testMissingDoubleMessage() throws Exception {        ArgsException e = new ArgsException(ArgsException.ErrorCode.MISSING_DOUBLE,                                            ‘x', null);        assertEquals(「Could not find double parameter for -x.」, e.errorMessage());      }    }

Listing 14-15 ArgsException.java

public class ArgsException extends Exception {      private char errorArgumentId = ‘\0';      private String errorParameter =「TILT」;      private ErrorCode errorCode = ErrorCode.OK;      public ArgsException() {}      public ArgsException(String message) {super(message);}      public ArgsException(ErrorCode errorCode) {        this.errorCode = errorCode;      }      public ArgsException(ErrorCode errorCode, String errorParameter) {        this.errorCode = errorCode;        this.errorParameter = errorParameter;      }      public ArgsException(ErrorCode errorCode, char errorArgumentId,                           String errorParameter) {        this.errorCode = errorCode;        this.errorParameter = errorParameter;        this.errorArgumentId = errorArgumentId;      }      public char getErrorArgumentId() {        return errorArgumentId;      }      public void setErrorArgumentId(char errorArgumentId) {        this.errorArgumentId = errorArgumentId;      }      public String getErrorParameter() {        return errorParameter;      }      public void setErrorParameter(String errorParameter) {        this.errorParameter = errorParameter;      }      public ErrorCode getErrorCode() {        return errorCode;      }      public void setErrorCode(ErrorCode errorCode) {        this.errorCode = errorCode;      }      public String errorMessage() throws Exception {        switch (errorCode) {          case OK:            throw new Exception(「TILT: Should not get here.」);          case UNEXPECTED_ARGUMENT:            return String.format(「Argument -%c unexpected.」, errorArgumentId);          case MISSING_STRING:            return String.format(「Could not find string parameter for -%c.」,                                 errorArgumentId);          case INVALID_INTEGER:            return String.format(「Argument -%c expects an integer but was ‘%s'.」,                                 errorArgumentId, errorParameter);          case MISSING_INTEGER:            return String.format(「Could not find integer parameter for -%c.」,                                 errorArgumentId);          case INVALID_DOUBLE:            return String.format(「Argument -%c expects a double but was ‘%s'.」,                                 errorArgumentId, errorParameter);          case MISSING_DOUBLE:            return String.format(「Could not find double parameter for -%c.」,                                 errorArgumentId);        }        return「」;      }      public enum ErrorCode {        OK, INVALID_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME,        MISSING_STRING,        MISSING_INTEGER, INVALID_INTEGER,        MISSING_DOUBLE, INVALID_DOUBLE}    }

Listing 14-16 Args.java

public class Args {      private String schema;      private Map<Character, ArgumentMarshaler> marshalers =        new HashMap<Character, ArgumentMarshaler>();      private Set<Character> argsFound = new HashSet<Character>();      private Iterator<String> currentArgument;      private List<String> argsList;      public Args(String schema, String[] args) throws ArgsException {        this.schema = schema;        argsList = Arrays.asList(args);        parse();      }      private void parse() throws ArgsException {        parseSchema();        parseArguments();      }      private boolean parseSchema() throws ArgsException {        for (String element : schema.split(「,」)) {          if (element.length() > 0) {            parseSchemaElement(element.trim());          }        }        return true;      }      private void parseSchemaElement(String element) throws ArgsException {        char elementId = element.charAt(0);        String elementTail = element.substring(1);        validateSchemaElementId(elementId);        if (elementTail.length() == 0)          marshalers.put(elementId, new BooleanArgumentMarshaler());        else if (elementTail.equals(「*」))          marshalers.put(elementId, new StringArgumentMarshaler());        else if (elementTail.equals(「#」))          marshalers.put(elementId, new IntegerArgumentMarshaler());        else if (elementTail.equals(「##」))          marshalers.put(elementId, new DoubleArgumentMarshaler());        else          throw new ArgsException(ArgsException.ErrorCode.INVALID_FORMAT,                                  elementId, elementTail);      }      private void validateSchemaElementId(char elementId) throws ArgsException {        if (!Character.isLetter(elementId)) {          throw new ArgsException(ArgsException.ErrorCode.INVALID_ARGUMENT_NAME,                                  elementId, null);        }      }      private void parseArguments() throws ArgsException {        for (currentArgument = argsList.iterator(); currentArgument.hasNext();) {          String arg = currentArgument.next();          parseArgument(arg);        }      }      private void parseArgument(String arg) throws ArgsException {        if (arg.startsWith(「-」))          parseElements(arg);      }      private void parseElements(String arg) throws ArgsException {        for (int i = 1; i < arg.length(); i++)          parseElement(arg.charAt(i));      }      private void parseElement(char argChar) throws ArgsException {        if (setArgument(argChar))          argsFound.add(argChar);        else {          throw new ArgsException(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,                                  argChar, null);        }      }      private boolean setArgument(char argChar) throws ArgsException {        ArgumentMarshaler m = marshalers.get(argChar);        if (m == null)          return false;        try {          m.set(currentArgument);          return true;        } catch (ArgsException e) {          e.setErrorArgumentId(argChar);          throw e;        }      }      public int cardinality() {        return argsFound.size();      }      public String usage() {        if (schema.length() > 0)          return「-[」+ schema +「]」;        else          return「」;      }      public boolean getBoolean(char arg) {        ArgumentMarshaler am = marshalers.get(arg);        boolean b = false;        try {          b = am != null && (Boolean) am.get();        } catch (ClassCastException e) {          b = false;        }        return b;      }      public String getString(char arg) {        ArgumentMarshaler am = marshalers.get(arg);        try {          return am == null ?「」: (String) am.get();        } catch (ClassCastException e) {          return「」;        }      }      public int getInt(char arg) {        ArgumentMarshaler am = marshalers.get(arg);        try {          return am == null ? 0 : (Integer) am.get();        } catch (Exception e) {          return 0;        }      }      public double getDouble(char arg) {        ArgumentMarshaler am = marshalers.get(arg);        try {          return am == null ? 0 : (Double) am.get();        } catch (Exception e) {          return 0.0;        }      }      public boolean has(char arg) {        return argsFound.contains(arg);      }    }

The majority of the changes to the Args class were deletions. A lot of code just got moved out of Args and put into ArgsException . Nice. We also moved all the ArgumentMarshaller s into their own files. Nicer!

Much of good software design is simply about partitioning—creating appropriate places to put different kinds of code. This separation of concerns makes the code much simpler to understand and maintain.

Of special interest is the errorMessage method of ArgsException . Clearly it was a violation of the SRP to put the error message formatting into Args. Args should be about the processing of arguments, not about the format of the error messages. However, does it really make sense to put the error message formatting code into ArgsException ?

Frankly, it's a compromise. Users who don't like the error messages supplied by ArgsException will have to write their own. But the convenience of having canned error messages already prepared for you is not insignificant.

By now it should be clear that we are within striking distance of the final solution that appeared at the start of this chapter. I'll leave the final transformations to you as an exercise.

Conclusion

It is not enough for code to work. Code that works is often badly broken. Programmers who satisfy themselves with merely working code are behaving unprofessionally. They may fear that they don't have time to improve the structure and design of their code, but I disagree. Nothing has a more profound and long-term degrading effect upon a development project than bad code. Bad schedules can be redone, bad requirements can be redefined. Bad team dynamics can be repaired. But bad code rots and ferments, becoming an inexorable weight that drags the team down. Time and time again I have seen teams grind to a crawl because, in their haste, they created a malignant morass of code that forever thereafter dominated their destiny.

Of course bad code can be cleaned up. But it's very expensive. As code rots, the modules insinuate themselves into each other, creating lots of hidden and tangled dependencies. Finding and breaking old dependencies is a long and arduous task. On the other hand, keeping code clean is relatively easy. If you made a mess in a module in the morning, it is easy to clean it up in the afternoon. Better yet, if you made a mess five minutes ago, it's very easy to clean it up right now.

So the solution is to continuously keep your code as clean and simple as it can be. Never let the rot get started.

15 JUnit Internals

