This chapter covers Creating an icon for the app Compiling the app for different OSs Testing the app on different platforms

In the world of software, it's easy to start a new project, but persisting with it andseeing it through to the end is not so easy. Shipping software is the big dividebetween those who make software that's used around the world and those who starta lot of projects but don't finish them.

In chapter 3, you fleshed out the skeleton of your desktop app until youreached the point where you could call it a minimally viable product. Now, the nextstep for you is to prepare the app for distribution by making it an app that users canget and run on Windows, Mac OS, and Linux.

You'll explore how to use build tools for NW.js and Electron to help build stand-

alone executables of the Lorikeet app.

75

76

4.1

4.1.1

CHAPTER 4 Shipping your first desktop application

Setting up the app for distributionOnce an app is built and ready for users to get their hands on, the next step is to getthe app ready for packaging and distribution. This involves a number of things:

 Getting the app to display a custom icon in place of the default app Creating native binaries of the app for the different OSs Testing those apps out on the various platforms

You'll start with creating the icons for the app.

Creating the app iconFor Lorikeet, you want to customize the look and feel of the app so that users can easilydistinguish it from the other apps they have on their computer. Changing the app iconis a bit of a tedious process, because each OS has its own file format and approach to dis-playing app icons, as well as the fact that changing the app icon requires a bit of manualtinkering. You'll start by looking at the different ways that each OS implements iconsand then looking at how you can create app icons for each OS.

The first step is to create an app icon as a high-resolution PNG at 512 x 512 pixels.If you feel creative and have an idea for an icon, this can be a fun exercise, but if you'dlike to skip that and use one that has already been made for the app, you can down-load a copy of the icon I made (based on a photo of some real-life lorikeets I took inAustralia) from https://github.com/paulbjensen/lorikeet/blob/master/icon.png.

Figure 4.1 shows what the icon looks like.

Figure 4.1 The icon for both versions of the Lorikeet app

Once you have this icon, you can begin the process of creating the different versionsof the icon for each OS.MAC OSMac OS uses the ICNS file format for app icons. This is a file format that contains ver-sions of the app icon at the following resolutions:

 16 px 32 px 128 px 256 px 512 px

Setting up the app for distribution

77

Depending on what OS you're running on your computer (I use Mac OS), there are anumber of approaches to creating an ICNS file. A quick search on the term ICNS gen-erator will show some online tools as well as commercial applications that generate notonly ICNS files but also icon files for Windows, iOS, and other platforms. On the MacApp Store there's a product called iConvert Icons that will convert the app icon intoan ICNS file as well as a Microsoft Windows ICO file (you can also use iConvert Iconsonline as a free option). Alternatively, if you have a subscription to Apple's DeveloperProgram, you can download Icon Composer for free (a tool that was originally bun-dled into Xcode). I'll show you the steps for creating an ICNS file using IConvertIcons (assuming you have a computer running Mac OS).

First, search for the app in the App Store, purchase it, and then open it when it's

finished downloading. You should see the screen shown in figure 4.2.

Figure 4.2 iConvert Icons, a tool for creating both ICNS and ICO icon files from an image. Notice that the iConvert Icons app has three checkboxes ticked here for the versions I want to generate.

Drag the app icon PNG image that you have into the dotted area of the app. A folderdialog box opens, asking for a place to save the generated files to. You want to save thefile to the images folder of your app. Choose the folder, and you'll find that the fileshave been saved to that location, as shown in figure 4.3.

Now that you have the ICNS file for the app, you have a number of ways to make itthe icon for your app, but you'll need to build the app before you can do that. Fornow, you'll keep the ICNS for use later.

78

CHAPTER 4 Shipping your first desktop application

Figure 4.3 The app icon files that were generated by iConvert Icons

WINDOWSMicrosoft Windows uses the ICO file format for its icons, which is also the file formatused for website icons that are displayed in web browsers. If you're already using iCon-vert Icons, you can use that program for the ICO file.

Alternatively, a quick search on Google shows a number of results, the top-rankingbeing a website called icoconverter.com. If you choose to use that website, make sureto check the checkboxes for all of the icon resolutions, because different versions ofWindows use a range of icon resolutions. Once you've uploaded your app icon andsaved a copy of it to your computer, it will be ready for when you build the app.LINUXAlthough there are many different distributions of Linux, the freedesktop.org organiza-tion has created a standard for handling icons across the different graphical desktopenvironments that are used on Linux (such as Gnome, KDE, and Xfce). It's known asthe desktop entry specification, and can be found at http://standards.freedesktop.org/desktop-entry-spec/latest.

The .desktop file is a configuration file that contains details about what the appname is, where it runs from, what icon it has, and some other configuration informa-tion. Here's an example of a .desktop file:

[Desktop Entry]Encoding=UTF-8Version=1.0Type=LorikeetTerminal=falseExec=$HOME/.lorikeet/lorikeetName=LorikeetIcon=$HOME/.lorikeet/icon.png

The .desktop file is saved on the user's computer with a filename—for example, lori-keet.desktop. The image file format for the icon used on Linux can be a PNG file, likethe one that was originally created for the app. That said, if you want to guarantee that

Packaging the app for distribution

79

your app icon looks good at all resolutions, it's better to use an SVG file, which is vec-tor-based and scales with resolution much better. Either way, you now have icon filessuitable for all three OSs.

To set the icon on the app, you need to go through the process of building the

app, and then you can go about setting the app icon on the different builds.

4.2

Packaging the app for distributionNow that you've configured the app to look the way you want, you're in a position togenerate native executable versions of the app, one for each OS. Both NW.js and Elec-tron have build tools that make it easy to build the app.

You'll start by looking at how to build standalone executables of the NW.js version

of the Lorikeet app. Then you'll look at how to do the same thing with Electron.

4.2.1 Using a build tool for NW.js

There are quite a few build tools for NW.js, but the one that I recommend using forthis case is called nw-builder. You can install nw-builder (formerly known as node-webkit-builder) by installing it with npm via the Terminal or Command Prompt:

npm install nw-builder -g

The preceding command installs nw-builder as a global npm module and thereforemakes the nwbuild command available to you on the command line for all yourNW.js apps.

Not only can nw-builder create standalone executables of the app for each OS, youcan also include the app icons you created earlier. In order to do this, you need topass some options to the nwbuild command to tell it to use the icons. Navigate to afolder where you would like the app files to be generated and run the following com-mand in Terminal or Command Prompt:

nwbuild . -o ./build -p win64,osx64,linux64

This will generate a build folder in the directory where the command was run. Insidethat build folder will be another folder with the name of the app (in this case, lori-keet-nwjs), and inside that you'll have six folders, one for each of the OS builds youwant to create the app for (win64, osx64, linux64). These folders contain the builtapp with 64-bit versions of the app on each OS. If you browse through those folders,you'll see .exe files for the Windows versions of the app, as well as an app file for theMac OS versions.

Double-click an app to see it open on your computer, and you should see it run-ning as a standalone app; there's no Terminal window open where it's being run from,and no external software dependencies to install before running it. If you're usingMac OS, then it should appear in your Dock. In Windows, you should see the apploaded in the taskbar at the bottom of the screen. If you're running Linux (say,Ubuntu), you should see the app open in the unity bar.

80

CHAPTER 4 Shipping your first desktop application

4.2.2 Using a build tool for Electron

A number of build tools are available for Electron, and one of them is called (youguessed it) electron-builder. It's a good tool to use for packaging Electron apps, soyou'll install it in this section. In Terminal or Command Prompt, install electron-builder via npm:

npm install electron-builder electron –-save-dev

You install electron-builder and electron as development dependencies for the app.After installation, you'll want to alter the package.json file so that it contains the con-figuration information for how to build the app.

In order to make electron-builder work, you need to check that the package.json

file has the following fields (or add them if it doesn't):

 Name Description Version Author Build configuration Scripts for packing and distribution

That's the bare minimum required for electron-builder to make a standalone exe-cutable of the app. The following listing shows an example of how your package.jsonfile might look.

Listing 4.1 An example of the package.json file with electron-builder config

{ "name": "lorikeet", "version": "1.0.0", "main": "main.js", "author": "Paul Jensen <paul@anephenix.com>", "description": "A file explorer application", "dependencies": { "async": "^2.1.4", "lunr": "^0.7.2", "osenv": "^0.1.4" }, "scripts": { "pack": "build", "dist": "build" }, "devDependencies": { "electron": "^1.4.14", "electron-builder": "^11.4.4" }, "build": {}}

Packaging the app for distribution

81

Once you have those fields filled in on the package.json file, you can look to build thestandalone executables for the Electron version of the Lorikeet app. You can then runthe following command via npm to start creating the standalone executables:

npm run pack

This will kick off building the Lorikeet Electron app. When the app build has fin-ished, there'll be a new folder called dist, which will contain another folder namedmac. This contains the Lorikeet app in multiple builds—a zip file and a DMG file.

Now that you have the app standalone, you can work on setting the app's icon to

the one you created in the previous section.

CONFIGURING OPTIONS FOR ELECTRON-BUILDER A huge range of options forconfiguring how electron-builder builds the various versions of your app isavailable. For more information, see this link: https://github.com/electron-userland/electron-builder/wiki/Options.

4.2.3

Setting the app icon on the appsNow that you have the app and the icon files for the different OSs, you need to com-bine them. The best way to do that is to follow the approaches described for each OS.MAC OSThere's a simple way to change the icon of an app in Mac OS. In the build folder con-taining the Mac OS version of the app, right-click the app and select Get Info. Youshould see a screen like figure 4.4.

Figure 4.4 The Info window on the Lorikeet NW.js app, pre-icon change

82

CHAPTER 4 Shipping your first desktop application

In another Finder window, find the icon.icns file you created earlier and drag it overthe icon of the app in the top left-hand corner of the Info window. You should thenexpect to see the Info window look like figure 4.5.

Figure 4.5 The Info window on the Lorikeet NW.js app, post-icon change

That's it! Drag and drop the icon.icns file over the app's icon in the Info window. Ifyou double-click the app, you should see the new app icon in the Dock, in the Finderwindow when browsing to where the app is stored, and in the list of apps that openswhen you press Command-Tab. This version of the app is now ready for distribution,and is quite the simplest and most effective way of changing the app icon for Mac ver-sions of the app.MICROSOFT WINDOWSChanging the icon for Windows versions of the app is not as simple as for Mac OS,but it's not that difficult either. There are two ways you can approach this. One isto change it manually with a third-party tool, and the other is to have nw-builderdo it for you. I'll document both approaches and let you use the one that worksbest for you.

Assuming that you have a Microsoft Windows PC available (or, alternatively, run animage of Microsoft Windows via a virtual machine), you can download a free toolcalled Resource Hacker (http://angusj.com/resourcehacker). Resource Hacker is atool for modifying executable files and will allow you to replace the .ico file that's usedfor the app.

Packaging the app for distribution

83

Once you have the Windows build of the app copied to the Windows desktop,open the lorikeet.exe file with Resource Hacker and click Action > Replace Icon inthe menu bar, as shown in figure 4.6.

Figure 4.6 Replacing the Windows app executable icon with Resource Hacker

Select the icon.ico file that was created for the Windows app and click File > Save.Select the lorikeet.exe file to be replaced, and the Windows app should now have anupdated icon. When you double-click the app icon, you should see the app running inWindows, with the icon displayed in the task bar. This approach works well with olderversions of Windows, but not with the latest versions of Windows.

nw-builder can handle setting the icon for the app, but isn't always guaranteed towork across all platforms—this approach is guaranteed to work with the latest versionsof Windows.

The first thing to do is to make sure that you have a copy of the app icon some-where in the app folder (it doesn't matter where exactly—it can be on the same folderlevel as the package.json file or nested inside an assets folder). Assuming that you'vesaved the file as icon.png in the same folder as the package.json file, modify the pack-age.json's window section so that it includes the following line:

"icon":"icon.png"

84

CHAPTER 4 Shipping your first desktop application

With this line in place, you tell NW.js to load the icon.png file as the icon for thetitle bar, and nw-builder will spot this file and use it to set the app's icon as displayedin the file explorer, as well as when the app is displayed in the task bar. After youmake this change, rebuild the app using nw-builder's nwbuild command (as men-tioned in the previous section), and when the app is built, you should see that theapp icon has been set to that of the lorikeet-based icon, rather than the dark bluehexagon icon for NW.js.

If you now double-click on that app, you should expect to see a screen like figure 4.7.

Figure 4.7 Lorikeet NW.js running on Windows 8.1. Notice that the taskbar icon and title bar icon display the app's lorikeet-inspired icon.

This allows you to ensure that the app's visual identity is complete on Windows 8.Something to bear in mind here is that your users will likely be using different ver-sions of Windows (there are many Windows XP users in China, for example), sodepending on what versions of Windows you want/need to support for your apps,the best course of action is to establish what versions of Windows will be used, usethe nwbuild option first, and then for older OSs, manually adjust the icon usingResource Hacker.

With that done, you can finally look to set up the app icon on the third OS, Linux.

Packaging the app for distribution

85

Getting a blank NW.js app on Windows?This is an issue that some NW.js users have been having with getting their apps towork on Windows (see https://github.com/nwjs/nw.js/issues/3212). It turns outthat Windows has a 256-character limit on file paths. People developing Node.js appson Windows have run into this issue due to the way that npm nests module depen-dencies in folders.

npm worked on resolving this issue in version 3 of the CLI by making npm installdependencies in a flat-folder structure, avoiding nested folders and thereby not runninginto Windows' 256-character limit.

You can install version 3 of npm by running the following command:

npm install npm

For more on this issue, and for tools to help resolve it, see the article http://engine-room.teamwork.com/dealing-with-long-paths/.

LINUXDepending on which distribution of Linux you use (I tend to use Ubuntu), the pro-cess of setting the icon on the app built for Linux can be even simpler than the pro-cess for Mac OS. If you don't have a copy of Linux running on your computer, you candownload and install VirtualBox, download Ubuntu Linux's ISO image, and then cre-ate a virtual machine that uses the ISO image. This way you can test whether yourdesktop apps work on other OSs without needing to have multiple computers and lap-tops with different OSs installed.

Once you have Linux booted and running, and assuming that you're using theGnome desktop environment, copy either version of the Lorikeet app built for Linuxand its files to a location on your computer, as well as the PNG image of the icon.Click the Files icon to open Gnome's file explorer, browse to the location of either ver-sion of the Lorikeet app, right-click the icon, and select Properties. In the Propertieswindow that appears, click the icon in the top left, select the path to the PNG imagefor the icon, and then confirm. This is all it takes to change the icon for the app. Now,if you double-click the app icon, you should see the app running, and it will appear inthe unity bar as well, as shown in figure 4.8.

That's all it takes to set up the app for Ubuntu Linux. You can now distribute theapp as a standalone app for others to use on their computers. This means you havecompleted the journey of building a desktop app and shipping it.

86

CHAPTER 4 Shipping your first desktop application

Figure 4.8 The Lorikeet NW.js app running on Ubuntu Linux

4.3

4.3.1

Testing your app on multiple OSsIn order to ensure that your apps work on multiple OSs, you have to try them on eachOS, which can be tricky if you only have one development machine.

Chances are, you might only use one OS for your development machine, and sowhen you need to support multiple OSs for your apps, you may ask, 「Where do Istart?」

If you're rich enough (or lucky enough to work somewhere with a good budget forequipment), you can purchase extra computers with the versions of Windows, Linux,and Mac OS that you want to support. But if that option isn't available, there are otheroptions.

Targeting Windows OSsIn terms of market share, Windows is the biggest desktop OS, and there are multiplevariants of Windows out there: Windows XP, Vista, 7, 8, 8.1, and 10. How do you caterto all these varieties of Windows if your development machine runs Mac OS or Linux? The answer involves virtual machines. VMs allow an OS to run in an isolated envi-ronment, sharing access to hard disk, memory, and other hardware resources with thecomputer's main OS. They can be used to run apps in secure, isolated environments(such as infrastructure-as-a-service companies like Amazon, Linode, and DigitalOcean)as well as test apps.

Summary

87

In the case of virtualization software, a variety of both commercial and open sourceofferings are available. On the Mac, commercial options include VMware Fusion andParallels, and for open source options, there's VirtualBox (which also works on Linux).There are some other open source virtualization tools (such as QEMU), but the threelisted here are well known.

Once you've installed a virtualization tool, the next step is to purchase a copy ofWindows and generate a VM for it, or use an available Windows image. Microsoft pro-vides a range of VM images for different OS platforms to assist developers with testingwebsites on Internet Explorer (http://dev.modern.ie/tools/vms/mac/), and if you'rehappy with the terms for using the VMs, then you can do that pretty quickly.

4.3.2

Targeting Linux OSs

Linux is easy to test apps for—the only challenge is knowing which distributions ofLinux and which versions of them to test for. VirtualBox is a popular tool for test-ing Linux distributions on both Mac OS and Windows PCs. Users can download ISOimages for their preferred Linux distributions and easily set up a Linux distribution totest their app on.

4.3.3

Targeting Mac OS

Sadly, testing your apps on Mac OS is not as straightforward. Mac OS's End UserLicense Agreement (EULA) prohibits the running of Mac OS on non-Apple hard-ware. That said, an internet search will reveal that some developers have managed torun Mac OS on non-Apple computers, but I can't recommend that course of action. Itlooks like your best (legal) bet is to purchase an Apple computer (either a MacBooklaptop or a Mac mini as a cheaper option), and use that to test your app.

4.4

SummaryIn this chapter, you've gone through the process of taking a minimally viable productand preparing it for distribution for multiple OSs. You've disabled the developer tool-bar, generated a custom icon for the app, built both 32-bit and 64-bit binaries acrossall the OSs, and discussed practical strategies for testing the app on those differentOSs. Here are some key takeaways to bear in mind:

 nw-builder and electron-builder provide the easiest ways to build your app for

multiple OSs.

 You have to check that the app icons work across multiple versions of Windows,

because they're not always guaranteed to work.

 If you don't have multiple computers running the different OSs that you need

to target, you can use a virtualization tool like VirtualBox.

 From a legal standpoint, you need to own a Mac computer in order to test your

app on Mac OS.

88

CHAPTER 4 Shipping your first desktop application

Well done on getting this far and going through the process of making a desktop appwith NW.js and Electron. You know enough now to be able to do it again with a differ-ent app. This exercise has helped set the foundations for diving deeper into bothElectron and NW.js, and lays the groundwork for better understanding the frame-works. In chapter 5, you'll explore the Node.js framework that underpins them bothand see how that works.

Part 2

Diving deeper

A fter building a file explorer app with both NW.js and Electron, we'll take

a step back and cast our eyes on the programming framework behind them:Node.js. You'll learn about its origins, how it works, and how it implements asyn-chronous programming. Then, we'll explore some of Node.js's key concepts suchas callbacks, streams, events, and modules.

In chapter 6, we'll continue on this theme by looking at how NW.js and Elec-tron operate under the hood. You'll see how the frameworks approach integrat-ing Node.js with Chromium, how they handle managing state between the front-end and back-end parts of the app, and how they're structured.

By the end of this part, you should be a in a good position to put Node.js touse in your desktop app as well as other Node.js apps, and you'll understand howNW.js and Electron differ in their approaches to desktop app development.

Using Node.js withinNW.js and Electron

This chapter covers Exploring Node.js Understanding the asynchronous nature of

Node.js

