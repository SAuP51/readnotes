â€“ Albert Einstein

We have gone through a lot of theory followed by even more practice. The entire journey was like a speeding train and we have hardly had an opportunity to repeat what we learned. There was no time for rest.

The good news is that the time for the reflection is now. We'll summarize everything we learned and go through TDD best practices. Some of those have already been mentioned, while others will be new.

Topics covered in this chapter include:

TDD in a nutshell

Common conventions and good practices, such as in naming tests

Tools

Next steps

Putting It All Together

Chapter 11

TDD in a nutshell

Red-Green-Refactor is the pillar of TDD that wraps it into a short and repeatable cycle. By short, we mean very short. The time dedicated to each phase is often counted in minutes, if not seconds. Write a test, see it fail, write just enough implementation code to make the last test pass, run all tests, and pass into the green phase. Once the minimum code is written so that we have safety in the form of passing tests, it is time to refactor the code until it is as good as we're hoping it to be. While in this phase, tests should always pass. Neither new functionalities nor new tests can be introduced while refactoring is in progress. Doing all this in such a short period of time is often scary, or might sound impossible. We hope that, through the exercises we did together, your skills have improved, as well as your confidence and speed.

While there is the word test in TDD, it is not the main benefit nor objective. TDD is, first and foremost, a concept of a better way to design our code. On top of that, we end up with tests that should be used to continuously check that the application continues working as expected.

The importance of speed was mentioned often previously. While part of this is accomplished by us being ever more proficient in TDD, another contributor is test doubles (mocking, stubbing, spying, and so on). With these, we can remove the need for external dependencies such as databases, file systems, third-party services, and so on.

What are the other benefits of TDD? Documentation is one of them. Since code itself is the only accurate and always up-to-date representation of the applications we're working on, specifications written using TDD (being code as well) is the first place we should turn to when we need to better understand what a piece of code does.

How about design? You noticed how TDD produces code that is designed better. Rather than defining design in advance, with TDD it tends to emerge as we progress from one specification to another. At the same time, code that is easy to test is well-designed code.

Tests force us to apply some coding best practices.

We also learned that TDD does not need to be practiced only on small units (methods). It can also be used at a much higher-level, where the focus is on a feature or a behavior that can span multiple methods, classes, or even applications and systems. One of the forms of TDD practiced at such a high-level is behavior-driven development (BDD). Unlike TDD, which is based on the unit tests that are done by developers for developers, BDD can be used by almost everyone in your organization. Since it tackles behaviors and it's written in natural (ubiquitous) language, testers, managers, business representatives, and others can participate in its creation and use it as a reference later on.

[ 262 ]

Putting It All Together

Chapter 11

We defined legacy code as code without tests. We faced some of the challenges legacy code puts in front of us and learned some of the techniques that can be used to make it testable.

With all this in mind, let's go through TDD best practices.

Best practices

Coding best practices are a set of informal rules that the software development community has developed over time, which can help to improve the quality of software. While each application needs a level of creativity and originality (after all, we're trying to build something new or better), coding practices help us avoid some of the problems others faced before us. If you're just starting with TDD, it is a good idea to apply some (if not all) of the best practices generated by others.

For easier classification of TDD best practices, we divided them into four categories: Naming conventions

Processes

Development practices

Tools

As you'll see, not all of them are exclusive to TDD. Since a big part of TDD consists of writing tests, many of the best practices presented in the following sections apply to testing in general, while others are related to general coding best practices. No matter the origin, all of them are useful when practicing TDD.

Take the advice with a certain dose of skepticism. Being a great programmer is not only about knowing how to code, but also about being able to decide which practice, framework, or style best suits the project and the team. Being agile is not about following someone else's rules, but about knowing how to adapt to circumstances and choose the best tools and practices that suit the team and the project.

[ 263 ]

Putting It All Together

Chapter 11

Naming conventions

Naming conventions help to organize tests better, so that it is easier for developers to find what they're looking for. Another benefit is that many tools expect that those conventions are followed. There are many naming conventions in use, and those presented here are just a drop in the ocean. The logic is that any naming convention is better than none. Most important is that everyone on the team knows what conventions are being used and are comfortable with them. Choosing more popular conventions has the advantage that newcomers to the team can get up to speed fast, since they can leverage existing knowledge to find their way around.

Separate the implementation from the test code.

Benefits: It avoids accidentally packaging tests together with production binaries; many build tools expect tests to be in a certain source directory.

Common practice is to have at least two source directories. Implementation code should be located in src/main/java and test code in src/test/java. In bigger projects, the number of source directories can increase, but the separation between implementation and tests should remain as is.

Build tools such as Gradle and Maven expect source directory separation as well as naming conventions.

You might have noticed that the build.gradle files that we used throughout this book did not explicitly specify what to test, nor what classes to use to create a .jar file. Gradle assumes that tests are in src/test/java and that the implementation code that should be packaged into a JAR file is in src/main/java.

Place test classes in the same package as implementation.

Benefits: Knowing that tests are in the same package as the code helps you to find code faster.

As stated in the previous practice, even though packages are the same, classes are in separate source directories.

All exercises throughout this book followed this convention.

Name test classes in a similar fashion to the classes they test.

Benefits: Knowing that tests have a similar name to the classes they are testing helps you find the classes faster.

[ 264 ]

Putting It All Together

Chapter 11

One commonly used practice is to name tests the same as the implementation classes, with the suffix Test. If, for example, the implementation class is TickTackToe, the test class should be TickTackToeTest.

However, in all cases, with the exception of those we used throughout the refactoring exercises, we prefer the suffix Spec. It helps to make a clear distinction that test methods are primarily created as a way to specify what will be developed. Testing is a great sub-product of those specifications.

Use descriptive names for test methods.

Benefits: It helps in understanding the objective of tests.

Using method names that describe tests is beneficial when trying to figure out why some tests failed or when the coverage should be increased with more tests. It should be clear what conditions are set before the test, what actions are performed, and what the expected outcome is.

There are many different ways to name test methods, and our preferred method is to name them using the Given/When/Then syntax used in the BDD scenarios. Given describes (pre)conditions, When describes actions, and Then describes the expected outcome. If a test does not have preconditions (usually set using @Before and @BeforeClass annotations), Given can be skipped.

Let's take a look at one of the specifications we created for our Tic-Tac-Toe application:

@Test

public void whenPlayAndWholeHorizontalLineThenWinner() {

ticTacToe.play(1, 1); // X

ticTacToe.play(1, 2); // O

ticTacToe.play(2, 1); // X

ticTacToe.play(2, 2); // O

String actual = ticTacToe.play(3, 1); // X

assertEquals("X is the winner", actual);

}

Just by reading the name of the method, we can understand what it is about. When we play and the whole horizontal or vertical and diagonal line is populated, then we have a winner.

Do not rely only on comments to provide information about the test

objective. Comments do not appear when tests are executed from your

favorite IDE, nor do they appear in reports generated by CI or build tools.

[ 265 ]

Putting It All Together

Chapter 11

Processes

TDD processes are the core set of practices. Successful implementation of TDD depends on practices described in this section.

Write a test before writing the implementation code.

Benefits: It ensures that testable code is written; it ensures that every line of code gets tests written for it.

By writing or modifying the test first, the developer is focused on requirements before starting to work on the implementation code. This is the main difference compared to writing tests after the implementation is done. The additional benefit is that with the tests written first, we are avoiding the danger that the tests work as quality checking (QC) instead of quality assurance (QA). We're trying to ensure that quality is built in, as opposed to checking later whether we met quality objectives.

Only write new code when the test is failing.

Benefits: It confirms that the test does not work without the

implementation.

If tests are passing without the need to write or modify the implementation code, then either the functionality is already implemented or the test is defective. If new functionality is indeed missing, then the test always passes and is therefore useless. Tests should fail for the expected reason. Even though there are no guarantees that the test is verifying the right thing, with fail first and for the expected reason, confidence that verification is correct should be high.

Rerun all tests every time the implementation code changes.

Benefits: It ensures that there are no unexpected side effects caused by code changes.

[ 266 ]

Putting It All Together

Chapter 11

Every time any part of the implementation code changes, all tests should be run. Ideally, tests are fast to execute and can be run by the developer locally. Once code is submitted to version control, all tests should be run again to ensure that there was no problem due to code merges. This is especially important when more than one developer is working on the code. Continuous integration (CI) tools should be used to pull the code from the repository, compile it, and run tests, such as:

Jenkins (https:/â€‹/â€‹jenkins.â€‹io/â€‹)

Hudson (http://hudson-ci.org/)

Travis (https://travis-ci.org/)

Bamboo (https://www.atlassian.com/software/bamboo)

All tests should pass before a new test is written.

Benefits: The focus is maintained on a small unit of work; implementation code is (almost) always in working condition.

It is sometimes tempting to write multiple tests before the actual implementation. In other cases, developers ignore problems detected by existing tests and move towards new features. This should be avoided whenever possible. In most cases, breaking this rule will only introduce technical debt that will need to be paid with interest. One of the goals of TDD is that the implementation code is (almost) always working as expected. Some projects, due to pressures to reach the delivery date or maintain the budget, break this rule and dedicate time to new features, leaving the task of fixing the code associated with failed tests for later. These projects usually end up postponing the inevitable.

Refactor only after all tests are passing.

Benefits: This type of refactoring is safe.

If all implementation code that can be affected has tests and they are all passing, it is relatively safe to refactor. In most cases, there is no need for new tests. Small modifications to existing tests should be enough. The expected outcome of refactoring is to have all tests passing both before and after the code is modified.

[ 267 ]

Putting It All Together

Chapter 11

Development practices

Practices listed in this section are focused on the best way to write tests. Write the simplest code to pass the test as it ensures cleaner and clearer design and avoids unnecessary features.

The idea is that the simpler the implementation, the better and easier it is to maintain the product. The idea adheres to the keep it simple, stupid (KISS) principle. This states that most systems work best if they are kept simple rather than made complex; therefore, simplicity should be a key goal in design, and unnecessary complexity should be avoided.

Write assertions first, act later as it clarifies the purpose of the requirements and tests early.

Once the assertion is written, the purpose of the test is clear and the developer can concentrate on the code that will accomplish that assertion and, later on, on the actual implementation. Minimize assertions in each test as it avoids assertion roulette; it allows the execution of more asserts.

If multiple assertions are used within one test method, it might be hard to tell which of them caused a test failure. This is especially common when tests are executed as part of the CI process. If the problem cannot be reproduced on a developer's machine (as may be the case if the problem is caused by environmental issues), fixing the problem may be difficult and time consuming.

When one assert fails, execution of that test method stops. If there are other asserts in that method, they will not be run and information that can be used in debugging is lost.

Last but not least, having multiple asserts creates confusion about the objective of the test.

This practice does not mean that there should always be only one assert per test method.

If there are other asserts that test the same logical condition or unit of functionality, they can be used within the same method.

[ 268 ]

Putting It All Together

Chapter 11

Let's go through a few examples:

@Test

public final void

whenOneNumberIsUsedThenReturnValueIsThatSameNumber() {

Assert.assertEquals(3, StringCalculator.add("3"));

}

@Test

public final void whenTwoNumbersAreUsedThenReturnValueIsTheirSum()

{

Assert.assertEquals(3+6, StringCalculator.add("3,6"));

}

The preceding code contains two specifications that clearly define what the objective of the tests is. By reading the method names and looking at the assert, there should be clarity on what is being tested. Consider the following example:

@Test

public final void

whenNegativeNumbersAreUsedThenRuntimeExceptionIsThrown() {

RuntimeException exception = null;

try {

StringCalculator.add("3,-6,15,-18,46,33");

} catch (RuntimeException e) {

exception = e;

}

Assert.assertNotNull("Exception was not thrown", exception);

Assert.assertEquals("Negatives not allowed: [-6, -18]",

exception.getMessage());

}

This specification has more than one assert, but they are testing the same logical unit of functionality. The first assert is confirming that the exception exists, and the second that its message is correct. When multiple asserts are used in one test method, they should all contain messages that explain the failure. This way, debugging the failed assert is easier.

In the case of one assert per test method, messages are welcome but not necessary, since it should be clear from the method name what the objective of the test is:

@Test

public final void whenAddIsUsedThenItWorks() {

Assert.assertEquals(0, StringCalculator.add(""));

Assert.assertEquals(3, StringCalculator.add("3"));

Assert.assertEquals(3+6, StringCalculator.add("3,6"));

Assert.assertEquals(3+6+15+18+46+33,

[ 269 ]

Putting It All Together

Chapter 11

StringCalculator.add("3,6,15,18,46,33"));

Assert.assertEquals(3+6+15, StringCalculator.add("3,6n15"));

Assert.assertEquals(3+6+15,

StringCalculator.add("//;n3;6;15"));

Assert.assertEquals(3+1000+6,

StringCalculator.add("3,1000,1001,6,1234"));

}

This test has many asserts. It is unclear what the functionality is, and if one of them fails, it is not known whether the rest would work or not. It might be hard to understand the failure when this test is executed through some CI tools.

Do not introduce dependencies between tests.

Benefits: The tests work in any order independently, whether all or only a subset is run.

Each test should be independent of the others. Developers should be able to execute any individual test, a set of tests, or all of them. Often, due to the test runner's design, there is no guarantee that tests will be executed in any particular order. If there are dependencies between tests, they might easily be broken with the introduction of new ones.

Tests should run fast.

Benefits: These tests are used often.

If it takes a lot of time to run tests, developers will stop using them or run only a small subset related to the changes they are making. The benefit of fast tests, besides fostering their usage, is quick feedback. The sooner the problem is detected, the easier it is to fix it.

Knowledge about the code that produced the problem is still fresh. If the developer already started working on the next feature while waiting for the completion of the execution of the tests, they might decide to postpone fixing the problem until that new feature is developed.

On the other hand, if they drops their current work to fix the bug, time is lost in context switching.

Tests should be so quick that developers can run all of them after each change without getting bored or frustrated.

Use test doubles.

Benefits: This reduces code dependency and test execution will be faster.

[ 270 ]

Putting It All Together

Chapter 11

Mocks are prerequisites for the fast execution of tests and the ability to concentrate on a single unit of functionality. By mocking dependencies external to the method that is being tested, the developer is able to focus on the task at hand without spending time in setting them up. In the case of bigger teams, those dependencies might not even be developed.

Also, the execution of tests without mocks tends to be slow. Good candidates for mocks are databases, other products, services, and so on.

Use setup and teardown methods.

Benefits: This allows setup and teardown code to be executed before and after the class or each method.

In many cases, some code needs to be executed before the test class or before each method in a class. For this purpose, JUnit has @BeforeClass and @Before annotations that should be used as the setup phase. @BeforeClass executes the associated method before the class is loaded (before the first test method is run).

@Before executes the associated method before each test is run. Both should be used when there are certain preconditions required by tests. The most common example is setting up test data in the (hopefully in-memory) database.

At the opposite end are @After and @AfterClass annotations, which should be used as the teardown phase. Their main purpose is to destroy data or a state created during the setup phase or by the tests themselves. As stated in one of the previous practices, each test should be independent from the others. Moreover, no test should be affected by the others.

The teardown phase helps to maintain the system as if no test was previously executed.

Do not use base classes in tests.

Benefits: It provides test clarity.

Developers often approach test code in the same way as implementation. One of the common mistakes is to create base classes that are extended by tests. This practice avoids code duplication at the expense of test clarity. When possible, base classes used for testing should be avoided or limited. Having to navigate from the test class to its parent, to the parent of the parent, and so on in order to understand the logic behind tests often introduces unnecessary confusion. Clarity in tests should be more important than avoiding code duplication.

[ 271 ]

Putting It All Together

Chapter 11

Tools

TDD, coding, and testing in general, are heavily dependent on other tools and processes.

Some of the most important ones are as follows. Each of them is too big a topic to be explored in this book, so they will be described only briefly.

Code coverage and CI.

Benefits: It gives assurance that everything is tested.

Code coverage practices and tools are very valuable in determining that all code, branches, and complexity is tested. Some of these tools are as follows:

JaCoCo (http://www.eclemma.org/jacoco/)

Clover (https://www.atlassian.com/software/clover)

Cobertura (http://cobertura.github.io/cobertura/)

CI tools are a must for all except the most trivial projects. Some of the most used tools are:

Jenkins (https:/â€‹/â€‹jenkins.â€‹io/â€‹)

Hudson (http://hudson-ci.org/)

Travis (https://travis-ci.org/)

Bamboo (https://www.atlassian.com/software/bamboo).

Use TDD together with BDD.

Benefits: Both developer unit tests and functional customer facing tests are covered.

While TDD with unit tests is a great practice, in many cases it does not provide all the testing that projects need. TDD is fast to develop, helps the design process, and gives confidence through fast feedback. On the other hand, BDD is more suitable for integration and functional testing, provides a better process for requirement gathering through narratives, and is a better way of communicating with clients through scenarios. Both should be used, and together they provide a full process that involves all stakeholders and team members. TDD (based on unit tests) and BDD should be driving the development process. Our recommendation is to use TDD for high code coverage and fast feedback, and BDD as automated acceptance tests. While TDD is mostly oriented towards white-box, BDD

often aims at black-box testing. Both TDD and BDD are trying to focus on QA instead of QC.

[ 272 ]

Putting It All Together

Chapter 11

Summary

In this chapter, we first went through a brief overview of TDD. We learned about the four best practices that can help to improve the quality of software.

Moving on to the final chapter, we will be introduced to the concepts of CI and continuous delivery, and the importance of TDD all through the pipeline process will be highlighted with an example.

[ 273 ]

12

Leverage TDD by Implementing

Continuous Delivery

"Nothing speaks like results. If you want to build the kind of credibility that connects with people, then deliver results before you deliver a message. Get out and do what you advise others to do. Communicate from experience."

