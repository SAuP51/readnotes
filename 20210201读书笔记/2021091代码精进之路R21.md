## 记忆时间

## 目录

第二部分 思想

0801 抽象

0901 分治

## 0801. 抽象

若想捉大鱼，就得潜入深渊。深渊里的鱼更有力，也更纯净。硕大而抽象，且非常美丽。

—— 大卫·林奇

### 本章小结

「抽象」作为名词，代表着一种思维方式，它的伟大之处在于可以让我们撇开细枝末节，去把握事物更本质、更一般的特性，从而更有效地对问题域进行分析设计。「抽象」作为动词，代表着一种能力，它是我们理解概念、理清概念之间逻辑关系的基础，也是我们面向对象分析设计所要求的底层能力。

归纳总结，合并同类项是进行抽象活动时最有效的方法。同时，我们也要注意到抽象是有层次性的。当一个概念无法涵盖其外延的时候，我们有必要提升一个抽象层次来减少它的内涵，让其有更大的外延。

建议读者一定要多多培养自己的抽象思维。阅读、写文章，以及逻辑思维训练都是提升抽象思维能力非常好的方式。只要坚持学习和锻炼，你慢慢就能体会到一种不一样的美 —— 抽象之美。

### 8.0

软件行业有一个概念，对其了解越深入，我就越会感叹之前的理解是多么肤浅。在很长一段时间里，对这个概念的一知半解阻碍了我对面向对象技术，甚至是软件架构的深层次理解。

实际上，对这个概念的认知偏差，我并非个例，我接触的工程师中能深入理解这个概念的并不多。能把这个概念和建模、面向对象和软件架构进行融会贯通，并进行问题分析、化繁为简的人就更是凤毛麟角了。

因此，我认为很有必要用一章的篇幅深入介绍这个重要的概念 —— 抽象。

### 8.1 伟大的抽象

没有抽象思维，就没有人类今天灿烂的文明。原始人看到一片满是松树的树林，不会给它们一个名字，而是给每一棵树取一个独特的名字，可能叫「silisiba」。原始人只知道某棵具体的树。

随着意识水平的发展，人类开始将具有相同特征的事物归并到一起，从「silisiba」到「松树」—— 到「树木」—— 到「植物」—— 到「物质」，从具象思维到抽象思维，这个过程人类花了几万年的漫长时间。

赫拉利在《人类简史》中说，「人类之所以成为人类，是因为人类能够想象」。这里的想象，我认为很大程度上是指抽象能力。正是抽象思维帮助人类从具体事物中抽象出各种概念，再用这些概念去构筑种种虚构的故事。这些概念包括经济（例如货币、证券）、文学、艺术和科学等，都是建立在抽象的基础之上的。

### 8.2 到底什么是抽象

抽象和具象是相对应的概念，「抽」就是抽离，「象」就是具象。从字面上理解抽象，就是从具体中抽离出来。英文的抽象 abstract 来自拉丁文 abstractio，它的原意是排除、抽出。

按照维基百科上的解释，抽象是指为了某种目的，对一个概念或一种现象包含的信息进行过滤，移除不相关的信息，只保留与某种最终目的相关的信息。例如，一个「皮质的足球」，我们可以过滤它的质料等信息，得到更一般性的概念，也就是「球」。从另一个角度看，抽象就是简化事物，抓住事物本质的过程。

按照这个定义，「苹果」就是一个抽象，是对「苹果」这个概念的统称，它抹去了单个苹果对象的特征，不管是大的小的、甜的不甜的、红的不红的，都叫作「苹果」。

在绘画流派中，有一种流派叫抽象主义，最著名的抽象派大师就是毕加索，图 8-1 所示是毕加索画的牛。

图 8-1 实物牛和抽象牛的对比

毕加索的画中只有几根线条，却是做了高度抽象之后的线条，过滤了绝大部分水牛的细节，只保留了牛的最主要的一些特征。正因为其抽象层次更高，因此其泛化能力更强，「抽象牛」不仅可以表示水牛，也可以表示黄牛、奶牛、野牦牛…… 只要是牛都逃不过这几根线。可以说，抽象更接近问题的本质。

### 8.3 抽象是 OO 的基础

面向对象（Object Oriented，OO）的思考方式，就是万物皆对象。抽象帮助我们将现实世界的对象抽象成类，完成从现实世界的概念到计算机世界的模型的映射。例如，有一堆苹果，如果对其进行抽象，我们可以得到 Apple 这个类，通过这个类，我们可以实例化一个红色的苹果：new Apple ("red")。此时，如果我们需要把香蕉、橘子等水果也纳入考虑范围，那么 Apple 的抽象层次就不够了，我们需要 Fruit 这个更高层次的抽象来表达「水果」的概念。

面向对象的思想主要包括 3 个方面：面向对象的分析（Object Oriented Analysis，OOA）、面向对象的设计（Object Oriented Design，OOD），以及我们经常提到的面向对象的编程（Object Oriented Programming，OOP）。

OOA 是根据抽象关键问题域来分解系统。OOD 是一种提供符号设计系统的面向对象的实现过程，它用非常接近实际领域术语的方法把系统构造成「现实世界」的抽象。OOP 可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反，传统的程序设计主张将程序看作一系列函数的集合，或者更直接些，就是一系列对计算机下达的指令。

可以看到，抽象贯穿于 OO 的始终，是 OO 的前提和底层能力，抽象能力差的人是很难做好 OO 的。

### 8.4 抽象的层次性

对同一个对象的抽象是有不同层次的。层次越往上，抽象程度越高，它所包含的东西就越多，其含义越宽泛，忽略的细节也越多；层次越往下，抽象程度越低，它所包含的东西越少，细节越多。也就是我们常说的，内涵越小，外延越大；内涵越大，外延越小。不同层次的抽象有不同的用途。

有一次在家，女儿问我：「爸爸你会不会画猫？」我说，「会呀」。然后她又问：「那你会画房子吗？」我说，「也会呀」。她有点失落，然后看看外面问：「那你会不会画城市？」。为了让女儿开心，我跟她说：「城市那么大，爸爸不会画。」她还太小，以为画城市就要把城市的每个细节都画出来，不知道抽象是有层次的。

这种抽象的层次性基本可以体现在任何事物上，以下是对一份报纸在多个层次上的抽象。

第一层：一个出版物。

第二层：一份报纸。

第三层：《旧金山纪事报》。

第四层：5 月 18 日出版的《旧金山纪事报》。

第五层：我拥有的 5 月 18 日出版的《旧金山纪事报》。

如果我要统计美国有多少家出版单位，那么就要用到第一层「出版单位」的抽象。如果我要查询旧金山 5 月 18 日当天的新闻，那么就要用到第五层的抽象。

分层抽象在软件的世界里随处可见，是软件架构的核心，也是我们构建当今信息帝国的基石。有一句名言，「软件领域的任何问题，都可以通过增加一个间接的中间层来解决。」

这种分层在某种意义上也是抽象的分层，每一层的抽象只关注本层相关的信息，对上层屏蔽复杂性，从而简化整个系统的设计。

例如，我们的系统就是分层的。最早的程序直接运行在硬件上，开发成本非常高。然后慢慢开始有了操作系统，操作系统提供了资源管理、进程调度、输入输出等所有程序都需要的基础功能，开发程序时调用操作系统的接口就可以了。再后来发现操作系统也不够用，于是又有了各种运行环境（如 JVM）。

编程语言也是一种分层的抽象。机器理解的其实是机器语言，即各种二进制的指令。但是使用二进制编程效率极低，所以我们用汇编语言抽象了二进制指令，用 C 语言抽象了汇编语言，而高级语言 Java 抽象了低级语言。

很难想象，如果没有抽象分层，人类该如何应对软件世界这么高的复杂度。阿里巴巴的软件系统的复杂度绝对不亚于一个城市，若是没有抽象分层，就像要在一张画布上画出整个城市的细节，从摩天大厦到门把手，从公园到街道上的猫，其画面难以想象……

### 8.5 如何进行抽象

#### 8.5.1 寻找共性

简单来说，抽象的过程就是合并同类项、归并分类和寻找共性的过程。也就是将有内在逻辑关系的事物放在一起，然后给这个分类进行命名，这个名字就代表了这组分类的抽象。

我们的生活中无时无刻不在进行着这样的抽象，语言本身就是对现实世界的抽象符号表达。比如当你说「花」的时候，就使用了抽象概念，它包含了各种各样、万紫千红的花的本性。

在我们写代码的过程中，如果遇到大量重复或者部分重复的代码，往往意味着抽象的缺失，可以通过合并归类来进行优化。

例如，我们在一个应用中大量使用搜索的功能，因为搜索的条件比较复杂，所以系统中充斥着大量的如下所示的代码：

```java
// 取默认搜索条件
List<String> defaultConditions = searchConditionCacheTunnel.getJsonQueryByLabelKey(labelKey);

for (String jsonQuery : defaultConditions) {
    jsonQuery = jsonQuery.replaceAll(SearchConstants.SEARCH_ DEFAULT_PUBLICSEA_ENABLE_TIME, String.valueOf(System.currentTimeMillis() / 1000));
    jsonQueryList.add(jsonQuery);
}

// 取主搜索框的搜索条件
if (StringUtils.isNotEmpty(cmd.getContent())) {
    List<String> jsonValues = searchConditionCacheTunnel.getJsonQueryByLabelKey(SearchConstants.ICBU_SALES_MAIN_SEARCH);
    for (String value : jsonValues) {
        String content = StringUtil.transferQuotation(cmd. getContent());
        value = StringUtil.replaceAll(value, SearchConstants. SEARCH_DEFAULT_MAIN, content);
        jsonQueryList.add(value);
    }
}
```

这样的代码不是出现在一个地方，而是散落在需要搜索查询的地方，总共几十处。随着时间的推移，这样的重复代码可能还会继续增加，如图 8-2 所示。

图 8-2　散落在各处的搜索代码

问题就在于抽象的缺失。首先，对于搜索条件，我们可以用 SearchCondition 这个类进行抽象和封装；其次，对于组装搜索条件的过程，我们可以用 SearchConditionAssembler 类进行抽象。添加这两个抽象之后，我们再对原来的代码进行重构，消除重复后的代码如下所示：

```java
public class SearchConditionAssembler {
    public static SearchCondition assemble(String labelKey) {
        String jsonSearchCondition = getJsonSearchConditionFromCache (labelKey);
        SearchCondition sc = assembleSearchCondition(jsonSearchCondition);
        return sc;
    }
}
```

因此，合并同类项，找到共性，再给这个共性命名的过程就是一个简单的抽象过程。

然而有些时候，发现共性的过程并不像重复代码这么简单直观，需要对问题域有深入理解。例如，如果你不了解 CRM 领域，就很难做出「公海」和「私海」的抽象。有时，可能还需要动用非凡的想象力。

#### 8.5.2 提升抽象层次

当我们发现有些东西无法归到一个类别中时，该怎么办呢？此时，我们可以通过上升一个抽象层次的方式，让它们在更高的抽象层次上产生逻辑关系。

例如，你可以合乎逻辑地将苹果和梨归类为水果，也可以将桌子和椅子归类为家具。但是怎样才能将苹果和椅子放在同一组中呢？仅仅提高一个抽象层次是不够的，因为上一个抽象层次是水果和家具的范畴。因此，你必须提高到更高的抽象层次，比如将其概括为「商品」。

如果我们想把大肠杆菌也纳入其中，该怎么办呢？此时，「商品」这个抽象也不够用了，需要再提高一个抽象层次，比如叫「物质」（见图 8-3）。但是这样的抽象太过于宽泛，难以说明思想之间的逻辑关系。类似于我们在 Java 中的顶层父类对象（Object），万物皆对象。

图 8-3 抽象的层次性示例

在开发工作中，很多时候就需要通过抽象层次的提升来提高代码的可读性和通用性。

举个例子，现在有 Apple 和 Watermelon 两个类，都继承自 Fruit。对于苹果来说，我们认为甜度大于 60 就是好的；对于西瓜，我们认为水分大于 60 就是好的。两个类的代码如下所示。

1、Apple 类：

```java
public class Apple extends Fruit {
    private int sweetDegree;
    public boolean isSweet(){
        return sweetDegree > 60;
    }
}
```

2、Watermelon 类：

```java
public class Watermelon extends Fruit {
    private int waterDegree;
    public boolean isJuicy(){
        return waterDegree > 60;
    }
}
```

此时，我们需要把好的水果挑出来，不难写出一个 FruitPicker（挑选水果的类），其代码如下：

```java
public class FruitPicker {
    public List<Fruit> pickGood(List<Fruit> fruits){
        return fruits.stream().filter(e -> check(e)).collect(Collectors.toList());
    }

    private boolean check(Fruit e) {
        if (e instanceof Apple) {
            if(((Apple) e).isSweet()) {
                return true;
            }
        }

        if (e instanceof Watermelon) {
            if (((Watermelon) e).isJuicy()) {
                return true;
            }
        }
        return false;
    }
}
```

这里的代码有个问题，就是 instanceof 的使用。为了判断苹果和西瓜是否好，我们需要借用 instanceof 获得具体的对象才能完成。

面对这种情况，可以考虑是否要做抽象层次的提升。进一步考查，我们会发现，不管是 Apple 的 isSweet()，还是 Watermelon 的 isJuicy()，本质上都是在判断水果是否可口。因此，我们完全可以在 Fruit 上定义一个 isTasty()，如图 8-4 所示。

图 8-4 提升抽象层次示例

通过提升抽象层次，我们有了新的 Fruit 类：

```java
public abstract class Fruit {
    // 提升抽象层次，需要一个新方法来表达这个抽象
    public abstract boolean isTasty();
}
```

再回头看一下 FruitPicker，已经不再需要 instanceof 来做辅助判断了：

```java
public class FruitPicker {
    public List<Fruit> pickGood(List<Fruit> fruits) {
        return fruits.stream().filter(e -> check(e)).collect(Collectors.toList());
    }
    // 不再需要 instanceof
    private boolean check(Fruit e) {
        return e.isTasty();
    }
}
```

通过上面的示例可以看到，提升了抽象层次的代码的通用性也随之提升，程序更好地满足了 LSP（里式替换原则）。因此，每当我们有强制类型转换，或者使用 instanceof 时，都值得停下来思考一下，是否需要做抽象层次的提升。

#### 8.5.3 构筑金字塔

《金字塔原理》是一本教人如何进行结构化思考和表达的书，核心思想是通过归类分组搭建金字塔结构，这是一种非常有用的思维框架，让我们更加全面地思考，在表达观点时更加清晰。

书中提到，要自下而上地思考，总结概括；自上而下地表达，结论先行。其中，自下而上总结概括的过程就是抽象的过程，构建金字塔的过程就是寻找逻辑关系、抽象概括的过程。经常锻炼用结构化的方式去处理问题，搭建自己的金字塔，可以帮助我们理清问题的脉络，提升抽象能力。

金字塔结构让我们通过抽象概括将混乱无序的信息形成不同的抽象层次，从而便于理解和记忆，这是一个非常实用的方法论。

举个例子，你要出门买报纸，你妻子让你带点东西回来并列了一个清单，里面有葡萄、橘子、咸鸭蛋、土豆、鸡蛋、牛奶和胡萝卜。当你准备出门时，你妻子说，「顺便再带点苹果和酸奶吧」。

如果不用纸笔写下来，你还能记住妻子让你买的 9 样东西吗？大部分人应该都不能，因为我们的大脑短期记忆无法一次容纳 7 个以上的记忆项目并超过 5 个小时，我们就会开始将其归类到不同的逻辑范畴，以便记忆。

对于葡萄、橘子、牛奶、咸鸭蛋、土豆、鸡蛋、胡萝卜、苹果和酸奶，我们可以按照逻辑关系进行分类，搭建一个金字塔结构，如图 8-5 所示。

图 8-5 金字塔结构示例

分类的作用不只是将一组中的 9 个概念分成每组各有 4 个、3 个和 2 个概念的 3 组概念，因为这样还是 9 个概念。你所要做的是提高一个抽象层次，将大脑需要处理的 9 个概念变成 3 个概念。

这样，你无须再记忆 9 个概念中的每一个概念，仅需记忆 9 个概念所属的 3 个组。思维的抽象程度提高了一层，由于处于较高层次的思想总是能够提示其下面一个层次的思想，因而更容易理解和记忆。

### 8.6 如何提升抽象思维

讲了这么多关于抽象的概念，抽象思维又是如此重要。那有没有办法来锻炼和提升我们的抽象思维呢？

当然有，抽象思维也是可以习得的。婴幼儿没有抽象思维，你和他玩躲猫猫游戏，把他的眼睛蒙上，他就以为你消失了，再放开，他看到你就会很高兴。因为他只能意识到你这个具象的人，意识还到不了抽象的程度。理解具象的内容要更加简单容易，而理解抽象内容则要困难和复杂很多。

#### 8.6.1 多阅读

为什么阅读书籍比看电视更好呢？因为图像比文字更加具象，阅读的过程可以锻炼我们的抽象能力、想象能力，而看画面时你的大脑会被铺满，较少需要抽象和想象。

这也是我们不提倡小孩子过多地看电视或玩手机的原因，因为不利于锻炼其抽象思维。

抽象思维的差别使孩子们的学习成绩从初中开始分化，许多不能适应这种抽象层面训练的孩子可能选择去读职业技校，因为这里比大学更加具象 —— 车铣刨磨、零件部件等都是能够看得到、摸得到的。

#### 8.6.2 多总结

小时候，我们可能不理解语文老师为什么总是要求我们总结段落大意、中心思想。现在回想起来，这种思维训练在基础教育中是非常必要的，其实质就是帮助学生提升抽象思维的能力。

做总结最好的方式就是写文章，小到博文，大到一本书，都是锻炼自己抽象思维和结构化思维的机会。记录也是很好的总结习惯。以读书笔记来说，最好不要原文摘录书中的内容，而是要用自己的话总结归纳，这样不仅可以加深理解，还可以提升自己的抽象思维能力。

现实世界纷繁复杂，只有具备较强的抽象思维能力的人，才能够具备抓住事物本质的能力。

#### 8.6.3 领域建模训练

对于技术人员来说，还有一个非常好的提升抽象能力的手段 —— 领域建模。当我们对问题域进行分析、整理和抽象时，或对领域进行划分和建模时，实际上都是在锻炼我们的抽象能力。

关于这一点，我深有感触。当开始使用第 6 章中介绍的建模方法论进行建模时，我会觉得无从下手，建出来的模型也很别扭。然而，经过几次锻炼之后，我很明显地感觉到自己的建模能力和抽象能力有所提升，不但分析问题的速度更快了，而且建出来的模型也更优雅了。

## 0901. 分治

要把大象装冰箱，拢共分几步？

—— 小品《钟点工》

### 本章小结

软件产业正在变得越来越庞大和复杂，互联网正在变得越来越激进。我们在同一时间能够关注和处理的信息有限，所以学会分治思想很重要。学会如何对复杂问题进行分层和拆解，是我们解决复杂问题的第一步。本章只介绍了分治思想在软件领域中的一些应用，而实际应用场景要广泛得多，不仅限于软件领域。

### 9.0

分治和抽象一样，都是人类进化过程中形成的伟大智慧，也是我们解决复杂问题的不二选择。人的思维要从一个字节大幅跨越到几百兆字节，也就是 9 个数量级（现阶段，后面还要再加 N 个零）。如此复杂的问题域，如果不进行分治，是远远超出人类智力范围的。

分治的价值在于，我们不应该试着在同一时间把整个问题域都塞进自己的大脑，而应该试着以某种方式去组织问题，以便在一个时刻专注于一个特定的部分。这样做的目的是尽量降低在任意时间所要思考问题的复杂度。

本章将介绍分治思想在软件领域的一些典型应用，以此加深我们对分治的理解和认知，让分治的理念融入我们的潜意识中，使我们在开发工作中灵活地使用分层、分场景和分步骤等解决办法，化解软件设计中的复杂问题，从而写出可读性更好的代码，开发出可维护性、可扩展性更好的系统。

### 9.1 分治算法

我记得在学校上算法课时，老师介绍的第一个算法思想就是分治算法，这是一种高效、简洁、优美的算法思想。分治算法主要包含两个步骤 —— 分、治。「分」就是递归地将原问题分解成小问题；「治」则是在解决了各个小问题（各个击破）之后合并小问题的解，从而得到整个问题的解。

分治法解题的一般步骤如下。

1、分解：将要解决的问题划分成若干规模较小的同类问题。

2、求解：当子问题划分得足够小时，用较简单的方法解决。

3、合并：按原问题的要求，将子问题的解逐层合并，构成原问题的解。

#### 9.1.1 归并排序

分治算法一般都可以写成一个递归表达式。例如，经典的归并排序的递归表达式 T(N)=2T(N/2)+O(N)，T(N) 代表整个原问题，采用了分治解决方案后，它可以表示成如下形式。

1、分解成规模只有原来一半（N/2）的两个子问题：T(N/2)。

2、解决了这两个子问题 T(N/2) 之后，再合并这两个子问题，需要的代价是 O(N)。

归并排序的求解过程如图 9-1 所示。

图 9-1 归并排序的求解过程

#### 9.1.2　二分搜索

二分搜索又称为二分查找、折半查找，是一种效率较高的查找方法。比如，数据库中的索引查找方式（哈希索引除外）就是一种二分、三分或者多分查找的算法，分的多少和索引的数据结构相关。

二分搜索要求线性表为有序表，并且要用向量作为表的存储结构。二分搜索的基本思想是先确定待查找记录所在的范围，然后逐步缩小范围，直至找到或找不到该记录位置。

二分查找的步骤如下。

1、先确定中间位置：middle = (left+right)/2。

2、将待查找的 key 值与 data[middle].key 值相比较。若相等，则查找成功并返回该位置；否则，需要确定新的查找区间，继续二分查找，具体方法如下。

如果 data[middle].key 大于 key，由于 data 为有序线性表，可知 data [middle…right].key 均大于 key，因此若表中存在关键字等于 key 的节点，则一定在位置 middle 左边的子表中。

反之，data[middle].key 小于 key，因此若表中存在关键字等于 key 的节点，则一定在位置 middle 右边的子表中，下一次针对新的区域进行查找。

二分查找的 Java 代码实现如下：

```java
public staticvoidmain(String[]args) {
    int[] a = {1,2,3,4,5,6,7,8,9};
    intpos = bSearch(a, 0, a.length-1, 1);
    System.out.println(pos);
}

public staticintbSearch(int[]data,intleft,intright,intkey) {
    // 获取中间位置
    intmiddle = (left+right) / 2;
    // 比较 key 值如相等，返回当前位置，否则确认新的查找空间
    if (data[middle] == key) {
        return middle;
    }
    elseif (data[middle] > key) {
        return bSearch(data, left, middle-1, key);
    }
    else {
        return bSearch(data, middle+1, right, key);
    }
}
```

#### 9.1.3　K 选择问题

K 选择问题是指，给出 N 个数，找出其中第 K 小的元素。如果直接用穷举法，一共需要比较 K×N 次，当 K 与 N 有关时，比如 K 是中位数（K=N/2），那么时间复杂度为 O(N2)；采用分治，则可把复杂度降低为 O(N)。

首先，在 N 个数中选出一个枢轴元素，将比枢轴元素大的元素放到枢轴元素的右边，将比枢轴元素小的元素放到枢轴元素的左边。这样，N 个数被分成了两部分，比枢轴大一部分记为 S(1)，比枢轴小的部分记为 S(2)，这就是分治的「分」。

假设一种理想的情况，枢轴元素基本位于中间值，即它总是将原数组划分成两个大小基本相等的子数组 S(1) 和 S(2)。

要求解第 K 小的元素，有以下 3 种情况。

1、若 K < |S(1)|，则说明第 K 小的元素位于 S(1) 子数组中。其中，|S(1)| 表示 S(1) 数组中元素的个数。

2、若 K == |S(1)| + 1，则说明第 K小的元素刚好是枢轴元素。

3、否则，第 K 小的元素位于 S(2) 子数组中。

如果是情况 1 或者情况 2，可以继续递归分解子数组。分解问题之后，将 N

个元素分成了两个 N/2 个元素的子数组，只需要在其中一个子数组中进行查找即可，使用穷举查找，复杂度为 O(N/2)。

递归表达式为 T(N) = T(N/2) + O(N/2)，解为 O(N)，这说明采用分治算法可以将 K 选择问题的时间复杂度降低为 O(N)。

### 9.2 函数分解

函数过大过长是典型的代码「坏味道」，意味着这个函数可能承载着过多的职责，我们有必要「分治」一下，将大函数分解成多个短小、易读、易维护的小函数。第 3 章中已经介绍了大量函数分解的技艺。关于函数分解，在此强调以下两点。

1、函数长短是职责单一的充分不必要条件，也就是长函数往往意味着职责不单一，但是短函数也不一定就意味着职责单一。

2、在使用组合函数模式时，要注意抽象层次一致性原则（Single Level of Abstration Principle，SLAP），不同抽象层次的内容放在一起会给人凌乱、逻辑不协调的感觉。

### 9.3 写代码的两次创造

本书一直在强调，我们不仅要写实现功能的代码，还要写容易理解的好代码。「写出好代码」除了需要好的技艺之外，还要有好的方法论。以我的实践经验来看，优雅的代码很少是一次成形的，大部分情况下要经过两次创造：第一遍实现功能，第二遍重构优化。

#### 9.3.1 第一遍实现功能

不要试图一次就写出「完美的」代码，这样只会拖慢我们的节奏。就像写文章，第一遍可以写得粗糙一点，把大概意思写出来，然后再仔细打磨，斟酌推敲，直到达到理想的样子。

写代码也是如此，第一遍以实现功能为主，可以允许一定的冗长和复杂，比如有过多的缩进和嵌套循环，有过长的参数列表，名称可以随意取，还会有部分的重复代码。第一遍主要是为了理清逻辑，为第二遍的重构优化做好准备。

#### 9.3.2 第二遍重构优化

如果只是止步于功能实现，那么代码最多只是一个半成品。而实际情况是我们的代码库中有太多这样的半成品，导致系统的复杂度不断攀升，越来越难维护。因此，我们需要有第二次创造 —— 重构优化，即在第一遍实现功能的基础上，看一看是否可以做得更好：命名合理吗？职责单一吗？满足 OCP 吗？函数是否过长？抽象是否合理？

第二次创造通常要比第一次创造更费精力、更耗时间，所以很少有人愿意去做第二遍的事情。比如，要你回答 2 加 2 等于几，你凭直觉就知道是 4，但是如果把问题换成 37×189，你可能都懒得去算，在心里想没事费这劲干嘛。这也是康纳曼·丹尼尔在《快思慢想》一书中提出的重要理论：系统一（感性）和系统二（理性）。动用系统二会耗费能量，而人类是从贫瘠的远古时代进化而来的，为了保存能量，一般默认的是使用系统一思考，不到万不得已，是不会启动系统二的。

因此，最好的优化肯定不是等系统上线后再去做，因为这样往往就等于「再也不会去做」（later equals never）。优化工作本应该是我们编码工作的一部分，拆成两步，主要对编码效率上的考量。

### 9.4 分治模式

很多的设计模式都用到了分治的思想。例如，第 5 章中介绍的管道模式，以及没有详细介绍的责任链模式和装饰者模式，其中都有分治的思想。就责任链模式来说，我们不会把处理一件事情需要的所有职责都放在一个组件中，而是放在多个组件中完成，形成一个链条。这样不仅增加了可扩展性，也使每个组件的职责变得更加单一，更容易维护。

以我曾做过的一个服务机器人项目为例，机器人的应答内容会根据页面、场景、类目、租户的不同而展现出不同的内容。从优先级上来说，租户 Handler 的优先级最低，也就是如果前面的 Handler 都没有命中，那么租户 Handler 可以用来兜底，如图 9-2 所示。这种情况下，使用责任链的分治策略是一种比较好的选择。

图 9-2 服务机器人响应请求的责任链

### 9.5 分层设计

分层设计是架构体系设计中最常见和重要的一种结构。分层设计最大的好处是分离关注（Separation of concerns），这样我们就可以通过分层隔离简化一个复杂的问题，让每一层只对上一层负责，从而使每一层的职责变得相对简单。

#### 9.5.1 分层网络模型

网络通信是互联网最重要的基础实施之一，它是一个很复杂的过程，包括 TCP 协议 —— 在不可靠的网络上出现状况要怎么办，IP 协议 —— 把数据包传给谁。需要处理的事情有很多，我们可不可以在一个层次中都处理掉呢？当然是可以的，但显然不科学。因此，ISO 制定了网络通信的七层参考模型，每一层只处理一件事情，低层为上层提供服务，直到应用层把 HTTP 和 FTP 等方便理解和使用的协议暴露给用户。

但是，我们实际在 Internet 中使用的并不是七层模型，而是 TCP/IP 四层模型，如图 9-3 所示。因为七层参考模型过于理想化，过多的分层反而降低了效率，让问题变得更复杂。这里就涉及另一个问题：分层是不是越多越好？当然不是，分层有很多好处，但也有代价。在处理复杂问题时，不能不进行分层，但只分有必要的层。

图 9-3 七层模型和四层模型

#### 9.5.2 分层架构

分层架构的目的是通过分离关注点来降低系统的复杂度，同时满足单一职责、高内聚、低耦合、提高可复用性和降低维护成本，也是一种典型的分治思想。

在分层架构中，分层的使用可以进行严格地限制 —— 分层只知道直接的下层；或者可以宽松一些 —— 分层可以访问它之下的任何分层。Martin Fowler 的经验是在实际中使用第二种方式会更好，我的经验也可以验证这个说法，因为它避免了在中间分层创建代码方法（或者完整的代理类），也避免了退化成千层面的反模式。

有时分层会安排领域层将数据源完全隐藏，不让展现层看到。但是更多时候，展现层会直接访问数据存储，这虽然不那么纯粹，但实际却工作得更好。

这种灵活的分层机制实际上是一种开放的分层架构，如图 9-4 所示。这种不教条和 12.2.2 节中介绍的 CQRS 有着类似的作用，即领域层是可选的，允许应用层绕过领域层直接和基础设施层进行通信。关于架构的更多内容，将在第 12 章详细讨论。

图 9-4 开放的分层架构

### 9.6 横切和竖切

随着互联网的发展，用户流量呈指数型增长，单体应用已经不能适应发展的需要，分布式架构正在变得越来越重要。如果你经常参加一些技术峰会，可以看到这样的分享：一个小企业从一台应用服务器、一个数据库慢慢壮大，发展成独角兽公司，其架构也随之演变成一个大型分布式系统。

这不是偶然，而是企业架构演化的必然结果，因为只有分治才能应对网络高并发，实现水平扩展。

以分布式数据库为例，我们把原来放在一个数据库中的几千亿数据通过竖切、横切（水平拆分和垂直拆分），切分成相对较小的几十个乃至几千个小数据库，以便满足性能和可用性的要求。所谓竖切，就是按照领域将单体数据库拆分成多个数据库。比如，原来电商数据都是放在一个库中，我们可以按照领域拆分成商品库、会员库、交易库等，如图 9-5 所示。

图 9-5 数据库竖切

横切是通过一种数据路由算法对数据进行分片，从而减少一个数据库中的数据量。比如，我们要将会员的交易数据切分成 10 个库，可以用 userId 对 10 进行取模，如图 9-6 所示，这种水平扩展能力在理论上来说提供了无限扩展的可能。

图 9-6 数据库横切
