## 记忆时间

## 卡片

### 0101. 主题卡 —— IPython 内魔法命令汇总

信息源自「2021020Useful-IPython-Magic-Commands.md」

查看所有的魔法命令：

To see all available magic commands, run %lsmagic.

To access documentation for all commands, either check the documentation page or run %magic.

To access documentation of a magic command, you can run the magic command followed by ?. For example: %load?.

Lastly, try running the following one liner in your Jupyter Notebook:

```py
%config MagicsManager
```

If you get the same output, even if we don't write % or %% at the beginning of a magic command, it will still be recognised. For instance, if you try running the following syntax, you will see the same output as before:

```
config MagicsManager
```

While I think it is a convenient feature, writing the prefix makes the code more readable as it's easy to tell it's a magic command by the prefix.

2『文中几个比较常用的魔法命令，做一张主题卡片。（2021-04-23）』—— 已完成

1、载入代码片段。

For most data science projects, you may find yourself importing the same set of libraries over and over again across different notebooks. To make this process quicker, we can prepare a standard setup script for a Jupyter Notebook and import this script at the beginning of each notebook to reduce the repetitive typing. Let's look at an example to illustrate what we mean by this.

Imagine that we are working in magic_commands.ipynb that is located in project1 folder and setup.py contained the following setup script:

```py
# Contents in setup.py
# Data manipulation
import numpy as np
import pandas as pd
pd.options.display.max_columns = None
pd.options.display.float_format = '{:.2f}'.format
# Visualisation
import matplotlib.pyplot as plt
import seaborn as sns
sns.set(style='whitegrid', context='talk', palette='rainbow')
```

We could import the contents in setup.py with the following one liner without leaving the notebook:

```
%load setup.py
```

As we can see from this example, when we run the command, it inserts the code from setup.py and comments itself. Since standard imports can be used across most projects, you may prefer to save the script in Desktop (the parent directory) and have a project specific setup in the project folder only when needed (for instance, NLP projects will need additional set of imports).

Before we move on to the next command, it's worth mentioning that while importing code from `.py` file is common, you can also import content from other files such as `.txt `and `.md`. In addition, you can also import code from URL like this:

1『补充：1）自己的 Mac 上应该改成 `%load ../setup.py`。2）只要是纯文本，应该都可以直接载入。（2021-02-20）』

```
%load 
https://gist.githubusercontent.com/zluvsand/74a6d88e401c4e3f76c2ae783a18689b/raw/5c9fd80a7bed839ba555bf4636e47572bd5c7e6d/pickle.py
```

2、写代码进文件。

```py
%%writefile ./setup.py
# Data manipulation
import numpy as np
import pandas as pd
pd.options.display.max_columns = None
pd.options.display.float_format = '{:.2f}'.format
# Visualisation
import matplotlib.pyplot as plt
import seaborn as sns
sns.set(style='whitegrid', context='talk', palette='rainbow')
```

This will create a setup.py file if doesn't exist. Otherwise, it will overwrite the contents in the existing file.

1『直接在 jupyter notebook 里敲上面的代码。（2021-04-23）』

3、测试代码的运行时长。

There are often multiple ways to accomplish the same task. One important consideration when choosing between the options is speed. Or sometimes you just want to time your code to understand its performance. Whatever your use case might be, it's useful to know how to time your code. Fortunately, timing code is easy with `%[%]timeit`.

Firstly, we will prepare some dummy data:

```py
import numpy as np
np.random.seed(seed=123)
numbers = np.random.randint(100, size=1000000)
```

Let's imagine we wanted to time this code: mean = np.mean(numbers). We can do so with the following one liner:

```py
%timeit mean = np.mean(numbers)
```

Output shows mean and standard deviation of the speed across multiple runs & loops. This is more rigorous way to time your code compared to timing based on a single run.

Now let's understand the difference between `%timeit` and `%%timeit` (the following guideline is true for most line and cell magic commands):

1 To use `%timeit`, a line magic command, the code you want to time should consist of a single line and be written in the same line following the magic command. Although this is a good general rule, multiple lines is possible with tweaks according to the documentation (see documentation for details).

[Built-in magic commands — IPython 7.22.0 documentation](https://ipython.readthedocs.io/en/stable/interactive/magics.html#magic-timeit)

2 To use `%%timeit`, a cell magic command, the code you want to time can consist of any number of lines and written in the next line(s) following the magic command.

Here's the equivalent of the previous code using `%%timeit`:

```py
%%timeit

mean = np.mean(numbers)
```

It's likely that the code you want to time will consist of multiple lines, in which case `%%timeit` will come in handy.

Here's a quick quiz to test your understanding. What do you think is the difference between the outputs of the following two cells? Try to think of the answer before proceeding.

```py
##### Cell A start #####
%timeit mean = np.mean(numbers)
np.mean(numbers)
##### Cell A end #####
##### Cell B start #####
%%timeit 
mean = np.mean(numbers)
np.mean(numbers)
##### Cell B start #####
```

Here comes the answer. In cell A, first we time the first line of code: mean = np.mean(numbers) then we find the average whereas in cell B, we time two lines of code:

You can see that cell B's mean speed is about twice as cell A's. This makes sense because we are essentially timing the same code twice (one with assignment and one without assignment) in cell B.

`%[%]timeit` automatically adjusts the number of loops depending on how long it takes to execute the code. This means that the longer the runtime, the less number of repetitions and vice versa so that it will always take about the same amount of time to time regardless of the complexity of the code. However, you can control the number of runs and loops by tweaking the optional arguments. Here's an example:

```py
%timeit -n500 -r5 np.mean(numbers)
```


### 0201. 术语卡 ——

根据反常识，再补充三个证据——就产生三张术语卡。

### 0202. 术语卡 ——

### 0203. 术语卡 ——

### 0301. 人名卡 ——

根据这些证据和案例，找出源头和提出术语的人是谁——产生一张人名卡，并且分析他为什么牛，有哪些作品，生平经历是什么。

### 0401. 金句卡 —— Closed for modification means that the result of extending the behavior of existing modules shouldn't force you to make changes in the modules depending on it

信息源自「20210317Five-Problems-Faced-When-Using-SOLID-Design-Principles.md」

Open-Closed Principle (OCP)

Each module should be opened for extension but closed for modification

Open for an extension means that adding new features to the application could be done only by providing new modules.

Closed for modification means that the result of extending the behavior of existing modules shouldn't force you to make changes in the modules depending on it.

1『原文中上面这段话高亮显示的，做一张金句卡片。（2021-04-23）』—— 已完成

### 0501. 行动卡 ——

行动卡是能够指导自己的行动的卡。

### 0601. 数据信息卡 ——

### 0701. 任意卡 ——

最后还有一张任意卡，记录个人阅读感想。

