## 记忆时间

## 目录

0201多久进行一次代码评审最合适.md

0203熊节什么代码应该被重构.md

## 0201多久进行一次代码评审最合适.md

### 总结时刻

今天的加餐我们讨论了代码评审。对于很多人来说，代码评审只是一个发现问题的过程，而通过今天的讨论，我们知道了代码评审是一个沟通反馈的过程。站在沟通反馈的角度，我们关注的是，尽可能多地暴露问题，尽可能多地做代码评审。代码评审可以从实现方案正确性、算法正确性和代码坏味道的角度去发现问题。代码评审的频率是越高越好，频率越高，发现和解决问题的难度越低，团队越容易坚持下去。

如果把代码评审推向极致就是随时随地做代码评审，这个实践就是结对编程。如果今天的内容你只能记住一件事，那请记住：代码评审暴露的问题越多越好，频率越高越好。

### 1.0

前面我们讲了很多代码的坏味道，我们的关注点都在代码本身上。知道了什么样的代码是坏味道，有了具体的评判标准。那么，该如何去运用坏味道这把「尺子」呢？

有一个发现坏味道的实践，就是代码评审，也就是很多人熟悉的 Code Review，Wikipedia 上定义是这样的：

代码评审，是指对计算机源代码系统化地审查，常用软件同行评审的方式进行，其目的是在找出及修正在软件开发初期未发现的错误，提升软件质量及开发者的技术。

大多数程序员都经历过代码评审，也都能够初步理解代码评审本身存在的价值，这也是差不多全行业都认为有价值的一个实践。只不过，每个团队在代码评审的实践差别还挺大的，有的团队是在一个完整的开发周期结束之后，做一次代码评审；有的是安排每周的代码评审；有的则是每天都要做代码评审。之所以会有这样的差异，主要就是团队对于代码评审本身的理解有差异。

所以，这一讲我们就来谈谈，到底应该如何理解代码评审。

### 1.1 代码评审是一个沟通反馈的过程

关于代码评审，第一个问题就是，为什么要做代码评审？

这个问题其实比较简单，没有人能够保证自己写出来的代码是没有问题的，而规避个体问题的主要方式就是使用集体智慧，也就是团队的力量。这个答案是从个体的角度在看问题，其实，看待代码评审还有一个团队视角，代码评审的过程，也是一个知识分享的过程，保证一些细节的知识不再是隐藏在某一个人的头脑中，而是放置到了团队的层面。

不过，无论是从哪个角度看代码评审，它的本质，就是沟通反馈的过程。我把我对这段代码的理解分享给你，你把你对这段代码的想法共享给我。有人给出代码实现的知识，有人贡献出对技术的理解。

如果我们理解了代码评审是一个沟通反馈的过程，那就可以把沟通反馈的一些原则运用到代码评审中。我在《10x 程序员工作法》里，花了一个模块的篇幅讲了沟通反馈，我们希望沟通要尽可能透明，尽可能及时。把这样的理解放到代码评审中，就是要尽可能多暴露问题，尽可能多做代码评审。

### 1.2 暴露问题

我们先来说暴露问题。代码评审就是一个发现问题的过程，这是一个大家都能理解的事情。但问题就在于，要发现什么问题？

如果泛泛地回答，那自然就是代码实现中的各种问题。然而，这个答案还可以细化一下，做代码评审时，我们可以从下面几个角度来看代码：1）实现方案的正确性；2）算法的正确性；3）代码的坏味道。

我们一个一个来看，先来说实现方案。理论上说，实现方案应该是设计评审中关注的内容，但在实际工作中，并不是所有团队都能够很好地执行设计评审，而且设计评审有时也关注不到特别细的点，所以，一些实现方案的问题只有在代码评审中才能发现。

在一次代码评审中，我看到一个批量处理的 REST 接口，接到请求经过一些处理之后，它会调用另外一个服务，因为这个服务只支持单一的请求，所以，REST 接口只能一个一个地向这个服务发送请求。

如果一切正常的话，这个接口是没有问题的。但是，如果在处理过程中出现失败，没有把所有的请求发给另一个服务，这个接口的行为是什么样呢？是需要客户端重新发起请求，还是服务端本身重新调用接口？如果是服务端负责重试，那么，这个方案本身没有任何重试的机制，也就是说，一个请求一旦出错，它就丢了，业务不能顺利地完成。

当我把这个问题抛了出来时，同事一下子愣住了。显然，他只考虑了正常的情况，而没有考虑出现失败的情况。把它做成一个完整的方案，很可能还需要做一个后台服务，负责替未能得到有效处理的任务善后，显然，这就不是代码调整，而是整个方案的调整。

这是很多程序员，尤其是经验比较少的程序员写程序经常会出现的问题：正常情况一切顺利，异常情况却考虑不足。

我们再来说说算法正确性。

别看整个行业都十分重视算法，但那是在面试的过程中。真正到了实际工作里，算法复杂度常常被人忽略。

我们之前讲过嵌套的代码，对于循环语句，我们要把处理一个元素的代码提取出来。不过，这有时候也会带来一些意想不到的问题。

有一次代码评审，我看到了一段写得很干净的代码，就是把循环里对于一个元素的处理拆了出去。还没等我来赞美这段代码写得好，我就看到了单个元素处理的代码，每次都要查询一次数据库，找出相应的元素，做修改之后再存回去。

就这样，单独看每段代码都是对的，但合在一起就出了问题，本来可以通过一次查询解决的问题变成了 N 次查询。

我再给你讲一个让我印象深刻的故事。在我职业生涯的初期，我做过一段时间图像识别的工作。有一次，一个实习生说自己的代码太慢了，让我帮忙看看。

从表面上看，代码写得还不错，不是一眼能够看出问题。仔细看了半天，我在一个遍历图像像素点的循环里发现了一个图像复制的代码，也就是说，每循环一次，都要把整个图像复制一遍，代码慢就在所难免了。

我相信，如果这是一个算法练习，这两个同事都能够有效地解决这个问题，但放在工程里，就难免挂一漏万了。所以，算法正确性也是我们要在代码评审中关注的。

无论是实现方案的正确性，还是算法的正确性，对于大多数团队来说，都会关注到。但代码坏味道却是很多团队容易忽略的，这里面的关键点就是很多团队对于坏味道的标准太低了。

在这个专栏里，我讲了很多坏味道，有一些是你早就认同的，有一些则在挑战你的认知。也正是因为有这些挑战你认知的部分，所以很多代码即便经过评审，也依然会产生很多问题。关于坏味道，我们整个专栏都在说，更多的细节我就不在这里讨论了。

### 1.3 及时评审

说完代码评审中要暴露的问题，我们再来说说代码评审的另外一个方面，代码评审的频率。

不同的团队代码评审，频率是不一样的，最糟糕的肯定是不评审，整个团队闭着眼睛向前冲，这就不是我们关心的范畴。常见的评审频率是每个迭代评审一次，也有每周评审的。

我对评审的建议是，提升评审的频率，比如，每天评审一次。

评审周期过长是有问题的，周期过长，累积的问题就会增多，造成的结果就是太多问题让人产生无力感。如果遇到实现方案存在问题，要改动的代码就太多了，甚至会影响到项目的发布。

而提升评审的频率，评审的周期就会缩短，每个周期内写出来的代码就是有限的，人是有心力去修改的。学过我任何一个专栏的同学都知道，我在专栏中反复强调短小的价值，只有及时的沟通反馈，才有可能实现这一原则。

你或许会好奇，我们是不是可以再进一步提升评审的频率呢？

肯定可以，如果把代码评审推至极致，就是有个人随时随地来做代码评审。我在《10x 程序员工作法》讲过极限编程的理念，就是把好的实现推向极致，而代码评审的极致实践就是结对编程。

结对编程就是两个人一起写一段代码，一个人主要负责写，一个人则站在用外部视角保证这段代码的正确性。好的结对编程对两个人的精力集中度要求是很高的，两个人一起写一天代码其实是很累的一件事，不过，也正是因为代码是两个人一起写，代码质量会提高很多。

从我之前经历的一些团队实践来看，结对编程还有一个额外的好处，就是对于团队中的新人提升极大，这就是拜结对编程这种高强度的训练和反馈所赐。高强度的训练和反馈，本质上就是一种刻意练习，而刻意练习是一个人提升最有效的方式。

我知道，对于大多数团队来说，是没有条件做大规模的结对编程的。但对个体来说，创造一些机会与高手一起写代码也是很好的。即便不能一起写，去观摩高手写代码也能学到很多东西。再退一步，实在身边没有机会，去网上看看高手写代码也是一种学习方式。

### 黑板墙

思考题：你在代码评审上有哪些经验，或者遇到过哪些让你印象深刻的问题代码，欢迎在留言区分享你的经验。

原文： 把循环里对于一个元素的处理拆了出去。还没等我来赞美这段代码写得好，我就看到了单个元素处理的代码，每次都要查询一次数据库，找出相应的元素，做修改之后再存回去。

结论，我认为这个每次查一次数据库没问题。决策依据：1）这样的单行操作更易理解。2）批查询可能伴随大事物（毕竟你是更新动作，可能要锁「悲观或乐观」所有数据行）。3）如果更新操作不需要锁数据行，也就是数据行的变更对更新操作的正确性无影响。那么通过加缓存会是更好的解决方案。综上所述，保证业务逻辑简单是第一原则。2021-02-01

老师，您说的太对了。因为一个敏捷教练，小波带领我们做了很多。例如：工程实践、每天 code review、结对编程。团队也已经这样运作了奖金一年。好处多多，老师您都说了。但是最近碰到一些问题：因为我们技术们，尽管没有的 Leader，但大家都执行的不错。结对编程、code review、暴徒式编程。但是最近 code review 上大家的分享越来越少了。

我猜测几种可能：

1、是不是随着大家技术的水涨船高，问题越来约少呢？

2、因为我最近分享老师的代码之丑，大家觉得 code review 变了一个调调，换成分享坏味道了？（其实分享代码之丑的时候，我分享初衷是想让大家都可以学习到，但是我本身自己做的就不太好，代码里面还有好多坏味道，直接去讲 担心大家会不会觉得太空呢？有句话说：道理都懂，可就是过不好这一生！实践真的太难了）

3、会不会我们的 code review 没有回顾会？没有去总结如何把 code review 做的更好？

4、是不是我们没有明确 code review 都需要做哪些事儿？列出来 1 2 3。

5、会不会是每天都 code review，频率太高了呢？每天工作量毕竟也是有限的？

6、会不会是太经常了，心态上已经没有最开始那么重视？我们每天 5 点 code review，我有的时候心里面会想，到 5 点就算这一天的工作做完了，开个会就下班了！

我期望老师给个意见，如何能让我们的 code review 更上一个台阶，做的更好、更有效率呢？

作者回复：你们如果能够坚持做得很好，那真的要恭喜你们了！Code Review 这种事是为了发现问题，如果没有发现问题，一种可能是代码写得真好，另一可能是你们遇到了团队的瓶颈，发现不了问题。实话说，后一种可能性更大。Code Review 不是一个结束，而是一个开始，发现了问题要去修改。我的团队发现问题后修改的工作量还不小，即便我们的频率已经算很高了，还是能发现不少的问题。所以，如果你们自己发现不了太多问题，可以引入别人的视角，帮你们发现问题。2021-02-01

郑老师，有没有用系统思考的方式评估过代码评审在软件开发中的位置或者作用？作者回复：如果你需要的是代码评审的价值，可以搜搜「why code review matter」。2021-01-30

我从来没经经历过代码评审，所以我感觉从老师这里真的学到了好多好多。作者回复：在一个正规的团队中工作，能学到很多基本的东西。2021-01-31

代码评审本身就是对团队成员代码质量提升的有效方法，之前我每次 commit 都会要求我自己先检查一下有没有更好的方式，然后老大再去看一下，每次找出问题来自己也会很难受，然后慢慢自己也都会注意起来。作者回复：自己重视，比团队重视提高得更快。2021-01-30

自己团队其实也一直在做代码 review，老大也比较重视。读完作者这篇文章感觉自己的收获就是 review 的方向有了：实现方案的正确性，算法的正确性和代码的坏味道。这点我觉得的可以在 review 的时候刻意注意的地方。特别认同作者说的刻意练习，不好的习惯，只能通过刻意的练习将其纠正过来。这个也是我最近自我感觉提高的一点，刻意的去做正确的事，慢慢的自己提高是很明显的。作者回复：刻意练习最重要的是适当的反馈。2021-01-30

自己团队其实也一直在做代码 review，老大也比较重视。读完作者这篇文章感觉自己的收获就是 review 的方向有了：实现方案的正确性，算法的正确性和代码的坏味道。这点我觉得的可以在 review 的时候刻意注意的地方。特别认同作者说的刻意练习，不好的习惯，只能通过刻意的练习将其纠正过来。这个也是我最近自我感觉提高的一点，刻意的去做正确的事，慢慢的自己提高是很明显的。2021-01-30

来个新鲜的案例，昨天代码评审时发现的问题：

```java
List<String> a = new ArrayList<>();
// 筛选数据，符合条件的添加到 a 中
List<String> b = new ArrayList<>();
a.addAll(b);
// 筛选数据，符合条件的添加到 b 中
// 结束返回 a
return a;
```

对引用的认识不清楚，集合的 addAll 方法是把参数集合中的每一个 Element 添加到自己这个集合中，不是把集合做为一个 Elements 添加到集合中，形成多维关系。事后追问了一个问题，同一个对象添加到两个不同的集合中，然后再从其中一个集合中取出对象对其进行修改，问此时另一个集合中的那个对象的受影响吗？作者回复：嗯，代码评审有经验的人会多问一句，就能发现不少问题。2021-01-30

还是菜鸟的时候，所在的团队有 Code Review，Leader 对每个人提交的代码都会亲自 Review 并指出问题，Leader 做评审的时候都会带上小本本记下问题，那段时间自己成长的特别快。后来因为某些原因团队解散，经历过的其他的一些团队再也没有那么好的 Review 氛围了。作者回复：运气不错。2021-01-30

做几年码农了，一直没人给我 review。当第一次有人给我 review 时，被说像刚毕业的，羞愧难当。如果在没有 review 氛围的公司，怎么提高自己的代码质量？作者回复：这就是缺乏反馈的结果，自己不知道自己的代码究竟写得怎么样。你从开始学习这个专栏，其实，就已经进入到一个提高自己代码质量的过程里了，至少，现在看到有坏味道的代码，你应该能够发现一些了。接下来，你可以去读读书，比如像《代码整洁之道》、《重构》之类的书，还是要看一下的。接下来，就是在实践中，不断地去打磨手艺了。当然，如果你身边有人能够通过代码评审的方式给你反馈，你的提高会更快。2021-02-06

## 0203熊节什么代码应该被重构.md

代码坏味道的说法源自《重构》这本书，坏味道和重构这两个概念几乎是如影随形。提及《重构》这本书，在国内谁还能比《重构》两版的译者熊节更了解它呢？所以，这一讲，我就请来了我的老朋友熊节，谈谈在他眼中看到的重构和坏味道。有请熊节老师！

你好，我是熊节。自从翻译了《重构》以后，很多公司找我去做重构的培训，光是华为一家，这个主题在各个不同的部门就培训过好些次。每次讲这个主题，我都觉得挺为难的：重构这事有什么可培训的呢，不就是一个无脑模式匹配的事吗！然而跟各家公司的读者们一交流，我就发现事情并没有那么简单。

很多人一说到重构，就聊到虚无缥缈的事上了，像什么架构啦、文化啦，等等。我不得不先把他们拉住仔细问问，他们是怎么读《重构》这本书的？这一问我就发现，原来很多读者（恐怕是绝大多数读者），还没弄明白这本书到底应该怎么读。

### 3.1 什么代码应该被重构？

《重构》这本书，以及重构这门手艺，提纲挈领的部分，都在一个关键的问题上：什么代码应该被重构。你可能会说，质量不好的代码需要被重构。没错，可是代码的质量到底应该如何评判呢？

首先我们要明确的是，代码的好与坏不应当用个人好恶、「含混的代码美学」来表达，因为这会带来两个困难：

第一，每个人对于「好」或「美」的观念可能相当不同；

第二，对于坏代码缺乏明确的「症状」判断，也就很难提出明确的改进措施。

即便是一些经典的程序设计原则，也有同样的问题。例如「高内聚低耦合」，尽管这是所有人都赞同的设计原则，但究竟什么样的代码呈现了「低内聚」、什么样的代码呈现了「高耦合」、「低内聚」与「高耦合」是否总是同时出现、应该以何种办法提高内聚降低耦合…… 这些问题仍然是悬而未决的。

因此，对于真正在一线工作的人来说，「高内聚低耦合」很多时候就成了一句咒语，念完咒语后，呼唤出的其实还是每个人原本的编程习惯与风格，并不真正指导任何行为的改变。

而当我们去观察「低内聚高耦合」带来的问题时，事情就变得明朗了。比如，当我们仔细阅读《重构》第三章时，我们会发现，「低内聚」会直接引发的现象是「霰弹式修改」（Shotgun Surgery）：

每当需要对某个事情做出修改时，你都必须在许多不同的类内做出许多小修改，那么就可以确定，你所面临的坏味道是霰弹式修改。当需要修改的代码分散在多处，你不但很难找到它们，也很容易忘记某个重要的修改。

而「高耦合」直接引发的现象则是有某种相似性、但又表现不同的「发散式变化」（Divergent Change）：

如果某个类经常因为不同的原因在不同的方向上发生变化，发散式变化就出现了。

我再举另一个设计原则的例子。「迪米特原则」也是常被提及的面向对象设计原则之一，然而知道这个名称是一回事，知道如何识别不符合迪米特原则的代码，则又需要更多的个人经验。《重构》第三章则把这个原则表述为两个非常直观的症状：「过长的消息链」（Message Chains）和「中间人」（Middle Man）。

如果你看到用户向一个对象请求另一个对象，而后者再次请求另一个对象，然后再请求另一个对象…… 这就是消息链。在实际代码中，你看到的可能是一长串取值函数，或者一长串临时变量。

人们可能过度运用委托。你也许会看到某个类接口有一半的函数都委托给其他类，这样就是过度运用。

你发现没？对于开始我们提到的「什么代码应该被重构」这个关键问题，虽然《重构》作者 Martin Fowler 和 Kent Beck 非常客气地声称：「并不试图给你一个何时必须重构的精确衡量标准」，实际上，《重构》给出的 24 项「坏味道」（在《重构》第一版中是 22 项）已经形成了一个非常明确的代码质量检查清单。

尽管这本书从未声称这是一份完备的坏味道清单，但在实际工作中，还不用说完全识别并消除这份列表中的全部坏味道，只要能做到命名合理、没有重复、各个代码单元（类、函数等）体量适当、各个代码单元有明确且单一的职责、各个代码单元之间有恰当的交互，这就已经是质量相当高的代码了。

更重要的是，伴随着对具体症状的了解，对症的解决办法也变得明确。在《重构》第三章里非常明确地讲到：

对于「霰弹式修改」，解决的办法是使用「搬移函数」和「搬移字段」，把所有需要修改的代码放进同一个模块；

对于「发散式变化」，解决的办法是首先用「提炼函数」将不同用途的逻辑分开，然后用「搬移函数」将它们分别搬移到合适的模块；

对于「过长的消息链」，你应该使用「隐藏委托关系」；对于「中间人」，对症的疗法则是「移除中间人」，甚至直接「内联函数」。

这就是我前面所说的「无脑模式匹配」。

讲到这里，你也就明白了，对于绝大多数程序员而言，阅读和使用《重构》这本书的正确方法就应该是：

打开任意一段代码（可以是自己刚写完的或者马上要动手修改的）；

翻开《重构》第三章，遍历其中的每个坏味道：

识别这段代码中是否存在上述坏味道；

如有，则遵循该坏味道所列的重构手法，对该段代码进行重构；

如无，则继续遍历代码。

上述过程不需要玄妙的理论和含混的代码美学，只需要机械的重复和简单的模式匹配。正因为此，重构才是一项完完全全具备可操作性、能够在任何遗留代码库上实践的技术。

### 3.2 培养对「坏味道」的判断力

当然，每位实践者仍然「必须培养出自己的判断力，学会判断一个类内有多少实例变量算是太大、一个函数内有多少行代码才算太长」。

就在最近，我看到某大厂的一位「代码委员会理事」在文章里说，某段代码「挺好的，长度没超过 80 行，逻辑比较清晰」。而在我看来，一个函数超过 7 行就已经是「太长」（这还是在考虑到 Java 语法比较啰嗦的前提下）。这就是不同实践者「自己的判断力」所体现的差异。

尽管从来没有明确指定对每个函数或类的代码行数要求，但「对象健身操」这篇文章（见于《ThoughtWorks 文集》）提出的 9 项规则已经有非常明确的指向：

方法中只允许使用一级缩进；

不允许使用 else 关键字；

封装所有的原生类型和字符串；

……

3『 [ThoughtWorks文集（精选版） - InfoQ](https://www.infoq.cn/minibook/thoughtworks-anthology)』

在这样的规则约束下，写出一个超过 10 行的函数将是相当困难的（实际上在「规则 6：保持实体对象简单清晰」中已经明确提出，每个类的长度不能超过 50 行）。

正如「对象健身操」这篇文章的作者 Jeff Bay 自己所说，这套「健身操」的意义在于：「在一个简单的项目里尝试一些比以前严格得多的编码标准…… 会迫使你更为严格地以面向对象的风格编写代码」，从而「以一种全新的方式思考你的代码」。

不过这得需要你刻意练习。正所谓「台上一分钟，台下十年功」，缺乏在受控环境下的刻意练习，很难通过工作中的自然积累提升判断力。

另外，对正确的代码构造足够熟悉，也是很重要的一个基本功，这个观点最早是 Kent Beck 的《实现模式》这本书中提到的。什么意思呢？

2-3『

[实现模式（豆瓣）](https://book.douban.com/subject/3324516/)

已下载书籍「2021077Implementation-Patterns」。

 』

传说旧时民间古董店的学徒需要先在仓库里看真货，看得多了，见到假货时就会本能地提起警觉。对于代码也是一样：程序员需要熟悉正确的代码构造，在看到有问题的代码构造时才会本能地提起警觉。并且，「正确的代码构造」并非无穷无尽，实际上在单线程编程中，几十个常见的模式已经几乎能够完全覆盖所有场景。

Kent Beck 在前言里说「这是一本关于‘如何编写别人能懂的代码'的书」，尽管他还谦虚地说这本书「不是模式书籍」，但实际上《实现模式》充分地展现了「模式」的本意：它提供了一整套「用代码表述意图」的模式语言，这套语言能让程序员在最短的时间内学会如何写出具有表现力的代码，并且自然而然地远离坏味道。

从一开始就以合理的方式编程，从而使坏味道不要出现，我想这才是负责任的程序员应该采取的工作方式。

当然，极限编程的各种实践，尤其是工程技术实践彼此紧密相关。例如自动化测试、持续集成、集体代码所有制的缺失，都会导致代码的坏味道更容易堆积。而从另一个角度来看，这些实践从任何一个切入，又都会自然地引导出其他相关的实践。

一位「知行合一」的程序员最终会发现，极限编程是唯一合理且有效的软件开发方法。最终，只有采用以可工作的软件为核心的软件开发方法，才能得到高质量的可工作的软件，这就是《敏捷宣言》第二句关于坏味道的终极答案。

郑老师说：熊节老师对于问题的分析总是这么一针见血。重构就是一个模式匹配的过程，识别出坏味道，运用对应的重构手法解决问题。坏味道是一切重构的起点，而识别坏味道不是靠个人审美，而要依赖通用的标准。我的这个专栏就是把一些坏味道用更直接的代码形式展现在你面前，让你可以日常的工作中，不断地锻炼自己的代码嗅觉。

### 黑板墙

思考题：经过熊节老师的讲解，你是不是对重构和坏味道有了新的认识呢？

就我经历过的团队（传统企业信息中心）来看，不论是初级还是中级的同事，总是喜欢学习和研究分布式架构相关的知识点，而不喜欢阅读如《重构》、《代码整洁之道》一类的提高程序员最本质的手艺 - 写代码。然而，分布式的东西对我所经历的团队来说并不重要，因为实际上能用上的并不多。然而，每次 Code Review 总会有一些让人摸不着头脑要讲半天的代码，虽然也加了静态代码复杂度检查之类的，但是还是层出不穷。或许是这个浮躁的信息爆炸时代让架构师课程随手可得，却让人忘了自己去追求所谓的整洁代码之美，其实个人觉得一堆可维护的代码就是取悦同事取悦领导最佳的方式。作为 TL，只能尽可能多培养识别坏味道的嗅觉，帮助团队成员指出坏味道并改正，先独善其身，才能有机会兼济天下，能指导和培养一个是一个。知易行难，学习的最高层次就是输出，找一两个小时，团队坐在一起 Code Review 也是一个输出和输入的过程，发挥集体智慧，走向重构。

作者回复：这是一个有趣的角度，现在大部分人其实用不到复杂的分布式知识，但这东西却成了主流，这与大公司面试方式有关。和当年受微软影响，各公司面试智力题有异曲同工的作用。微软后来发现，这种选拔人才的方式有问题，需要改进，估计国内公司也需要经过一个漫长的过程之后，发现他们用这种方式选出来的人，与他们需要的人之间存在差距。毕竟，有大量用户规模的事，只有一些大公司的核心团队才会遇到，而大部分人需要的是，写好代码。而大部分人学习分布式只是学习屠龙术，空有一身本事，无处施展。2021-02-05

读书不等于掌握；掌握了不等于正在执行；执行了不等于一直在践行；识别出坏味道并践行重构的能力就像武功一样，不用就会慢慢荒废。难的不是掌握这个能力，最难的是坚持践行合一。作者回复：知行合一，谈何容易。2021-02-04

这种极限拆分，对于很多业务代码，拆分成很多方法，更加零散一些，而且有些拆出来的方法几乎不会被复用。这样还有必要拆分么？作者回复：举个不是特别恰当的例子，这就像现在还在吃糠咽菜，就担心钱多了该怎么花。先把函数拆小，能不能复用才能看出来，没有拆，何谈复用。再者，更重要的是，拆出来的目标不一定要复用，而是为了让代码更清晰。2021-02-04

静态代码扫描，其实也不治根，规约然后说了，但是就是存在，还是得从意识上去唤醒这种细节点，毕竟只能要求自己，团队太难驱动。作者回复：先做好自己，再去影响他人。2021-02-04

这种机械和简单的模式匹配最好能交给机器去做。作者回复：道理上是这样的，问题是，现在这种模式匹配机器暂时还没法识别，也许是一个值得探索的方向。2021-02-04

学习了老师的三个专栏，收获颇多，感谢分享。请问老师，除了专栏中提到的书籍和示例代码等一些代码片段，哪里可以找到更多符合高质量代码标准的完整的工程 / 代码示例？感觉通过学习了专栏之后，再结合优秀优秀代码会加深理解。目前 github 上代码太多，没办法逐个甄别，如果老师能够帮忙推荐一些最好了，感激不尽。作者回复：Google 的开源项目代码质量一般都很高，推荐 Guava。Spring 的也可以看看。2021-04-22

喜欢郑老师的课程。每次都能 get 到好的新主题，进而课后可以做专项的主题学习。课程内容反而是附赠的。本章：1）get：缺乏在受控环境下的刻意练习，很难通过工作中的自然积累提升判断力。原本认知：一直认为对象健身操过于苛刻，不适合在工作中应用，只是理想化的东西。但如果把它做为训练手段，用于提高自己对代码坏味道的觉察心，就直接豁然开朗了。下来可以时常写些小玩意，对照着苛刻下。2）get：《实现模式》，书已买，拜读下。2021-02-05