## 记忆时间

## 目录

0105大类如何避免写出难以理解的大类.md

0106长参数列表如何处理不同类型的长参数.md

## 0105大类如何避免写出难以理解的大类.md

### 总结时刻

我们今天讲了大类这个坏味道，这是程序员日常感知最为深刻的坏味道之一。应对大类的解决方案，主要是将大类拆分成小类。我们需要认识到，模块拆分，本质上是帮助人们降低理解成本的一种方式。我们还介绍了两种产生大类的原因：1）职责不单一；2）字段未分组。无论是哪种原因，想要有效地对类进行拆分，我们需要对不同内容的变动原因进行分析，而支撑我们来做这种分析的就是单一职责原则。将大类拆分成小类，本质上在做的是设计工作，所以，想要写好代码，程序员需要学好软件设计。

有人觉得拆分出来的小类过多，不易管理，但其实程序设计语言早就为我们提供了各种构造类集合的方式，比如包、命名空间等，再进一步，还可以封装出各种程序库。如果今天的内容你只能记住一件事，那请记住：把类写小，越小越好。

### 5.0

上一讲我们讲了长函数，一个让你感受最直观的坏味道。这一讲，我们再来讲一个你一听名字就知道是怎么回事的坏味道：大类。

一听到大类，估计你的眼前已经浮现出一片无边无际的代码了。类之所以成为了大类，一种表现形式就是我们上节课讲到的长函数，一个类只要有几个长函数，那它就肯定是一眼望不到边了（长函数的话题，我们上一讲已经讨论过了，这里就不再赘述了）。大类还有一种表现形式，类里面有特别多的字段和函数，也许，每个函数都不大，但架不住数量众多啊，这也足以让这个类在大类中占有一席之地。这一讲，我们就主要来说说这种形式的大类。

### 5.1 分模块的程序

我先来问你一个问题，为什么不把所有的代码都写到一个文件里？

你可能会觉得这个问题很傻，心里想：除了像练习之类的特定场景，谁会在一个正经的项目上把代码写到一个文件里啊？没错，确实没有人这么做，但你思考过原因吗？把代码都写到一个文件里，问题在哪里呢？

事实是，把代码写到一个文件里，一方面，相同的功能模块没有办法复用；另一方面，也是更关键的，把代码都写到一个文件里，其复杂度会超出一个人能够掌握的认知范围。简言之，一个人理解的东西是有限的，没有人能同时面对所有细节。

人类面对复杂事物给出的解决方案是分而治之。所以，我们看到几乎各种程序设计语言都有自己的模块划分方案，从最初的按照文件划分，到后来，使用面向对象方案按照类进行划分，本质上，它们都是一种模块划分的方式。这样，人们面对的就不再是细节，而是模块，模块的数量显然会比细节数量少，人们的理解成本就降低了。

好，你现在已经理解了，对程序进行模块划分，本质上就是在把问题进行分解，而这种做法的背后原因，就是人类的认知能力是有限的。理解了这一点，我们再回过头来看大类这个坏味道，你就知道问题出在哪了。如果一个类里面的内容太多，它就会超过一个人的理解范畴，顾此失彼就在所难免了。按照这个思路，解决大类的方法也就随之而来了，就是把大类拆成若干个小类。你可能会想，这我也知道，问题是，怎么拆呢？

### 5.2 大类的产生

想要理解怎么拆分一个大类，我们需要知道，这些类是怎么变成这么大的。

#### 5.2.1 职责不单一

最容易产生大类的原因在于职责的不单一。我们先来看一段代码：

```java
public class User {
  private long userId;
  private String name;
  private String nickname;
  private String email;
  private String phoneNumber;
  private AuthorType authorType;
  private ReviewStatus authorReviewStatus;
  private EditorType editorType;
  ...
}
```

这个 User 类拥有着一个大类的典型特征，其中包含着一大堆的字段。面对这样一个类时，我们要问的第一个问题就是，这个类里的字段都是必需的吗？我们来稍微仔细地看一下这个类，用户 ID（userId）、姓名（name）、昵称（nickname） 之类应该是一个用户的基本信息，后面的邮箱（email）、电话号码（phoneNumber） 也算是和用户相关联的。今天的很多应用都提供使用邮箱或电话号码登录的方式，所以，这个信息放在这里，也算是可以理解。

再往后看，作者类型（authorType），这里表示作者是签约作者还是普通作者，签约作者可以设置作品的付费信息，而普通作者不能。后面的字段是作者审核状态（authorReviewStatus），就是说，作者成为签约作者，需要有一个申请审核的过程，这个状态就是审核的状态。

再往后，又出现了一个编辑类型（editorType），编辑可以是主编，也可以是小编，他们的权限是不一样的。这还不是这个 User 类的全部。但是，即便只看这些内容，也足以让我们发现一些问题了。

首先，普通的用户既不是作者，也不是编辑。作者和编辑这些相关的字段，对普通用户来说，都是没有意义的。其次，对于那些成为了作者的用户，编辑的信息意义也不大，因为作者是不能成为编辑的，反之亦然，编辑也不会成为作者，作者信息对成为编辑的用户也是没有意义的。

在这个类的设计里面，总有一些信息对一部分人是没有意义，但这些信息对于另一部分人来说又是必需的。之所以会出现这样的状况，关键点就在于，这里只有「一个」用户类。

普通用户、作者、编辑，这是三种不同角色，来自不同诉求的业务方关心的是不同的内容。只是因为它们都是这个系统的用户，就把它们都放到用户类里，造成的结果就是，任何业务方的需求变动，都会让这个类反复修改。这种做法实际上是违反了单一职责原则。

在《软件设计之美》中，我曾经专门用了一讲的篇幅讲单一职责原则，它让我们把模块的变化纳入考量。单一职责原则是衡量软件设计好坏的一把简单而有效的尺子，通常来说，很多类之所以巨大，大部分原因都是违反了单一职责原则。而想要破解「大类」的谜题，关键就是能够把不同的职责拆分开来。

回到我们这个类上，其实，我们前面已经分析了，虽然这是一个类，但其实，它把不同角色关心的东西都放在了一起，所以，它变得如此庞大。我们只要把不同的信息拆分开来，问题也就迎刃而解了。下面就是把不同角色拆分出来的结果：

```java
public class User {
  private long userId;
  private String name;
  private String nickname;
  private String email;
  private String phoneNumber;
  ...
}
```

```java
public class Author {
  private long userId;
  private AuthorType authorType;
  private ReviewStatus authorReviewStatus;
  ...
}
```

```java
public class Editor {
  private long userId;
  private EditorType editorType;
  ...
}
```

这里，我们拆分出了 Author 和 Editor 两个类，把与作者和编辑相关的字段分别移到了这两个类里面。在这两个类里面分别有一个 userId 字段，用以识别这个角色是和哪个用户相关。这个大 User 类就这样被分解了。

#### 5.2.2 字段未分组

大类的产生往往还有一个常见的原因，就是字段未分组。

有时候，我们会觉得有一些字段确实都是属于某个类，结果就是，这个类还是很大。比如，我们看一下上面拆分的结果，那个新的 User 类：

```java
public class User {
  private long userId;
  private String name;
  private String nickname;
  private String email;
  private String phoneNumber;
  ...
}
```

前面我们分析过，这些字段应该都算用户信息的一部分。但是，即便相比于原来的 User 类小了许多，这个类依然也不算是一个小类，原因就是，这个类里面的字段并不属于同一种类型的信息。比如，userId、name、nickname 几项，算是用户的基本信息，而 email、phoneNumber 这些则属于用户的联系方式。

从需求上看，基本信息是那种一旦确定就不怎么会改变的内容，而联系方式则会根据实际情况调整，比如，绑定各种社交媒体的账号。所以，如果我们把这些信息都放到一个类里面，这个类的稳定程度就要差一些。所以，我们可以根据这个理解，把 User 类的字段分个组，把不同的信息放到不同的类里面。

```java
public class User {
  private long userId;
  private String name;
  private String nickname;
  private Contact contact;
  ...
}
```

```java
public class Contact {
  private String email;
  private String phoneNumber;
  ...
}
```

这里我们引入了一个 Contact 类（也就是联系方式），把 email 和 phoneNumber 放了进去，后面再有任何关于联系方式的调整就都可以放在这个类里面。经过这次调整，我们把不同的信息重新组合了一下，但每个类都比原来要小。

对比一下，如果说前后两次拆分有什么不同，那就是：前面是根据职责，拆分出了不同的实体，后面是将字段做了分组，用类把不同的信息分别做了封装。

或许你已经发现了，所谓的将大类拆解成小类，本质上在做的工作是一个设计工作。我们分解的依据其实是单一职责这个重要的设计原则。没错，很多人写代码写不好，其实是缺乏软件设计的功底，不能有效地把各种模型识别出来。所以，想要写好代码，还是要好好学学软件设计的。

学了这一讲，如果你还想有些极致的追求，我给你推荐《ThoughtWorks 文集》这本书里「对象健身操」这一篇，这里提到一个要求：每个类不超过 2 个字段。《ThoughtWorks 文集》是我当年参与翻译的一本书，今天看来，里面的内容大部分都过时了，但「对象健身操」这一篇还是值得一读的。

关于大类的讨论差不多就接近尾声了，但我估计结合这一讲最初的讨论，有些人心中会升起一些疑问：如果我们把大类都拆成小类，类的数量就会增多，那人们理解的成本是不是也会增加呢？

其实，这也是很多人不拆分大类的借口。

在这个问题上，程序设计语言早就已经有了很好的解决方案，所以，我们会看到在各种程序设计语言中，有诸如包、命名空间之类的机制，将各种类组合在一起。在你不需要展开细节时，面对的是一个类的集合。再进一步，还有各种程序库把这些打包出来的东西再进一步打包，让我们只要面对简单的接口，而不必关心各种细节。

如此层层封装，软件不就是这样构建出来的吗？

### 黑板墙

思考题：你在实际工作中遇到过多大的类，你分析过它是怎样产生的吗？又是如何拆分的呢？欢迎在留言区分享你的经历。如果你身边有同事总是写出大类，你不妨把这节课分享给他，帮他解决大类的烦恼。

正如类太大会超出人的理解范畴，类太多也会。举个 java 的例子，做业务开发时大部分需求都可以通过 spring boot 完成，但如果要对 spring 进行定制，需要理解的内容就多了一个数量级。框架本身在满足更多需求的同时不断重构，类的职责越来越单一，数量也越来越多。虽然每个改动都有正当的理由，但如果不知道这些改动的历史，一下子就被那么多类糊一脸，任谁也是吃不消的。个人理解这可能是在业务优先的场景下，两害相权取其轻的结果吧。作者回复：认为类太多是个问题，我在文章中已经说了一个角度，这里再补充一个角度。这里有一个假设是，一上来就要把所有的类理解掉，

然而，这种假设是不成立的，作为 Java 程序员，你不会去看所有 JDK 里的类，也不会看 Spring 所有的类。一般的做法是理解主线，然后，根据需要了解相应的类，这是做事方法的问题。不能因为我们可能要面对所有代码，就一下子去吃透所有的代码，这是普通人做不到的。所以，类的数量多少不是问题，通过怎样的方式，降低代码理解的难度才是我们要考虑的问题。2021-01-09

目前在做嵌入式的项目，里面的 C 代码如郑老师所言，大部分都是以「效率」为名，写的巨长无比。我有一个问题想咨询郑老师，我们的项目不算法，4 万行左右，我在进行一代往二代的重构，我个人感觉应该把功能都拆开，以不同文件夹的层级方式进行代码的整理；而组内的同事以及外包的员工觉得代码不算多，一个文件夹，几个文件一把就搞定了，没必要搞那么复杂。这个问题就和老师这篇文章所述有一点不一样了：如果觉得代码架构和代码逻辑能够理解，是不是 clean code 的必要性或者说急迫性就没有那么大了。先以交付为目标进行 coding，后续再看情况。作者回复：马斯洛需求层次理论告诉我们，人有不同层次的追求。生存是底线，总有人会告诉你，温饱解决就行。

写代码也一样，功能实现就可以了，代码规模不大，可以理解。问题在于，等规模大了，你真的改得动吗？你的代码为什么要改动？还不是一代的代码改起来很吃力了。为什么吃力了？是因为功能实现不了吗？还不是代码可维护性差。为什么可维护性差？还不是根本不知道可维护性好的代码是什么样。你不妨推演一下，按照他们的建议写代码，距离走回老路上，还有多远的距离。既然有机会建立新的标准，既然有机会知道可维护的代码长什么样，为什么要按照老路走呢？如果知道什么是「积重难返」，就会懂得「勿以善小而不为」的价值所在了。2021-01-09

看了郑大的例子，正合我当前做法，给自己吃颗定心丸。我现在 java 一个 4 万行代码的项目，最大的类不到 300 行代码。普遍 100 行以下。很多是得益于对象健身操。操练了对象健身操，对面向对象会有更深刻理解作者回复：你做得已经很好了！2021-01-11

每个类两个字段？？？作者回复：我知道大多数人做不到，但我们应该知道更高的追求是什么。2021-01-09

将 user 里的联系信息单独拆出一个类来以后，我要对外暴露一个修改联系信息的方法是应该放 user 里还是放 contact 里？

作者回复：如果 user 类是整个的根，修改联系方式就可以在 user 类里提供一个入口，然后，再调用 contact 类。2021-01-11

有的时候，拆分和聚合是需要做取舍的。比如，微服务的聚合层，是为了适配和性能考虑会做裁剪或聚合，不可避免的会出现些大类，此时可以进行字段分组，但是聚合后的大类是无法进行拆分。作者回复：我的理解，你问的问题是，在微服务中，有专门把多个服务的结果聚合起来，返回给客户端，这是你所说的聚合层。你的问题是，在这个聚合层里，表示请求和应答的类可能会比较大，改怎么办。

根据这个理解，我的回答是，这里的聚合层扮演的角色其实一个防腐层，它本身的职责就是和请求应答去做一一应对。一般来说，这样类行为很单一，主要的职责就是数据转换。对于这种类，大一点是可以的，因为它不会对业务造成什么影响。重点在于，这个类里没有业务。如果你想把类里面的字段做一个分组，可以研究一下不同的转换库，比如，在 Java 中把 JSON 和对象进行相互转换的 Jackson。看看它们怎么可以把不同类的字段和协议中的平铺字段直接映射，肯定有方案的。不过，最后要提醒你的一个重点是，简单的聚合并不是一个好办法，而是需要谨慎地设计通信协议，这才是保证类比较小的根本办法。2021-01-11

我们的项目中，或者是用到的类似于 JPUSH 这种开源软件中，都存在「大类」的问题。最头疼的是遇见没有注释说明的大类，里面罗列了很多字段、函数，但是你都没法一眼就看出来各自都是干嘛的，只能先猜一下，完了之后根据调用关系去梳理。最近用 PHP 进行二次开发，用到一个扩展包，里面的入口 class 写得巨长无比......目前来看，把类写小，越小越好能做到的是凤毛麟角呀。也可能是我见得太少了。作者回复：不意外，大多数代码都是有问题的，Clean Code 是稀缺的。2021-01-09

MVC 里常出现的大类是 UserService, 提供登陆，注册，修改密码，查询用户等方法里面会有 UserDao、LoginRecordDao、CacheDao 等很多个注入的「字段」。这种应该怎么拆分呢，如果按职责拆分成 UserLoginService、UserRegisterService、UserPasswordService、UserInfoService，保持每个 service 里面又少量注入「Service、Dao」，这么拆对不对呢。作者回复：我现在通常的做法是，引入应用服务层，在应用服务层去协调各个领域服务层。而在领域服务层，一个服务通常只对应一个数据库访问层的代码。你这里的纠结其实就是缺少了应用服务层。如果不引入应用服务层，可以考虑的做法是，服务层内部可以引用，但服务只对应一个数据库访问层代码。2021-01-12


总结：1）小类大对象 + 面相意图的抽象。2）好的抽象只需关心使用不用关心实现，所以能降低复杂性。但不好的抽象。3）个人觉得还是讲究平衡，没必要一上来就拆分得很细致。当复杂度让你皱眉头时再拆也许更物有所值。作者回复：看一下我在开篇词中提供的自查表，那里面的括号就是你要根据自己团队的实际情况填写的内容。2021-01-12

我们项目实体类和数据库表是直接映射的，如果拆分成上面这样的话，数据库是也需要拆多表？（用户、作者、编辑）作者回复：这是设计怎么与实现映射的事，通常来说，应该把实现拆分成多个表。2021-01-11

我也有个一直找不到平衡点的问题，就是类爆炸问题，如果拆分的类太多 会不会出现累爆炸的问题呢，从而影响系统性能，这个有没有个比较数字化的标准呢。还是我看这个问题的角度就完全不对。作者回复：不要把性能放在这里说事，因为这属于发力找错了对象。性能优化肯定不是在这个层面上的，而是要从一个系统的层面上进行考量。类爆炸，首先是，啥叫类爆炸？类多就是类爆炸吗？那岂不是所有代码都在一个类里完成就是最好的。类多不是问题，问题是过度设计造成的难以理解的结构才是问题。2021-01-11

现在项目中很多大类，把很多东西都返回前端。美其名曰这样前端想怎么用怎么用。还有就是拆分成多个小类之后，很多人没有管理好小类的能力。分散的越来越复杂。作者回复：唉，用加班代替思考。2021-01-09

分而治之、单一职责、字段分组、分离变化、将类设计了小类，不超出可控范围。2021-03-29

请问一下，一般来说实体的大小和数据表的列是对应关系的，User 类拆分出了 Contact 这个类，那么数据库的层面是否也应该差分出一个 Contact 表还是把信息都存储在 User 表的列中呢？作者回复：都可以，根据自己的需要。很多人纠结的点在于没做过「类分开，表在一起」，其实，很多框架是支持的。2021-02-09

## 0106长参数列表如何处理不同类型的长参数.md

### 总结时刻

今天我们讲解的坏味道是长参数列表，它同样是一个「我一说，你就知道是怎么回事」的坏味道。应对长参数列表主要的方式就是减少参数的数量，一种最直接的方式就是将参数列表封装成一个类。但并不是说所有的情况都能封装成类来解决，我们还要分析是否所有的参数都有相同的变动频率。变化频率相同，则封装成一个类。变化频率不同的话：1）静态不变的，可以成为软件结构的一部分；2）多个变化频率的，可以封装成几个类。3）除此之外，参数列表中经常会出现标记参数，这是参数列表变长的另一个重要原因。对于这种标记参数，一种解决方案就是根据这些标记参数，将函数拆分成多个函数。如果今天的内容你只能记住一件事，那请记住：减小参数列表，越小越好。

### 6.0

前面两讲，我们分别讲了长函数和大类，它们都是那种「我一说，你就知道是怎么回事」的坏味道，而且都让我们深恶痛绝，唯恐避之不及。这样典型的坏味道还有一个，就是长参数列表。好吧，我知道你的脑子里已经出现了一个长长的参数列表了。每个程序员只要想到，一个函数拥有几十甚至上百个参数，内心就难以平静下来。

那么，函数为什么要有参数呢？我们知道，不同函数之间需要共享信息，于是才有了参数传递。其实，函数间共享信息的方式不止一种，除了参数列表，最常见的一种方式是全局变量。但全局变量会带给我们太多意想不到的问题，所以，在初学编程的时候，老师就会告诉我们，不要使用全局变量。从程序设计语言发展的过程中，我们也可以看到，取消全局变量已经成为了大势所趋。

但函数之间还是要传递信息的，既然不能用全局变量，参数就成了最好的选择，于是乎，只要你想到有什么信息要传给一个函数，就自然而然地把它加到参数列表中，参数列表也就越来越长了。那么，长参数列表有啥问题呢？这个问题其实我在上一讲已经说过了，人脑能够掌握的内容有限，一旦参数列表变得很长，作为普通人，我们就很难对这些内容进行把控了。

既然长参数列表的问题是数量多，秉承我们一以贯之的思路，解决这个问题的关键就在于，减少参数的数量。既然知道了解决方案的方向，那我们接下来就具体看看，有哪些方法可以减少参数的数量。

### 6.1 聚沙成塔

我们来看一段代码：

```java
public void createBook(final String title, 
                       final String introduction,
                       final URL coverUrl,
                       final BookType type,
                       final BookChannel channel,
                       final String protagonists,
                       final String tags,
                       final boolean completed) {
  ...
  Book book = Book.builder
    .title(title) 
    .introduction(introduction)
    .coverUrl(coverUrl)
    .type(type)
    .channel(channel)
    .protagonists(protagonists)
    .tags(tags)
    .completed(completed)
    .build();
    
  this.repository.save(book);
}
```

这是一个创建作品的函数，我们可以看到，这个函数的参数列表里，包含了一部作品所要拥有的各种信息，比如：作品标题、作品简介、封面 URL、作品类型、作品归属的频道、主角姓名、作品标签、作品是否已经完结等等。如果你阅读这段代码，只是想理解它的逻辑，你或许会觉得这个函数的参数列表还挺合理，它把创建一部作品所需的各种信息都传给了函数，这是大部分人面对一段代码时理解问题的角度。不过，虽然这样写代码容易让人理解，但这不足以让你发现问题。

比如，如果你现在要在作品里增加一项信息，表明这部作品是否是签约作品，也就是这部作品是否可以收费，那你该怎么办？

顺着前面的思路，我们很自然地就会想到给这个函数增加一个参数。但正如我在讲「长函数」那节课里说到的，很多问题都是这样，每次只增加一点点，累积起来，便不忍直视了。如果我们有了「坏味道」的视角，我们就会看到这里面的问题：这个函数的参数列表太长了。

怎么解决这个问题呢？

这里所有的参数其实都是和作品相关的，也就是说，所有的参数都是创建作品所必需的。所以，我们可以做的就是将这些参数封装成一个类，一个创建作品的参数类：

```java
public class NewBookParamters {
  private String title;
  private String introduction;
  private URL coverUrl;
  private BookType type;
  private BookChannel channel;
  private String protagonists;
  private String tags;
  private boolean completed;
  ...
}
```

这样一来，这个函数参数列表就只剩下一个参数了，一个长参数列表就消除了：

```java
public void createBook(final NewBookParamters parameters) {
  ...
}
```

这里你看到了一个典型的消除长参数列表的重构手法：将参数列表封装成对象。

或许你还有个疑问，只是把一个参数列表封装成一个类，然后，用到这些参数的时候，还需要把它们一个个取出来，这会不会是多此一举呢？就像这样：

```java
public void createBook(final NewBookParamters parameters) {
  ...
  Book book = Book.builder
    .title(parameters.getTitle()) 
    .introduction(parameters.getIntroduction())
    .coverUrl(parameters.getCoverUrl())
    .type(parameters.getType())
    .channel(parameters.getChannel())
    .protagonists(parameters.getProtagonists())
    .tags(parameters.getTags())
    .completed(parameters.isCompleted())
    .build();
    
  this.repository.save(book);
}
```

如果你也有这样的想法，那说明一件事：你还没有形成对软件设计的理解。我们并不是简单地把参数封装成类，站在设计的角度，我们这里引入的是一个新的模型。我在《软件设计之美》讨论模型封装的时候曾经说过，一个模型的封装应该是以行为为基础的。

之前没有这个模型，所以，我们想不到它应该有什么行为，现在模型产生了，它就应该有自己配套的行为，那这个模型的行为是什么呢？从上面的代码我们不难看出，它的行为应该是构建一个作品对象出来。你理解了这一点，我们的代码就可以进一步调整了：

```java
public class NewBookParamters {
  private String title;
  private String introduction;
  private URL coverUrl;
  private BookType type;
  private BookChannel channel;
  private String protagonists;
  private String tags;
  private boolean completed;
  
  public Book newBook() {
    return Book.builder
      .title(title) 
      .introduction(introduction)
      .coverUrl(coverUrl)
      .type(type)
      .channel(channel)
      .protagonists(protagonists)
      .tags(tags)
      .completed(completed)
      .build();
  }
}
```

创建作品的函数就得到了极大的简化：

```java
public void createBook(final NewBookParamters parameters) {
  ...
  Book book = parameters.newBook();
    
  this.repository.save(book);
}
```

好，这里我们讨论消除长参数列表的一种方法，将参数列表封装成类。还记得我们前面提到的「如何扩展需求」这个问题吗？如果需求扩展，需要增加创建作品所需的内容，那这个参数列表就是不变的，相对来说，它就是稳定的。

或许你会问，那这个类就会不断膨胀，变成一个大类，那该怎么办呢？关于这一点，你可以回顾一下我们的前一讲，看看怎么解决大类的问题。

### 6.2 动静分离

把长参数列表封装成一个类，这能解决大部分的长参数列表，但并不等于所有的长参数列表都应该用这种方式解决，因为不是所有情况下，参数都属于一个类。我们再来看一段代码：

```java
public void getChapters(final long bookId, 
                        final HttpClient httpClient,
                        final ChapterProcessor processor) {
  HttpUriRequest request = createChapterRequest(bookId);
  HttpResponse response = httpClient.execute(request);
  List<Chapter> chapters = toChapters(response);
  processor.process(chapters);
}
```

这个函数的作用是根据作品 ID 获取其对应的章节信息。如果，单纯以参数个数论，这个函数的参数数量并不算多。

如果你只是看这个函数，可能很难发现直接的问题。即便我们认为有问题，也可以用一个类把这个函数的参数都封装起来。不过，秉承我在这个专栏里讨论的一贯原则，绝对的数量并不是关键点，参数列表也应该是越少越好。针对这个函数，我们需要稍微分析一下这几个参数。

在这几个参数里面，每次传进来的 bookId 都是不一样的，是随着请求的不同而改变的。但 httpClient 和 processor 两个参数都是一样的，因为它们都有相同的逻辑，没有什么变化。

换言之，bookId 的变化频率同 httpClient 和 processor 这两个参数的变化频率是不同的。一边是每次都变，另一边是不变的。

我在《软件设计之美》中讲分离关注点时曾经讲到过，不同的数据变动方向也是不同的关注点。这里表现出来的就是典型的动数据（bookId）和静数据（httpClient 和 processor），它们是不同的关注点，应该分离开来。

具体到这个场景下，静态不变的数据完全可以成为这个函数所在类的一个字段，而只将每次变动的东西作为参数传递就可以了。按照这个思路，代码可以改成这个样子：

```java
public void getChapters(final long bookId) {
  HttpUriRequest request = createChapterRequest(bookId);
  HttpResponse response = this.httpClient.execute(request);
  List<Chapter> chapters = toChapters(response);
  this.processor.process(chapters);
}
```

这个坏味道其实是一个软件设计问题，代码缺乏应有的结构，所以，原本应该属于静态结构的部分却以动态参数的方式传来传去，无形之中拉长了参数列表。这个例子也给了我们一个提示，长参数列表固然可以用一个类进行封装，但能够封装出这个类的前提条件是：这些参数属于一个类，有相同的变化原因。如果函数的参数有不同的变化频率，就要视情况而定了。对于静态的部分，我们前面已经看到了，它可以成为软件结构的一部分，而如果有多个变化频率，我们还可以封装出多个参数类来。

### 6.3 告别标记

我们再来看一个例子：

```java
public void editChapter(final long chapterId, 
                        final String title, 
                        final String content, 
                        final boolean apporved) {
  ...
}
```

这是我们在前面课程「重复代码」那一讲里提到过的一个函数，我们稍微复习一下，这几个参数分别表示，待修改章节的 ID、标题和内容，最后一个参数表示这次修改是否直接审核通过。

前面几个参数是修改一个章节的必要信息，而这里的重点就在最后这个参数上。

之所以要有这么个参数，从业务上说，如果是作者进行编辑，之后要经过审核，而如果编辑来编辑的，那审核就直接通过，因为编辑本身扮演了审核人的角色。所以，你发现了，这个参数实际上是一个标记，标志着接下来的处理流程会有不同。

使用标记参数，是程序员初学编程时常用的一种手法，不过，正是因为这种手法实在是太好用了，造成的结果就是代码里面彩旗（flag）飘飘，各种标记满天飞。不仅变量里有标记，参数里也有。很多长参数列表其中就包含了各种标记参数。这也是很多代码产生混乱的一个重要原因。

在实际的代码中，我们必须小心翼翼地判断各个标记当前的值，才能做好处理。解决标记参数，一种简单的方式就是，将标记参数代表的不同路径拆分出来。回到这段代码上，这里的一个函数可以拆分成两个函数，一个函数负责「普通的编辑」，另一个负责「可以直接审核通过的编辑」。

```java
// 普通的编辑，需要审核
public void editChapter(final long chapterId, 
                        final String title, 
                        final String content) {
  ...
}


// 直接审核通过的编辑
public void editChapterWithApproval(final long chapterId,
                                    final String title,
                                    final String content) {
 ...
}
```

标记参数在代码中存在的形式很多，有的是布尔值的形式，有的是以枚举值的形式，还有的就是直接的字符串或者整数。无论哪种形式，我们都可以通过拆分函数的方式将它们拆开。在重构中，这种手法叫做移除标记参数（Remove Flag Argument）。

最近这三节课，我们讲了长函数、大类和长参数列表三种不同的坏味道，但在我们阐述了对于这些坏味道的理解之后，仔细想想这些坏味道，其实背后都是一件事：我们应该编写「短小」的代码。

这是由人类理解复杂问题的能力决定的，只有短小的代码，我们才能有更好地把握，而要写出短小的代码，需要我们能够「分离关注点」。

### 黑板墙

思考题：你曾经遇到的长参数列表有多长呢？你是怎样解决它的呢？欢迎在留言区分享你的经历。也建议你「在教中学」，充分吸收理解这一讲的内容，并讲给自己的团队听。

关于通过拆分函数的方式来移除标记有一点疑问：这种方式不是意味着，外部调用函数的时候需要标记去判断调用哪个函数吗？这是不是说，这种方式变化过后，标记判断逻辑从当前函数转移到了调用函数部分，但是由于该标记是由调用函数产生，所以总的来说相当于减少了标记作为参数传递的部分。作者回复：如果只有一处地方传递标记，其实还好。如果标记是一路传递，透过多个函数，也许说明，这是另外一条路径，可以完全拆分出来。2021-01-12

一个方法第一选择是没有参数。第二选择是一个参数。稍次之是两个参数。三个以上参数简直无法忍受。—— 代码整洁之道。作者回复：这是要努力追求的。2021-01-12

get/set 的普及，很容易让人先入为主的把 get 开头的方法当做是「轻量级访问器」这样的用法：它只是简单地返回一个内部成员变量。文中的 getChapters，使用 fetch 或者 query 可能更合适？它们看起来更像是有一些代价的操作。作者回复：很好的角度，是这样的。2021-01-12

在前一家公司，因为项目里几个相同的逻辑散落在各处，维护起来很不方便，所以做了一次重构，将逻辑放在一个方法里，根据标记参数处理特性化的地方。那次重构的结果就是其中一个方法的参数巨多，大约有十几个，其中好几个参数就是标记参数。看完今天这节课的内容，知道了，原来这也是一种坏味道。已经离开上家公司很久了，期望后面维护业务的小伙伴一切安好。作者回复：恭喜脱离苦海。2021-01-13

前端往往是直接传一个 json 对象，看起来就只有一个参数，但往往也是一个偷懒的做法，因为啥时候想加字段就加字段。作者回复：这种做法没有封装。2021-03-13

有个疑问，如果方法 A 的参数列表原先就需要八九个参数，重构以后把参数放一个类 B 里面。调方法 A 之前不一样要有一个参数很多的构造方法？作者回复：构造一个对象的方法有很多，比如，builder 模式。2021-01-19

告别标记：被调用者将业务进行拆分，移除了标记参数。但有这样一种情况：函数 B 调用函数 C 时，给 C 传了一个 flag 标志位，但 B 的这个 flag 不是 B 定义的，而是 A 传给 B 的，所以，我理解 B 也要进行业务拆分，这样层层拆分，业务就明确了。请老师指正。作者回复：对，比一个函数本身有标记更可怕的是，把标记传来传去。2021-01-17

通过封装类形式上缩短了参数列表，但是传递的信息量其实还是那么多，本质上我们是不是应该减少非必要的信息传递呢？一个函数传递多少信息量较为合适呢？作者回复：是的，你这个思路是对的，真正应该思考的是，到底哪些信息是必要的。2021-01-14

我们项目中，因为方法职责不够单一，一个方法可能被很多地方调用。当某个类需要增加参数的时候，其他被调用者都需要传该参数，有些用不到这个参数的地方，则直接传 null，或者空字符串。然后在方法里面判断该参数不等于空，就走后面的指定逻辑，想请教一下 这种应该怎么重构。作者回复：本质上来说，这和标记参数是一回事，可以参考标记参数的处理。2021-01-12

那怎么去构建 NewBookParamters 嗯，是不是也得把全部属性在构造函数里面传进去？特别是每个字段都没有默认值，需要设置。作者回复：可以，也可以使用 Builder 模式。2021-04-27

封装为对象，动静分离以及移除标记。2021-03-31

枚举作为参数时，函数里就得根据枚举做不同处理；如果把枚举参数去掉改为多个对应的函数，那根据枚举做不同的处理就提前到调用的地方了。除非用其它一些设计模式。作者回复：这种情况其实可能需要多态。2021-01-19