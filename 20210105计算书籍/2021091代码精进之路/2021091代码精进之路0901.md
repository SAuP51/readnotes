## 0901. 分治

要把大象装冰箱，拢共分几步？

—— 小品《钟点工》

### 本章小结

软件产业正在变得越来越庞大和复杂，互联网正在变得越来越激进。我们在同一时间能够关注和处理的信息有限，所以学会分治思想很重要。学会如何对复杂问题进行分层和拆解，是我们解决复杂问题的第一步。本章只介绍了分治思想在软件领域中的一些应用，而实际应用场景要广泛得多，不仅限于软件领域。

### 9.0

分治和抽象一样，都是人类进化过程中形成的伟大智慧，也是我们解决复杂问题的不二选择。人的思维要从一个字节大幅跨越到几百兆字节，也就是 9 个数量级（现阶段，后面还要再加 N 个零）。如此复杂的问题域，如果不进行分治，是远远超出人类智力范围的。

分治的价值在于，我们不应该试着在同一时间把整个问题域都塞进自己的大脑，而应该试着以某种方式去组织问题，以便在一个时刻专注于一个特定的部分。这样做的目的是尽量降低在任意时间所要思考问题的复杂度。

本章将介绍分治思想在软件领域的一些典型应用，以此加深我们对分治的理解和认知，让分治的理念融入我们的潜意识中，使我们在开发工作中灵活地使用分层、分场景和分步骤等解决办法，化解软件设计中的复杂问题，从而写出可读性更好的代码，开发出可维护性、可扩展性更好的系统。

### 9.1 分治算法

我记得在学校上算法课时，老师介绍的第一个算法思想就是分治算法，这是一种高效、简洁、优美的算法思想。分治算法主要包含两个步骤 —— 分、治。「分」就是递归地将原问题分解成小问题；「治」则是在解决了各个小问题（各个击破）之后合并小问题的解，从而得到整个问题的解。

分治法解题的一般步骤如下。

1、分解：将要解决的问题划分成若干规模较小的同类问题。

2、求解：当子问题划分得足够小时，用较简单的方法解决。

3、合并：按原问题的要求，将子问题的解逐层合并，构成原问题的解。

#### 9.1.1 归并排序

分治算法一般都可以写成一个递归表达式。例如，经典的归并排序的递归表达式 T(N)=2T(N/2)+ O(N)，T(N) 代表整个原问题，采用了分治解决方案后，它可以表示成如下形式。

1、分解成规模只有原来一半（N/2）的两个子问题： T(N/2)。

2、解决了这两个子问题 T(N/2) 之后，再合并这两个子问题，需要的代价是 O(N)。

归并排序的求解过程如图 9-1 所示。

图 9-1　归并排序的求解过程

#### 9.1.2　二分搜索

二分搜索又称为二分查找、折半查找，是一种效率较高的查找方法。比如，数据库中的索引查找方式（哈希索引除外）就是一种二分、三分或者多分查找的算法，分的多少和索引的数据结构相关。

二分搜索要求线性表为有序表，并且要用向量作为表的存储结构。二分搜索的基本思想是先确定待查找记录所在的范围，然后逐步缩小范围，直至找到或找不到该记录位置。

二分查找的步骤如下。

（1）先确定中间位置：middle = (left+right)/2。

（2）将待查找的 key 值与 data [middle].key 值相比较。若相等，则查找成功并返回该位置；否则，需要确定新的查找区间，继续二分查找，具体方法如下。

如果 data [middle].key 大于 key，由于 data 为有序线性表，可知 data [middle…right].key 均大于 key，因此若表中存在关键字等于 key 的节点，则一定在位置 middle 左边的子表中。

反之，data [middle].key 小于 key，因此若表中存在关键字等于 key 的节点，则一定在位置 middle 右边的子表中，下一次针对新的区域进行查找。

二分查找的 Java 代码实现如下：

```java
public

static void main(String[] args) {

int[] a = {1,2,3,4,5,6,7,8,9};

int pos =bSearch(a, 0, a.length-1, 1);

System.out.println(pos);

}

public

static int bSearch(int[] data,int left,int right,int key){

// 获取中间位置

int middle = (left+right)/2;

// 比较 key 值如相等，返回当前位置，否则确认新的查找空间

if

(data[middle] == key){

return

middle;

}

else if

(data[middle] >key){

return

bSearch(data, left, middle-1, key);

}

else

{

return

bSearch(data, middle+1, right, key);

}

}
```

#### 9.1.3　K 选择问题

K 选择问题是指，给出 N 个数，找出其中第 K 小的元素。如果直接用穷举法，一共需要比较 K×N 次，当 K 与 N 有关时，比如 K 是中位数（K=N/2），那么时间复杂度为 O(N2)；采用分治，则可把复杂度降低为 O(N)。

首先，在 N 个数中选出一个枢轴元素，将比枢轴元素大的元素放到枢轴元素的右边，将比枢轴元素小的元素放到枢轴元素的左边。这样，N 个数被分成了两部分，比枢轴大一部分记为 S(1)，比枢轴小的部分记为 S(2)，这就是分治的「分」。

假设一种理想的情况，枢轴元素基本位于中间值，即它总是将原数组划分成两个大小基本相等的子数组 S(1) 和 S(2)。

要求解第 K 小的元素，有以下 3 种情况。

1、若 K < | S(1)|，则说明第 K 小的元素位于 S(1) 子数组中。其中，| S(1)| 表示 S(1) 数组中元素的个数。

2、若 K == | S(1)| + 1，则说明第 K小的元素刚好是枢轴元素。

3、否则，第 K 小的元素位于 S(2) 子数组中。

如果是情况 1 或者情况 2，可以继续递归分解子数组。分解问题之后，将 N

个元素分成了两个 N/2 个元素的子数组，只需要在其中一个子数组中进行查找即可，使用穷举查找，复杂度为 O(N/2)。

递归表达式为 T(N) = T(N/2) + O(N/2)，解为 O(N)，这说明采用分治算法可以将 K 选择问题的时间复杂度降低为 O(N)。

### 9.2 函数分解

函数过大过长是典型的代码「坏味道」，意味着这个函数可能承载着过多的职责，我们有必要「分治」一下，将大函数分解成多个短小、易读、易维护的小函数。第 3 章中已经介绍了大量函数分解的技艺。关于函数分解，在此强调以下两点。

1、函数长短是职责单一的充分不必要条件，也就是长函数往往意味着职责不单一，但是短函数也不一定就意味着职责单一。

2、在使用组合函数模式时，要注意抽象层次一致性原则（Single Level of Abstration Principle，SLAP），不同抽象层次的内容放在一起会给人凌乱、逻辑不协调的感觉。

### 9.3 写代码的两次创造

本书一直在强调，我们不仅要写实现功能的代码，还要写容易理解的好代码。「写出好代码」除了需要好的技艺之外，还要有好的方法论。以我的实践经验来看，优雅的代码很少是一次成形的，大部分情况下要经过两次创造：第一遍实现功能，第二遍重构优化。

#### 9.3.1 第一遍实现功能

不要试图一次就写出「完美的」代码，这样只会拖慢我们的节奏。就像写文章，第一遍可以写得粗糙一点，把大概意思写出来，然后再仔细打磨，斟酌推敲，直到达到理想的样子。

写代码也是如此，第一遍以实现功能为主，可以允许一定的冗长和复杂，比如有过多的缩进和嵌套循环，有过长的参数列表，名称可以随意取，还会有部分的重复代码。第一遍主要是为了理清逻辑，为第二遍的重构优化做好准备。

#### 9.3.2 第二遍重构优化

如果只是止步于功能实现，那么代码最多只是一个半成品。而实际情况是我们的代码库中有太多这样的半成品，导致系统的复杂度不断攀升，越来越难维护。因此，我们需要有第二次创造 —— 重构优化，即在第一遍实现功能的基础上，看一看是否可以做得更好：命名合理吗？职责单一吗？满足 OCP 吗？函数是否过长？抽象是否合理？

第二次创造通常要比第一次创造更费精力、更耗时间，所以很少有人愿意去做第二遍的事情。比如，要你回答 2 加 2 等于几，你凭直觉就知道是 4，但是如果把问题换成 37×189，你可能都懒得去算，在心里想没事费这劲干嘛。这也是康纳曼·丹尼尔在《快思慢想》一书中提出的重要理论：系统一（感性）和系统二（理性）。动用系统二会耗费能量，而人类是从贫瘠的远古时代进化而来的，为了保存能量，一般默认的是使用系统一思考，不到万不得已，是不会启动系统二的。

因此，最好的优化肯定不是等系统上线后再去做，因为这样往往就等于「再也不会去做」（later equals never）。优化工作本应该是我们编码工作的一部分，拆成两步，主要对编码效率上的考量。

### 9.4 分治模式

很多的设计模式都用到了分治的思想。例如，第 5 章中介绍的管道模式，以及没有详细介绍的责任链模式和装饰者模式，其中都有分治的思想。就责任链模式来说，我们不会把处理一件事情需要的所有职责都放在一个组件中，而是放在多个组件中完成，形成一个链条。这样不仅增加了可扩展性，也使每个组件的职责变得更加单一，更容易维护。

以我曾做过的一个服务机器人项目为例，机器人的应答内容会根据页面、场景、类目、租户的不同而展现出不同的内容。从优先级上来说，租户 Handler 的优先级最低，也就是如果前面的 Handler 都没有命中，那么租户 Handler 可以用来兜底，如图 9-2 所示。这种情况下，使用责任链的分治策略是一种比较好的选择。

图 9-2　服务机器人响应请求的责任链

#### 9.5 分层设计

分层设计是架构体系设计中最常见和重要的一种结构。分层设计最大的好处是分离关注（Separation of concerns），这样我们就可以通过分层隔离简化一个复杂的问题，让每一层只对上一层负责，从而使每一层的职责变得相对简单。

#### 9.5.1 分层网络模型

网络通信是互联网最重要的基础实施之一，它是一个很复杂的过程，包括 TCP 协议 —— 在不可靠的网络上出现状况要怎么办，IP 协议 —— 把数据包传给谁。需要处理的事情有很多，我们可不可以在一个层次中都处理掉呢？当然是可以的，但显然不科学。因此，ISO 制定了网络通信的七层参考模型，每一层只处理一件事情，低层为上层提供服务，直到应用层把 HTTP 和 FTP 等方便理解和使用的协议暴露给用户。

但是，我们实际在 Internet 中使用的并不是七层模型，而是 TCP/IP 四层模型，如图 9-3 所示。因为七层参考模型过于理想化，过多的分层反而降低了效率，让问题变得更复杂。这里就涉及另一个问题：分层是不是越多越好？当然不是，分层有很多好处，但也有代价。在处理复杂问题时，不能不进行分层，但只分有必要的层。

图 9-3 七层模型和四层模型

#### 9.5.2 分层架构

分层架构的目的是通过分离关注点来降低系统的复杂度，同时满足单一职责、高内聚、低耦合、提高可复用性和降低维护成本，也是一种典型的分治思想。

在分层架构中，分层的使用可以进行严格地限制 —— 分层只知道直接的下层；或者可以宽松一些 —— 分层可以访问它之下的任何分层。Martin Fowler 的经验是在实际中使用第二种方式会更好，我的经验也可以验证这个说法，因为它避免了在中间分层创建代码方法（或者完整的代理类），也避免了退化成千层面的反模式。

有时分层会安排领域层将数据源完全隐藏，不让展现层看到。但是更多时候，展现层会直接访问数据存储，这虽然不那么纯粹，但实际却工作得更好。

这种灵活的分层机制实际上是一种开放的分层架构，如图 9-4 所示。这种不教条和 12.2.2 节中介绍的 CQRS 有着类似的作用，即领域层是可选的，允许应用层绕过领域层直接和基础设施层进行通信。关于架构的更多内容，将在第 12 章详细讨论。

图 9-4　开放的分层架构

### 9.6 横切和竖切

随着互联网的发展，用户流量呈指数型增长，单体应用已经不能适应发展的需要，分布式架构正在变得越来越重要。如果你经常参加一些技术峰会，可以看到这样的分享：一个小企业从一台应用服务器、一个数据库慢慢壮大，发展成独角兽公司，其架构也随之演变成一个大型分布式系统。

这不是偶然，而是企业架构演化的必然结果，因为只有分治才能应对网络高并发，实现水平扩展。

以分布式数据库为例，我们把原来放在一个数据库中的几千亿数据通过竖切、横切（水平拆分和垂直拆分），切分成相对较小的几十个乃至几千个小数据库，以便满足性能和可用性的要求。所谓竖切，就是按照领域将单体数据库拆分成多个数据库。比如，原来电商数据都是放在一个库中，我们可以按照领域拆分成商品库、会员库、交易库等，如图 9-5 所示。

图 9-5 数据库竖切

横切是通过一种数据路由算法对数据进行分片，从而减少一个数据库中的数据量。比如，我们要将会员的交易数据切分成 10 个库，可以用 userId 对 10 进行取模，如图 9-6 所示，这种水平扩展能力在理论上来说提供了无限扩展的可能。

图 9-6 数据库横切
