建模的艺术就是去除实在中与问题无关的部分。

—— 利普·沃伦·安德森（1977 年诺贝尔物理学奖得主）

在软件工程中，有两个高阶工作分别是架构和建模。如果把写代码比喻成「施工」，那么架构和建模就是「设计图纸」。相比于编码，建模的确是对设计经验和抽象能力要求更高的一种技能。例如，在当前热门的人工智能和机器学习领域，建模就是其中非常重要的工作。

6.1　什么是模型

模型是对现实世界的简化抽象。建立模型有很多方法，并不意味着要用特定的符号、工具和流程。我们只是想在研究复杂东西时，让其中的一些部分易于理解。因此，无论使用何种建模工具和表示法（Notation），只要有助于我们对问题域的理解，均可认为是好的模型。

在一个信息爆炸的时代，有时，不必要的细节反而会让情况更加难以理解。在处理问题时，我们最好隐藏那些不必要的细节，只专注于重要的方面，抓住问题的本质。这也是建模和抽象的价值所在。

在不同的场景下，模型对相同的实体会有不同的表达方式。模型的作用就是表达不同概念的性质。根据使用场景的不同，模型大致可以分为物理模型、概念模型、数学模型和思维模型等。

6.1.1　物理模型

物理模型是拥有体积及重量的物理形态概念实体物件，是根据相似性理论制造的按原系统比例缩小（也可以是放大或与原系统尺寸一样）的实物。例如，风洞实验中的飞机模型、水力系统实验模型、建筑模型和船舶模型和汽车模型（如图 6-1 所示）等。

图 6-1　汽车模型

6.1.2　数学模型

数学模型是用数学语言描述的一类模型，可以是一个或一组代数方程、微分方程、差分方程、积分方程或统计学方程，也可以是某种适当的组合数学模型。利用这些方程可以定量地或定性地描述系统各变量之间的相互关系或因果关系，来描述系统的行为和特征，而不是系统的实际结构。如图 6-2 所示，是一个对汽车 4S 店进行销售预测的建模过程。

图 6-2　4S 店销售预测建模

6.1.3　概念模型

概念模型是对真实世界中问题域内的事物的描述，是领域实体，而不是对软件设计的描述，它和技术无关。概念模型将现实世界抽象为信息世界，把现实世界中的客观对象抽象为某一种信息结构，这种信息结构并不依赖于具体的计算机系统。以一辆汽车为例，我们可以画出图 6-3 所示的领域模型。

图 6-3　汽车的领域模型

6.1.4　思维模型

我们把用简单易懂的图形、符号或者结构化语言等表达人们思考和解决问题的形式，统称为思维模型。简单来说，就是我们可以总结出一些能够解决特定问题的「思维套路」，这些套路能帮助我们高效地解决问题。例如，8.5.3 节中介绍的金字塔模型就是一种非常好的结构化思维模型。

6.1.5　模型不能代替现实

模型毕竟是模型，不能代替现实，就像类比不能代替问题本身一样。建模的过程与建模者的观察视角和对问题的认知有直接关系，所以我们要带着审视的眼光去看待模型。

就像牛顿认为两个物体之间的引力正比于它们质量的乘积，这是对一种特定现象的数学描述 —— 数学模型。牛顿自己推测过引力的可能原理：地球就像海绵一样，不断吸收天空降落下来的轻质流体，这种流体作用到地球上的物体，导致它们下降。很多年后，爱因斯坦提出了一种不同的引力原理模型 —— 广义相对论，引力被概念化为四维时空的几何特性。相比之下，爱因斯坦的引力模型显然更加科学，但引力的本质是什么，为什么时空弯曲可以产生引力，答案仍然是一个谜。

模型在软件开发中的作用也是一样的，我们也要用发展的眼光来看待模型，能解决当前问题的模型就是好模型，随着时间的推移，我们可能要像重构代码那样去重构模型，确保它能跟上我们对问题域的最新理解。

6.2　UML

在软件领域，影响力最强的建模工具当属统一建模语言（Unified Modeling Language，UML）了。

1997 年，对象管理组织（Object Management Group，OMG）发布了 UML。UML 的目标之一是为开发团队提供标准通用的设计语言来开发和构建计算机应用。UML 提出了一套 IT 专业人员期待多年的统一的标准建模符号

。通过使用 UML，用户能够阅读和交流系统架构和设计规划，就像建筑工人使用的建筑设计图一样。

UML 拥有一种定义良好的、富有表现力的表示法，这对软件开发过程非常重要。标准的表示法让分析师或开发者能够描述一个场景、阐明一种架构，并准确地将这些信息告诉别人。

总的来说，我们构建的 UML 模型将以一定的保真度和角度展现要构建的真实系统。但是复杂软件系统面临的问题是多样的，在不同的软件研发阶段，针对不同的使用目的，我们需要不同的模型图，每一种模型图都提供了系统的某一种视图。

UML 分为结构型和行为型建模图形，具体分类如图 6-4 所示。

图 6-4　UML 分类

关于 UML 的资料和书籍已有很多。在本书中，我不打算详尽描述每一种建模图形，需要进一步学习的读者，推荐阅读 Grady Booch 等人的《面向对象分析与设计》和 Larman 的《UML 和模式应用》这两本书。

下面详细介绍一下类图，主要有两个原因。

（1）首先，在面向对象设计中，类图占有非常重要的地位。类图不仅可以表示类之间的关系，其表示法还可以表达领域概念之间的关系，非常适合进行领域建模。在我的团队中，都是用类 UML 类图来制作领域模型的。

（2）其次，我在面试和工作的过程中发现很多应试者并不熟悉 UML 类图，要么不会画类图，要么用错表示法。

6.3　类图

类（Class）封装了数据和行为，是面向对象的重要组成部分，是具有相同属性、操作、关系的对象集合的总称。在系统中，每个类都具有一定的职责，职责指的是类要完成什么样的功能，要承担什么样的义务。

类图用于描述类以及它们的相互关系。在分析时，我们利用类图来说明实体共同的角色和责任，这些实体提供了系统的行为。在设计时，我们利用类图来记录类的结构，这些类构成了系统的架构。在类图中，两个基本元素是类，以及类之间的关系。

6.3.1　类的 UML 表示法

在 UML 中，类由包含类名、属性和操作 3 部分组成，这 3 部分使用分隔线分隔的矩形表示。例如，定义一个 Employee 类，包含属性 name、age 和 email，以及操作 getName ()，在 UML 类图中，该类如图 6-5 所示。

图 6-5　类图示例

Employee 类对应的 Java 代码片段如下：

public class

Employee {

private

String name;

private

int age;

private

String email;

public

void getName() {

return

name；

}

}

在 UML 类图中，类一般由以下 3 个部分组成。

（1）类名（Name）：每个类都必须有一个名字，类名是一个字符串。

（2）类的属性（Attributes）：属性指类的性质，即类的成员变量。一个类可以有任意多个属性，也可以没有属性。

（3）类的操作（Operations）：操作是类的任意一个实例对象都可以使用的行为，是类的成员方法。

类图中属性和操作的格式有规格说明。属性规格说明格式是「可见性 属性名称：类型」，比如「- name : String」。操作规格说明格式是「可见性 操作名称（参数名称：类型）：返回值类型」，比如「+ getName () : String」。

其中，可见性、名称和类型的定义分别如下。

可见性：表示该属性对于类外的元素而言是否可见，包括公有（public）、私有（private）和受保护（protected），在类图中分别用符号 +、- 和 #表示。

名称：按照惯例，类的名称以大写字母开头，单词之间使用驼峰隔开。属性和操作的名称以小写字母开头，后续单词使用驼峰。

类型：表示属性的数据类型，可以是基本数据类型，也可以是用户自定义类型。

类和类之间的关系主要有关联关系、依赖关系和泛化关系。接下来，我们重点来看这些关系的 UML 表示法。

6.3.2　类的关联关系

关联（Association）关系是一种结构化关系，用于表示一类对象与另一类对象之间有联系，如汽车和轮胎、师傅和徒弟、班级和学生等。关联关系是类与类之间常用的一种关系。在 UML 类图中，用实线连接有关联关系的对象所对应的类。在代码实现上，通常将一个类的对象作为另一个类的成员变量。

在使用类图表示关联关系时，可以在关联线上标注角色名，一般使用一个表示两者之间关系的动词或者名词来表示角色名（有时该名词为实例对象名），关系的两端代表两种不同的角色。因此，在一个关联关系中可以包含两个角色名，角色名并不是必需的，可以根据需要增加，其目的是使类之间的关系更加明确。

在 UML 中，关联关系通常又包含以下 6 种形式。

1．双向关联

在默认情况下，关联是双向的。例如，一位教师（Teacher）可以教授一或多门课程（Course），一门课程只能被一位教师教授，因此 Teacher 类和 Course 类之间具有双向关联关系，如图 6-6 所示。

图 6-6　双向关联实例

在图 6-6 中，三角形标注表示关联关系的阅读方向，是可选的。直线两边的数字代表关联的重数性（Multiplicity），也是可选的，表示两个关联对象在数量上的对应关系。在 UML 中，对象之间的多重性可以直接在关联直线上用一个数字或数字范围表示。

对象之间可以存在多种多重性关联的关系，常见的多重性表示方式如表 6-1 所示。

表 6-1　多重性表示方式

表示方法

多重性说明

1..1

表示另一个类的一个对象只与该类的一个对象有关系

0..*

表示另一个类的一个对象与该类的零个或多个对象有关系

1..*

表示另一个类的一个对象与该类的一个或多个对象有关系

0..1

表示另一个类的一个对象没有或只与该类的一个对象有关系

m..n

表示另一个类的一个对象与该类最少

m

，最多

n

个对象有关系 （

m

n

)

2．限定关联

限定关联（Qualified association）具有限定符（Qualifier），限定符的作用类似 HashMap 中的键（key），用于从一个集合中选择一个或多个对象。例如，一个用户（User）可以有多个角色（Role），但是在一个场景（Scenario）下，它只会是一种角色。

对于限定关联，有一点需要注意，即多重性的变化。例如，比较图 6-7a 和图 6-7b，限定减少了在关联目标端的多重性，通常是由多变为一，因为限定关联通常是从较大集合中选择一个实例。

图 6-7　限定关联实例

用代码实现限定关联时，成员变量通常是 Map，而 Map 的键就是限定符，图 6-7b 对应的 Java 代码片段如下：

public class

User {

private

Map<String, Role> roles;

public

Role getRole(String scenario){

return

roles.get(scenario);

}

}

public class

Role {

}

3．单向关联

类的关联关系也可以是单向的，单向关联用带箭头的实线表示。例如，顾客（Customer）拥有地址（Address），则 Customer 类与 Address 类具有单向关联关系，如图 6-8 所示。

图 6-8　单向关联实例

4．自关联

在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。例如，一个节点类（Node）的成员又是节点 Node 类型的对象，如图 6-9 所示。

图 6-9　自关联实例

设计模式中的装饰者模式也是一种自关联，都有类似如下的代码形式：

public class Node {

private Node subNode;

}

5．聚合关系

聚合（Aggregation）关系表示整体与部分的关联关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在 UML 中，聚合关系用带空心菱形的直线表示。例如，汽车发动机（Engine）是汽车（Car）的组成部分，但是汽车发动机可以独立存在，因此汽车和发动机是聚合关系，如图 6-10 所示。

图 6-10　聚合关系实例

在用代码实现聚合关系时，成员对象通常作为构造方法、Setter 方法或业务方法的参数注入整体对象中，图 6-10 对应的 Java 代码片段如下：

public class

Car {

private

Engine engine;

// 构造注入

public

Car(Engine engine) {

this

.engine = engine;

}

// 设值注入

public

void setEngine(Engine engine) {

this

.engine = engine;

}

}

public class

Engine {

}

6．组合关系

组合（Composition）关系也表示类之间整体和部分的关联关系，但是在组合关系中，整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有「同生共死」的关系。在 UML 中，组合关系用带实心菱形的直线表示。例如，人的头部（Head）与嘴（Mouth），嘴是头部的组成部分，如果头部不存在，那么嘴也就不存在了，因此头部和嘴是组合关系，如图 6-11 所示。

图 6-11　组合关系实例

在用代码实现组合关系时，通常在整体类的构造方法中直接实例化成员类。成员对象域整体对象有同样的生命周期，也就是要「共生死」，这也是组合和聚合的主要区别。代码上的体现是组合没有 Setter 方法，图 6-11 对应的 Java 代码片段如下：

public class

Head {

private

Mouth mouth;

public

Head() {

mouth =

new

Mouth (); // 实例化成员类

}

}

public class

Mouth {

}

6.3.3　类的依赖关系

依赖（Dependency）关系是一种使用关系，特定事物的改变可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时，使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。在 UML 中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。例如，教师（Teacher）上课时使用投影仪（Projector）进行演示，如图 6-12 所示。

在系统实施阶段，依赖关系通常通过 3 种方式来实现。

（1）第一种方式（也是常用的一种方式）是将一个类的对象作为另一个类中方法的参数，如图 6-12 所示。

图 6-12　依赖关系实例

（2）第二种方式是在一个类的方法中将另一个类的对象作为其局部变量。

（3）第三种方式是在一个类的方法中调用另一个类的静态方法。

第一种方式对应的 Java 代码片段如下：

public class

Teacher {

public

void use(Projector projector) {

projector.demonstrate();

}

}

public class

Projector {

public

void demonstrate() {

}

}

6.3.4　类的泛化关系

泛化（Generalization）关系也称为继承关系，用于描述父类与子类之间的关系。父类称为基类或超类，子类称为派生类。在 UML 中，泛化关系用带空心三角形的直线来表示。在代码实现时，我们使用面向对象的继承机制来实现泛化关系，例如，在 Java 语言中使用 extends 关键字。

举例说明，Student 类和 Teacher 类都是 Person 类的子类，Student 类和 Teacher 类继承了 Person 类的属性和方法，Person 类的属性包含姓名（name）和年龄（age），每一个 Student 和 Teacher 也都具有这两个属性。另外，Student 类增加了属性学号（studentNo），Teacher 类增加了属性教师编号（teacherNo），如图 6-13 所示。

图 6-13　泛化关系实例

图 6-13 对应的 Java 代码片段如下：

// 父类

public class

Person {

protected

String name;

protected

int age;

……

}

// 子类

public class

Student

extends

Person {

private

String studentNo;

……

}

// 子类

public class

Teacher

extends

Person {

private

String teacherNo;

……

}

6.3.5　接口与实现关系

面向对象语言中会引入接口的概念。在接口中，通常没有属性，其操作通常都是抽象的，只有操作的声明，没有操作的实现。在 UML 中，类与接口之间的实现关系通常是用带空心三角形的虚线来表示。例如，第 13 章介绍的「工匠平台」中，每一个度量项（Metrics）都是可度量的（Measurable），其实现如图 6-14 所示。

图 6-14　实现关系实例

需要注意的是，UML 提供了多种方法表示接口实现（Interface realization）。例如，在 UML 2 中新定义的插座表示法（Socket notation），有助于表示「类 X 需要（使用）接口 Y」。在上面的例子中，我们有一个统计类（Statistics）要使用度量项进行统计，其插座表示法如图 6-15 所示。

图 6-15　接口和实现的插座表示法

6.4　领域模型

在理解领域模型之前，我们先思考一下软件开发的本质是什么。从本质上来说，软件开发过程就是问题空间到解决方案空间的一个映射转化，如图 6-16 所示。

图 6-16　软件开发的本质

在问题空间中，我们主要是找出某个业务面临的挑战及其相关需求场景用例分析；而在解决方案空间中，则通过具体的技术工具手段来进行设计实现。

就软件系统来说，「问题空间」就是系统要解决的「领域」问题。因此，也可以简单理解为一个领域就对应一个问题空间，是一个特定范围边界内的业务需求的总和。

「领域模型」就是「解决方案空间」，是针对特定领域里的关键事物及其关系的可视化表现，是为了准确定义需要解决问题而构造的抽象模型，是业务功能场景在软件系统里的映射转化，其目标是为软件系统的构建统一的认知。

例如，请假系统解决的是人力工时的问题，属于人力资源领域，对口的是 HR 部门；费用报销系统解决的是员工和公司之间的财务问题，属于财务领域，对口的是财务部门；电商平台解决的是网上购物问题，属于电商领域。可以看出，每个软件系统本质上都解决了特定的问题，属于某一个特定领域，实现了同样的核心业务功能来解决该领域中核心的业务需求。

总结一下，领域模型在软件开发中的主要起到如下作用。

帮助分析理解复杂业务领域问题，描述业务中涉及的实体及其相互之间的关系，是需求分析的产物，与问题域相关。

是需求分析人员与用户交流的有力工具，是彼此交流的语言。

分析如何满足系统功能性需求，指导项目后续的系统设计。

关于如何进行领域建模，会在第 7 章中详细介绍。

6.5　敏捷建模

和开发模式一样，建模也可以用一套价值观、原则和实践来进行指导，以求尽可能地敏捷。敏捷建模方法的重点如下。

模型能用来沟通和理解。

力争用简单的工具创建简单的模型。

我们知道需求是变化的，因此创建模型时要拥抱变化。

重点是交付软件，而不是交付模型。模型能带来价值时，我们就使用；如果模型没有价值，不能加速软件的交付，就不创建它们。

我们只保留必要的模型。如果模型完成了它的使命，就可以把它扔掉。这能让我们轻装上阵，而不会陷入繁忙的工作。

我们使用多种模型。在使用模型时会考虑不同的角度和抽象层次，还有不同的读者。对于创建出来的所有模型，我们都知道它的读者是谁、要达成什么目标。如果我们还没理解目标，就不会创建模型。

6.6　广义模型

除了像 UML 这样的「正规军」，我认为凡是可以实现对复杂问题的抽象、帮助理解问题域、让沟通变得更高效的图形化方法都是建模。

6.6.1　C4 模型

C4 模型由 Simon Brown 提出。C4 模型提出使用上下文（Context）、容器（Container）、组件（Component）和代码（Code）等一系列分层的图表，来描述不同缩放级别的软件架构，其主要构件如图 6-17 所示。

图 6-17　C4 模型中的主要构件

6.6.2　UI 流程图

UI 流程图使用页面之间的流转来描述系统交互流程。用户可以通过 UI 流程图进行业务分析和检查，UI 流程图也可以作为系统文档向新人介绍业务。如图 6-18 所示，UI 流程图和 C4 模型一样，虽然不是标准的 UML，但也非常实用。

图 6-18　UI 流程图实例

6.6.3　业务模型

除描述技术以外，用户也可以用图形化的方式来描述业务。图形化的表达往往比文字更容易使人理解，也更加生动。原始人没有文字，漫长的进化过程诞生了文字后，人类处理图像的进程比语言快了 60000 倍

[1]

。我们回忆图片类的信息要比文字类信息容易 6 倍，这也是「一图胜千言」的原因。

图 6-19 描述了一个电商网站客户动线，虚线表示不同阶段跳出（终止交易），线条的粗细表示流量的大小，很形象、生动，我们可以很容易地看出来下单漏洞是如何发生的。

图 6-19　电商网站客户动线

图 6-20 是关于 O2O 就医的流程，这张图非常巧妙地使用了线条（line），线条本身除了表达时间顺序外，还用来作为线上（online）和线下（offline）的区隔，线条上面的是 online，下面的是 offline，直观明了，让人印象深刻。

图 6-20　基本就医的 O2O 流程

由此可见，好的图形表示法不仅需要我们对问题域有深入的理解，还要我们具备一定的想象力和创造力。UML 可以表达大部分软件工程中遇到的问题，提供了大家都熟悉的表示法，省去了重新理解图形元素的负担，因此我们应该优先使用 UML 来表达。但是在面对一些特殊场景时，UML 的表达能力有限，我们也可以尝试不一样的表达。

6.7　本章小结

建模在软件设计中占有重要的地位，是我们分析问题和架构设计的重要手段。UML 为我们提供了一套标准的需求分析和软件架构的表示法，共用一套表示法和描述语言的好处是可以减少认知成本，提升沟通效率。

但是，我们也要看到 UML 并没有覆盖所有的建模场景，有时我们不用完全拘泥于现有的教条。只要合理地使用线条、图形、箭头和颜色来描述我们想要表达的技术问题或者业务问题，就是好的「建模」。还是那句话，建模并不意味着要用特定的符号、工具和流程。不管你用什么建模工具、什么表示法，只要有助于对问题域的理解，就是好的模型。

[1]

信息参考自 Thermopylae Sciences + Technology 公司官网。

第 7 章　DDD 的精髓

