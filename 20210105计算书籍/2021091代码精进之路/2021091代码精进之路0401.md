每个人都有义务捍卫、遵守或完善原则。原则可以修正，但是不能肆意妄为。

—— 瑞·达利欧《原则》

所谓原则，就是一套前人通过经验总结出来的，可以有效解决问题的指导思想和方法论。遵从原则，可以事半功倍；反之，则有可能带来麻烦。

在软件设计领域中，有很多这样的原则，遵从这些设计原则可以有效地指导我们设计出更灵活、易于扩展和维护的软件系统。需要注意的是，和其他道理一样，原则并非是形而上学的静态客观真理，不是说每一个设计都要教条地遵守每一个原则，而是要根据具体情况进行权衡和取舍。

4.1　SOLID 概览

SOLID 是 5 个设计原则开头字母的缩写，其本身就有「稳定的」的意思，寓意是「遵从 SOLID 原则可以建立稳定、灵活、健壮的系统」。5 个原则分别如下。

Single Responsibility Principle（SRP）：单一职责原则。

Open Close Principle（OCP）：开闭原则。

Liskov Substitution Principle（LSP）：里氏替换原则。

Interface Segregation Principle（ISP）：接口隔离原则。

Dependency Inversion Principle（DIP）：依赖倒置原则。

SOLID 最早由 Robert C. Martin 在 2000 年的论文「Design Principles and Design Patterns」中引入。在 2004 年前后，Michael Feathers 提醒 Martin 可以调整一下这些原则的顺序，那么它们的首字母的缩写就可以排列成 SOLID。这个新名字的确促进了 SOLID 思想的传播，再一次证明了命名的重要性。

SOLID 原则之间并不是相互孤立的，彼此间存在着一定关联，一个原则可以是另一个原则的加强或基础；违反其中的某一个原则，可能同时违反了其他原则。其中，开闭原则和里氏代换原则是设计目标；单一职责原则、接口分隔原则和依赖倒置原则是设计方法。

4.2　SRP

任何一个软件模块中，应该有且只有一个被修改的原因。

SRP 要求每个软件模块职责要单一，衡量标准是模块是否只有一个被修改的原因。职责越单一，被修改的原因就越少，模块的内聚性（Cohesion）就越高，被复用的可能性就越大，也更容易被理解。

例如，有一个 Rectangle 类（如图 4-1 所示），该类包含两个方法，一个方法用于把矩形绘制在屏幕上，另一个方法用于计算矩形的面积。

图 4-1　Rectangle 类

按照 SRP 的定义，Rectangle 类是违反了 SRP 原则的。因为 Rectangle 类具有至少两个职责，不管是改变绘制逻辑，还是面积计算逻辑，都要改动 Rectangle 类。

为了遵从 SRP 原则，我们需要把两个职责分离出来，放在两个不同的类中，这样就可以互相不影响了。最简单的解决方案是将数据与函数分离，如图 4-2 所示。设计两个用来做逻辑处理的类，每个类只包含与之相关的函数代码，互相不可见，这样就不存在互相依赖的情况了。

图 4-2　数据和函数分离

上面的方式有点「贫血」模式的味道。我们也可以采用面向对象的做法，把重要的业务逻辑与数据放在一起，然后用 Rectangle 类来调用其他没那么重要的函数，如图 4-3 所示。

图 4-3　业务逻辑和数据在一起

另外，SRP 不仅在模块和类级别适用，在函数级别同样适用，3.6 节中已经介绍了如何做到函数级别的 SRP。

4.3　OCP

软件实体应该对扩展开放，对修改关闭。

对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改关闭，意味着类一旦设计完成，就可以独立完成工作，而不要对其进行任何修改。

为什么 OCP 这么重要？因为可扩展性是我们衡量软件质量的一个重要指标。在软件的生命周期内，更改是难免的，如果有一种方案既可以扩展软件功能，又可以不修改原代码，那是我们梦寐以求的。因为不修改就意味着不影响现有业务，新增的代码不会对既有业务产生影响，也就不会引发漏洞。

在面向对象设计中，我们通常通过继承和多态来实现 OCP，即封装不变部分。对于需要变化的部分，通过接口继承实现的方式来实现「开放」。因此，区别面向过程语言和面向对象语言最重要的标志就是看它是否支持多态。

实际上，很多的设计模式都以达到 OCP 目标为目的。例如，装饰者模式，可以在不改变被装饰对象的情况下，通过包装（Wrap）一个新类来扩展功能；策略模式，通过制定一个策略接口，让不同的策略实现成为可能；适配器模式，在不改变原有类的基础上，让其适配（Adapt）新的功能；观察者模式，可以灵活地添加或删除观察者（Listener）来扩展系统的功能。

当然，要想做到绝对地「不修改」是比较理想主义的。因为业务是不确定的，没有谁可以预测到所有的扩展点，因此这里需要一定的权衡，如果提前做过多的「大设计」，可能会犯 YAGNI（You Ain't Gonna Need It）的错误。

4.4　LSP

程序中的父类型都应该可以正确地被子类型替换。

里氏替换原则由 2008 年图灵奖得主、美国第一位计算机科学女博士 Barbara Liskov 教授和卡内基·梅隆大学的 Jeannette Wing 教授于 1994 年提出。

LSP 认为「程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的」，即子类应该可以替换任何基类能够出现的地方，并且经过替换后，代码还能正常工作。

根据 LSP 的定义，如果在程序中出现使用 instanceof、强制类型转换或者函数覆盖，很可能意味着是对 LSP 的破坏。

4.4.1　警惕 instanceof

如果我们发现代码中有需要通过强制类型转换才能使用子类函数的情况，或者要通过 instanceof 判断子类类型的地方，那么都有不满足 LSP 的嫌疑。

出现这种情况的原因是子类使用的函数没有在父类中声明。在程序中，通常使用父类来进行定义，如果一个函数只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该函数。

可以通过 提升抽象层次来解决此问题

，也就是将子类中的特有函数用一种更抽象、通用的方式在父类中进行声明。这样在使用父类的地方，就可以透明地使用子类进行替换了，具体做法请参考 8.5.2 节。

4.4.2　子类覆盖父类函数

子类方法覆盖（Override）了父类方法，并且改变了其含义。这样在做里氏替换时，就会出现意想不到的问题。

在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反之，则不成立。如果一个软件实体使用的是一个子类对象，那么它不一定能够使用基类对象。例如，我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。

有时，现实世界中「is-a」的关系，在软件设计中不一定适合使用继承关系。好的继承应该是子类可以替换任何父类出现的地方，而不出现问题。如果两个实体有内在的「is-a」的关系，但是在外在行为上表现并不一致，我们就需要警惕继承在此是不是最合适的了。

例如，正方形是一个矩形，但是如果你把正方形设计成矩形的子类，就会出现一些意想不到的问题。以计算面积为例，矩形是 a 乘以 b，而正方形是 a 的平方，它们在含义上是有区别的。

假如 Rectangle 类是如下形式：

public class

Rectangle {

protected

int width;

protected

int height;

public

void setWidth(int width) {

this

.width = width;

}

public

void setHeight(int height) {

this

.height = height;

}

public

int area(){

return

width * height;

}

}

现在我们想要用 Square 去继承 Rectangle，并且复用其计算面积的方法。为了适配 Rectangle 的行为，我们可以在 Square 做 set 操作时做一些判断，如果不符合正方形的定义，则抛出异常，其代码如下：

public class

Square

extends

Rectangle {

@Override

public

void setWidth(int width){

throw new

RuntimeException("setWidth is not available for Square");

}

@Override

public

void setHeight(int height){

throw new

RuntimeException("setHeight is not available for Square");

}

public

void setLength(int length){

this

.width =

this

.height = length;

}

}

这样的设计实际上破坏了 LSP 原则，因为在 Retangle 出现的地方使用 Square 进行替换，就会抛出异常。实际上，这也是一个著名的设计问题 —— 正方形 - 矩形问题（Square-rectangle Problem），有兴趣的读者可以探索更多解法。

4.5　ISP

多个特定客户端接口要好于一个宽泛用途的接口。

接口隔离原则认为不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口要好。

我们先分别来看不遵循 ISP（见图 4-4）和遵循 ISP（见图 4-5）。

图 4-4　未遵循 ISP 的示例

图 4-5　遵循 ISP 的示例

对比二者可以发现，遵循 ISP 的做法，在依赖关系和语义的表达上会更加精确。类 A 不需要用到「方法 4」和「方法 5」，就可以选择不依赖他们。

在做接口拆分时，我们也要满足单一职责原则，让一个接口的职责尽量单一，而不是像图 4-4 中那样无所不包。满足 ISP 之后，最大的好处是可以将外部依赖减到最少。你只需要依赖你需要的东西，这样可以降低模块之间的耦合（Couple）。

4.6　DIP

模块之间交互应该依赖抽象，而非实现。

DIP 要求高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖细节，细节应该依赖抽象。

类不是孤立的，一个类需要依赖于其他类来协作完成工作。但是这种依赖不应该是特定的具体实现，而应该依赖抽象。也就是我们通常所说的要「 面向接口编程

」。然而「面向接口编程」只是实现 DIP 的一个技法，DIP 本身的意义要宽泛得多，它是一种思想，是一种软件设计的哲学。

这个原则实在是太重要了，社会化分工协作在某种意义上也是在遵从 DIP。例如，一个生产计算机主板的公司，其显卡插槽肯定是按照业界标准接口（共同抽象）来设计的，而不会设计成只支持某个特定公司的显卡。这样，只要主板公司和显卡公司都依赖同一个抽象（显卡接口协议），就能实现互通了。

遵循 DIP 会大大提高系统的灵活性。如果类只关心它们用于支持的特定契约，而不是特定类型的组件，就可以快速而轻松地修改这些低级服务的功能，同时最大限度地降低对系统其余部分的影响。

例如，在 Java 应用中使用 Logger 框架有很多选择，比如 log4j、logback、common logging 等。每个 Logger 的 API 和用法都稍有不同，有的需要用 isLoggable () 来进行预判断，以便提高性能，有的则不需要。如果要切换不同的 Logger 框架，会非常复杂，可能要改动很多地方。产生这些问题的原因是我们直接依赖了 Logger 框架，应用和 Logger 框架强耦合在一起了。

我曾维护过的一个阿里巴巴的交易系统，其中就有非常复杂的 Logger 依赖关系，如图 4-6 所示。

图 4-6　复杂的 Logger 依赖关系

导致这种复杂依赖的根源，是引用直接依赖了 Logger 框架（见图 4-7），导致后续的 Logger 框架升级必须要保持向后兼容，最终形成了图 4-6 中复杂的依赖关系。

图 4-7　直接依赖 Logger

实际上，只要遵循依赖倒置原则（如图 4-8 所示），这类问题就会很容易解决。依赖倒置，就是要反转依赖的方向，让原来紧耦合的依赖关系得以解耦，这样依赖方和被依赖方都有更高的灵活度。

图 4-8　依赖倒置后的 Logger 依赖

所以我强烈建议所有的业务系统都应该有这样一个 Logger 抽象，来屏蔽对具体 Logger 框架的依赖。这也是为什么我们要在 COLA 中引入新的 Logger 抽象，目的就是要和具体的 Logger 框架进行解耦。

除了组件级别的 DIP，在架构层面，DIP 同样有着重要的指导意义。例如，在 COLA 架构中，领域层不应该直接依赖基础设施层，它们之间的解耦就是通过 DIP 完成的。关于领域层的设计的内容，可以参考 7.8.3 节和 12.3 节。

4.7　DRY

DRY 是 Don't Repeat Yourself 的缩写，DRY 原则特指在程序设计和计算中避免重复代码，因为这样会降低代码的灵活性和简洁性，并且可能导致代码之间的矛盾。DRY 是 Andy Hunt 和 Dave Thomas 在 The Pragmatic Programmer

一书中提出的核心原则。

系统的每一个功能都应该有唯一的实现。也就是说，如果多次遇到同样的问题，就应该抽象出一个共同的解决方法，不要重复开发同样的功能。在 8.5.1 节中，我们通过创建缺失的抽象来消除重复代码，就是一个很好的 DRY 案例。

贯彻 DRY 可以让我们避免陷入「散弹式修改（Shotgun Surgery）」的麻烦，「散弹式修改」是 Robert Martin 在《重构》一书中列出的一个典型代码「坏味道」，由于代码重复而导致一个小小的改动，会牵扯很多地方。

4.8　YAGNI

YAGNI（You Ain't Gonna Need It）的意思是「你不会需要它」，出自 Ron Jeffries 的 Extreme Programming Installed

一书。

YAGNI 是针对「大设计」（Big Design）提出来的，是「极限编程」提倡的原则，是指你自以为有用的功能，实际上都是用不到的。因此，除了核心的功能之外，其他的功能一概不要提前设计，这样可以大大加快开发进程。它背后的指导思想就是尽可能快、尽可能简单地让软件运行起来。

但是，这里出现了一个问题。仔细推敲，你会发现 DRY 原则和 YAGNI 原则是不兼容的。前者追求「抽象化」，要求找到通用的解决方法；后者追求「快和省」，意味着不要把精力放在抽象化上面，因为很可能「你不会需要它」。因此，就有了 Rule of Three 原则。

4.9　Rule of Three

Rule of Three 也被称为「三次原则」，是指当某个功能第三次出现时，就有必要进行「抽象化」了。这也是软件大师 Martin Fowler 在《重构》一书中提出的思想。

三次原则指导我们可以通过以下步骤来写代码。

（1）第一次用到某个功能时，写一个特定的解决方法。

（2）第二次又用到的时候，复制上一次的代码。

（3）第三次出现的时候，才着手「抽象化」，写出通用的解决方法。

这 3 个步骤是对 DRY 原则和 YAGNI 原则的折中，是代码冗余和开发成本的平衡点。同时也提醒我们反思，是否做了很多无用的超前设计、代码是否开始出现冗余、是否要重新设计。软件设计本身就是一个平衡的艺术，我们既反对过度设计（Over Design），也绝对不赞成无设计（No Design）。

4.10　KISS 原则

KISS（Keep It Simple and Stupid）最早由 Robert S. Kaplan 在著名的平衡计分卡理论中提出。他认为把事情变复杂很简单，把事情变简单很复杂。好的目标不是越复杂越好，反而是越简洁越好。

KISS 原则被运用到软件设计领域中，常常会被误解，这成了很多没有设计能力的工程人员的挡箭牌。在此，我们一定要理解「简单」和「简陋」的区别。

真正的「简单」绝不是毫无设计感，上来就写代码，而是「宝剑锋从磨砺出」，亮剑的时候犹如一道华丽的闪电，背后却有着大量的艰辛和积累。真正的简单，不是不思考，而是先发散、再收敛。在纷繁复杂中，把握问题的核心。

4.11　POLA 原则

POLA（Principle of least astonishment）是最小惊奇原则，写代码不是写侦探小说，要的是简单易懂，而不是时不时冒出个「Surprise」。

在《复杂》一书的第 7 章「度量复杂性」中，就阐述了用「惊奇度」来度量复杂度的方法，「惊奇度」越高，复杂性越大，这也是侦探小说要比一般小说更「烧脑」的原因。

如何减少「惊奇」呢？首要的当然是规范和标准。在第 2 章中，我们已经讨论了大量的代码规范和设计规范，给出了可落地实施的案例。

4.12　本章小结

本章介绍的设计原则能够指导我们编写出更好的代码。但还是那句话，不要教条，软件是一种平衡的艺术。要清楚一点，我们不是为了满足这些原则而工作的，原则只是背后的指导思想。我们的目的是构建可用的软件系统，并尽量减少系统的复杂度。在不能满足所有原则时，要懂得适当取舍。

第 5 章　设计模式

