# 2020027郑晔的软件设计之美R01

## 0100. 了解一个软件的设计

1、了解设计，先模型，再接口，最后是实现。

2、理解模型，要了解模型设计的来龙去脉。

3、理解一个项目的接口，先找主线，再看风格。

4、理解实现，带着自己的问题，了解软件的结构和关键的技术。

## 0101. 三步走：如何了解一个软件的设计？

今天，我们学习了如何了解一个软件设计，可以从三个部分入手：模型、接口和实现。1）模型，也可以称为抽象，是一个软件的核心部分，是这个系统与其它系统有所区别的关键，是我们理解整个软件设计最核心的部分。2）接口，是通过怎样的方式将模型提供的能力暴露出去，是我们与这个软件交互的入口。3）实现，就是软件提供的模型和接口在内部是如何实现的，是软件能力得以发挥的根基。

了解设计的顺序应该是，先模型，再接口，最后是实现。了解设计，需要一层一层地展开，在每个层次都按照模型、接口和实现进行理解，在头脑中形成一棵设计树。现在你已经有了一个了解设计的基本方法，接下来几讲，我会用几个开源项目带你再进一步，去看看如何去了解模型、接口和实现。如果今天的内容你只能记住一件事，那请记住：了解设计，先模型，再接口，最后是实现。

经过了前面几讲的铺垫，我们已经对软件设计是什么，以及要考虑哪些因素有了一个初步的了解。热身之后，就该开启正式的旅程了。作为一个程序员，我们在职业生涯中免不了要接手新项目，承担维护该项目的职责。如果一个新项目摆在面前，你会怎么去研究它呢？

很多人的第一反应就是去看源代码。但是，一头扎入代码中，很快你就会迷失其中，最初那股子探索精神，也会逐渐被迷茫所代替。回想一下，有多少次你满怀希望地打开一个开源项目，结果多半都是坚持不了多久就放弃了。你有没有想过，问题出在哪里呢？你的迷茫在于缺少对这个软件整体的了解，这就如同不带地图指南针闯入密林一般，迷路只是早晚的事。所以，虽然阅读源码是必经的一步，却不应该是你的第一步。我们应该先从了解软件的设计开始。那我们该如何了解一个软件的设计呢？

### 1.1 模型、接口和实现

了解一个软件的设计可以从三个部分着手：模型、接口和实现。这三者的关系就好比你去看代码，你会先去看有哪些类以及它们之间的关系，这就是看模型；然后你会打开一个具体的类，看它提供了哪些方法，这就相当于看接口；最后，你再来打开一个具体的方法，去看它的代码是怎么写的，这就是看实现。

好，接下来，我们具体地分析一下每一个部分。首先是模型，它是一个软件的核心部分。在其它的材料里，也有人称之为抽象，为了统一，我这里就都叫模型了。我们在前面的课程里也说过，设计最关键的就是构建出模型。而理解一个设计中的模型，可以帮助我们建立起对这个软件整体的认知。

比如，你在编写分布式计算代码时，需要考虑怎样在不同的节点上调度计算；而使用 MapReduce 时，只要考虑如何把计算分开（Map）最后再汇总（Reduce）；而到了 Spark，注意力就集中在要做怎样的计算上。它们在解决同样的问题，只是抽象层次逐步提高了，越来越接近要解决的问题，越来越少地考虑计算在不同的机器上是如何执行的，由此，降低了理解的门槛。当你知道了模型的重要性，目光甚至可以不局限在某一个软件上。如果把同一个领域不同阶段的多个模型联系起来看，你还能看到软件发展的趋势。

其次是接口，它决定了软件通过怎样的方式，将模型提供的能力暴露出去。它是我们与这个软件交互的入口。如何理解这句话呢？我给你举几个具体的例子。1）一个程序库的接口就是它的 API，但对于同样的模型，每个人会设计出不同的 API，而不同的 API 有着不同的表达能力。比如：Google 的 Guava 对 JDK 的一些 API 重新做了封装，其目的就是简化开发，而很多优秀的做法后来又被 JDK 学了回去。2）一个工具软件一般会提供命令行接口，比如，每个程序员必备的基本技能 ——Unix 命令行工具就是典型的命令行接口。3）一个业务系统的接口，就是对外暴露的各种接口，比如，它提供的各种 REST API，也可能是提供了 RPC 给其它系统的调用……如果你想深入源码，去了解一个软件，接口是一个很好的指向标。你可以从一个接口进入到软件中，看它是怎样完成各种基本功能的。

最后是实现，就是指软件提供的模型和接口在内部是如何实现的，这是软件能力得以发挥的根基。这么说可能比较抽象，我再来举些例子。1）一个业务系统收到一个请求之后，是把信息写到数据库，还是转发给另外的系统。2）一个算法的实现，是选择调用与别人已有的程序库，还是需要自己实现一个特定的算法。3）一个系统中的功能，哪些应该做成分布式的，哪些应该由一个中央节点统一处理。4）一段业务处理，是应该做成单线程，还是多线程的。5）当资源有竞争，是每个节点自己处理，还是交由一个中间件统一处理。6）不同系统之间的连接，该采用哪种协议，是自己实现，还是找一个中间件……

讲到这，相信你一定发现了，「实现」里面的内容很多。所以，做每一个技术决策都应该结合自己所开发应用的特点，并不存在一个通用的解决方案。在实际的工作中，我发现许多人以为的设计其实是这里所讲的实现。

我也知道，「实现」很重要，但是，它必须建立在模型和接口的基础之上。因为在一个系统的设计中，模型是最核心的部分。如果模型变了，这个软件便不再是这个软件了，而接口通常反映的就是模型。所以，模型和接口的稳定度都要比实现高，实现则是要随着软件发展而不断调整。

举个例子，很多人都知道 Redis 这个键值对存储性能非常好，他们学习 Redis 时，对其单线程模型印象深刻，因为它简单高效。但随着人们使用 Redis 的增多，对 Redis 有了进一步的需求。所以，从 6.0 开始，它开始支持多线程版本，以便于更好地满足人们的需求。但即便 Redis 改成了多线程，它还是那个 Redis，它的模型和接口还是一如既往，只是实现变了而已。

### 1.2 了解设计三步走

之所以要把模型、接口和实现区分开来，是因为这三者的关注点是不同的，而很多人在讨论所谓的「设计」时，经常会把它们混在一起。如果你在讨论的时候连「讨论的内容到底是什么」都没弄清楚，就很难得出一个清晰的结果。我参与过很多类似的讨论，经常有一种很混乱的感觉。我思考了很长时间才发现，问题就在于他们把不同层面的内容混在了一起。

所以正确的做法是什么呢？就是你在讨论设计时应该遵循一个顺序，先模型，再接口，最后是实现，同理，了解一个设计也应该遵循这样的顺序。

如果模型都还没有弄清楚，就贸然进入细节的讨论，你很难分清哪些东西是核心，是必须保留的，哪些东西是可以替换的。如果你清楚了解了模型，也就知道哪些内容在系统中是广泛适用的，哪些内容必须要隔离。简单地说，分清模型会帮助你限制实现的使用范围。

下面是一张简化过的架构图，在这幅图里，订单模块完成处理之后，通过一个 Kafka 队列把消息发给支付模块，支付模块处理之后，再通过一个 Kafka 队列把消息发给物流模块。很多人都应该在自己的项目中见过类似的，但是更复杂的架构图。你能看出这张图的问题在哪吗？

这张架构图的问题就在于，它把模型和实现混淆在一起了。图中的订单、支付和物流，说的都是模型层面的东西，但 Kafka 的出现，就把实现层面的东西拉了进来。Kafka 只是实现这个功能时的一个技术选型，这也就意味着，如果随着业务的发展，它不能很好地扮演它的角色，你就可以替换掉它，而整个设计是不用变的。所以，实现这段代码的时候，必须把 Kafka 相关的代码进行封装，不能在系统各处随意地调用，因为它属于实现，是可能被替换的。

我还要强调一点，在了解设计时，要按层次去了解，因为设计常常是分层的。每当我们打开一个层次，需要了解它的内部时，我们还要按照模型、接口和实现的顺序解读这个层次。

我用大家比较熟悉的操作系统来举个例子，如果你去了解它的内部，就知道它有内存管理、进程调度、文件系统等模块。我们可以按照模型、接口和实现去理解每个模块，就以进程管理为例：1）进程管理的核心模型就包括进程模型和调度算法；2）它的接口就包括，进程的创建、销毁以及调度算法的触发等；3）不同调度算法就是一个个具体的实现。

操作系统课程难以学习，很大程度上就在于，很多人没有搞清楚其中各个概念之间的关系。即便层层展开到最后，到了一个具体类，甚至是一个具体的数据结构，我们依然可以按照模型、接口和实现这个结构来理解，比如很多 Java 面试题常问到的 HashMap：1）它的模型就是我们在数据结构中学习的 HashMap；2）它定义了一些接口，比如，get、put 等；3）它的实现原来是用标准的 HashMap 实现，后来则借鉴了红黑树。

实际上，当你能够一层一层地去理解设计，就像一棵知识树逐渐展开一样，每一个知识节点在展开的时候，都会有下面一级更具体的内容。当你的头脑中有了这样一棵设计树，你也就掌握了整个系统的地图，再有新需求到来时，你就不会再盲目地去改代码了。

### 黑板墙

现在的开源项目越来越多，每个开源项目都会提供一些不同的特点，请你找一些自己感兴趣的开源项目，看看它们分别提供了什么，是新的模型、是新的接口，还是新的实现？

模型，通常包含两类要素，一是基本元素，二是这些元素之间的关系。比如常见的 CRM，基本元素就包括项目、客户、合同和回款，相互之间的主要关系通常是客户报备，进入立项环节（评估投入产出），再签约，最后进入回款环节。这是基本模型。这个模型（系统）的接口，就是要为 BD 提供从客户报备到签约、回款的整个流程管理。实现就是要考虑如何用消息在这些模块之间传递数据，状态控制、数据查重锁定等等。作者回复：赞，这个思路很清晰！2020-06-01

当使用一个新的库或者框架的时候，首先看的是接口，看对外提供的功能的是否满足自己的要求，然后才是具体的实现。对于模型，想学习开源软件的架构的时候在去关注的。2020-06-01

思考：1）模型：圈定了数据，明确了边界。在我的数据范围内的业务才是我的业务。模型是业务的抽象定义。2）接口：定义了功能，明确了提供什么服务和这个服务的规格。接口是业务的功能口径。3）实现：选择技术，明确了功能的性能，满足接口的规格，实现业务的逻辑。实现与业务无关，只考虑接口规格和技术选型。2020-06-01

看 rocketmq 的文档，可以先从 [rocketmq/concept.md at master · apache/rocketmq](https://github.com/apache/rocketmq/blob/master/docs/cn/concept.md) 了解模型开始。作者回复：很好的补充！2020-06-02

这个分析思路比较好，好多一上来就深入源码细节（实现）容易懵，特别是集成关系比较重的时候，最后都不知道调用到哪地方去了，这样就需要单步跟踪才能了解其脉络。若是先分析了类的层次关系，有个一定的理解，后面的调用脉络就有一定的清晰认识。模型这部分比较难理解，要想到作者为什么会这样定义模型，这样的设计用途是什么，可能刚开始不了解，到实现部分有种豁然开朗的感觉。2020-06-01

看了文章，知道自己以前为什么读不懂源码了，因为我每次都是从「实现」入手，想要自顶向上的去了解整个软件的架构，也许这条路也能走通，但是难度太大。之前看过《代码阅读方法与实践》（和大多数书一样没能看完），这本书其实就是从细节开始讲起的，书是好书，但是我的打开方式似乎有点问题。进程管理的模型包括调度算法，这个稍微有一点不好理解，我之前以为模型都是一些比较「实」的东西。不过如果从模型是「名词」/ 概念，接口是「动词」/ 命令，实现是动作 / 技术细节这个角度就更清楚一些。翻回到专栏的第一篇，老师举例说在交易系统中，有交易原语：下单、成交和撤单，交易动作：冻结、解冻、出金、入金，当时解释说这是模型上的分层。那么我的问题是，这些原语和动作都当做模型来看待么？如果让我来分析，那么交易系统的模型可能是：用户、商品、订单、支付、物流；接口是：下单、成交、撤单……作者回复：模型只有名词是一个误区，模型里会包含动词的，比如，Service 从角色上讲，就是一种动词。后面你还会看到相关的讨论。2020-06-01

模型是否可以这样理解：它可以包括，软件中有哪些类，类与类之间是如何组织的；软件中用了哪些框架（是 MVC，还是 DDD，TTD；也可以是业务模块之间的关系。总之，它是软件最基础，最核心的，也是最不可变的内容，最有别于其他软件的部分。作者回复：你可以把模型理解成一个个的类，但是，到了框架，就和实现相关了。MVC 是一种设计模式，DDD 是一种设计方法，TDD 是一种实践。2020-06-09

模型：需求，接口：可以提供哪些功能，实现：实现模型和接口的办法，语言，框架等技术。2020-06-06

以前一直以为 react 的接口设计很有前瞻性，以至于它们的内部架构改了几次对于使用者来说都没什么影响。读了这个课程之后才发现，它们只是严格遵循了软件设计的原则罢了。以前一直苦于不知如何改进现有项目的腐败点以及文档的产出，在这里我找到了切入点了。作者回复：好的设计都是类似的。2020-06-06

分析框架的流程应当从子模型往上建模，若从 mvc 入手，开始分析其内部的子模型是怎么实现，感觉虽然明显看到顶层模型的交互但是会很含糊。认为应当自底向上的进行分析，从框架运行的流程（生命周期）进行模型分析再上升为组件模型，最后总结 mvc 模型 / 其他模型，这种分析的方式，虽然相反，但是感觉更容易懂。2020-06-01

使用一个软件，就是通过其接口进行的。接口分为 api 和 ui。要想正确使用一个东西，就要知道一点内部的原理。模型是对内部原理的简化，可以让人快速上手。如果想玩一些高级的玩法，或者想要改造软件，就少不了研究实现了。接口和模型组合起来，就相当于一个「ADT」。作者回复：很好的补充，但 ADT 的说法，容易让人误解成实现。2020-06-01

理解软件开发中的设计可以通过三步走套路：模型 -> 接口 -> 实现，这个也就是了解软件设计的「模型」。1）模型其实是一个软件设计中的抽象，通过与其它软件设计中的进行对比学习，理解它们的异同，突出自身的核心抽象结构；2）接口是软件交互的入口，是一个软件系统的能力提现，它是一种规范，它与模型共同组成了软件系统的稳定性因素；3）实现是软件设计中对模型和接口的具体的逻辑实现，这个很好理解。2020-06-01

例如在 C++ 的一个小系统中，模型可以理解为定义的类么？接口类似于类里面的函数，接口类似于函数的调用？作者回复：后面你会看到不同的模块组织方式，本质上，C++ 的组织方式只有一个「类」的概念，幸好有宏定义，可以定义出不同的概念。2020-06-04

## 0102. Spring DI 容器：如何分析一个软件的模型？

今天，我们学习了如何了解设计的第一部分：看模型。理解模型，要知道项目提供了哪些模型，这些模型都提供了怎样的能力。但还有更重要的一步就是，要了解模型设计的来龙去脉。这样，一方面，可以增进了我们对它的了解，但另一方面，也会减少我们对模型的破坏或滥用。

我以 Spring 的 DI 容器为例给你讲解了如何理解模型。DI 容器的引入有效地解决了对象的创建和组装的问题，让程序员们拥有了一个新的编程模型。按照这个编程模型去写代码，整体的质量会得到大幅度的提升，也会规避掉之前的许多问题。这也是一个好的模型对项目起到的促进作用。像 DI 这种设计得非常好的模型，你甚至不觉得自己在用一个特定的模型在编程。有了对模型的了解，我们已经迈出了理解设计的第一步，下一讲，我们来看看怎样理解接口。如果今天的内容你只能记住一件事，那请记住：理解模型，要了解模型设计的来龙去脉。

在上一讲中，我们讨论了如何了解一个软件的设计，主要是从三个部分入手：模型、接口和实现。那么，在接下来的三讲中，我将结合几个典型的开源项目，告诉你如何具体地理解一个软件的模型、接口和实现。

今天这一讲，我们就先来谈谈了解设计的第一步：模型。如果拿到一个项目，我们怎么去理解它的模型呢？我们肯定要先知道项目提供了哪些模型，模型又提供了怎样的能力。这是所有人都知道的事情，我并不准备深入地去探讨。但如果只知道这些，你只是在了解别人设计的结果，这种程度并不足以支撑你后期对模型的维护。

在一个项目中，常常会出现新人随意向模型中添加内容，修改实现，让模型变得难以维护的情况。造成这一现象的原因就在于他们对于模型的理解不到位。我们都知道，任何模型都是为了解决问题而生的，所以，理解一个模型，需要了解在没有这个模型之前，问题是如何被解决的，这样，你才能知道新的模型究竟提供了怎样的提升。也就是说，理解一个模型的关键在于，要了解这个模型设计的来龙去脉，知道它是如何解决相应的问题。今天我们以 Spring 的 DI 容器为例，来看看怎样理解软件的模型。

### 2.1 耦合的依赖

Spring 在 Java 世界里绝对是大名鼎鼎，如果你今天在做 Java 开发而不用 Spring，那么你大概率会被认为是个另类。今天很多程序员都把 Spring 当成一个成熟的框架，很少去仔细分析 Spring 的设计。但作为一个从 0.8 版本就开始接触 Spring 的程序员，我刚好有幸经历了 Spring 从渺小到壮大的过程，得以体会到 Spring 给行业带来的巨大思维转变。

如果说 Spring 这棵参天大树有一个稳健的根基，那其根基就应该是 Spring 的 DI 容器。DI 是 Dependency Injection 的缩写，也就是「依赖注入」。Spring 的各个项目都是这个根基上长出的枝芽。那么，DI 容器要解决的问题是什么呢？它解决的是组件创建和组装的问题，但是为什么这是一个需要解决的问题呢？这就需要我们了解一下组件的创建和组装。

在前面的课程中，我讲过，软件设计需要有一个分解的过程，所以，它必然还要面对一个组装的过程，也就是把分解出来的各个组件组装到一起，完成所需要的功能。为了叙述方便，我采用 Java 语言来进行后续的描述。

我们从程序员最熟悉的一个查询场景开始。假设我们有一个文章服务（ArticleService）提供根据标题查询文章的功能。当然，数据是需要持久化的，所以，这里还有一个 ArticleRepository，用来与持久化数据打交道。熟悉 DDD 的同学可能发现了，这个仓库（Repository）的概念来自于 DDD。如果你不熟悉也没关系，它就是与持久化数据打交道的一层，和一些人习惯的 Mapper 或者 DAO（Data Access Object）类似，你可以简单地把它理解成访问数据库的代码。

```java
class ArticleService {
  //提供根据标题查询文章的服务
  Article findByTitle(final String title) {
    ...
  }
}

interface ArticleRepository {
  //在持久化存储中，根据标题查询文章
  Article findByTitle(final String title)；
}
```

在 ArticleService 处理业务的过程中，需要用到 ArticleRepository 辅助它完成功能，也就是说，ArticleService 要依赖于 ArticleRepository。这时你该怎么做呢？一个直接的做法就是在 ArticleService 中增加一个字段表示 ArticleRepository。

```java
class ArticleService {
  private ArticleRepository repository;
  
  public Article findByTitle(final String title) {
    // 做参数校验
    return this.repository.findByTitle(title);
  }
}
```

目前看起来一切都还好，但是接下来，问题就来了，这个字段怎么初始化呢？程序员一般最直接的反应就是直接创建这个对象。这里选用了一个数据库版本的实现（DBArticleRepository）。

```java
class ArticleService {
  private ArticleRepository repository = new DBArticleRepository();
  
  public Article findByTitle(final String title) {
    // 做参数校验
    return this.repository.findByTitle(title);
  }
}
```

看上去很好，但实际上 DBArticleRepository 并不能这样初始化。正如这个实现类的名字所表示的那样，我们这里要用到数据库。但在真实的项目中，由于资源所限，我们一般不会在应用中任意打开数据库连接，而是会选择共享数据库连接。所以，DBArticleRepository 需要一个数据库连接（Connection）的参数。在这里，你决定在构造函数里把这个参数传进来。

```java
class ArticlService {
  private ArticleRepository repository;
  
  public ArticlService(final Connection connection) {
    this.repository = new DBArticleRepository(connection);
  }
  
  public Article findByTitle(final String title) {
    // 做参数校验
    return this.repository.findByTitle(title);
  }
}
```

好，代码写完了，它看上去一切正常。如果你的开发习惯仅仅到此为止，可能你会觉得这还不错。但我们并不打算做一个只写代码的程序员，所以，我们要进入下一个阶段：测试。

一旦开始准备测试，你就会发现，要让 ArticleService 跑起来，那就得让 ArticleRepository 也跑起来；要让 ArticleRepository 跑起来，那就得准备数据库连接。是不是觉得太麻烦，想放弃测试。但有职业素养的你，决定坚持一下，去准备数据库连接信息。然后，真正开始写测试时，你才发现，要测试，你还要在数据库里准备各种数据。比如，要测查询，你就得插入一些数据，看查出来的结果和插入的数据是否一致；要测更新，你就得先插入数据，测试跑完，再看数据更新是否正确。

不过，你还是没有放弃，咬着牙准备了一堆数据之后，你突然困惑了：我在干什么？我不是要测试服务吗？做数据准备不是测试仓库的时候应该做的事吗？那么，问题出在哪儿呢？其实就在你创建对象的那一刻，问题就出现了。

### 2.2 分离的依赖

为什么说从创建对象开始就出问题了呢？因为当我们创建一个对象时，就必须要有一个具体的实现类，对应到我们这里，就是那个 DBArticleRepository。虽然我们的 ArticleService 写得很干净，其他部分根本不依赖于 DBArticleRepository，只在构造函数里依赖了，但依赖就是依赖。

与此同时，由于要构造 DBArticleRepository 的缘故，我们这里还引入了 Connection 这个类，这个类只与 DBArticleRepository 的构造有关系，与我们这个 ArticleService 的业务逻辑一点关系都没有。所以，你看到了，只是因为引入了一个具体的实现，我们就需要把它周边配套的东西全部引入进来，而这一切与这个类本身的业务逻辑没有任何关系。

这就好像，你原本打算买一套家具，现在却让你必须了解树是怎么种的、怎么伐的、怎么加工的，以及家具是怎么设计、怎么组装的，而你想要的只是一套能够使用的家具而已。

这还只是最简单的场景，在真实的项目中，构建一个对象可能还会牵扯到更多的内容：1）根据不同的参数，创建不同的实现类对象，你可能需要用到工厂模式。2）为了了解方法的执行时间，需要给被依赖的对象加上监控。3）依赖的对象来自于某个框架，你自己都不知道具体的实现类是什么……所以，即便是最简单的对象创建和组装，也不像看起来那么简单。

既然直接构造存在这么多的问题，那么最简单的办法就是把创建的过程拿出去，只留下与字段关联的过程：

```java
class ArticleService {
  private ArticleRepository repository;
  
  public ArticleService(final ArticleRepository repository) {
    this.repository = repository;
  }
  
  public Article findByTitle(final String title) {
    // 做参数校验
    return this.repository.findByTitle(title);
  }
}
```

1『对头，不要在 ArticleService 里 new 任何 ArticleRepository 对象，直接传进来一个 ArticleRepository 对象。』

这时候，ArticleService 就只依赖 ArticleRepository。而测试 ArticleService 也很简单，只要用一个对象将 ArticleRepository 的行为模拟出来就可以了。通常这种模拟对象行为的工作用一个现成的程序库就可以完成，这就是那些 Mock 框架能够帮助你完成的工作。

或许你想问，在之前的代码里，如果我用 Mock 框架模拟 Connection 类是不是也可以呢？理论上，的确可以。但是想要让 ArticleService 的测试通过，就必须打开 DBArticleRepository 的实现，只有配合着其中的实现，才可能让 ArticleService 跑起来。显然，你跑远了。

现在，对象的创建已经分离了出去，但还是要要有一个地方完成这个工作，最简单的解决方案自然是，把所有的对象创建和组装在一个地方完成：

```java
...
ArticleRepository repository = new DBArticleRepository(connection);
AriticleService service = new ArticleService(repository);
...
```

相比于业务逻辑，组装过程并没有什么复杂的部分。一般而言，纯粹是一个又一个对象的创建以及传参的过程，这部分的代码看上去会非常的无聊。虽然很无聊，但这一部分代码很重要，最好的解决方案就是有一个框架把它解决掉。在 Java 世界里，这种组装一堆对象的东西一般被称为「容器」，我们也用这个名字。

```java
Container container = new Container();
container.bind(Connection.class).to(connection);
container.bind(ArticleReposistory.class).to(DBArticleRepository.class);
container.bind(ArticleService.class).to(ArticleService.class)

ArticleService service = container.getInstance(ArticleService.class);
```

至此，一个容器就此诞生。因为它解决的是依赖的问题，把被依赖的对象像药水一样，注入到了目标对象中，所以，它得名「依赖注入」（Dependency Injection，简称 DI）。这个容器也就被称为 DI 容器了。至此，我简单地给你介绍了 DI 容器的来龙去脉。虽然上面这段和 Spring DI 容器长得并不一样，但其原理是一致的，只是接口的差异而已。

事实上，这种创建和组装对象的方式在当年引发了很大的讨论，直到最后 Martin Fowler 写了一篇《反转控制容器和依赖注入模式》的文章，才算把大家的讨论做了一个总结，行业里总算是有了一个共识。

3『 [Inversion of Control Containers and the Dependency Injection pattern](https://www.martinfowler.com/articles/injection.html)

』

那段时间，DI 容器也得到了蓬勃的发展，很多开源项目都打造了自己的 DI 容器，Spring 是其中最有名的一个。只不过，Spring 并没有就此止步，而是在这样一个小内核上面发展出了更多的东西，这才有了我们今天看到的庞大的 Spring 王国。

讲到这里，你会想，那这和我们要讨论的「模型」有什么关系呢？正如我前面所说，很多人习惯性把对象的创建和组装写到了一个类里面，这样造成的结果就是，代码出现了大量的耦合。时至今日，很多项目依然在犯同样的错误。很多项目测试难做，原因就在于此。这也从另外一个侧面佐证了可测试性的作用，我们曾在第 3 讲中说过：可测试性是衡量设计优劣的一个重要标准。由此可见，在没有 DI 容器之前，那是怎样的一个蛮荒时代啊！

有了 DI 容器之后呢？你的代码就只剩下关联的代码，对象的创建和组装都由 DI 容器完成了。甚至在不经意间，你有了一个还算不错的设计：至少你做到了面向接口编程，它的实现是可以替换的，它还是可测试的。与之前相比，这是一种截然不同的思考方式，而这恰恰就是 DI 容器这个模型带给我们的。

而且，一旦有了容器的概念，它还可以不断增强。比如，我们想给所有与数据库相关的代码加上时间监控，只要在容器构造对象时添加处理即可。你可能已经发现了，这就是 AOP（Aspect Oriented Programming，面向切面编程）的处理手法。而这些改动，你的业务代码并无感知。

Spring 的流行，对于提升 Java 世界整体编程的质量是大有助益的。因为它引导的设计方向是一个好的方向，一个普通的 Java 程序员写出来的程序只要符合 Spring 引导的方向，那么它的基本质量就是有保障的，远超那个随意写程序的年代。不过，如果你不能认识到 DI 容器引导的方向，我们还是无法充分利用它的优势，更糟糕的是，我们也不能太低估一些程序员的破坏力。我还是见过很多程序员即便在用了 Spring 之后，依然是自己构造对象，静态方法满天飞，把原本一个还可以的设计，打得七零八落。

你看，通过上面的分析，我们知道了，只有理解了模型设计的来龙去脉，清楚认识到它在解决的问题，才能更好地运用这个模型去解决后面遇到的问题。如果你是这个项目的维护者，你才能更好地扩展这个模型，以便适应未来的需求。

### 黑板墙

最后，我想请你思考一个问题，DI 容器看上去如此地合情合理，为什么在其他编程语言的开发中，它并没有流行起来呢？

汇总：1）斟酌再三，虽说直接说 spring di 容器好像也没啥毛病，但个人觉得这描述并不是很准确，故阐述下自己的认知。2）我认为 spring 提供的这个编程模型应该叫 ioc（控制反转和响应式编程有点像）而不是 di。因为最开始被提出来的是 ioc（好莱坞原则），而且最早的实现也不是 spring，jdk 和 ejb 都有对 ioc 的实现，spring 才是后来者。但是 di 确实好像是在 spring 上被流行起来，且长期主流的（spring di 容器没毛病的原因）。不过 spring 对 ioc 的实现，除了 di 还有依赖查找，在我眼里 ioc 是模型，依赖查找和依赖注入是功能，所以我认为应该是 spring 提供了 ioc 的编程模型，利用 ioc 容器 + di 的功能简化了开发。3）依赖注入相对于依赖查找，透明度更好，调用方对 ioc 容器的 api 和具体接口实现的查表获取被隐藏了（技术与业务的解耦最终都该透明无感）。但依赖查找在需要动态选择策略时依旧有其用武之地。4）回答课后题： 对于 py 和 go 这类函数式编程语言，函数是一等公民，是可以作为参数传递的。那么直接改变所传的函数就可以实现 mock 和函数替换（使用和创建天然解耦）。为什么 java 会流行？我认为有个原因，是因为 java 是单分派的语言，编译期方法和参数类型是绑定死的（强类型），运行期走哪个 bean 的方法是动态决定的。如此就引出了面向接口编程的多态实现方案，才会有后面 ioc 的诉求。2020-06-03

我觉得最根本原因是大多数开发不写测试，所以不会考虑依赖问题，大多数方法都是面向实现而不是接口，使用 DI 容器反而增加了工作量。目前所在小组偏向于外包，代码只有一层，不是单列，就是静态方法；为了达到快速交付，基本没有设计，不管怎么说这都是不合理的。是前人挖，后人跳。作者回复：唉，你说的现状，我非常理解。所谓的「快」，只是从当前一个时点上看，放在长期，就是越跑越慢。2020-06-03

```java
container.bind(Connection.class).to(connection);
container.bind(ArticleReposistory.class).to(DBArticleRepository.class);
container.bind(ArticleService.class).to(ArticleService.class)
```

请问这 3 行代码的具体含义是啥？作者回复：1）将 Connection 这个类绑定在 connection 这个对象上，当需要一个 Connection 对象时，返回 connection 这个对象。2）将 ArticleReposistory 这个接口绑定在 DBArticleRepository 这个类上，当需要一个 ArticleReposistory 对象时，返回 DBArticleRepository 这个类的一个对象。3）将 ArticleService 这个类就绑定在其自身，当需要一个 ArticleService 对象时，返回这个类的一个对象。2020-06-03

理解软件设计中模型首先要理解模型解决的核心问题是什么，然后抽丝剥茧了解模型的来龙去脉，深入理解模型解决问题的过程。spring 中的 di 模型是为了解决对象的创建和组装的问题。那为什么创建对象和组装要用 di 来解决？一个重要的原因是为了解耦。分离接口与实现的强依赖，也就是软件设计第一步分离关注点。而这个恰恰就是为了可测试性，当一个代码是可测的，其实就是说明它是比较灵活的，修改起来不会牵一发而动全身，提高开发的体验，减少因修改引入的额外问题。2020-06-03

放下历史长河之中去看问题，比如现在去看几年前甚至 10 年前的代码，才知道这样做的好处，分离关注点，可测试性是多么需要，不然真的改不动。作者回复：这是我在开篇词里的立论，软件设计是一门关注长期变化的学问。2020-06-04

为什么不建议使用静态方法？如果只是简单的模型转换，用静态方法不是更好吗？作者回复：静态方法，没法去模拟它的行为，所以，要做测试的话，遇到静态方法，你必须关注它的实现，而不是它的接口。总的来说，静态方法是写着爽，但测着不方便。2020-06-04

一个框架的流行根本原因不是它简化了开发，而是导致了问题的简化的那个开发模型。像 spring 提供的 di 模型，你甚至感受不到它的存在。它更像是一种理念，而这是一个模型的最高级形态。在 di 的核心模型之上，又出现了 starter、auto configuration 等理念，这就是 spring boot 的模型创新。在 springboot 之上，又有 springcloud.....Spring 这个框架，真的是牛逼 (找不到合适的词了）。作者回复：没错，简化开发是结果，模型才是动因。Spring Boot 是在 Spring 出现好多年之后才出现的。2020-06-03

文中说「静态方法满天飞」是为了在实例方法中调用别的方法所以改为静态方法，是这样的意思吗？作者回复：为了方便，定义静态方法，到处调用，然后，没法 mock，不好测试。2020-06-03

接触 spring 七八年，一直在学习 BeanFactory 和 ApplicationContext 上打转，今天才算对容器这个概念有一个直觉性的认识！作者回复：学习一个软件，要从基础模型开始。2020-06-03

回答作业：1）Java 有反射，其他语言不一定有；2）Java 生态比较完善，大神比较多，有模版可以学；3）前端开发集中在 UI 界面和数据解析，需求变更快，用 DI 容器去做有点吃力；（UI 大多是包含的方式，很难把子控件拎出来初始化）4）DI 容器的 AOP 可能更适合后端，突如其来的统计、归档之类的需求。而前端的应用生命周期和页面生命周期都由 UI 框架提供了，AOP 自然用的少。总结：我觉得 AOP 可能才是开发者爱用 DI 的主要原因，加上 Java 生态的繁荣最终流行起来。（个人看法）作者回复: AOP 早在 DI 之前就有了，它并没有那么大的推动作用，DI 兴起之后，它才有了更多的用武之地。2020-06-03

DI 是模型？我理解的 DI 是一种实现，IoC 是模型。作者回复：当年，IoC、DIP 和 DI 几个名字争论了好久，最后决定叫了 DI，这个几个词确实有很多类似的地方。其实，它们都是设计原则。后面讲设计原则的时候，还会提到 DIP 的。2020-06-03

多半因为 Java 在企业级应用里独占鳌头，所以 Java 的 DI 更为人所知，也因为更早地出现了容器级的 DI，Java 才这么流行。作者回复: DI 没有成为主流时，Java 也已经很流行了，比如，J2EE。2020-06-03

跳出软件设计领域，像家具装潢（比如买沙发）等传统行业是可以找到对应概念的，但是相比软件设计复杂多；客户期望只关注产品功能（对应模型），然而企业销售产品时往往揉入了很多客户并不想了解的产品实现细节比如加工工艺、材料源头等（杂糅模型和实现）；这也算是造就了程序员的单纯吧。作者回复：打开盖子，才能看到细节。2020-06-22

我是一个两年的前端程序媛，不太了解 java。面向对象编程时，你只想要一颗树，却得到整个森林，于是有些人就觉得面向对象编程是不好的，所以认为函数式编程的方式更好，不过文章提到的组件创建和组合放入到一个容器中，也就是说将所有依赖都放入都一个地方，提供业务需要的接口，而不写到业务中，那么为啥没有在前端火起来呢？函数式编程是不是就是面向接口编程的一种呢？作者回复：后面会讲到函数式编程，简单来说，面向对象提供了组织类的能力，函数式编程提供了组织动作的能力，二者可以混合使用。2020-06-07

我觉得是因为 Java 面向对象，更多的是使用组合解决问题，使用组合那就避免不了对象的依赖，加上接口实现分离，就更加依赖于 DI，而像其他的语言，像面向过程全程使用函数来解决问题，貌似有点用不到对象的组合和创建。我的一点小理解，也不知道有没有问题。作者回复：面向对象和面向过程只是用到了不同的设计元素，其实，使用程序设计语言完全可以兼顾二者，稍后，我会在编程方范式部分进一步讲解。2020-06-04

其实很早就听说过 Inversion of Control 和 Dependency Injection，但是似乎一直没有搞明白其中的概念，也没有机会有意识的去使用 DI（也许是用了，但是没有意识到）。重读了 Martin Fowler 的长（旧）文，有一个疑惑，专栏里面的 Spring DI 是属于哪一种类型的 IoC，看上去比较像 type 1，Constructor Injection。但是在 Martin Fowler 的文章里面说道 Spring 的开发者更推荐使用 Setter Injection（Spring 框架应该是同时支持这两种依赖注入方式的），不知道是因为框架的进展，改用了 Constructor Injection，或者只是局限于作者的这个例子。结合专栏的内容，简单的了解了一下 Spring 中的 DI。1）在 Ruby 中可以使用 dry-rb 实现依赖倒置：[Introduction to dependency injection in Ruby | by Christian Paling | Medium](https://medium.com/@Bakku1505/introduction-to-dependency-injection-in-ruby-dc238655a278)。2）但是 DHH 也说过：[Dependency injection is not a virtue in Ruby (DHH)](https://dhh.dk/2012/dependency-injection-is-not-a-virtue.html)。2020-06-03

我的理解，IoC 是一种思想，就像 OOP、AOP 一样都是思想。而 DI 是技术实现，是 IoC 的最常见以及最合理的实现方式。按照老马（Martin Fowler）的意思，可以使用 DI 代替掉 IoC。因为 DI 就基本能够体现出 IoC 的意思了。省得搞混淆了。另外对于静态方法，在日常开发中，老师的建议是什么呀？推荐使用吗？在什么场景下可以推荐使用？作者回复: IoC、DI、DIP 其实这几个名字在早先的讨论里是类似的，容易混淆的，其重点都是把依赖通过接口隔离开。最后 DI 容器这里选了 DI，后面我们会讲到 DIP，可以再来看。IoC 远远到不了 OO 的级别，只是一种设计原则。静态方法能不用就不用，大多数情况下都可以用普通方法代替。只有少数程序库适合写成 static 的。2020-06-18

我觉得可能是用的太浅吧，或者把发挥的空间就留给了一小部分人，所谓的上手快，形成的优质案例不多影响也不大。编程思想是跨语言层面的，比如说 java 实现的用其它高级语言也能实现，要我说都是用的人的问题。人的因素很大，比如 C++ 也可以不写成多继承啊，不能因为语言层面没有禁止就说是语言设计的不好是吧。作者回复：对，只有脑子里面有一个该怎么做的主线，才不会被各种语言带偏了。2020-06-03

## 0103. Ruby on Rails：如何分析一个软件的接口？

今天我们学习如何了解设计的第二部分：看接口。看接口的一个方法是找主线，看风格。先找到一条功能主线，对项目建立起结构性的了解。有了主线之后，再沿着主线把相关接口梳理出来。查看接口，关键要看接口的风格，也就是项目作者引导人们怎样使用接口。在一个项目里，统一接口风格也是很重要的一个方面，所以，熟悉现有的接口风格，保持统一也是非常重要的。我还介绍了一个曾经火爆的 Web 开发框架：Ruby on Rails。借着它的起步走文档，我给你介绍了它的一些接口，包括：1）Web 应用对外暴露的接口：REST API；2）程序员写程序时用到的接口：API；3）程序员在开发过程中用到的接口：命令行。从 Rails 的接口设计中，我们可以看到，一个好的接口设计，无论是最佳实践的引入，抑或是 API 设计风格的引导，都可以帮助我们建立起良好的开发习惯。当我们理解了模型和接口，接下来就该看实现了，这就是我们下一讲要讲的内容。如果今天的内容你只能记住一件事，那请记住：理解一个项目的接口，先找主线，再看风格。

在上一讲中，我以 Spring 的 DI 容器为例，给你讲解了如何理解一个项目的模型。在模型之后，下一步就该是接口了。

在任何一个项目中，接口的数量都不是一个小数目。仅仅一个普通的程序库，里面的接口少则几十个，多则成百上千。难道我们理解接口，就是要一个一个地读这些接口吗？显然，你不太可能把所有的接口细节都记住。我写 Java 程序差不多 20 年了，但很多 JDK 里的类我都不了解。甚至有时候，还没有等我去了解这个类，它就过时了。那么，如何才能从纷繁复杂的接口中，披荆斩棘而出呢？我给你个方法：找主线，看风格。

找主线的意思是，你需要找到一条功能主线，建立起对这个项目结构性的认知，而不是一上来就把精力放在每一个接口的细节上。你对细节部分的了解会随着你对项目的深入而逐渐增加。而有了主线后，你就有了着力点，就可以不断深入了。但是，我们要学习的不只是这些接口的用法，要想从项目的接口设计上学到更多，这就需要你关注它所引导的风格，换句话说，就是它希望你怎样使用它，或是怎样在上面继续开发。

从一个项目的接口风格中，我们不难看出设计者的品位。我们常把编程视为一种艺术，而在接口的设计上就能窥见一二。这些内容是我们在学习软件设计时，应该慢慢品味的。为什么要看风格，还有一个很重要的原因，就是你要维护项目的一致性，必须有一个统一的风格。有不少项目，里面会共存多种不同风格的接口，就是每个人都在设计自己习惯的接口，那势必会造成混乱。

这一讲，我们就来一起来学习怎样看接口，我选择的项目是 Ruby on Rails，因为它的接口设计风格是带给我最多震撼的，无论是编程接口的优雅，还是开发过程接口的顺畅。不过，正如我在第 4 讲所说，看设计要先看模型。所以，我们还是先快速地了解一下 Ruby on Rails 的模型。

### 3.1 Ruby on Rails 模型

如果你是一个比较年轻的程序员，Ruby on Rails 这个名字可能会让你有一些陌生。但是在十多年前，它初出茅庐之际，可是给行业带来了极大的冲击。只是后来时运不济，编程模型发生了大的改变，使它失去了行业领导者的地位。这个故事还是要从你最熟悉的 Web 开发说起。

自从互联网兴起，人们对于 Web 开发的探索就从未停止过。最早期的 Web 开发只是静态页面的开发，那时候，你只要熟悉 HTML，就可以说自己懂 Web 开发了。后来，人们不再满足于静态页面，开始尝试编写有动态效果的页面。一方面，浏览器开始支持 JavaScript，让页面本身有了动态效果；另一方面，有人开始制作后台服务，在页面之间切换的时候，也可以有动态的效果。那个时候出现了像 CGI（Common Gateway Interface）这样的编程规范。

当 Java 世界里出现了 Servlet、JSP 这些规范，Web 开发也逐渐由小打小闹变成了企业开发的主力，越来越多的公司开始正视 Web 开发。因为这些规范很沉重，一些号称要简化 Web 开发的框架开始出现，比如：Struts、Webwork 以及 Spring MVC 等等。

这些框架的出现，让 Web 开发摆脱了 Servlet 的初级阶段，使 MVC 模式成为了 Web 开发的主流。但即便如此，那个时候的 Java Web 开发依然是沉重的，比如写一个 Web 应用，光是配置文件就足以把人逼疯。Ruby on Rails 正是在这样的背景下横空出世的。为了叙述方便，后面我就把 Ruby on Rails 简称 Rails 了。

从模型上讲，Rails 是标准的基于 MVC 模型进行开发的 Web 框架。在这一点上，它没有什么特殊的，它给行业带来巨大冲击的是它的接口设计。Rails 一个重要的设计理念就是约定优于配置，无需配置，按照缺省的风格就可以完成基本的功能，这样的理念贯穿在 Rails 各个接口的设计中。接下来，我们就来看 Rails 的接口。

前面我提到过理解接口应该先找主线，找到项目主线的一个方法就是从起步走文档开始，因为它会把项目最基本的用法展现给你，你可以轻松地找到主线。Rails 的起步走文档做得就非常好，主线可以说是一目了然。它用了一个 Web 项目帮你介绍了 Rails 开发的基本过程，通过这个过程，你就对 Rails 有了初步的印象。

有了主线之后，我们就要开始从中了解接口的风格。Rails 给我们提供的三种接口，分别是：1）Web 应用对外暴露的接口：REST API；2）程序员写程序时用到的接口：API；3）程序员在开发过程中用到的接口：命令行。接下来，我们就一个个地深入其中，了解它们的风格，以及它们给行业带来的不同思考。

### 3.2 REST 接口

先说应用对外暴露的接口：REST API。REST 如今已经成为很多人耳熟能详的名词，它把 Web 的各种信息当作资源。既然是资源，它就可以对这些 Web 信息做各种操作，这些操作对应着 HTTP 的各种动词（GET、POST、PUT、DELETE 等）。

REST 当年的问世是 Roy Fielding 博士为了纠正大家对 HTTP 的误用。REST 刚出来的时候，开发者普遍觉得这是一个好的想法，但怎么落地呢？没有几个人想得清楚。Rails 恰逢其时地出现了。Rails 对 REST 的使用方式做了一个约定。只要你遵循 Rails 的惯用写法，写出来的结果基本上就是符合 REST 结构的，也就是说，Rails 把 REST 这个模型用一种更实用的方式落地了。

```c
Rails.application.routes.draw do
  ...
  resources :articles
  ...
end
```

在用 Rails 写程序的时候，你只要添加一个 resource 进去，它就会替你规划好这个资源应该如何去写、怎么设计 URL、用哪些 HTTP 动词，以及它们对应到哪些方法。

```ruby
$ bin/rails routes
      Prefix Verb   URI Pattern                  Controller#Action
    articles GET    /articles(.:format)          articles#index
             POST   /articles(.:format)          articles#create
 new_article GET    /articles/new(.:format)      articles#new
edit_article GET    /articles/:id/edit(.:format) articles#edit
     article GET    /articles/:id(.:format)      articles#show
             PATCH  /articles/:id(.:format)      articles#update
             PUT    /articles/:id(.:format)      articles#update
             DELETE /articles/:id(.:format)      articles#destroy
        root GET    /                            welcome#index
```

看了 Rails 给你的这个映射关系后，你就知道自己该怎么写代码了。这就是一种约定，不需要你费心思考，因为这是人家总结出来的行业中的最佳实践。只要按照这个规范写，你写的就是一个符合 REST 规范的代码，这就是 Rails 引导的外部接口风格。

### 3.3 API 接口

我们再来看 API 接口。当年我接触 Rails 时，最让我感到震惊的是它的数据库查询方式，与传统开发的风格截然不同，就这么简单的一句：

```ruby
Article.find_by_title("foo")
```

要知道，那个时候用 Java 写程序，即便是想做一个最简单的查询，写的代码也是相当多的。我们不仅要创建一个对象，还要写对应的 SQL 语句，还要把查询出来的结果，按照一定的规则组装起来。而 Rails 用一句轻描淡写 find\_by 就解决了所有的问题，而且，这个 find\_by\_title 方法还不是我实现的，Rails 会替你自动实现。当我们需要有更多的查询条件时，只要一个一个附加上去就可以了。

```ruby
Article.find_by_title_and_author("foo", "bar")
```

同样的事，如果放到 Java 里去做，还需要把前面说的事再做一遍，差别只是查询语句不一样。虽然我说的是当年的场景，但时至今日，在这些简单问题上，很多使用 Java 的团队所付出的工作量并不比当年少。从功能的角度说，这样的查询在功能上是完全一样的，但显然 Rails 程序员和 Java 程序员的工作量是天差地别的。这其中的差异就是不同的编程接口所造成的。

所以你看，一个好的接口设计会节省很多工作量，会减少犯错的几率。因为它会在背后帮你实现那些细节。而设计不好的接口，则会把其中的细节暴露出来，让使用者参与其中。写程序库和写应用虽然都是写代码，但二者的要求确实相差极大。把细节暴露给所有人，显然是一个增加犯错几率的事情。

Rails 的 API 接口给行业带来的另一个影响是，它让人们开始关注 API 的表达性。比如，每篇文章可以有多个评论，用 Rails 的方式写出来是这样的：

```ruby
class Article < ApplicationRecord
  has_many :comments
  ...
end
```

而如果用传统 Java 风格，你写出来的代码，可能是这个样子的：

```java
class Article {
  private List<Comment> comments;
  ...
}
```

很明显，「有多个」这种表示关系的语义用 has\_many 表示更为直白，如果用 List ，你是无法辨别它是一个属性，还是一个关系的。Rails 里面类似的代码有很多，包括我们前面提到的 find\_by。所以，如果你去读 Rails 写成的应用，会觉得代码的可读性要好得多。

由于 Rails 的蓬勃发展，人们也开始注意到好接口的重要性。Java 后期的一些开源项目也开始向 Rails 学习。比如，使用 Spring Data JPA 的项目后，我们也可以写出类似 Rails 的代码。声明一对多的关系，可以这样写：

```java
class Article {
  @OneToMany
  private List<Comment> comments;
  ...
}
```

而查询要定义一个接口，代码可以这样写：

```java
interface ArticleRepository extends JpaRepository<Article, Long> {
  Article findByTitle(String title);
  Article findByTitleAndAuthor(String title, String author);
}
```

当你需要使用的时候，只要在服务里调用对应的接口即可。

```java
class ArticleService {
  private ArticleRepository repository;
  ...
  public Article findByTitle(final String title) {
    return repository.findByTitile(title);
  }
}
```

显然，Java 无法像 Rails 那样不声明方法就去调用，因为这是由 Ruby 的动态语言特性支持的，而 Java 这种编译型语言是做不到的。不过比起从前自己写 SQL、做对象映射，已经减少了很多的工作量。顺便说一下，Spring Data JPA 之所以能够只声明接口，一个重要的原因就是它利用了 Spring 提供的基础设施，也就是上一讲提到的依赖注入。它帮你动态生成了一个类，不用你自己手工编写。简单，表达性好，这就是 Rails API 的风格。

### 3.4 命令行接口

作为程序员，我们都知道自动化的重要性，但 Rails 在「把命令行的接口和整个工程配套得浑然一体」这个方面做到了极致。Rails 的自动化不仅会帮你做一些事情，更重要的是，它还把当前软件工程方面的最佳实践融合进去，这就是 Rails 的命令行风格。如果要创建一个新项目，你会怎么做呢？使用 Rails，这就是一个命令：

```
$ rails new article-app
```

这个命令执行的结果生成的不仅仅是源码，还有一些鼓励你去做的最佳实践，比如：1）它选择了 Rake 作为自动化管理的工具，生成了对应的 Rakefile；2）它选择了 RubyGem 作为包管理的工具，生成了对应的 Gemfile；3）为防止在不同的人在机器上执行命令的时间不同，导致对应的软件包有变动，生成了对应的 Gemfile.lock，锁定了软件包的版本；3）把对数据库的改动变成了代码……

而这仅仅是一个刚刚生成的工程，我们一行代码都没有写，它却已经可以运行了。

```
$ bin/rails server
```

这就启动了一个服务器，访问 http://localhost:3000/ 这个 URL，你就可以访问到一个页面。如果你打算开始编写代码，你也可以让它帮你生成代码骨架。执行下面的命令，它会帮你生成一个 controller 类，生成对应的页面，甚至包括了对应的测试，这同样是一个鼓励测试的最佳实践。

```
$ bin/rails generate controller Welcome index
```

在 Rails 蓬勃发展的那个时代，人们努力探索着 Web 开发中各种优秀的做法，而在这个方面走在最前沿的就是 Rails。所以，那个时候，我们经常会关注 Rails 的版本更新，看看又有哪些好的做法被融入其中。Rails 中那些优秀的实践逐步地被各种语言的框架学习着。语言编写者们在设计各种语言框架时，也都逐步借鉴了 Rails 中的那些优秀实践。比如，今天做 Java 开发，我们也会用到数据库迁移的工具，比如 Flyway。当然，另一个方面，即便到了今天，大部分项目的自动化整合程度也远远达不到 Rails 的高度，可能各方面的工具都有，但是如此浑然一体的开发体验，依然是 Rails 做得最好。

最后，你可能会问，Rails 这么优秀，为什么今天却落伍了呢？在 Web 开发领域，Rails 可谓成也 MVC，败也 MVC。MVC 是那个时代 Web 开发的主流，页面主要在服务端进行渲染。然而，后来风云突变，拜 JavaScript 虚拟机 V8 所赐，JavaScript 能力越来越强，Node.js 兴起，人们重新认识了 JavaScirpt。它从边缘站到了舞台中心，各种组件层出不穷，前端页面的表现力大幅度增强。Web 开发的模式由原来的 MVC，逐渐变成了前端提供页面，后端提供接口的方式。Java 的一些框架和服务也逐步发展了起来，Spring 系列也越来越强大，重新夺回了 Web 后端开发的关注。

### 黑板墙

最后，我想请你来分享一下，你在哪个项目的设计中学到了一些好的开发习惯呢？

汇总：1）最早自学的就是 ruby，要不是因为找不到工作，可能就做不成 javaer 了。论快速搭建一个 web 项目，至今依旧是 ruby on rails。一个多小时从无到有搭建一个博客系统的时候，信心爆棚。2）本篇，明天得再看看。get 不到点。只能理解风格应该是说设计偏好。至于主线，从 ruby 这个 demo 里没能 get 到。3）spring。兼容（老版本以及各种场景），开放（提供规范和基础工具，方便各种「实现」自己写插件接入 spring），与时俱进（springboot 的推出，算得上破而后立），追求卓越（在迭代中改变接口命名，只为让原本达意的命名更达意）。作者回复：Ruby 成于 Rails，也败于 Rails。2020-06-05

在 Spring 的源码中 接口 -> 抽象类 -> 实现类，如 BeanDefinition -> AbstractBeanDefinition -> RootBeanDefinition。这样的设计风格。顶层接口规定定义，抽象类提供部分实现。用户需要扩展，可以选择从抽象类进行扩展，或从接口扩展。作者回复：上一讲是 Spring，这一讲是 Ruby on Rails，这个评论让我有一种走错片场的感觉。2020-06-05

找主线，看风格。找主线看文章，看风格看接口。从上到下，从整体到局部。不过这也是正常读源码的一个步骤。作者回复：太喜欢你这个评论了，这就应该是正常的步骤啊，可是很多人不知道。2020-06-07

Ruby on Rails 这个设计在当时感觉很超前，也不知道现在的 SpringBoot 是不是借鉴了，感觉从 SpringBoot 上能看倒 Ruby on Rails 的身影，SpringBoot 的约定大于配置，还 SpringBoot 把命简洁的页面，勾选之后就可以创建一个简单的 SpringBoot 项目等等，Ruby on Rails 的设计在现在看来可能确实没什么，但在当时感觉这个设计就太超前了。作者回复：你说得很对，Rails 超前是全方位的，今天看来，很多东西都影响了全行业。2020-06-06

理解软件中的接口设计，要抓住主线，可以从文档开始入手，了解软件设计者的风格品味，看看作者希望我们是如何使用这些接口的。我没用过 Ruby，但是通过分析之后，其实它的接口设计中，整合了许多极佳的工程实践，提高编码效率，解放生产力，这些思想在软件设计的时候是可以学习和参考的。作者回复：能够把开发效率提高，也是一大推动力。2020-06-05

好的设计要多从使用者角度考虑，是否有助于释放程序员精力，是否易用，是否有良好的可读性和可扩展性。自己先用，并在开始时就设定好边界，即使先只在一点上有所突破也比全面开花哪哪不灵要好。作者回复：这个我完全同意！你说的单点突破实际上就是 MVP 的思路。2020-06-07

最早接触 BDD 是 cucumber，当时觉得简直是 magic。整个 RoR 框架也到处给人 magic 的感觉。但是软件开发不应该有 magic，否则容易失控。RoR 式微部分原因可能也是 Ruby 过于灵活了，印象中 RoR 有些严重的安全漏洞就是由此引发。此外 Ruby 的执行效率也逐渐落后于时代了。近年来有 Crystal 语言借由 llvm 复兴 Ruby，加入了很多现代语言的特性，希望能有好结果。作者回复：这是两个方面，使用者和开发者。使用者的角度，那是简单的，开发者的角度，需要理解那些 Magic。Ruby 有些问题其实动态语言的问题，在开发大型应用上，没有类型是一个很伤的地方。执行效率其实与使用程度是相关的，只要有更多的人在用，就会有更多的人来优化，如果没有人用，优化的动力自然就不强了。2020-06-05

「优雅的编程接口，顺畅的开发过程」，虽然我也非常的喜欢 Ruby on Rails，却没有办法像老师这样精辟的总结提升。给我的感觉，RoR 在设计的时候非常的体贴程序员，并且采用了一大堆优秀的设计范式。看了文中对于 Rails 接口的分析，感觉更喜欢 Rails 了，可惜的确如同留言里面 @Jxin 说的那样，工作不好找，另外薪水不高。如果按照开发模式的变迁，那么现在是不是应该学习 Deno ? 请老师推荐一个比较有潜力的语言或者框架，Go 或者 TypeScript ？作者回复：很快就轮到讲程序设计语言了，简言之，多学点。2020-06-05

接触的第一个框架就是 rails，用起来确实很爽，今天看到此篇文章，让我对它更有敬意，而不会因为现在不就行，或者性能不够好，就看不起它，没有东西是绝对的好，或者绝对不好，今天全是对这个道理有更深层的理解了。我之后学习了 JavaScript，转了前端，学习 Vue 框架，它使用虚拟 dom 将组件高度抽象化，使页面组件可以多端运行，比如 node 端，如此可以前后端同构，解决单页面应用的劣势，而保留其优势。模块如何拆解然后又如何组装，逻辑清晰。提供了很多全局组件和生命周期函数，以及其他方法，这些就是给程序员提供的接口，可以让我们在特定的场景让你更加关注功能需求的实现，而不是代码的实现细节，会自动帮你做好很多事情。并且使用了很多高阶函数，化繁为简，最终返回一个干净的只有核心逻辑的函数。即大量使用了函数式编程。学习的过程就是写一段简单的，特定场景代码，然后进行断点测试，看看源码中主要会走那些流程。然后大概就有了一条小主线。好的框架理解起来应该是容易的，清晰的。而那些不假思索写出来的面向过程的代码，如果不一行一行去看的话，就不知道问题出在哪里，甚至以后回过来看，都不知道自己是怎么写出这种代码的，就像写正则表达式一样，写完之后，自己都看不懂了。作者回复：感谢你的分享，丰富了更多的内容。2020-06-08

问个问题，如果说 rails 落伍的原因是因为 Javascript，为什么没有演变成 javascript + rails 后端服务这样的组合呢？作者回复：在加餐里讲了 JavaScript 的兴起，实际上，Node.js 并没有真正意义上成为后端开发的主力，却促进了前端的发展，让前后端分离了，结果，后端借此兴起的是 Java。Rails 归根结底是有硬伤的，性能差。在没有了 MVC 的加持之后，Java 就重新回来了。2020-06-28

那 python 的 Django 是不是也有 rails 的问题？那 flask 呢？java 的 spring boot 是更好的实践吗？另外 rails 应该也可以使用前后端分离吗？老师是否还可以再分享下，spring 具体是如何越来越强大，使得 rails 落伍？spring 和 node 如何联手超越 rails 的？作者回复：从工程实践的角度看，Rails 是最好的，很多后来者抄袭了 Rails，比如，Django。Spring Boot 最近这些年进步很大，但依然不如 Rails。Spring Boot 其实就是把 Spring 这么多年积累的组件合到了一起，再加上嵌入式服务器的发展，大幅度地降低了开发难度。编程模型从 MVC 转向了 REST 服务，是一个重大的契机。Rails 自身的执行效率本来就是一个硬伤。Spring Boot 可以说抓住了新一波的浪潮，让 Java 重新回到了巅峰上。之所以 MVC 转向了 REST，要拜 Node.js 所赐，让前端有了大发展，这段分析在程序设计语言的加餐中。2020-06-19

关于接口想请教一下老师，我们平时在公司内部的二方库，是不是应该拆分成两个 jar 包，分为 api 模型包和一个实现包。对于大多数开发业务我们只关心一个系统的模型以及提供什么样的功能接口。拆分成不同包可以根据需要引入不同的实现包，而 api 和模型是共用的。比如最近有个项目需要把查数据湖的报表改成差数据库，如果封装的足够好应该只要替换实现就可以不改一行代码达到目标。作者回复：这其实是打包原则的事。从理论上说，分成两个是最好，只是实际情况很多人分不了那么干净。2020-06-11

## 0104. Kafka：如何分析一个软件的实现？

今天是了解设计的第三部分：看实现。理解一个实现，是以对模型和接口的理解为前提的。每个系统的实现都有非常多的细节，我们不可能一上来就把所有的细节吃透。如果想了解一个系统的实现，应该从软件结构和关键技术两个方面着手。无论是软件结构，还是关键技术，我们都需要带着自己的问题入手，而问题的出发点就是我们对模型和接口的理解。了解软件的结构，其实，就是把分层的模型展开，看下一层的模型。一方面，你要知道这个层次给你提供了怎样的模型，另一方面，你要带着自己的问题去了解这些模型为什么要这么设计。最后，我借着 Kafka 的关键技术还给你讲了软硬结合的思路，在系统优化之路上寻求突破时，可以增加你选择的道路。不过，实现都是有约束的，比如，Kafka 的实现主要是针对机械硬盘做的优化，现在的 SSD 硬盘越来越多，成本越来越低，这个立意的出发点已经不像以前那样稳固了。

至此，了解设计的三步我们已经全部走完了。接下来，我们就要开始自己的设计历程了。首先，我们需要掌握一些关于设计的基础知识。下一讲，我们就从最基础的部分入手，我们来谈谈程序设计语言。如果今天的内容你只能记住一件事，那请记住：理解实现，带着自己的问题，了解软件的结构和关键的技术。

上一讲，我们学习了如何看接口，今天我们进入第三个部分 —— 看实现。在一个系统中，模型和接口是相对稳定的部分。但是，同样的模型和接口，如果采用不同的实现，稳定性、可扩展性和性能等诸多方面相差极大。而且，只有了解实现，你才有改动代码的基础。但是，不得不说，「看实现」是一个很大的挑战，因为有无数的细节在那里等着你。所以，在很多团队里，一个新人甚至会用长达几个月的时间去熟悉代码中的这些细节。

面对这种情况，我们该怎么办呢？首先，你要记住一件事，你不太可能记住真实项目的所有细节，甚至到你离开项目的那一天，你依然会有很多细节不知道，可这并不妨碍你的工作。但是，如果你心中没有一份关于项目实现的地图，你就一定会迷失。

像我前面所说的新人，他们用几个月的时间熟悉代码，就是在通过代码一点点展开地图，但是，这不仅极其浪费时间，也很难形成一个整体认知。所以我建议，你应该直接把地图展开。怎么展开呢？你需要找到两个关键点：软件的结构和关键的技术。

可能你还不太理解我的意思，下面我就以开源软件 Kafka 为例，给你讲一下如何把地图展开，去看一个软件的实现。按照我们之前讲过的思路，了解一个软件设计的步骤是「先模型，再接口，最后看实现」。所以，我们要先了解 Kafka 的模型和接口。

### 4.1 消息队列的模型与接口

Kafka 是这么自我介绍的：Kafka 是一个分布式流平台。这是它现在的发展方向，但在更多人的心目中，Kafka 的角色是一个消息队列。可以说，消息队列是 Kafka 这个软件的核心模型，而流平台显然是这个核心模型存在之后的扩展。所以，我们要先把焦点放在 Kafka 的核心模型 —— 消息队列上。简单地说，消息队列（Messaging Queue）是一种进程间通信的方式，发消息的一方（也就是生产者）将消息发给消息队列，收消息的一方（也就是消费者）将队列中的消息取出并进行处理。

站在看模型的角度上，消息队列是很简单的，无非是生产者发消息，消费者消费消息。而且消息队列通常还会有一个 topic 的概念，用以区分发给不同目标的消息。消息队列的基本接口也很简单。以 Kafka 为例，生产者是这样发消息的：

```java
producer.send(new KafkaRecord<>("topic", new Message()));
```

而消费者收消息是这样的：

```java
ConsumerRecords<String, Message> records = consumer.poll(1000);
```

有了对模型和接口的基本了解，我们会发现，消息队列本身并不难。但我们都知道，消息队列的实现有很多，Kafka 只是其中一种，还有诸如 ActiveMQ、RabbitMQ 等的实现。为什么会有这么多不同的消息队列实现呢？因为每个消息队列的实现都会有所侧重，不同的消息队列有其适用的场景。

消息队列还有一个最常见的特性是，它会提供一定的消息存储能力。这样的话，当生产者发消息的速度快于消费者处理消息的速度时，消息队列可以起到一定的缓冲作用。所以，有一些系统会利用消息队列的这个特性做「削峰填谷」，也就是在消息量特别大时，先把消息收下来，慢慢处理，以减小系统的压力。Kafka 之所以能从一众消息队列实现中脱颖而出，一个重要的原因就是，它针对消息写入做了优化，它的生产者写入速度特别快。从整体的表现上看，就是吞吐能力特别强。

好，我们已经对 Kafka 的能力有了一个初步的认识。显然，介绍接口和模型不足以将它与其他消息队列实现区分开来。所以，我们必须拉开大幕，开始去了解它的实现。

### 4.2 软件的结构

前面我提到，当我们想去看一个软件的实现时，有两件事特别重要：软件的结构和关键的技术。

我们先来看软件的结构。软件的结构其实也是软件的模型，只不过，它不是整体上的模型，而是展开实现细节之后的模型。我在第 1 讲也说过，模型是分层的。对于每个软件来说，当你从整体的角度去了解它的时候，它是完整的一块。但当你打开它的时候，它就变成了多个模块的组合，这也是所谓「分层」的意义所在。而上一层只要使用下一层提供给它的接口就好。所以，当我们打开了一个层次，了解它的实现时，也要先从大处着手。最好的办法就是我们能够找到一张结构图，准确地了解它的结构。

如果你能够找到这样一张图，你还是很幸运的。因为在真实的项目中，你可能会碰到各种可能性：1）结构图混乱：你找到一张图，上面包含了各种内容。比如，有的是模块设计，有的是具体实现，更有甚者，还包括了一些流程；2）结构图复杂：一个比较成熟的项目，图上画了太多的内容。确实，随着项目的发展，软件解决的问题越来越多，它必然包含了更多的模块。但对于初次接触这个项目的我们而言，它就过于复杂了；3）无结构图：这是最糟糕的情况，你最好先想办法画出一张图来。

无论遇到上述的哪种情况，你了解项目都不会很顺利。所以，你还是要先了解模型和接口，因为它们永远是你的主线，可以帮你从混乱的局面中走出来。那么，假设现在你有了一张结构图，在我们继续前进之前，我想先问一个问题：现在你有了一张结构图，你打算做什么？你可能会问，难道不是了解它的结构吗？是，但不够。我们不仅要知道一个设计的结果，最好还要推断出设计的动因。

所以，一种更好的做法是，带着问题上路。我们不妨假设自己就是这个软件的设计者，问问自己要怎么做。然后再去对比别人的设计，你就会发现，自己的想法和别人想法的相同或不同之处。对于理解 Kafka 而言，第一个问题就是如果你来设计一个消息队列，你会怎么做呢？

如果在网上搜索 Kafka 的架构图，你会搜到各种各样的图，上面包含了不同的信息。有的告诉你分区（Partition）的概念，有的告诉你 Zookeeper。根据前面对模型的介绍，我特意挑了一张看上去最简单的架构图，因为它最贴近消息队列的基础模型：

那么，从这个图中，你能看到什么呢？你能看到，Kafka 的生产者一端将消息发送给 Kafka 集群，然后，消费者一端将消息取出来进行处理。这样的结构和你想的是不是一样的呢？如果让你负责进一步设计，你会怎么做呢？1）生产者端封装出一个 SDK，负责消息的发送；2）消费者端封装出一个 SDK，负责消息的接收；3）设计一个集群系统，作为生产者和消费者之间的连接。

然后，你就可以问自己更多的问题：1）生产端如果出现网络抖动，消息没有成功发送，它要怎么重试呢？2）消费端处理完的消息，怎样才能保证集群不会重复发送呢？3）为什么要设计一个集群呢？要防止出现单点的故障，而一旦有了集群，就会牵扯到下一个问题，集群内的节点如何保证消息的同步呢？4）消息在集群里是怎么存储的？5）生产端也好，消费端也罢，如果一个节点彻底掉线，集群该怎么处理呢？……

你有了更多的问题之后，你就会在代码里进行更深入地探索。你可以根据需要，打开对应模块，进一步了解里面的实现。比如，消息重发的问题，你就可以看看生产端是怎么解决这些问题的。当问题细化到具体实现时，我们就可以打开对应的源码，去里面寻找答案。

从结构上来说，Kafka 不是一个特别复杂的系统。所以，如果你的项目更复杂，层次更多，我建议你把各个层次逐一展开，先把整体结构放在心中，再去做细节的探索。

### 4.3 关键的技术

我们再来看看理解实现的另一个重要方面：关键技术。

什么算是关键技术呢？就是能够让这个软件的「实现」与众不同的地方。了解关键技术可以保证一点，就是我们对代码的调整不会使项目出现明显的劣化。幸运的是，大多数项目都会愿意把自己的关键技术讲出来，所以，找到这些信息并不难。以 Kafka 为例，前面说过，它针对写入做了优化，使得它的整体吞吐能力特别强。那它是怎么做到的呢？

消息队列实现消息存储的方式通常是把它写入到磁盘中，而 Kafka 的不同之处在于，它利用了磁盘顺序读写的特性。对于普通的机械硬盘而言，如果是随机写，需要按照机械硬盘的方式去寻址，然后磁头做机械运动，写入速度就会慢得多。但顺序写的话，会大幅度减少磁头的运动，效率自然就得到了大幅度的提高。

之所以可以这样实现，是充分利用了消息队列本身的特性：有序。它是技术实现与需求完美结合的产物。有了这个基础，就可以有进一步的优化。比如，利用内存映射文件减少用户空间到内核空间复制的开销。如果站在了解实现的角度，你会觉得非常地自然。但要想从设计的角度学到更多，我们还是应该带着问题上路，多问自己一个问题，为什么其他的消息队列之前不这么做呢？这是一个值得深思的问题。Kafka 这个实现到底是哪里不容易想到呢？答案是软硬结合。

之前的消息队列实现也会把消息写入到文件里，但文件对它们来说，只是一个通用的接口。开发者并没有想过利用硬件的特性做开发。而 Kafka 的开发者突破了这个限制，把硬件特性利用了起来，从而取得了更好的结果。一旦理解了这一点，我们再来看其他的一些设计，就能学到更多的东西。比如，有一个著名的开源项目 LMAX Disruptor，它号称是最强劲的线程通信库。它有一段非常奇怪的代码，类似这样：

```java
protected long p1, p2, p3, p4, p5, p6, p7;
```

以正常程序员的标准，这简直是无厘头的低劣代码。而想要理解这段代码，你必须理解 CPU 缓存行的机制，这也是一种软硬结合的思路。

对于习惯写「软」件的程序员而言，在软件上投入的努力到达极限时，软硬结合是一种思路上的突破。当然，这种突破的前提是要对硬件的机制有所了解，这往往是很多程序员在基本功上欠缺的，可以学习一下计算机组成原理之类的课程。如果你有时间去学习，《深入理解计算机系统》一书值得一读。

### 黑板墙

最后，我想请你来思考一下，在项目上学习的哪些东西对你个人在实现思路上有了一个极大的突破。

旁外话：我的能力只能做到描述自己的理解。我描述自己的理解是希望能从栏主和其他学员处获得反馈，从而调整个人认知。我的身边缺少在软件设计上有追求的队友，很感谢有这个平台可以让我试错，交流，调整。

1、我认为软件的结构和核心技术应该是分开的。kafka 之所以是消息队列，看的是对消息队列这个模型的实现。kafka 之所以是 kafka 看的是其消息存储这一核心技术的实现。所以，如果我是想通过看 kafka 了解消息队列，那么就没必要也不该去看存储实现，我该看的是，路由信息管理，消息生产，消息消费这 3 块核心业务的骨干，以及其旁支功能的选择（限制消息大小，故障节点延后，延迟消费）；如果我想知道 kafka 为什么在 mq 中间件中如此突出，那么我就得了解其核心技术的实现，也就这里所说的「软硬结合的存储设计」。

2、谈谈对模型的理解。模型是一个抽象的概念，被抽象的对象可以是某个聚合实体（订单中心中的订单），也可以是某个流程或功能（java 内存模型中的主存与缓存同步的规则）。分层对模型来说是实现层面的东西，是一种水平方向的拆分，是一个实现上的规范；模型的细粒度拆分（父模型，子模型），应该是一种垂直维度的拆分，子模型的功能要高内聚，其复杂性不该发散到外部。

3、protected long p1, p2, p3, p4, p5, p6, p7; 这个玩意是 Disruptor 的缓存行填充中的填充字段。Disruptor 中的一个元素是一个 volatile 的 long 类型，占用 8 字节。一但一个元素被修改，则与其出于同个缓存行的所有元素的缓存都会失效。这就导致变更索引位 1 的元素，会导致索引位 0 的元素缓存也失效（操作时需要重新从主内存加载）。故而 Disruptor 做了一个缓存行填充的优化，在目标元素的前后都加了 7 个类型字段，两边都占据掉 56 个字节。故而保证每个元素都独占缓存行。是一种用空间换时间的优化。

4、04 讲说过要拿个开源项目来分析，刚好我拿的也是 mq，就借当前这个篇幅补充下。我看的是 RocketMq，目前看完了路由信息管理中心，消息生产端和消息存储的逻辑。拿路由信息管理中心 NameServer 来说。被抽象的模型对象是路由信息管理中心，既包含路由信息也包含路由信息的管理。路由信息由 QueueData，Broker，TopicRouteData 三个实体承载，路由信息管理由 BrokerLiveInfo 和 RouteInfoManager 负责。提供了路由注册，路由发现和路由删除三个接口。1）路由注册的接口触发是以 Nameserver 处理 Broker 的心跳包的方式接入的，具体代码见 RouteInfoManager#registerBroker。2）路由发现的接口触发 Nameserver 不管，由客户端定时请求获取路由信息，具体看 DefaultRequestProcessor#getRouteInfoByTopic。3）路由删除接口的触发是由 Nameserver 定时 10S 扫一遍 brokerLiveTable。将超时 120s 的 broker 信息全部剔除。或者 broker 正常关闭会来调用。具体见 RouteInfoManager#scanNotActiveBroker 和 unregisterBroker。

评价：作为路由信息中心，功能相对简单，所以技术设计上就没太多好说的。比较突出的就是 NameServer 节点间不做信息同步，每个 NameServer 都单独接收 broker 的心跳维护路由信息。这样的设计无疑极大降低了 NameServer 实现的复杂度，毕竟集群内消息同步一直是个头疼的事情。但是这样的方式，在 NameServer 节点过多和 broker 节点过多的场景下感觉都会有性能瓶颈（单位时间心跳的次数增多和需要心跳通知的节点增多）。可是这样的设计依旧抗住了大规模集群的场景，用实践案例打了我理论感观的脸。

但作为一个 apache 开源项目，其代码实现风格实在令人难受。违反单一职责原则，NamesrvController 做了外放接口，存储数据，启动定时等等一系列事情。且因为涵盖数据容器的职责，所以还需要再其他类中传递。违反依赖倒置原则，接口都找不到，就不用提啥基于接口而非实现编程了。如果要说这个项目的风格或者说代码设计偏好，那么就是没有原则，甚至都看不到阿里巴巴编程规范的影子。而这个问题不仅是在 NameServer 一个子模块中，而是在整个 rocketMq 模块都普遍存在。于此带来的就是，这个项目的新老交接，持续迭代，成本都会比较高。

限于篇幅，其他部分就不表了。rocketMq 是个很优秀很成功的产品，但也因为它的光辉，目前其背后的代码实现才越显得格格不入。作者回复：感谢你的分享，其他人可以从中学习到新的知识。2020-06-08

看一个项目的实现，主要是去看软件结构和关键技术。类似于 Kafka 这样的「网红」开源项目，可以找到的结构图和相关资料不少，特别是官方资料还是比较权威的，比平时工作中接触到的那些陈旧代码要好很多。文中对于 Kafka 的生产者消费者模型的初步提问，并不难以想到，生产者、消费者、集群连接；而后续问出更多的问题 —— 网络抖动、集群…… 这个就比较需要功力了。Kafka 的关键技术在于利用了磁盘顺序读写的特性，这个和 Disruptor 利用缓存填充技术颇有异曲同工之妙。而我前两天刚好在「数据结构和算法之美」的打卡活动里面，看过 Disruptor，印象颇深。顺路去看了「深入浅出计算机组成原理」中关于 Kafka 的章节，还试读了两篇「Kafka 核心技术与实战」，确实应该认真的学习一下 Kafka，这个号称薪资排名比较靠前的技能。我也好奇，面对 SSD 硬盘，Kafka 怎么办？作者回复：其实也不需要怎么办，享受硬件升级带来的好处就好了，性能自然就提升了。2020-06-08

相同的功能可能要不同的软件产品。他们的接口与模型都是差不多的，不同之处就在于实现。所以理解这些产品族以及他们的差异就该从实现入手。就像 LinkedList 和 ArrayList 都可以提供 List 的功能，但是实现的不同决定了他们各自不同的特性。使用时的选型还是要根据业务场景的需求来的。作者回复：这取决于你的模型是什么，如果是 List，LinkedList 和 ArrayList 就是实现。如果是具体类，它们就是各自的模型了。2020-06-08

先后看了 php 的源代码和 laravel，CI，Tp 等框架的源码。从从组件到接口，从组件到模型，最后从模型到实现，走完一整个生命周期，学习到了很多优雅的设计，以及扩展如何接入，不过并不真的为什么会这么设计，设计的时候会解决什么样的问题，以及应用场景，当时还是在大学，所以实战经验不是特别丰富，于是自己想动手实现一下框架，看看为什么框架可以引用于不同的架构，逐步扩展，发现思想虽然相同，但是实现的优雅程度还是不可比拟。作者回复：还有一个原因，你没有面对那个问题。所有的代码只是设计的结果，一些东西变复杂通常都是有原因的。2020-06-10
