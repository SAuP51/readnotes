# 2020009李运华的从零开始学架构R04

## 记忆时间

## 0400. 可扩展架构模式

## 0401. 可扩展架构的基本思想和模式

软件系统与硬件和建筑系统最大的差异在于软件是可扩展的，一个硬件生产出来后就不会再进行改变、一个建筑完工后也不会再改变其整体结构。例如，一颗 CPU 生产出来后装到一台 PC 机上，不会再返回工厂进行加工以增加新的功能；金字塔矗立千年历经风吹雨打，但其现在的结构和当时建成完工时的结构并无两样。相比之下，软件系统就完全相反，如果一个软件系统开发出来后，再也没有任何更新和调整，反而说明了这套软件系统没有发展、没有生命力。真正有生命力的软件系统，都是在不断迭代和发展的，典型的如 Windows 操作系统，从 Windows 3.0 到 Windows 95 到 Windows XP，直到现在的 Windows 10，一直在跟着技术的发展而不断地发展。

今天我们进入架构可扩展模式的学习，这部分内容包括分层架构、SOA 架构、微服务和微内核等，先来聊聊架构的可扩展模式。软件系统的这种天生和内在的可扩展的特性，既是魅力所在，又是难点所在。魅力体现在我们可以通过修改和扩展，不断地让软件系统具备更多的功能和特性，满足新的需求或者顺应技术发展的趋势。而难点体现在如何以最小的代价去扩展系统，因为很多情况下牵一发动全身，扩展时可能出现到处都要改，到处都要推倒重来的情况。这样做的风险不言而喻：改动的地方越多，投入也越大，出错的可能性也越大。因此，如何避免扩展时改动范围太大，是软件架构可扩展性设计的主要思考点。

### 1.1 可扩展的基本思想

幸运的是，可扩展性架构的设计方法很多，但万变不离其宗，所有的可扩展性架构设计，背后的基本思想都可以总结为一个字：拆！

拆，就是将原本大一统的系统拆分成多个规模小的部分，扩展时只修改其中一部分即可，无须整个系统到处都改，通过这种方式来减少改动范围，降低改动风险。说起来好像挺简单，毕竟「拆」我们见得太多了。一般情况下，我们要拆一个东西时，都是简单粗暴的。例如，用推土机拆房子、用剪刀拆快递包装、用手撕开包装袋等，反正拆完了这些东西就扔了。但面对软件系统，拆就没那么简单了，因为我们并不是要摧毁一个软件系统，而是要通过拆让软件系统变得更加优美（具备更好的可扩展性）。形象地说，软件系统中的「拆」是建设性的，因此难度要高得多。

按照不同的思路来拆分软件系统，就会得到不同的架构。常见的拆分思路有如下三种。1）面向流程拆分：将整个业务流程拆分为几个阶段，每个阶段作为一部分。2）面向服务拆分：将系统提供的服务拆分，每个服务作为一部分。3）面向功能拆分：将系统提供的功能拆分，每个功能作为一部分。

理解这三种思路的关键就在于如何理解「流程」「服务」「功能」三者的联系和区别。从范围上来看，从大到小依次为：流程 > 服务 > 功能，单纯从概念解释可能难以理解，但实际上看几个案例就很清楚了。我以 TCP/IP 协议栈为例，来说明「流程」「服务」「功能」的区别和联系。TCP/IP 协议栈和模型图如下图所示。

1、流程。对应 TCP/IP 四层模型，因为 TCP/IP 网络通信流程是：应用层 → 传输层 → 网络层 → 物理 + 数据链路层，不管最上层的应用层是什么，这个流程都不会变。

2、服务。对应应用层的 HTTP、FTP、SMTP 等服务，HTTP 提供 Web 服务，FTP 提供文件服务，SMTP 提供邮件服务，以此类推。

3、功能。每个服务都会提供相应的功能。例如，HTTP 服务提供 GET、POST 功能，FTP 提供上传下载功能，SMTP 提供邮件发送和收取功能。

1『上面关于流程、服务和功能的信息，收获很大，特别是意外获得了：HTTP 提供 Web 服务，FTP 提供文件服务，SMTP 提供邮件服务。拆分软件系统的思路，做一张主题卡片。』——已完成

我再以一个简单的学生信息管理系统为例（几乎每个技术人员读书时都做过这样一个系统），拆分方式是：

1、 面向流程拆分。展示层 → 业务层 → 数据层 → 存储层，各层含义是：1）展示层：负责用户页面设计，不同业务有不同的页面。例如，登录页面、注册页面、信息管理页面、安全设置页面等。2）业务层：负责具体业务逻辑的处理。例如，登录、注册、信息管理、修改密码等业务。3）数据层：负责完成数据访问。例如，增删改查数据库中的数据、记录事件到日志文件等。4）存储层：负责数据的存储。例如，关系型数据库 MySQL、缓存系统 Memcache 等。最终的架构如下：

2、面向服务拆分。将系统拆分为注册、登录、信息管理、安全设置等服务，最终架构示意图如下：

3、面向功能拆分。每个服务都可以拆分为更多细粒度的功能，例如：1）注册服务：提供多种方式进行注册，包括手机号注册、身份证注册、学生邮箱注册三个功能。2）登录服务：包括手机号登录、身份证登录、邮箱登录三个功能。3）信息管理服务：包括基本信息管理、课程信息管理、成绩信息管理等功能。4）安全设置服务：包括修改密码、安全手机、找回密码等功能。最终架构图如下：

通过学生信息管理系统的案例可以发现，不同的拆分方式，架构图差异很大。但好像无论哪种方式，最终都是可以实现的。既然如此，我们何必费尽心机去选择呢，随便挑选一个不就可以了？当然不能随便挑，否则架构设计就没有意义了，架构师也就要丢掉饭碗了。原因在于：不同的拆分方式，本质上决定了系统的扩展方式。

### 1.2 可扩展方式

当我们谈可扩展性时，很多同学都会有一个疑惑：就算是不拆分系统，只要在设计和写代码时做好了，同样不会出现到处改的问题啊？例如，在面向服务拆分的案例中，增加「学号注册」，就算是不拆分为服务，也可以控制修改的范围，那为何我们要大费周章地去拆分系统呢？

在一个理想的环境，你的团队都是高手，每个程序员都很厉害，对业务都很熟悉，新来的同事很快就知晓所有的细节…… 那确实不拆分也没有问题。但现实却是：团队有菜鸟程序员，到底是改 A 处实现功能还是改 B 处实现功能，完全取决于他觉得哪里容易改；有的程序员比较粗心；有的程序员某天精神状态不太好；新来的同事不知道历史上某行代码为何那么「恶心」，而轻易地将其改漂亮了一些…… 所有的这些问题都可能出现，这时候你就会发现，合理的拆分，能够强制保证即使程序员出错，出错的范围也不会太广，影响也不会太大。

下面是不同拆分方式应对扩展时的优势。

1、面向流程拆分。扩展时大部分情况只需要修改某一层，少部分情况可能修改关联的两层，不会出现所有层都同时要修改。例如学生信息管理系统，如果我们将存储层从 MySQL 扩展为同时支持 MySQL 和 Oracle，那么只需要扩展存储层和数据层即可，展示层和业务层无须变动。

2、面向服务拆分。对某个服务扩展，或者要增加新的服务时，只需要扩展相关服务即可，无须修改所有的服务。同样以学生管理系统为例，如果我们需要在注册服务中增加一种「学号注册」功能，则只需要修改「注册服务」和「登录服务」即可，「信息管理服务」和「安全设置」服务无须修改。

3、面向功能拆分。对某个功能扩展，或者要增加新的功能时，只需要扩展相关功能即可，无须修改所有的服务。同样以学生管理系统为例，如果我们增加「学号注册」功能，则只需要在系统中增加一个新的功能模块，同时修改「登录功能」模块即可，其他功能都不受影响。

不同的拆分方式，将得到不同的系统架构，典型的可扩展系统架构有：1）面向流程拆分：分层架构。2）面向服务拆分：SOA、微服务。3）面向功能拆分：微内核架构。当然，这几个系统架构并不是非此即彼的，而是可以在系统架构设计中进行组合使用的。以学生管理系统为例，我们最终可以这样设计架构：1）整体系统采用面向服务拆分中的「微服务」架构，拆分为「注册服务」「登录服务」「信息管理服务」「安全服务」，每个服务是一个独立运行的子系统。2）其中的「注册服务」子系统本身又是采用面向流程拆分的分层架构。3）「登录服务」子系统采用的是面向功能拆分的「微内核」架构。

### 黑板墙

规则引擎是常用的一种支持可扩展的方式，按照今天的分析，它属于哪一类？

面向流程、面向服务、面向功能，这三个的命名，面向服务和面向功能还可以，面向流程这个容易让人误解。面向流程，大概指的是数据移动的流程，而不是业务流程。分层架构的本质，就是固定的内核，移动的数据。规则引擎的扩展方式，可以用下排除法。首先，肯定不是分层架构，即不是面向流程的，因为规则引擎主要作用在业务层。其次，也不应该是面向服务的，因为规则引擎都是跨越多个服务的。规则引擎和插件式架构，解决的都是功能扩展的问题。微内核架构就是一种插件式架构。所以，规则引擎应该是面向功能的扩展方式。作者回复：思路很清晰，赞，面向流程这个说法确实不那么容易理解，但你对照 TCP/IP 那个图就很清晰了。2018-07-10

规则引擎由推理引擎发展而来，是一种嵌入在应用程序中的组件，实现了将业务决策从应用程序代码中分离出来，并使用预定义的语义模块编写业务决策。接受数据输入，解释业务规则，并根据业务规则做出业务决策。规则引擎是将业务决策与业务分离，它提供的还是决策功能，我觉得是面向功能，我没使用规则引擎的经验！不知道这样理解是否存在问题？作者回复：理解正确。2018-07-10

规则引擎是嵌入的一种功能组件，就像计算引擎一样，属于功能级的概念，应该属于面向功能的拆分。另一方面，即使把规则相关的部分做成服务，仅就规则引擎来讲，它也是功能级的概念，而非流程或者服务。2018-07-26

面向服务和面向功能，这两个概念感觉十分难以区分，某个功能也可以做成一个微服务，某个微服务也可以认为是一个功能，求教二者的差别。作者回复：可以理解服务是一组相似功能的集合，例如用户登录是服务，这个服务支持手机号登录，微信登录，QQ 登录 3 个登录功能，当然，如果你真的需要把手机号登录做成一个独立的服务也是可以的，不存在绝对的界限。2018-07-11

面向流程是否可以这样理解，比如电商网站下单的流程。登陆、浏览商品、加入购物车、结算、下单、支付、收货、评价等。拆完就是用户服务、商品服务、订单服务、评价服务等。谢谢华仔这么赞的所有章节！作者回复：是的，这就是面向流程拆分，同样是这个电商案例，如果按照男装，女装，电器拆分，就是面向服务拆分。2018-07-17

总结下今天所学到的内容。可拓展架构的基本思想就是拆，拆又分为流程拆分，服务拆分，功能拆分，三个粒度是越来越小。在工作中首先是按照业务流程拆分为不同的服务，小服务为了支持可拓展按流程拆分为合单、过滤拦截、冻结、查询库存、预售、寻仓等，再每个小流程按功能去拆分为不同的接口，再通过配置化实现这些接口的组装或者说调用链，来实现可配置化的支持业务。有新增业务，只需增加配置项和接口，不会影响到其他业务功能。2020-08-07

面向服务的拆分成独立的子系统，如文中所讲的学生管理系统，拆分为注册服务，登录服务，管理系统等子系统，请问老师，这些子系统是自己链接数据库的吗？实际项目都是怎么做的？作者回复：每个服务是独立的子系统，有各自独立的数据库，缓存，服务器。2018-07-10

规则引擎更多的是对变化比较频繁、参数比较多、条件组合比较多场景下的一种相对优雅的解决方法，可以归属为服务或功能层面，具体是功能还是服务要看切分的粒度。比如判断当前操作者是否为用户本人，可以采用规则引擎来实现，但这是一个服务还是功能就需要看具体的切分粒度和实现方式。作者回复：通常规则引擎还是按功能拆分更方便实施。2018-09-09

面向服务拆分的具体表现形式是每个服务部署为一个子系统，面向功能拆分的具体表现形式是怎样的呢，新功能一个 dll？作者回复：微内核，规则引擎。2018-07-16

感觉像是按功能拆分，一个模块可能之前只支持一两个规则，在有新的功能要加进来时可以只添加具体功能的实现，嵌入到原来的流程中。比如我们之前做的积分系统，各种活动获取积分时翻倍，新的活动规则都是用插件的方式添加的，不知道这个算不算。作者回复：是的，功能拆分。2018-07-10

## 0402. 传统的可扩展架构模式：分层架构和 SOA

李运华 2018-07-12

相比于高性能、高可用架构模式在最近几十年的迅猛发展来说，可扩展架构模式的发展可以说是步履蹒跚，最近几年火热的微服务模式算是可扩展模式发展历史中为数不多的亮点，但这也导致了现在谈可扩展的时候必谈微服务，甚至微服务架构都成了架构设计的银弹，高性能也用微服务、高可用也用微服务，很多时候这样的架构设计看起来高大上，实际上是大炮打蚊子，违背了架构设计的「合适原则」和「简单原则」。为了帮助你在实践中更好的进行可扩展架构设计，我将分别介绍几种可扩展架构模式，指出每种架构模式的关键点和优缺点。今天我来介绍传统的可扩展模式，包括分层架构和 SOA，后面还会介绍微服务架构。

### 2.1 分层架构

分层架构是很常见的架构模式，它也叫 N 层架构，通常情况下，N 至少是 2 层。例如，C/S 架构、B/S 架构。常见的是 3 层架构（例如，MVC、MVP 架构）、4 层架构，5 层架构的比较少见，一般是比较复杂的系统才会达到或者超过 5 层，比如操作系统内核架构。按照分层架构进行设计时，根据不同的划分维度和对象，可以得到多种不同的分层架构。

1、C/S 架构、B/S 架构。划分的对象是整个业务系统，划分的维度是用户交互，即将和用户交互的部分独立为一层，支撑用户交互的后台作为另外一层。例如，下面是 C/S 架构结构图。

2、MVC 架构、MVP 架构。划分的对象是单个业务子系统，划分的维度是职责，将不同的职责划分到独立层，但各层的依赖关系比较灵活。例如，MVC 架构中各层之间是两两交互的：

3、逻辑分层架构。划分的对象可以是单个业务子系统，也可以是整个业务系统，划分的维度也是职责。虽然都是基于职责划分，但逻辑分层架构和 MVC 架构、MVP 架构的不同点在于，逻辑分层架构中的层是自顶向下依赖的。典型的有操作系统内核架构、TCP/IP 架构。例如，下面是 Android 操作系统架构图。

典型的 J2EE 系统架构也是逻辑分层架构，架构图如下：

针对整个业务系统进行逻辑分层的架构图如下：

无论采取何种分层维度，分层架构设计最核心的一点就是需要保证各层之间的差异足够清晰，边界足够明显，让人看到架构图后就能看懂整个架构，这也是分层不能分太多层的原因。否则如果两个层的差异不明显，就会出现程序员小明认为某个功能应该放在 A 层，而程序员老王却认为同样的功能应该放在 B 层，这样会导致分层混乱。如果这样的架构进入实际开发落地，则 A 层和 B 层就会乱成一锅粥，也就失去了分层的意义。

分层架构之所以能够较好地支撑系统扩展，本质在于隔离关注点（separation of concerns），即每个层中的组件只会处理本层的逻辑。比如说，展示层只需要处理展示逻辑，业务层中只需要处理业务逻辑，这样我们在扩展某层时，其他层是不受影响的，通过这种方式可以支撑系统在某层上快速扩展。例如，Linux 内核如果要增加一个新的文件系统，则只需要修改文件存储层即可，其他内核层无须变动。

当然，并不是简单地分层就一定能够实现隔离关注点从而支撑快速扩展，分层时要保证层与层之间的依赖是稳定的，才能真正支撑快速扩展。例如，Linux 内核为了支撑不同的文件系统格式，抽象了 VFS 文件系统接口，架构图如下：

如果没有 VFS，只是简单地将 ext2、ext3、reiser 等文件系统划为「文件系统层」，那么这个分层是达不到支撑可扩展的目的的。因为增加一个新的文件系统后，所有基于文件系统的功能都要适配新的文件系统接口；而有了 VFS 后，只需要 VFS 适配新的文件系统接口，其他基于文件系统的功能是依赖 VFS 的，不会受到影响。

对于操作系统这类复杂的系统，接口本身也可以成为独立的一层。例如，我们把 VFS 独立为一层是完全可以的。而对于一个简单的业务系统，接口可能就是 Java 语言上的几个 interface 定义，这种情况下如果独立为一层，看起来可能就比较重了。例如，经典的 J2EE 分层架构中，Presentation Layer 和 Business Layer 之间如果硬要拆分一个独立的接口层，则显得有点多余了。

分层结构的另外一个特点就是层层传递，也就是说一旦分层确定，整个业务流程是按照层进行依次传递的，不能在层之间进行跳跃。最简单的 C/S 结构，用户必须先使用 C 层，然后 C 层再传递到 S 层，用户是不能直接访问 S 层的。传统的 J2EE 4 层架构，收到请求后，必须按照下面的方式传递请求：

分层结构的这种约束，好处在于强制将分层依赖限定为两两依赖，降低了整体系统复杂度。例如，Business Layer 被 Presentation Layer 依赖，自己只依赖 Persistence Layer。但分层结构的代价就是冗余，也就是说，不管这个业务有多么简单，每层都必须要参与处理，甚至可能每层都写了一个简单的包装函数。我以用户管理系统最简单的一个功能「查看头像」为例。查看头像功能的实现很简单，只是显示一张图片而已，但按照分层分册架构来实现，每层都要写一个简单的函数。比如：

Presentation Layer：

```java
package layer;
   
  /**
   * Created by Liyh on 2017/9/18.
   */
  public class AvatarView {
     public void displayAvatar(int userId){
         String url = AvatarBizz.getAvatarUrl(userId);
   
         //此处省略渲染代码
         return;
     }
  }
```

Business Layer：

```java
package layer;
   
  /**
   * Created by Liyh on 2017/9/18.
   */
  public class AvatarBizz {
     public static String getAvatarUrl(int userId){
         return AvatarDao.getAvatarUrl(userId);
     }
  }
```

Persistence Layer：

```java
package layer;
   
  /**
   * Created by Liyh on 2017/9/18.
   */
  public class AvatarDao {
     public static String getAvatarUrl(int userId) {
       //此处省略具体实现代码，正常情况下可以从MySQL数据库中通过userId查询头像URL即可
         return "http://avatar.csdn.net/B/8/3/1_yah99_wolf.jpg";
     }
  }
```

可以看出 Business Layer 的 AvatarBizz 类的 getAvatarUrl 方法和 Persistence Layer 的 AvatarDao 类的 getAvatarUrl 方法，名称和参数都一模一样。既然如此，我们是否应该自由选择是否绕过分层的约束呢？例如，「查看头像」的示例中，直接让 AvatarView 类访问 AvatarDao 类，不就可以减少 AvatarBizz 的冗余实现了吗？

答案是不建议这样做，分层架构的优势就体现在通过分层强制约束两两依赖，一旦自由选择绕过分层，时间一长，架构就会变得混乱。例如，Presentation Layer 直接访问 Persistence Layer，Business Layer 直接访问 Database Layer，这样做就失去了分层架构的意义，也导致后续扩展时无法控制受影响范围，牵一发动全身，无法支持快速扩展。除此以外，虽然分层架构的实现在某些场景下看起来有些啰嗦和冗余，但复杂度却很低。例如，样例中 AvatarBizz 的 getAvatarUrl 方法，实现起来很简单，不会增加太多工作量。

分层架构另外一个典型的缺点就是性能，因为每一次业务请求都需要穿越所有的架构分层，有一些事情是多余的，多少都会有一些性能的浪费。当然，这里所谓的性能缺点只是理论上的分析，实际上分层带来的性能损失，如果放到 20 世纪 80 年代，可能很明显；但到了现在，硬件和网络的性能有了质的飞越，其实分层模式理论上的这点性能损失，在实际应用中，绝大部分场景下都可以忽略不计。

### 1.2 SOA

SOA 的全称是 Service Oriented Architecture，中文翻译为「面向服务的架构」，诞生于上世纪 90 年代，1996 年 Gartner 的两位分析师 Roy W. Schulte 和 Yefim V. Natis 发表了第一个 SOA 的报告。2005 年，Gartner 预言：到了 2008 年，SOA 将成为 80% 的开发项目的基础。历史证明这个预言并不十分靠谱，SOA 虽然在很多企业成功推广，但没有达到占有绝对优势的地步。SOA 更多是在传统企业（例如，制造业、金融业等）落地和推广，在互联网行业并没有大规模地实践和推广。互联网行业推行 SOA 最早的应该是亚马逊，得益于杰弗·贝索斯的远见卓识，亚马逊内部的系统都以服务的方式构造，间接地促使了后来的亚马逊云计算技术的出现。

SOA 出现的背景是企业内部的 IT 系统重复建设且效率低下，主要体现在：1）企业各部门有独立的 IT 系统，比如人力资源系统、财务系统、销售系统，这些系统可能都涉及人员管理，各 IT 系统都需要重复开发人员管理的功能。例如，某个员工离职后，需要分别到上述三个系统中删除员工的权限。2）各个独立的 IT 系统可能采购于不同的供应商，实现技术不同，企业自己也不太可能基于这些系统进行重构。3）随着业务的发展，复杂度越来越高，更多的流程和业务需要多个 IT 系统合作完成。由于各个独立的 IT 系统没有标准的实现方式（例如，人力资源系统用 Java 开发，对外提供 RPC；而财务系统用 C# 开发，对外提供 SOAP 协议），每次开发新的流程和业务，都需要协调大量的 IT 系统，同时定制开发，效率很低。

为了应对传统 IT 系统存在的问题，SOA 提出了 3 个关键概念。

1、服务。所有业务功能都是一项服务，服务就意味着要对外提供开放的能力，当其他系统需要使用这项功能时，无须定制化开发。服务可大可小，可简单也可复杂。例如，人力资源管理可以是一项服务，包括人员基本信息管理、请假管理、组织结构管理等功能；而人员基本信息管理也可以作为一项独立的服务，组织结构管理也可以作为一项独立的服务。到底是划分为粗粒度的服务，还是划分为细粒度的服务，需要根据企业的实际情况进行判断。

2、ESB。ESB 的全称是 Enterprise Service Bus，中文翻译为「企业服务总线」。从名字就可以看出，ESB 参考了计算机总线的概念。计算机中的总线将各个不同的设备连接在一起，ESB 将企业中各个不同的服务连接在一起。因为各个独立的服务是异构的，如果没有统一的标准，则各个异构系统对外提供的接口是各式各样的。SOA 使用 ESB 来屏蔽异构系统对外提供各种不同的接口方式，以此来达到服务间高效的互联互通。

3、松耦合。松耦合的目的是减少各个服务间的依赖和互相影响。因为采用 SOA 架构后，各个服务是相互独立运行的，甚至都不清楚某个服务到底有多少对其他服务的依赖。如果做不到松耦合，某个服务一升级，依赖它的其他服务全部故障，这样肯定是无法满足业务需求的。但实际上真正做到松耦合并没有那么容易，要做到完全后向兼容，是一项复杂的任务。典型的 SOA 架构样例如下：

SOA 架构是比较高层级的架构设计理念，一般情况下我们可以说某个企业采用了 SOA 的架构来构建 IT 系统，但不会说某个独立的系统采用了 SOA 架构。例如，某企业采用 SOA 架构，将系统分为「人力资源管理服务」「考勤服务」「财务服务」，但人力资源管理服务本身通常不会再按照 SOA 的架构拆分更多服务，也不会再使用独立的一套 ESB，因为这些系统本身可能就是采购的，ESB 本身也是采购的，如果人力资源系统本身重构为多个子服务，再部署独立的 ESB 系统，成本很高，也没有什么收益。

SOA 解决了传统 IT 系统重复建设和扩展效率低的问题，但其本身也引入了更多的复杂性。SOA 最广为人诟病的就是 ESB，ESB 需要实现与各种系统间的协议转换、数据转换、透明的动态路由等功能。例如，下图中 ESB 将 JSON 转换为 Java（摘自《Microservices vs. Service-Oriented Architecture》）。

下图中 ESB 将 REST 协议转换为 RMI 和 AMQP 两个不同的协议：

ESB 虽然功能强大，但现实中的协议有很多种，如 JMS、WS、HTTP、RPC 等，数据格式也有很多种，如 XML、JSON、二进制、HTML 等。ESB 要完成这么多协议和数据格式的互相转换，工作量和复杂度都很大，而且这种转换是需要耗费大量计算性能的，当 ESB 承载的消息太多时，ESB 本身会成为整个系统的性能瓶颈。

当然，SOA 的 ESB 设计也是无奈之举。回想一下 SOA 的提出背景就可以发现，企业在应用 SOA 时，各种异构的 IT 系统都已经存在很多年了，完全重写或者按照统一标准进行改造的成本是非常大的，只能通过 ESB 方式去适配已经存在的各种异构系统。

### 黑板墙

为什么互联网企业很少采用 SOA 架构？

SOA 是把多个系统整合，而微服务是把单个系统拆开来，方向正好相反。作者回复：言简意赅。2018-07-19

SOA 是集成的思想，是解决服务孤岛打通链条，是无奈之举。esb 集中化的管理带来了性能不佳，厚重等问题。也无法快速扩展。不适合互联网的业务特点。作者回复：赞同。2018-07-18

为什么互联网不用 SOA？1）互联网企业，通常比较年轻，没有那么多异构系统，技术是公司的关键；如果有整合或者服务化的需求，公司有人也有钱专门搞这个；拆到重做/重构很平常；相反的，传统企业，举个例子：某传统炼钢国企：有多个遗留 .net 系统，有几个实习生做的 java 系统，有基于数据库 procedure 的系统；有各种已经倒闭了的第三方企业的系统等等；企业领导不会有精力和想法全部推倒重来，只会花钱请第三方，成本越低越好；这个时候就需要 ESB 这种总线。2）传统企业 IT 追求的是「需求灵活，变更快」，而互联网企业追求性能，传统 soa 性能不佳。传统的 esb，说实话，使用 webservice 以及 soap 这种基于 xml 的技术；wsdl 这东西是真的难用，难学难用难维护；结构冗杂。3）soa 这个东西很多时候只是一个概念，而不是实践。个人觉得，现在的微服务，更像是 soa 思想的一个落地（相比 esb）。作者回复：分析的很好，微服务和 SOA 的关系后面会讲。2018-07-12

回答问题：文中也说了，soa 是特定历史条件下的产物，为了适配各种异构的 it 系统，而有如此多系统的自然是变化减少且稳定的传统企业。互联网企业的特点就是小，新，快。没有历史包袱，变化快，大部分是从单体演进到分布式，技术栈一脉相承或者在分布式之前已经从 php,ruby 等改造到 java 等了。而到了分布式之后，面对不断的耦合，系统复杂度的陡增，这时一个 soa 的特例微服务出现了。实际上 soa 的思想还在，只不过实现的方式不一样了。作者回复：关于 soa 和微服务的关系，我会特别讲述。2018-07-12

一直不明白 SOA 和微服务的具体区别，知道作者讲到了 ESB 的功能，原来就是适配各种协议，顿时明白了！SOA 是为了适配老系统。作者回复：是的，所以 SOA 不适合创新型的互联网企业，比较适合传统大企业。2019-10-25

在传统企业从原先的手工作业转为采用 IT 系统作业的过程中，大多是采用向外采购的方式逐步实现的，在这个过程中不同部门采购系统的实现语言、通信协议并不完全相同，但为提升运行效率又要能够做到企业内部信息互通、相互协作，这是 soa 诞生的背景。而互联网企业是新创的企业，没有这么多的历史包袱，同时出于快速迭代的要求，有时会自建所需的系统，即使是对外采购，也会选择和已有系统对接方便的系统，从根本上避免了相关问题，因而 soa 在互联网公司中使用不多。作者回复：赞同。2018-09-09

SOA 更像一种架构理念，不够具体。在传统企业的 IT 系统中落地为 ESB，主要是为了集成异构系统。因为传统企业特别是大型企业的历史长，在其发展过程中自己开发或采购了不少异构系统。而互联网企业历史都短（腾讯 98 年，阿里 99 年，百度 2000 年），很少有遗留异构系统（像阿里的系统绝大部分应该都是 Java 开发的吧？)。像阿里这种互联网大型企业的痛点是随着业务越来越多，整个系统成了个巨无霸（可能是数以千记的模块数），模块之间的调用像蜘蛛网，极大降低了开发、测试、部署、运维的效率，所以把庞大的业务逻辑层又切分成了业务更独立的应用层和公共功能模块组成服务层。接下来一是要提供应用层与服务层之间、服务层内部服务之间的高效通信机制，二是要对大量的服务进行治理，于是分布式服务框架出现了（阿里就出了 Dubbo 和 HSF 两个服务框架？）。感觉在大型互联网企业，SOA 实际是落地为分布式服务框架，它更像是微服务架构的一个雏形，服务框架提供的功能实际也是微服务架构里必不可少的功能。作者回复：确实也有人将 SOA 理解为一个思想，微服务理解为 SOA 的具体实现。2019-05-04

soa 解决的是资源的重复利用，它的拆分粒度比较大，比如财务系统跟 oa 系统的员工模块。互联网企业有几种情况：1）初创公司，这种公司一般会有试错的过程，需要技术快速实现业务落地，这种情况下使用 SOA 不适合快速敏捷迭代开发。2）对于成熟的互联网业务来说，需要解决的是是高并发，高性能和高存储等一系列问题，对于这类企业来说，使用 SOA 拆分不能解决太多问题，还得做更加细粒度的拆分。作者回复：分析到位。2018-08-21

其实，个人理解的传统 SOA 和 ESB 在互联网企业之所以不怎么使用主要原因就是中心化的 ESB 架构会逐渐成为性能、可用性、可扩展性的瓶颈。但是 SOA 的思想本身是没有什么问题的。互联网企业中用的微服务甚至最近很火的 Service Mesh 都可以看成是 SOA、ESB 的变形。比如 Service Mesh 也可以看成是一个去中心化的 ESB。作者回复：这也是一种理解方式吧，微服务基础设施做完，确实感觉是做了一个 ESB。2018-07-18

互联网行业很少采用 soa，感觉有两点原因：1）soa 主要是解决异构系统之间的集成，传统企业有大量的异构系统，而互联网属于新兴行业，不存在大量的异构系统需要集成，2）esb 存在性能的瓶颈和不易扩展的问题，无法应对互联网这种业务会快速增长场景。作者回复：赞同。2018-07-12

第一章说 MVC 是开发规范，本章节说 MVC 是分层架构，不太明白，这两 MVC 说的不是一个东西吗，还是出发点不同。作者回复：按照 MVC 开发规范的系统就是 MVC 架构，这个是逻辑上的架构。2019-02-15

ESB 太重了，一般的互联网企业无福消受，性价比低。作者回复：其实现在微服务全套搞下来，不见得比 ESB 简单了，ESB 的核心问题是所有东西都在一套系统里面。2020-03-30

感觉 ESB 就像一个集中式的网关一样…...作者回复：是的，不单是网关，是整个微服务基础组件都在里面。2020-02-23

我对 soa 一直是不太清楚，其中 ESB 是不是可以理解为我们用的 dubbo，soa 可不可以理解为把项目进行粗力度的拆分，通过 dubbo 或者 http 协议向外提供服务。作者回复: dubbo 不是 ESB，dubbo 是统一的协议，ESB 需要兼容和适配很多协议。soa 主要不是为了拆分，而是将已经存在的异构系统整合起来。2018-07-17

之前还以为 SOA 在互联网很流行呢，没想到根本不用啊。作者回复：用得少，都用微服务了。2018-07-17

不知道大家为什么总是提到 esb 的问题，从文章中可以看到 esb 的出现也是无奈之举，互联网完全可以做到统一，不需要 esb，而且 soa 只是在功能分解上面的发展，而按照功能分解实现是很早就开始的，所以，不明白为什么互联网公司 soa 比较少。作者回复：虽然是无奈，但确实太重量级了，互联网公司 soa 用的少，但微服务做到最后，复杂度和 ESB 其实也差不多了。2018-07-16

## 0403. 深入理解微服务架构：银弹 or 焦油坑？

微服务是近几年非常火热的架构设计理念，大部分人认为是 Martin Fowler 提出了微服务概念，但事实上微服务概念的历史要早得多，也不是 Martin Fowler 创造出来的，Martin 只是将微服务进行了系统的阐述「[Microservices](https://martinfowler.com/articles/microservices.html)」。不过不能否认 Martin 在推动微服务起到的作用，微服务能火，Martin 功不可没。

微服务的定义相信你早已耳熟能详，参考维基百科，我就来简单梳理一下微服务的历史吧：

2005 年：Dr. Peter Rodgers 在 Web Services Edge 大会上提出了「Micro-Web-Services」的概念。

2011 年：一个软件架构工作组使用了「microservice」一词来描述一种架构模式。

2012 年：同样是这个架构工作组，正式确定用「microservice」来代表这种架构。

2012 年：ThoughtWorks 的 James Lewis 针对微服务概念在 QCon San Francisco 2012 发表了演讲。

2014 年：James Lewis 和 Martin Fowler 合写了关于微服务的一篇学术性的文章，详细阐述了微服务。

1-2『 2014 年的那篇文章就是前面的那个原文链接，一定要去研读。（2020-11-20）』——未完成

由于微服务的理念中也包含了「服务」的概念，而 SOA 中也有「服务」的概念，我们自然而然地会提出疑问：微服务与 SOA 有什么关系？有什么区别？为何有了 SOA 还要提微服务？这几个问题是理解微服务的关键，否则如果只是跟风拿来就用，既不会用，也用不好，用了不但没有效果，反而还可能有副作用。今天我们就来深入理解微服务，到底是银弹还是焦油坑。

### 3.1 微服务与 SOA 的关系

对于了解过 SOA 的人来说，第一次看到微服务这个概念肯定会有所疑惑：为何有了 SOA 还要提微服务呢？等到简单看完微服务的介绍后，可能很多人更困惑了：这不就是 SOA 吗？关于 SOA 和微服务的关系和区别，大概分为下面几个典型的观点。

1、微服务是 SOA 的实现方式。如下图所示，这种观点认为 SOA 是一种架构理念，而微服务是 SOA 理念的一种具体实现方法。例如，「微服务就是使用 HTTP、RESTful 协议来实现 ESB 的 SOA」「使用 SOA 来构建单个系统就是微服务」和「微服务就是更细粒度的 SOA」。

2、微服务是去掉 ESB 后的 SOA。如下图所示，这种观点认为传统 SOA 架构最广为人诟病的就是庞大、复杂、低效的 ESB，因此将 ESB 去掉，改为轻量级的 HTTP 实现，就是微服务。

3、微服务是一种和 SOA 相似但本质上不同的架构理念。如下图所示，这种观点认为微服务和 SOA 只是有点类似，但本质上是不同的架构设计理念。相似点在于下图中交叉的地方，就是两者都关注「服务」，都是通过服务的拆分来解决可扩展性问题。本质上不同的地方在于几个核心理念的差异：是否有 ESB、服务的粒度、架构设计的目标等。

以上观点看似都有一定的道理，但都有点差别，到底哪个才是准确的呢？单纯从概念上是难以分辨的，我来对比一下 SOA 和微服务的一些具体做法，再来看看到底哪一种观点更加符合实际情况。

1、服务粒度。整体上来说，SOA 的服务粒度要粗一些，而微服务的服务粒度要细一些。例如，对一个大型企业来说，「员工管理系统」就是一个 SOA 架构中的服务；而如果采用微服务架构，则「员工管理系统」会被拆分为更多的服务，比如「员工信息管理」「员工考勤管理」「员工假期管理」和「员工福利管理」等更多服务。

2、服务通信。SOA 采用了 ESB 作为服务间通信的关键组件，负责服务定义、服务路由、消息转换、消息传递，总体上是重量级的实现。微服务推荐使用统一的协议和格式，例如，RESTful 协议、RPC 协议，无须 ESB 这样的重量级实现。Martin Fowler 将微服务架构的服务通讯理念称为「Smart endpoints and dumb pipes」，简单翻译为「聪明的终端，愚蠢的管道」。之所以用「愚蠢」二字，其实就是与 ESB 对比的，因为 ESB 太强大了，既知道每个服务的协议类型（例如，是 RMI 还是 HTTP），又知道每个服务的数据类型（例如，是 XML 还是 JSON），还知道每个数据的格式（例如，是 2017-01-01 还是 01/01/2017），而微服务的「dumb pipes」仅仅做消息传递，对消息格式和内容一无所知。

3、服务交付。SOA 对服务的交付并没有特殊要求，因为 SOA 更多考虑的是兼容已有的系统；微服务的架构理念要求「快速交付」，相应地要求采取自动化测试、持续集成、自动化部署等敏捷开发相关的最佳实践。如果没有这些基础能力支撑，微服务规模一旦变大（例如，超过 20 个微服务），整体就难以达到快速交付的要求，这也是很多企业在实行微服务时踩过的一个明显的坑，就是系统拆分为微服务后，部署的成本呈指数上升。

4、应用场景。SOA 更加适合于庞大、复杂、异构的企业级系统，这也是 SOA 诞生的背景。这类系统的典型特征就是很多系统已经发展多年，采用不同的企业级技术，有的是内部开发的，有的是外部购买的，无法完全推倒重来或者进行大规模的优化和重构。因为成本和影响太大，只能采用兼容的方式进行处理，而承担兼容任务的就是 ESB。微服务更加适合于快速、轻量级、基于 Web 的互联网系统，这类系统业务变化快，需要快速尝试、快速交付；同时基本都是基于 Web，虽然开发技术可能差异很大（例如，Java、C++、.NET 等），但对外接口基本都是提供 HTTP、RESTful 风格的接口，无须考虑在接口层进行类似 SOA 的 ESB 那样的处理。

综合上述分析，我将 SOA 和微服务对比如下：

对比维度 | SOA | 微服务
|---|---|---|
| 服务粒度 | 粗 | 细 |
| 服务通信 | 重量级、ESB | 轻量级，如 RESTful |
| 服务交付 | 慢 | 快 |
| 应用场景 | 企业级 | 互联网 |

因此，我们可以看到，SOA 和微服务本质上是两种不同的架构设计理念，只是在「服务」这个点上有交集而已，因此两者的关系应该是上面第三种观点。其实，Martin Fowler 在他的微服务文章中，已经做了很好的提炼：

In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery.

上述英文的三个关键词分别是：small、lightweight、automated，基本上浓缩了微服务的精华，也是微服务与 SOA 的本质区别所在。

2『微服务，做一张术语卡片。』——已完成

通过前面的详细分析和比较，似乎微服务本质上就是一种比 SOA 要优秀很多的架构模式，那是否意味着我们都应该把架构重构为微服务呢？其实不然，SOA 和微服务是两种不同理念的架构模式，并不存在孰优孰劣，只是应用场景不同而已。我们介绍 SOA 时候提到其产生历史背景是因为企业的 IT 服务系统庞大而又复杂，改造成本很高，但业务上又要求其互通，因此才会提出 SOA 这种解决方案。如果我们将微服务的架构模式生搬硬套到企业级 IT 服务系统中，这些 IT 服务系统的改造成本可能远远超出实施 SOA 的成本。

### 3.2 微服务的陷阱

单纯从上面的对比来看，似乎微服务大大优于 SOA，这也导致了很多团队在实践时不加思考地采用微服务 —— 既不考虑团队的规模，也不考虑业务的发展，也没有考虑基础技术的支撑，只是觉得微服务很牛就赶紧来实施，以为实施了微服务后就什么问题都解决了，而一旦真正实施后才发现掉到微服务的坑里面去了。我们看一下微服务具体有哪些坑：

1、服务划分过细，服务间关系复杂。服务划分过细，单个服务的复杂度确实下降了，但整个系统的复杂度却上升了，因为微服务将系统内的复杂度转移为系统间的复杂度了。从理论的角度来计算，n 个服务的复杂度是 `n×(n-1)/2`，整体系统的复杂度是随着微服务数量的增加呈指数级增加的。下图形象了说明了整体复杂度：

粗粒度划分服务时，系统被划分为 3 个服务，虽然单个服务较大，但服务间的关系很简单；细粒度划分服务时，虽然单个服务小了一些，但服务间的关系却复杂了很多。

2、服务数量太多，团队效率急剧下降。微服务的「微」字，本身就是一个陷阱，很多团队看到「微」字后，就想到必须将服务拆分得很细，有的团队人员规模是 5-6 个人，然而却拆分出 30 多个微服务，平均每个人要维护 5 个以上的微服务。这样做给工作效率带来了明显的影响，一个简单的需求开发就需要涉及多个微服务，光是微服务之间的接口就有 6-7 个，无论是设计、开发、测试、部署，都需要工程师不停地在不同的服务间切换。1）开发工程师要设计多个接口，打开多个工程，调试时要部署多个程序，提测时打多个包。2）测试工程师要部署多个环境，准备多个微服务的数据，测试多个接口。3）运维工程师每次上线都要操作多个微服务，并且微服务之间可能还有依赖关系。

3、调用链太长，性能下降。由于微服务之间都是通过 HTTP 或者 RPC 调用的，每次调用必须经过网络。一般线上的业务接口之间的调用，平均响应时间大约为 50 毫秒，如果用户的一起请求需要经过 6 次微服务调用，则性能消耗就是 300 毫秒，这在很多高性能业务场景下是难以满足需求的。为了支撑业务请求，可能需要大幅增加硬件，这就导致了硬件成本的大幅上升。

4、调用链太长，问题定位困难。系统拆分为微服务后，一次用户请求需要多个微服务协同处理，任意微服务的故障都将导致整个业务失败。然而由于微服务数量较多，且故障存在扩散现象，快速定位到底是哪个微服务故障是一件复杂的事情。下面是一个典型样例。

Service C 的数据库出现慢查询，导致 Service C 给 Service B 的响应错误，Service B 给 Service A 的响应错误，Service A 给用户的响应错误。我们在实际定位时是不会有样例图中这么清晰的，最开始是用户报错，这时我们首先会去查 Service A。导致 Service A 故障的原因有很多，我们可能要花半个小时甚至 1 个小时才能发现是 Service B 返回错误导致的。于是我们又去查 Service B，这相当于重复 Service A 故障定位的步骤…… 如此循环下去，最后可能花费了几个小时才能定位到是 Service C 的数据库慢查询导致了错误。如果多个微服务同时发生不同类型的故障，则定位故障更加复杂，如下图所示。

Service C 的数据库发生慢查询故障，同时 Service C 到 Service D 的网络出现故障，此时到底是哪个原因导致了 Service C 返回 Error 给 Service B，需要大量的信息和人力去排查。

5、没有自动化支撑，无法快速交付。如果没有相应的自动化系统进行支撑，都是靠人工去操作，那么微服务不但达不到快速交付的目的，甚至还不如一个大而全的系统效率高。例如：1）没有自动化测试支撑，每次测试时需要测试大量接口。2）没有自动化部署支撑，每次部署 6-7 个服务，几十台机器，运维人员敲 shell 命令逐台部署，手都要敲麻。3）没有自动化监控，每次故障定位都需要人工查几十台机器几百个微服务的各种状态和各种日志文件。

6、没有服务治理，微服务数量多了后管理混乱。信奉微服务理念的设计人员总是强调微服务的 lightweight 特性，并举出 ESB 的反例来证明微服务的优越之处。但具体实践后就会发现，随着微服务种类和数量越来越多，如果没有服务治理系统进行支撑，微服务提倡的 lightweight 就会变成问题。主要问题有：1）服务路由：假设某个微服务有 60 个节点，部署在 20 台机器上，那么其他依赖的微服务如何知道这个部署情况呢？2）服务故障隔离：假设上述例子中的 60 个节点有 5 个节点发生故障了，依赖的微服务如何处理这种情况呢？3）服务注册和发现：同样是上述的例子，现在我们决定从 60 个节点扩容到 80 个节点，或者将 60 个节点缩减为 40 个节点，新增或者减少的节点如何让依赖的服务知道呢？如果以上场景都依赖人工去管理，整个系统将陷入一片混乱，最终的解决方案必须依赖自动化的服务管理系统，这时就会发现，微服务所推崇的「lightweight」，最终也发展成和 ESB 几乎一样的复杂程度。

### 黑板墙

你们的业务有采用微服务么？谈谈具体实践过程中有什么经验和教训。

我们公司的实践是比较粗粒度的子系统或服务，基本上没有太细粒度的微服务，以 webapi 为主。感觉更像微服务架构，只是服务粒度比较粗，从概念上算是 SOA 还是微服务架构呢？作者回复：我理解算微服务，千万不要理解为微服务就是将服务拆的很细，后面有具体实践技巧介绍这部分。2018-08-10

对于一个新事物的诞生，本能地套用已有的知识。特别是一个并不简单的东西，这算是一种高效的入门方法。微服务架构其实相当复杂，我是分成好几个阶段理解。1）第一阶段，微服务架构就是去掉了 ESB 的 SOA 架构，只不过是通信的方式和结构变了。对于初级的使用者而言，这样理解没有太大问题。2）第二阶段，没有了 ESB，原本很多由 ESB 组件做的事儿，转到服务的提供者和调用者这里了。他们需要考虑服务的拆分粒。大体仍然算是 SOA 架构。3）第三阶段，随着服务的数量大幅增加，服务的管理越来越困难，此时 DevOps 出现了。这个阶段的微服务架构，已经是跟 SOA 架构完全不同的东西了。

之前给一家大国企分享过一些经验。他们想从传统架构，转向微服务架构。1）建设好基础设施，RPC、服务治理、日志、监控、持续集成、持续部署、运维自动化是基本的，其它包括服务编排、分布式追踪等。2）要逐步演进和迭代，不要过于激进，更不要拆分过细，拆分的粒度，要与团队的架构相互匹配。（康威定律）3）微服务与数据库方面，是个很大的难点，可以深入了解下领域驱动设计，做好领域建模，特别是数据库要随着服务一起拆分。说完上面这些，他们的研发负责人说，我说的跟他们的架构师说的不一样，他们的架构师说，微服务就是各种拆分，不顾一切地拆分。作者回复：他们架构师是水货，你的理解和分析是对的，后一篇就讲了。2018-07-16

之前一家公司搞了一次完整的微服务改造，享受到了一些好处，但是文中说到的问题，大部分都碰上了。先说下好处，原来的单体应用都服务化了，扩容简单很多。功能隔离后之前一个 bug 导致系统挂掉的现象没了。问题责任定位划分的更清楚，比如之前大量慢 sql 无人管，现在通过监控快速找到开发责任人。再说下坏处，1）服务太多了，人不够啊。之前的架构师按照小的原则，把数据层，服务层，应用层严格拆分。一个人手上超过 10 几个服务。2）服务化不彻底，太多事手工干。服务监控只能监控一半指标，各种远程调用异常没人解决。运维只有打包发布做了自动化。可以想象下开发人员基本下改 bug 和发布的死循环中。服务网关没有，服务调用就是一张密密麻麻的网。3）培训不到位，直接上阵，开发人员对微服务理解不到位，服务质量可想而知。没有专职测试，自动化测试靠开发写脚本，谁有空啊，单元测试能写一个就算相当有觉悟了。总结下来，做服务化改造首先问自己这些问题，业务真的需要微服务来解决吗？真的所有模块的问题都要微服务来解决吗？技术人员的配置和水平达到要求了吗？2018-07-14

我们是一家社交公司，后端加厚的演变符合 dubbo 官网的那张图，在 Mvc 架构坚持了一年后，业务越来越大，工程越来越臃肿。后面我们一致同意进行服务话，开始用了 dubbo。后面由于决策层的原因没有上，后面来了个架构师，又重启了服务拆分，到现在已经用于生产。我们使用的是 Spring cloud，现在拆分暴露了很多问题：1）个别服务没有熔断出来，出现过雪崩效应。2）服务拆分过细，服务调用链过长。3）开发人员能力不一样，代码水平不一样。4）没有监控措施。5）每个服务部署多台，日志查询就会死人的感觉。6）开发过程中经常出现访问不到该访问的接口，这是因为开发人员经常启动本地服务，就会导致 30% 的概率访问不到。7）使用了不合理的持久层框架，使用了 JPA 访问。大概就有上面的问题，总之微服务不是银弹，用得不好会发现无穷无尽的坑。当然，出现问题解决问题就是了。唯一的就像 CEO 说的：你们他妈的是完全在拿用户当小白鼠使用。2018-07-16

我们目前全部微服务，踩坑踩了不少，拆分服务同时要把自动化运维系统和多维度监控系统，包括问题定位跟踪系统建立起来，要不然拆了就是噩梦。作者回复：感同身受啊。2018-08-17

说到微服务，切分的粒度和基础设施都致关重要。经历的项目有创业初期的单体服务，也有不太完善的服务切分的系统，也有微服务基础设施相对完善的公司。单体服务致命就致命在随着项目的发展，项目会越来越臃肿，越不利于扩展开发。微服务过程怕就怕基础不完善，人员配备不够盲目切分，导致工程师开发和维护的战线拉长，特别疲惫和泄气，容易产生一种抱怨的大气氛，从而导致微服务失败，重新合并一部分服务。

微服务做的好的，也有所经历，公司的基础设施完全云化和统一管理，申请几台机器，一套缓存集群，一套 mq，sql/nosql…...特别容易，工程师愿意建独立的工程，因为很容易构建和部署。这种感觉有点像 svn 和 git，git 建分支特别轻量，大家都愿意用分支管理自己的代码，迭代开发，应急处理都能自由切换，得心应手。

现在遇到一个问题，就是微服务内部系统大多使用 rpc，但对接外部系统，或者跨外网传输到客户端就需要 http-rest 类的协议。也就是我们常说的网关，如果是纯 http 就很容易做到通用的转发机制，但是 http 转 rpc 就不知道有什么方式可以做到通用转发了，内部每增加一个 rpc，网关就需要增加一个对应的服务处理逻辑。不知道，这个问题，有没有好的解决办法？作者回复：把 HTTP 转 RPC 做成规则，别硬编码每个接口，例如，规定 HTTP URL 为 `/service/interface/method?para1=xxx&para2=yyy`。2018-07-16

我们公司的平台就是使用微服务架构，十多二十个微服务，但是没有自动化部署，监控，自动化测试这些，而且每次报错日志也特别难找，但是我们那架构师却不重视这些，只想继续升级平台的功能。2018-07-15

我们项目之前是把数据采集，和展示都是我们 Java 组去写的。后面公司为了统一，把采集部分交给了.net 组。我们 Java 只负责数据展示。但是我们这边又按照领导的要求把整个业务拆分为模板解析层 —> api 层 —> 终端层。现在每次最烦的事就是找 bug。一直感觉现阶段我们的任务和目标没有这么庞大，这与架构中的简单和合适原则想违背。搞的整个项目组一直在反复的开发工作中。都很心累。2018-09-18

我们的业务也算是微服务吧，接手项目时，已经有好多服务，主要采用的语言有 java，php，nodejs，存在以下问题：1）没有一个统一的网关服务，前端请求后端服务都需要后端的服务 A 来充当安全校验，权限校验等，A 服务充当了多重职责，变的职责不明确了，后来抽出网关系统，负责平台统一的流量入口。在构建微服务网关系统是至关重要的。2）监控系统不完善，调用链跟踪，异常报警都不完善，对微服务是巨坑，查找问题如同一场噩梦，调用链很长，一旦发生异常不知道到底哪里出现问题，得一个一个去找。后来慢慢完善，变得好了很多，问题很快定位。3）加入网关后，没有一个统一的服务发现注册中心，网关的路由依靠人工手动配置，变的很麻烦，也很容易出错。后来引入 consul，得到改善。作者回复：spring 全家桶，你值得拥有。2018-07-14

16 年时，架构师引入了微服务架构，架构设计分为三层：网关层、业务处理层、数据处理层（getaway —> ls —> ds），自上而下依赖，业务层之间也互相依赖，构建过程中发现引入了分布式事务和调用链长（调用链的消耗时间无法接受），经常无故报错，定位问题慢，测试复杂等问题，而我们的大多数业务相对简单，所以重新划分服务粒度，分为两层：1）网关层：提供路由功能，2）业务处理层：处理请求，业务层中间可以相互调用，当出现有出现分布式事务时，采取 MQ 或者更新状态的方式解决，如果是充值 + 业务订单的这种会直接在一个事务里处理（其实这里就混乱一点了），层与层之间没有完全隔离，但是将调用链缩短，我觉得采用微服务架构确实解决了单体应用的一些问题，如资源问题（但消耗资源是比以前多的）、耦合问题、快速迭代问题，服务与服务的职责更加清晰，不同的服务粒度设计的系统是天差地别的。作者回复：是的，粒度太重要了。2018-12-11

我个人比较认同康威定律，微服务的拆分粒度一定要和组织结构匹配起来，组织结构和开发管理模式是微服务粒度的最重要参考指标之一。作者回复：是的，康威定律和微服务拆分是相关的。2018-11-08

个人觉得 SOA 只是提出了面向服务的编程，到但没有对服务粒度的定义，以及服务的治理问题做深入的分析。提出微服务主要是为了解决面向服务架构后如何能够在实际工程中带来真正的红利。微服务对 SOA 的技术关键点给出了指导意见。微服务对分布式服务的诱惑力的确很大，但做但微服务都不会免费的，需要很多的基础设施来做铺垫和基石，才有可能搞定。除了基础设施还有很多设计思想需要学习，我觉得 DDD 就是微服务的绝配。作者回复：SOA 是完整的解决方案哦，IBM 等公司卖 ESB 都卖了好多钱。2018-08-09

我弄微服务遇到最大的坑，就是 jvm 与 docker 兼容性不好，导致每个微服务会消耗过多不必要的内存，我感觉从资源消耗上来说，java 开发的微服务都不能算是微服务了，最近在转向 go 来改造。作者回复：这还真是第一次听说 jvm 与 docker 不兼容，看看是不是有 bug。2018-07-14

我记得有一次做业务，当时不知道什么原因，整体使用微服务，当时是个新业务，完全从 0 开始，没有任何用户基础，当时按照业务把服务拆成了 7.8 个微服务，但没有自动化，服务还是部署在一台机器上，服务之间也没有服务治理，服务之间的调用链很长，开发就 4.5 个人，定位问题花费时间长，典型的基础服务也跟不上。现在想想，当时团队不知道咋想的，觉得微服务比较新就上了，完全没有考虑到产生的问题。还好后来这块业务黄了。要不然估计坑更多。对于创业公司来说，刚开始的时候，其实一个服务就够了，真等用户上来了，业务有希望了，那时候再上其他架构模式也不迟，忌讳一开始就求新求全，说到底，对于大部分公司来说。技术是为业务服务的。作者回复：你们缺少一个真正的架构师。2018-08-21

dubbo 和 motan 这类 rpc 框架，是微服务框架？作者回复：dubbo 可以算微服务基础设施的一部分，主要承担服务注册发现等。2018-07-15。我们用的是 dubbo。最开始系统要快速上线，所以服务拆分的不彻底。订单，商品，店铺等这些服务都没有进行拆分。就把支付和营销两个服务拆分出来了。服务拆分不彻底经常导致一个业务有问题。整个系统都用不了。作者回复：不是拆分有问题，是配套基础设施有问题。2018-07-15

我家公司之前在满足现有业务增长规模的情况下，也涉足微服务领域了，其实遇到的问题跟大家也差不多：1）业务拆分问题，大家对服务的理解类似于某个技术框架，让这个技术框架适配现有业务流程和架构就好了，这就有点新瓶装旧酒的味道，对于怎么拆分，大家各执一词，争论不休，尤其在数据库规划上，更是举步维艰，很难有进展，后来才找到一种方法，领域驱动设计（DDD），算是解了燃眉之急。2）技术栈在应对微服务架构的时候，显得心有余而力不足，传统技术栈不会包括服务发现，服务治理，以及调用链分析，在微服务架构上知识结构体系是不全的。3）整个微服务环境甚至文化处于原始阶段，大家都觉得微服务只是一个点上面的事情，比如只是后台的事情，而事实上，这个关乎测试（自动化测试）还有运维（持续集成，持续部署，监控）等，也就是华哥在回复区提到的基础架构部分。4）研发部门的尴尬，由于公司一向偏向于 c++，没有人熟悉 java，所以在落地的时候，就没有 spring 全家桶就能解决所有事情的那种小幸运，而要选择不同的服务组件来满足微服务架构的需求。作者回复：c++ 确实没有合适的全家桶，自己搞投入还是很大的。2020-03-10

我们现有的服务也算是微服务了，也是逐渐演进过来的，微服务不单单是服务的拆分解耦。还包含 devops 自动化部署，自动化监控，服务编排以及各类方便开发人员聚焦到开发上的工具，不要把精力都消耗在那些重复工作中。作者回复：嗯，微服务必须要有基础设施配套，不然很蛋疼。2019-12-12

微服务遇到的坑，不知道算不算。第一个是到底满足什么条件才能算一个微服务，往往是为了拆分而拆分，比如将一个服务拆分成了 ABC 三个微服务，BC 仅仅是为 A 提供服务不具有独立的能力，接口也只是内部接口，对外完全不可见。第二个是微服务内部是有状态的，这就导致了其它访问的时候必须请求到那个实例，对伸缩和可靠性带来了不利的影响。第三个是扩缩容依赖，服务 A 需要扩充一倍，依赖的服务要扩充多少呢？这个往往很难评估准确，曾出现过由于扩充的比例不对导致现网紧急变更。最后是分布式一致性，微服务之间往往需要互相配合来完成某个业务功能，但是由于网络故障或其它原因经常处理不一致。然后通过各种系统定时任务去清理或修正，系统越来越难以理解。作者回复：都算，尤其是最后一个，查起来很麻烦。2019-09-20

非常认同老师的微服务没有基础的治理平台是非常坑的观点，我就亲身经历过，上一家公司是个只有七八个人的小团队，一切都是从零开始，项目经理也挺喜欢研究技术的，当时就是使用 spring 的全家桶来搭建的微服务，开发、测试、部署、运维真是非常费劲。一台机器从编译到部署完启动起来就需要半天功夫，什么都是人肉来处理，效率相当慢。目前的公司基础技术服务比较完善，RPC、MQ、缓存、监控、部署等等都有专门的团队来维护，基本是自研或二次开发，上线部署轻松简单，上几百台也是很轻松容易的，时间主要花费在业务验证上，有一套流程要走。基础服务的使用也比较简单，他们来运维，有需求也可以提。微服务是把双刃剑，用好了能杀敌，用不好会伤己。2019-09-02

服务拆分的粒度太小，造成了一个业务的修改涉及的系统太多，引入了很多系统复杂度，但是又缺少人手，经常造成开发工作量太大，需要同时上线多个服务，缺乏自动化部署，每次测试都要涉及多个系统接口的测试。最大问题是服务无法实现事务的原子性（实现分布式事务代价太高没有采用），造成一个业务异常无法回滚，频繁需要修改数据。服务没有实现治理，造成发生问题时，没有及时发现问题。2019-08-30

我们公司拆分的原因主要是基于现有遗留的老系统太过于庞大，代码结构比较混乱，每次新的需求过来的时候，都会牵一发而动全身，从而有了服务拆分的想法，但是对于当时的服务拆分的粒度，受限于人员数量以及对微服务的理解，根据业务模块做了服务的拆分，但是有一个问题是还是共用的一个库，而且链路监控以及服务治理都还在预研阶段，并没有落地，现在都是哪边遇到坑就去填坑，数据库的拆分以及数据迁移在后面也是一个不得不头痛的问题，请求老师现在的这个情况，您这边有什么好的建议么？作者回复：先完善基础设施。2019-04-18

我在想如果启动一个服务进程 服务里有多线程 每个线程启动一个 vm 虚拟机去执行脚本 一个脚本的 vm 去对应一个微服务 这个部署只需启动一个进程服务器就可以啦 另外一个 vm 对应一个 actor 实体 对应一个微服务 然后用每个 actor 处理自己的消息，通过 rpc 调用是不是可以？部署从外部看是一个整体 从内部看是众多的服务（每个服务对应一个 actor 个体实现相应的功能）。作者回复：akka 框架就是做这事的，但很复杂。2018-12-14

我想问问 HTTP 和 RPC 的调用方式，目前对外接口采用 http，内部服务间调用采用 RPC，不知道有没有问题。作者回复：这是最常见的做法，你可以思考一下为什么对外用 HTTP 对内用 RPC，而不是反过来。2018-11-12

文中说的问题深有体会！服务与服务之间调用失败难以定位，因为这个问题我们也做了服务调用链路日志监控，但还不完善。因为服务拆分数据存储在不同的库，导致统计报表，一些实时查询缓慢。部署耗时 3 个环境，多个服务简直是蛋疼。目前没有自动化部署，自动化测试，后端开发 3 人。因为是新产品试用阶段，根据用户反馈不断修改增加功能。因为没控制好拆分和架构师的指导目前项目显得有点臃肿。基于一路走过来的坑，我感觉新项目开始，需要不明确，功能逻辑反复推翻，未有一套完整的微服务架构。基础设施不完善的情况下不要实施微服务，前期实施单体，业务功能稳定后有一定的微服务经验才实施微服务。作者回复：你们应该是过度设计了。2018-09-26

之前公司把业务是分为几个大系统，通过 hessian 进行通信，请问老师这算是什么架构，这个架构师是支付宝过来的。还有系统间可以直接调用，什么情况下需要 esb，它究竟有什么用？作者回复：你可以这么理解，每个系统对外提供的接口协议都是一样的就是服务拆分，每个系统的接口协议不同，需要中间件来转换，那就是 ESB。2018-08-26

像我们公司这种：产品划分为几个大应用，每个应用暴露出来一系列 rpc 接口，部分公共逻辑拆分为小应用，也是暴露 rpc 接口。系统之间就通过 rpc 交互，中间加个 nginx 做负载均衡；没有服务发现和配置中心，因为接口不是很多，都靠配置文件手工管理。算不算是比较 low 的微服务？作者回复：合适就好，太高逼格可能问题更多，参考架构设计的其中一条原则。2018-08-25

App 后台设计了用户、LBS、商品、UGC、订单 & 支付、活动等微服务，然后由 API 根据不同功能模块串联提供给客户端。服务之间通过 rpc 通信。优点：1）独立部署，性能优化容易。2）便于分工，实现相互独立 & 透明。缺点：1）需求开发沟通成本高（尤其当新增终端时）。2）线上排查问题慢（链路长，多机部署）。作者回复：需要微服务基础设施来解决你的问题。2018-08-03

http 转 rpc 我们卡在了怎么去掉模型和接口这两个骨架代码这里，有没有办法可以不加入骨架代码，按照既定的 url 自动解析，然后转发？或者说只能使用协议解析实现？我们用的 thrift，回头我需要确认一下 thrift 的 protocol 在编解码的时候，有没有写入模型的类型信息，如果没有的话，实现起来感觉不会太复杂，如果包含模型的类型信息，就和骨架代码强耦合了。阿里如何处理的这种情况呢？作者回复：HTTP 协议解析很简单的呀，可以试试，阿里也有 MTOP 承担类似职责。2018-07-17

按照这样说，用 Web API 方式构造的服务，也是属于微服务吗？作者回复：不一定，微服务不单单是将 ESB 改为 HTTP，后面会深入阐述。2018-07-17
