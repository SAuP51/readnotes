## 记忆时间

## 卡片

### 0101. 主题卡——JS 中执行上下文的知识框架

执行上下文最常见的是全局执行上下文和函数执行上下文两大类。执行上下文基本等价于词法环境（Lexical Environment），只有涉及到 var 声明的时候才是变量环境（Variable Environment），而词法环境包括：环境记录、指向外层环境的引用和 this 绑定。

函数执行上下文与全局执行上下文的区别在于，其词法环境里的环境记录（一个对象），多了一个参数属性「Arguments: {0: arg1, 1: arg2, length: 2}」。

### 0201. 术语卡——Execution Context

Global Execution Context — This is the default or base execution context. The code that is not inside any function is in the global execution context. It performs two things: it creates a global object which is a window object (in the case of browsers) and sets the value of this to equal to the global object. There can only be one global execution context in a program.

Functional Execution Context — Every time a function is invoked, a brand new execution context is created for that function. Each function has its own execution context, but it’s created when the function is invoked or called. There can be any number of function execution contexts. Whenever a new execution context is created, it goes through a series of steps in a defined.

### 0202. 术语卡——How is the Execution Context created

How an execution context is created by the JavaScript engine. The execution context is created in two phases: Creation Phase and Execution Phase. The execution context is created during the creation phase. Following things happen during the creation phase: 1) Lexical Environment component is created. 2) Variable Environment component is created. 

### 0203. 术语卡——Lexical Environment

The official ES6 docs define Lexical Environment as: A Lexical Environment is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an Environment Record and a possibly null reference to an outer Lexical Environment.

Simply put, A lexical environment is a structure that holds identifier-variable mapping. (here identifier refers to the name of variables/functions, and the variable is the reference to actual object [including function object and array object] or primitive value).

Each Lexical Environment has three components: 1) Environment Record. 2) Reference to the outer environment. 3) This binding.

词法环境三元素：环境记录、指向外层环境的引用和 this 绑定。

### 0204. 术语卡——Variable Environment

It’s also a Lexical Environment whose EnvironmentRecord holds bindings created by VariableStatements within this execution context. As written above, the variable environment is also a lexical environment, So it has all the properties and components of a lexical environment as defined above.

In ES6, one difference between LexicalEnvironment component and the VariableEnvironment component is that the former is used to store function declaration and variable (let and const) bindings, while the latter is used to store the variable (var) bindings only.

1『个人理解，ES6 以后基本不会用 var 声明了，所以知识储备里不用记忆 Variable Environment 的具体内容，只需知道用 var 声明的时候才会有环境变量。』

### 0205. 术语卡——hoisting

As you might have noticed that the let and const defined variables do not have any value associated with them during the creation phase, but var defined variables are set to undefined. This is because, during the creation phase, the code is scanned for variable and function declarations, while the function declaration is stored in its entirety in the environment, the variables are initially set to undefined (in case of var) or remain uninitialized (in case of let and const). This is the reason why you can access var defined variables before they are declared (though undefined) but get a reference error when accessing let and const variables before they are declared. This is, what we call hoisting.

对「提升」改理解加深了很多很多。在执行环境的创建阶段，代码里的变量声明和函数声明会被扫描，其中函数声明会被整体存入到环境里，变量声明这边分 2 种情况：var 声明的变量会被直接赋值（没赋值的话指定为 undefined），而 let、const 声明的变量在此阶段不会被赋值（执行阶段才会赋值）。这就可以解释提升为啥只对 var 变量和函数有效，在执行阶段里，因为前面的创建阶段这 2 个东西已经被存入环境里了，在声明语句之前就可以用执行语句操作，但是 let、const 声明的变量在前面没赋值过，当然报错，所以 let、const 声明的变量必须要在其执行语句之前。

## 20200501Understanding-Execution-Context-and-Execution-Stack-in-Javascript.md

If you are or want to be a JavaScript developer, then you must know how the JavaScript programs are executed internally. The understanding of execution context and execution stack is vital in order to understand other JavaScript concepts such as Hoisting, Scope, and Closures. Properly understanding the concept of execution context and execution stack will make you a much better JavaScript developer.

Tip: Use Bit to build JS apps faster with components. It helps you share and reuse components with your team, using them to build new apps! Give it a try.

3『 [The shared component cloud · Bit](https://bit.dev/) 』

### 01. What is an Execution Context?

Simply put, an execution context is an abstract concept of an environment where the Javascript code is evaluated and executed. Whenever any code is run in JavaScript, it’s run inside an execution context.

Types of Execution Context. There are three types of execution context in JavaScript.

1. Global Execution Context — This is the default or base execution context. The code that is not inside any function is in the global execution context. It performs two things: it creates a global object which is a window object (in the case of browsers) and sets the value of this to equal to the global object. There can only be one global execution context in a program.

2. Functional Execution Context — Every time a function is invoked, a brand new execution context is created for that function. Each function has its own execution context, but it’s created when the function is invoked or called. There can be any number of function execution contexts. Whenever a new execution context is created, it goes through a series of steps in a defined order which I will discuss later in this article.

3. Eval Function Execution Context — Code executed inside an eval function also gets its own execution context, but as eval isn’t usually used by JavaScript developers, so I will not discuss it here.

### 02. Execution Stack

Execution stack, also known as「calling stack」in other programming languages, is a stack with a LIFO (Last in, First out) structure, which is used to store all the execution context created during the code execution. When the JavaScript engine first encounters your script, it creates a global execution context and pushes it to the current execution stack. Whenever the engine finds a function invocation, it creates a new execution context for that function and pushes it to the top of the stack.

The engine executes the function whose execution context is at the top of the stack. When this function completes, its execution stack is popped off from the stack, and the control reaches to the context below it in the current stack. Let’s understand this with a code example below:

```js
let a = 'Hello World!';
function first() {
  console.log('Inside first function');
  second();
  console.log('Again inside first function');
}
function second() {
  console.log('Inside second function');
}
first();
console.log('Inside Global Execution Context');
```

When the above code loads in the browser, the Javascript engine creates a global execution context and pushes it to the current execution stack. When a call to first() is encountered, the Javascript engines creates a new execution context for that function and pushes it to the top of the current execution stack.

When the second() function is called from within the first() function, the Javascript engine creates a new execution context for that function and pushes it to the top of the current execution stack. When the second() function finishes, its execution context is popped off from the current stack, and the control reaches to the execution context below it, that is the first() function execution context.

When the first() finishes, its execution stack is removed from the stack and control reaches to the global execution context. Once all the code is executed, the JavaScript engine removes the global execution context from the current stack.

### 03. How is the Execution Context created?

Up until now, we have seen how the JavaScript engine manages the execution context, Now let’s understand how an execution context is created by the JavaScript engine. The execution context is created in two phases: 1) Creation Phase and 2) Execution Phase.

1『 JS 里代码的执行，脑子里时刻要有创建阶段和执行阶段这两个概念，变量声明在创建阶段就动起来了，执行阶段的时候才真正赋值，这两个阶段的分离有助于理解「提升」的概念。』

### 04. The Creation Phase

The execution context is created during the creation phase. Following things happen during the creation phase: 1) Lexical Environment component is created. 2) Variable Environment component is created. So the execution context can be conceptually represented as follows:

```js
ExecutionContext = {
  LexicalEnvironment = <ref. to LexicalEnvironment in memory>,
  VariableEnvironment = <ref. to VariableEnvironment in  memory>,
}
```

#### 1. Lexical Environment

The official ES6 docs define Lexical Environment as:

A Lexical Environment is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an Environment Record and a possibly null reference to an outer Lexical Environment.

3『 [ECMAScript 2015 Language Specification – ECMA-262 6th Edition](http://ecma-international.org/ecma-262/6.0/) 』

Simply put, A lexical environment is a structure that holds identifier-variable mapping. (here identifier refers to the name of variables/functions, and the variable is the reference to actual object [including function object and array object] or primitive value).

For example, consider the following snippet:

```js
var a = 20;
var b = 40;
function foo() {
  console.log('bar');
}
```

So the lexical environment for the above snippet looks like this:

```js
lexicalEnvironment = {
  a: 20,
  b: 40,
  foo: <ref. to foo function>
}
```

Each Lexical Environment has three components: 1) Environment Record. 2) Reference to the outer environment. 3) This binding.

Environment Record. The environment record is the place where the variable and function declarations are stored inside the lexical environment. There are also two types of environment record :

1. Declarative environment record — As its name suggests stores variable and function declarations. The lexical environment for function code contains a declarative environment record.

2. Object environment record — The lexical environment for global code contains a objective environment record. Apart from variable and function declarations, the object environment record also stores a global binding object (window object in browsers). So for each of binding object’s property (in case of browsers, it contains properties and methods provided by browser to the window object), a new entry is created in the record.

Note — For the function code, the environment record also contains an arguments object that contains the mapping between indexes and arguments passed to the function and the length(number) of the arguments passed into the function. For example, an argument object for the below function looks like this:

```js
function foo(a, b) {
  var c = a + b;
}
foo(2, 3);
// argument object
Arguments: {0: 2, 1: 3, length: 2},
```

Reference to the Outer Environment. The reference to the outer environment means it has access to its outer lexical environment. That means that the JavaScript engine can look for variables inside the outer environment if they are not found in the current lexical environment.

1『闭包的概念。』

This Binding. In this component, the value of this is determined or set. 

1. In the global execution context, the value of this refers to the global object. (in browsers, this refers to the Window Object).

2. In the function execution context, the value of this depends on how the function is called. If it is called by an object reference, then the value of this is set to that object, otherwise, the value of this is set to the global object or undefined(in strict mode). For example:

1『目前 JS 的知识储备里关于 this 绑定值的理解。函数对象里的 this 绑定值取决于以何种方式调用：1）直接调用，其绑定到全局对象 window，在严格模式下绑定到 undefined。2）作为某个对象的方法被调用（提取），其绑定到该对象上；3）通过 new 调用构造函数构建新对象，其绑定到这个新对象上。4）通过 call/apply 方法调用，其绑定到 call/apply 方法指定的对象上，指定的对象是作为参数传入 call/apply 方法里的。』

```js
const person = {
  name: 'peter',
  birthYear: 1994,
  calcAge: function() {
    console.log(2018 - this.birthYear);
  }
}
person.calcAge(); 
// 'this' refers to 'person', because 'calcAge' was called with //'person' object reference
const calculateAge = person.calcAge;
calculateAge();
// 'this' refers to the global window object, because no object reference was given
```

Abstractly, the lexical environment looks like this in pseudocode:

```js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // Identifier bindings go here
    }
    outer: <null>,
    this: <global object>
  }
}
FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // Identifier bindings go here
    }
    outer: <Global or outer function environment reference>,
    this: <depends on how function is called>
  }
}
```

#### 2. Variable Environment

It’s also a Lexical Environment whose EnvironmentRecord holds bindings created by VariableStatements within this execution context. As written above, the variable environment is also a lexical environment, So it has all the properties and components of a lexical environment as defined above.

In ES6, one difference between LexicalEnvironment component and the VariableEnvironment component is that the former is used to store function declaration and variable (let and const) bindings, while the latter is used to store the variable (var) bindings only.

### 05. Execution Phase

In this phase assignments to all those variables are done and the code is finally executed.

### 06. Example

Let’s look at some example to understand the above concepts:

```js
let a = 20;
const b = 30;
var c;
function multiply(e, f) {
 var g = 20;
 return e * f * g;
}
c = multiply(20, 30);
```

When the above code is executed, the JavaScript engine creates a global execution context to execute the global code. So the global execution context will look something like this during the creation phase:

```js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // Identifier bindings go here
      a: < uninitialized >,
      b: < uninitialized >,
      multiply: < func >
    }
    outer: <null>,
    ThisBinding: <Global Object>
  },
  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // Identifier bindings go here
      c: undefined,
    }
    outer: <null>,
    ThisBinding: <Global Object>
  }
}
```

During the execution phase, the variable assignments are done. So the global execution context will look something like this during the execution phase.

```js
GlobalExectionContext = {
LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // Identifier bindings go here
      a: 20,
      b: 30,
      multiply: < func >
    }
    outer: <null>,
    ThisBinding: <Global Object>
  },
VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // Identifier bindings go here
      c: undefined,
    }
    outer: <null>,
    ThisBinding: <Global Object>
  }
}
```

When a call to function multiply(20, 30) is encountered, a new function execution context is created to execute the function code. So the function execution context will look something like this during the creation phase:

```js
FunctionExectionContext = {
LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // Identifier bindings go here
      Arguments: {0: 20, 1: 30, length: 2},
    },
    outer: <GlobalLexicalEnvironment>,
    ThisBinding: <Global Object or undefined>,
  },
VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // Identifier bindings go here
      g: undefined
    },
    outer: <GlobalLexicalEnvironment>,
    ThisBinding: <Global Object or undefined>
  }
}
```

After this, the execution context goes through the execution phase that means assignments to the variables inside the function are done. So the function execution context will look something like this during the execution phase:

```js
FunctionExectionContext = {
LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // Identifier bindings go here
      Arguments: {0: 20, 1: 30, length: 2},
    },
    outer: <GlobalLexicalEnvironment>,
    ThisBinding: <Global Object or undefined>,
  },
VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // Identifier bindings go here
      g: 20
    },
    outer: <GlobalLexicalEnvironment>,
    ThisBinding: <Global Object or undefined>
  }
}
```

After the function completes, the returned value is stored inside c. So the global lexical environment is updated. After that, the global code completes and the program finishes.

Note — As you might have noticed that the let and const defined variables do not have any value associated with them during the creation phase, but var defined variables are set to undefined. 

This is because, during the creation phase, the code is scanned for variable and function declarations, while the function declaration is stored in its entirety in the environment, the variables are initially set to undefined (in case of var) or remain uninitialized (in case of let and const). This is the reason why you can access var defined variables before they are declared (though undefined) but get a reference error when accessing let and const variables before they are declared. This is, what we call hoisting.

Note — During the execution phase, if the JavaScript engine couldn’t find the value of let variable at the actual place it was declared in the source code, then it will assign it the value of undefined.

1『对「提升」改理解加深了很多很多。在执行环境的创建阶段，代码里的变量声明和函数声明会被扫描，其中函数声明会被整体存入到环境里，变量声明这边分 2 种情况：var 声明的变量会被直接赋值（没赋值的话指定为 undefined），而 let、const 声明的变量在此阶段不会被赋值（执行阶段才会赋值）。这就可以解释提升为啥只对 var 变量和函数有效，在执行阶段里，因为前面的创建阶段这 2 个东西已经被存入环境里了，在声明语句之前就可以用执行语句操作，但是 let、const 声明的变量在前面没赋值过，当然报错，所以 let、const 声明的变量必须要在其执行语句之前。』

