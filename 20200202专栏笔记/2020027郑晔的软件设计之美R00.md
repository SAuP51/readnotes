# 2020027郑晔的软件设计之美R00

## 记忆时间

## 卡片

### 0101. 反常识卡——盲人摸象

常识：盲人摸象代表一群只能看到局部的傻 B。

反常识：从局部和整体的角度来看，盲人摸象也可以是一种很正能量的思维方式。

一群盲人被带到一头大象面前，让他们摸摸大象像什么。一个瞎子摸到了大象的腿，说大象像一棵树；另一个瞎子摸到了大象的耳朵，说大象像一个扇子；第三个摸着大象的身体，说它像一堵墙；第四个瞎子则拽着大象的尾巴说，它分明像一根绳子......这就是我们熟知的《盲人摸象》的寓言。它主要是用来讽刺：我们不应该只看到一个事物的侧面，就匆忙给出结论，这样我们就与瞎子无异。

正如万事只要换个坐标系，就可能会得出不同结论一样；回到我们软件设计领域，重新衡量这个问题，会发现盲人摸象的效果恰恰是我们所苦苦追求的。假设我们拥有一头大象。如果现在有人需要一把扇子，我们就让他使用大象的耳朵来扇会儿风；如果有人需要一把长茅，就让他把象牙当作武器；而如果有人需要一根绳子，我们则可以把大象尾巴借他当绳子用会儿……

总而言之，对于不同个体，需要的是更加具体的服务，而不是一头大象，因而他也并不关心为他服务的事物背后是否是一头大象。而大象，是个完整的个体，不可分割（这很重要）。它很大，大到可以为外部提供多种功能的服务。而对于每种不同的服务需要者，它就扮演不同的角色。

### 0102. 反常识卡——类和对象

尝试：类和对象是对等的，对象只是实例化后的类。

反常识：类与对象是完全两种不同的事物。

但事实上，类与对象是完全两种不同的事物 —— 类的作用，是为了模块化，我们应该遵从高内聚低耦合的原则去划分类，那怕由此产生了远超领域实体概念数量的类，也无妨。让软件容易应对变化，是我们无论采取何种方法论都应该遵从的原则。而对象，是我们运行时承载了数据和行为的实体：它的种类和数量应该与领域的真实概念存在清晰、明确、直接的映射。因而，类应该是小的，对象应该是大的。上帝类是糟糕的，但上帝对象却恰恰是我们所期盼的。

1『哇塞哇塞，太有启发性了。小类大对象，类是为了模块化，在类里做接口，来隔离变化。对象是为了映射真实世界的事物，封装好行为和数据。』

而从类到对象，是一种多对一的关系：最终一个对象模版是由诸多单一职责的小类 —— 它们分别都可以有自己的数据和行为 —— 所构成。而将类映射到对象的过程，在 Ruby 中的 Mixin；在 Scala 中则通过 Traits；而 C++ 则通过多重继承。因而，自 Scala 以来，诸多新设计的语言都开始包含 Trait 这个语法特性。但是其中一些完全没理解 Trait 的真正价值，不允许 Trait 包含数据，因而它们也失去了发挥更强大威力的潜力。

2011 年，我们在一个电信项目的重构和开发过程中，发现在一个概念上不可分割的领域对象上，其过多的变化方向上导致了大规模重复代码，从而导致代码极难理解和维护。而如果将其切分为很多小对象，可以将重复消除掉，但却会导致对于诸多小对象的管理问题，以及大量的内存浪费，当时那个项目内存优化也是一种重要的目标。

这逼迫我们对 OO 进行了更深入的思考，最终明确了小类，大对象的概念，也开始真正发挥 OO 的威力。由此，在那个项目上，我们得到了两全其美的解决方案：不仅大大增强了系统的可理解性和可维护性，也大幅降低内存占用（内存节省了 70%）。并且作为一种通用方法，在随后的项目中不断发挥其威力。

总而言之，通过将类和对象看作不同事物，现代 OO 方法学漂亮的解决了设计中最重要的两个问题（见《[简单设计 - 简书](https://www.jianshu.com/p/0228d2dd90fe)》）：1）类作为一种模块化手段，遵循高内聚，低耦合，让软件易于应对变化；让贫血模型和充血模型不再成为一个两难选择；2）对象作为一种领域对象的的直接映射，解决了过多的类带来的可理解性问题，让领域可以指导设计，设计真正反映领域，而这才是领域驱动设计的真正目的和精髓。自此，已经没有人可以阻挡我们深信 OO 是一种非常有效的分析和设计方法论了。

### 0201. 术语卡——面向接口编程，而非面向实现编程

实现继承是站在子类的视角，少用，能用组合实现就别用「实现继承」；多态是站在父类视角的，通过「接口继承」来实现，多用。这就是经常听到的「面向接口编程，而非面向实现编程」。

我们说过，继承有两种，实现继承和接口继承。其中，实现继承尽可能用组合的方式替代继承。而接口继承，主要是给多态用的。这里面的重点在于，这个继承体系的使用者，主要考虑的是父类，而非子类。就像下面这段代码里，我们不必考虑具体的形状是什么，只要调用它的绘图方法即可。

这种做法的好处就在于，一旦有了新的变化，比如，需要将正方形替换成圆形，除了变量初始化，其他的代码并不需要修改。不过，这是任何一本面向对象编程的教科书上都会讲的内容。那么，问题来了。既然多态这么好，为什么很多程序员不能在自己的代码中很好地运用多态呢？因为多态需要构建出一个抽象。

构建抽象，需要找出不同事物的共同点，而这是最有挑战的部分。而遮住程序员们双眼的，往往就是他们眼里的不同之处。在他们眼中，鸡就是鸡，鸭就是鸭。寻找共同点这件事，地基还是在分离关注点上。只有你能看出来，鸡和鸭都有羽毛，都养在家里，你才有机会识别出一个叫做「家禽」的概念。这里，我们又一次强调了分离关注点的重要性。

我们构建出来的抽象会以接口的方式体现出来，强调一点，这里的接口不一定是一个语法，而是一个类型的约束。所以，在这个关于多态的讨论中，接口、抽象类、父类等几个概念都是等价的，为了叙述方便，我这里统一采用接口的说法。在构建抽象上，接口扮演着重要的角色。首先，接口将变的部分和不变的部分隔离开来。不变的部分就是接口的约定，而变的部分就是子类各自的实现。

1『这里的接口啊、抽象类啊、父类啊，对应于「小类大对象」里的小类。』

在软件开发中，对系统影响最大的就是变化。有时候需求一来，你的代码就要跟着改，一个可能的原因就是各种代码混在了一起。比如，一个通信协议的调整需要你改业务逻辑，这明显就是不合理的。对程序员来说，识别出变与不变，是一种很重要的能力。

其次，接口是一个边界。无论是什么样的系统，清晰界定不同模块的职责是很关键的，而模块之间彼此通信最重要的就是通信协议。这种通信协议对应到代码层面上，就是接口。

很多程序员在接口中添加方法显得很随意，因为在他们心目中，并不存在实现者和使用者之间的角色差异。这也就造成了边界意识的欠缺，没有一个清晰的边界，其结果就是模块定义的随意，彼此之间互相影响也就在所难免。后面谈到 Liskov 替换法则的时候，我们还会再谈到这一点。所以，要想理解多态，首先要理解接口的价值，而理解接口，最关键的就是在于谨慎地选择接口中的方法。

至此，你已经对多态和接口有了一个基本的认识。你就能很好地理解一个编程原则了：面向接口编程。面向接口编程的价值就根植于多态，也正是因为有了多态，一些设计原则，比如，开闭原则、接口隔离原则才得以成立，相应地，设计模式才有了立足之本。

### 0202. 术语卡——函数是一等公民

了解了函数式编程产生的背景之后，我们就可以正式打开函数式编程的大门了。函数式编程第一个需要了解的概念就是函数。在函数式编程中，函数是一等公民（first-class citizen）。一等公民是什么意思呢？1）它可以按需创建；2）它可以存储在数据结构中；3）它可以当作实参传给另一个函数；4）它可以当作另一个函数的返回值。

对象，是面向对象程序设计语言的一等公民，它就满足所有上面的这些条件。在函数式编程语言里，函数就是一等公民。函数式编程语言有很多，经典的有 LISP、Haskell、Scheme 等，后来也出现了一批与新平台结合紧密的函数式编程语言，比如：Clojure、F#、Scala 等。很多语言虽然不把自己归入函数式编程语言，但它们也提供了函数式编程的支持，比如支持了 Lambda 的，这类的语言像 Ruby、JavaScript 等。

如果你的语言没有这种一等公民的函数支持，完全可以用某种方式模拟出来。在前面的例子里，我们就用对象模拟出了一个函数，也就是 Predicate。在旧版本的 C++ 中，也可以用 functor（函数对象）当作一等公民的函数。在这两个例子中，既然函数是用对象模拟出来的，自然就符合一等公民的定义，可以方便将其传来传去。

### 0203. 术语卡——领域

领域驱动设计这个名字里面，排在第一位的是领域（Domain），它就对应着要解决的问题。正如我们一直说的，软件开发是解决问题，而解决问题要分而治之。所谓分而治之，就是要把问题分解了，对应到领域驱动设计中，就是要把一个大领域分解成若干的小领域，而这个分解出来的小领域就是子域（Subdomain）。

我们在上一讲中说，领域驱动设计首先要建立起一套通用语言，这样一来，我们就拥有了各种各样的词汇，它们对应着模型。接下来，我们就要给这些词汇做个分类，而分类就是要把它们划分到不同的子域中去。这里面的关键就在于，要找出不同的关注点。没错，还是分离关注点。

比如，我要做一个项目管理软件，就需要有用户、有项目、有团队，不同的人还要扮演不同的角色。第一步，我们至少可以先把身份管理和项目管理这两件事分开，因为它们的关注点是不同的。身份管理关注的是用户的身份信息，诸如用户名密码之类的，而项目管理关注的重点是项目和团队之类的。所以，我们这里有了两个子域：身份管理和项目管理。

如果直接给你看结果，你可能会觉得很好理解。但是，划分出不同的子域还是比较容易出问题的，因为有一些概念并不容易区分。比如，用户应该怎么划分呢？放在身份管理是合适的，但项目管理也要用到用户。

幸好，我们已经学习了单一职责原则，它给了我们一个重要的思考维度，变化从何而来。不同角色的人会关注不同的变化，所以，我们知道虽然我们用的词都是「用户」，但我们想表达的含义却是不同的，我们最好将这些不同的含义分开，也就是将不同的角色分开。比如，在身份管理中，它是「用户」，而在项目管理中，它就成了「项目成员」。所以，我们划分子域实际上就是在把不同的概念区分开来，让它们各归其位。

对于一个真实项目而言，划分出来的子域可能会有很多，但并非每个子域都一样重要。所以，我们还要把划分出来的子域再做一下区分，分成核心域（Core Domain）、支撑域（Supporting Subdomain）和通用域（Generic Subdomain）。

核心域是整个系统最重要的部分，是整个业务得以成功的关键。关于核心域，Eric Evans 曾提出过几个问题，帮我们识别核心域：1）为什么这个系统值得写？2）为什么不直接买一个？3）为什么不外包？如果你对这几个问题的回答能够帮你找到这个系统非写不可的理由，那它就是你的核心域。

什么是支撑域呢？有一些子域不是你的核心竞争力，但却是系统不得不做的东西，市场上也找不到一个现成的方案，这种子域就是支撑域。比如，我们要做一个排行榜功能，可能根据各种信息做排名，这种东西没有人会按照你的需要做出一个，对你来说，又是扩展自己系统的重要一步，它就是一个支撑域。还有一种子域叫通用域，就是行业里通常都是这么做，即便不自己做，也并不影响你的业务运行。比如，很多 App 要给用户发通知，这样的功能完全可以买一个服务来做，丝毫不影响你的业务运行。它就是一个通用域。

我们之所以要区分不同的子域，关键的原因就在于，我们可以决定不同的投资策略。核心域要全力投入，支撑域次之，通用域甚至可以花钱买服务。

### 0204. 术语卡——loC

其实很早就听说过 Inversion of Control 和 Dependency Injection，但是似乎一直没有搞明白其中的概念，也没有机会有意识的去使用 DI（也许是用了，但是没有意识到）。重读了 Martin Fowler 的长（旧）文，有一个疑惑，专栏里面的 Spring DI 是属于哪一种类型的 IoC，看上去比较像 type 1，Constructor Injection。但是在 Martin Fowler 的文章里面说道 Spring 的开发者更推荐使用 Setter Injection（Spring 框架应该是同时支持这两种依赖注入方式的），不知道是因为框架的进展，改用了 Constructor Injection，或者只是局限于作者的这个例子。结合专栏的内容，简单的了解了一下 Spring 中的 DI。1）在 Ruby 中可以使用 dry-rb 实现依赖倒置：[Introduction to dependency injection in Ruby | by Christian Paling | Medium](https://medium.com/@Bakku1505/introduction-to-dependency-injection-in-ruby-dc238655a278)。2）但是 DHH 也说过：[Dependency injection is not a virtue in Ruby (DHH)](https://dhh.dk/2012/dependency-injection-is-not-a-virtue.html)。

### 0205. 术语卡——纯函数

我们再来看纯函数。编写纯函数的重点是，不修改任何字段，也不调用修改字段内容的方法。因为在实际的工作中，我们使用的大多数都是传统的程序设计语言，而不是严格的函数式编程语言，不是所有用到的量都是值。所以，站在实用性的角度，如果要使用变量，就使用局部变量。

还有一个实用性的编程建议，就是使用语法中不变的修饰符，比如，Java 就尽可能多使用 final，C/C++ 就多写 const。无论是修饰变量还是方法，它们的主要作用就是让编译器提醒你，要多从不变的角度思考问题。

### 0206. 术语卡——惰性求值

为什么会是这样呢？答案就在于这段代码是惰性求值的。什么叫惰性求值呢？惰性求值（Lazy Evaluation）是一种求值策略，它将求值的过程延迟到真正需要这个值的时候。惰性求值的好处就在于可以规避一些不必要的计算，尤其是规模比较大，或是运行时间比较长的计算。

其实，如果你学习过设计模式，惰性求值这个概念你应该并不陌生。有一些设计模式就是典型的惰性求值，比如，Proxy 模式，它就是采用了惰性求值的策略，把一些消耗很大的计算延迟到不得不算的时候去做。还有 Singleton 模式有时也会采用惰性求值的策略，在第一次访问的时候，再去生成对象。

### 0301. 人名卡——

根据这些证据和案例，找出源头和提出术语的人是谁——产生一张人名卡，并且分析他为什么牛，有哪些作品，生平经历是什么。

### 0401. 金句卡——继承是从子类的角度往上看父类，多态是从父类的角度往下看子类

继承和多态的底层实现原理：继承是在子类里维护一个父类对象的指针，这样子类可以访问父类对象的数据；多态是在父类里维护多个子类的对象的指针，这样父类可以访问子类对象的数据。继承是从子类的角度往上看父类，多态是从父类的角度往下看子类（推荐这种视角）。

### 0402. 金句卡——面向对象编程范式提供了组织类的能力，函数式编程范式提供了组织动作的能力

用面向对象编程范式对系统结构进行搭建，用函数式编程范式对函数接口进行设计。至此，我们已经学习了函数式编程的组合。你可能会有一个疑问，我们之前在讲面向对象的时候，也谈到了组合，这里讲函数式编程，又谈到了组合。这两种组合之间是什么关系呢？其实，对比一下代码，你就不难发现了，面向对象组合的元素是类和对象，而函数式编程组合的是函数。

这也就牵扯到在实际工作中，如何将面向对象和函数式编程两种不同的编程范式组合运用的问题。我们可以用面向对象编程的方式对系统的结构进行搭建，然后，用函数式编程的理念对函数接口进行设计。你可以把它理解成盖楼，用面向对象编程搭建大楼的骨架，用函数式编程设计门窗。

### 0501. 任意卡——各个语言的特性

一些程序设计语言的特性：1）C 语言提供了对汇编指令直接的封装。2）C++ 先是提供了面向对象，后来又提供了泛型编程。3）Java 把内存管理从开发者面前去掉了，后来引入的 Annotation 可以进行声明式编程。4）Ruby 提供了动态类型，以及由 Ruby on Rails 引导出的 DSL 风格。5）Scala 和 Clojure 提供了函数式编程。6）Rust 提供了新的内存管理方式，而 Libra 提供的 Move 语言则把它进一步抽象成了资源的概念。

### 0502. 任意卡——编程范式是对程序员的能力施加了约束

编程范式不仅仅是提供了一个个的概念，更重要的是，它对程序员的能力施加了约束。1）结构化编程，限制使用 goto 语句，它是对程序控制权的直接转移施加了约束。2）面向对象编程，限制使用函数指针，它是对程序控制权的间接转移施加了约束。3）函数式编程，限制使用赋值语句，它是对程序中的赋值施加了约束。之后讲到具体的编程范式时，我们再来展开讨论，这些约束到底是什么意思。