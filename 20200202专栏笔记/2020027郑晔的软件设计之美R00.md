# 2020027郑晔的软件设计之美R00

## 记忆时间

## 卡片

### 0101. 反常识卡——盲人摸象

常识：盲人摸象代表一群只能看到局部的傻 B。

反常识：从局部和整体的角度来看，盲人摸象也可以是一种很正能量的思维方式。

一群盲人被带到一头大象面前，让他们摸摸大象像什么。一个瞎子摸到了大象的腿，说大象像一棵树；另一个瞎子摸到了大象的耳朵，说大象像一个扇子；第三个摸着大象的身体，说它像一堵墙；第四个瞎子则拽着大象的尾巴说，它分明像一根绳子......这就是我们熟知的《盲人摸象》的寓言。它主要是用来讽刺：我们不应该只看到一个事物的侧面，就匆忙给出结论，这样我们就与瞎子无异。

正如万事只要换个坐标系，就可能会得出不同结论一样；回到我们软件设计领域，重新衡量这个问题，会发现盲人摸象的效果恰恰是我们所苦苦追求的。假设我们拥有一头大象。如果现在有人需要一把扇子，我们就让他使用大象的耳朵来扇会儿风；如果有人需要一把长茅，就让他把象牙当作武器；而如果有人需要一根绳子，我们则可以把大象尾巴借他当绳子用会儿……

总而言之，对于不同个体，需要的是更加具体的服务，而不是一头大象，因而他也并不关心为他服务的事物背后是否是一头大象。而大象，是个完整的个体，不可分割（这很重要）。它很大，大到可以为外部提供多种功能的服务。而对于每种不同的服务需要者，它就扮演不同的角色。

### 0102. 反常识卡——类和对象

尝试：类和对象是对等的，对象只是实例化后的类。

反常识：类与对象是完全两种不同的事物。

但事实上，类与对象是完全两种不同的事物 —— 类的作用，是为了模块化，我们应该遵从高内聚低耦合的原则去划分类，那怕由此产生了远超领域实体概念数量的类，也无妨。让软件容易应对变化，是我们无论采取何种方法论都应该遵从的原则。而对象，是我们运行时承载了数据和行为的实体：它的种类和数量应该与领域的真实概念存在清晰、明确、直接的映射。因而，类应该是小的，对象应该是大的。上帝类是糟糕的，但上帝对象却恰恰是我们所期盼的。

1『哇塞哇塞，太有启发性了。小类大对象，类是为了模块化，在类里做接口，来隔离变化。对象是为了映射真实世界的事物，封装好行为和数据。』

而从类到对象，是一种多对一的关系：最终一个对象模版是由诸多单一职责的小类 —— 它们分别都可以有自己的数据和行为 —— 所构成。而将类映射到对象的过程，在 Ruby 中的 Mixin；在 Scala 中则通过 Traits；而 C++ 则通过多重继承。因而，自 Scala 以来，诸多新设计的语言都开始包含 Trait 这个语法特性。但是其中一些完全没理解 Trait 的真正价值，不允许 Trait 包含数据，因而它们也失去了发挥更强大威力的潜力。

2011 年，我们在一个电信项目的重构和开发过程中，发现在一个概念上不可分割的领域对象上，其过多的变化方向上导致了大规模重复代码，从而导致代码极难理解和维护。而如果将其切分为很多小对象，可以将重复消除掉，但却会导致对于诸多小对象的管理问题，以及大量的内存浪费，当时那个项目内存优化也是一种重要的目标。

这逼迫我们对 OO 进行了更深入的思考，最终明确了小类，大对象的概念，也开始真正发挥 OO 的威力。由此，在那个项目上，我们得到了两全其美的解决方案：不仅大大增强了系统的可理解性和可维护性，也大幅降低内存占用（内存节省了 70%）。并且作为一种通用方法，在随后的项目中不断发挥其威力。

总而言之，通过将类和对象看作不同事物，现代 OO 方法学漂亮的解决了设计中最重要的两个问题（见《[简单设计 - 简书](https://www.jianshu.com/p/0228d2dd90fe)》）：1）类作为一种模块化手段，遵循高内聚，低耦合，让软件易于应对变化；让贫血模型和充血模型不再成为一个两难选择；2）对象作为一种领域对象的的直接映射，解决了过多的类带来的可理解性问题，让领域可以指导设计，设计真正反映领域，而这才是领域驱动设计的真正目的和精髓。自此，已经没有人可以阻挡我们深信 OO 是一种非常有效的分析和设计方法论了。

### 0201. 术语卡——面向接口编程，而非面向实现编程

实现继承是站在子类的视角，少用，能用组合实现就别用「实现继承」；多态是站在父类视角的，通过「接口继承」来实现，多用。这就是经常听到的「面向接口编程，而非面向实现编程」。

我们说过，继承有两种，实现继承和接口继承。其中，实现继承尽可能用组合的方式替代继承。而接口继承，主要是给多态用的。这里面的重点在于，这个继承体系的使用者，主要考虑的是父类，而非子类。就像下面这段代码里，我们不必考虑具体的形状是什么，只要调用它的绘图方法即可。

这种做法的好处就在于，一旦有了新的变化，比如，需要将正方形替换成圆形，除了变量初始化，其他的代码并不需要修改。不过，这是任何一本面向对象编程的教科书上都会讲的内容。那么，问题来了。既然多态这么好，为什么很多程序员不能在自己的代码中很好地运用多态呢？因为多态需要构建出一个抽象。

构建抽象，需要找出不同事物的共同点，而这是最有挑战的部分。而遮住程序员们双眼的，往往就是他们眼里的不同之处。在他们眼中，鸡就是鸡，鸭就是鸭。寻找共同点这件事，地基还是在分离关注点上。只有你能看出来，鸡和鸭都有羽毛，都养在家里，你才有机会识别出一个叫做「家禽」的概念。这里，我们又一次强调了分离关注点的重要性。

我们构建出来的抽象会以接口的方式体现出来，强调一点，这里的接口不一定是一个语法，而是一个类型的约束。所以，在这个关于多态的讨论中，接口、抽象类、父类等几个概念都是等价的，为了叙述方便，我这里统一采用接口的说法。在构建抽象上，接口扮演着重要的角色。首先，接口将变的部分和不变的部分隔离开来。不变的部分就是接口的约定，而变的部分就是子类各自的实现。

1『这里的接口啊、抽象类啊、父类啊，对应于「小类大对象」里的小类。』

在软件开发中，对系统影响最大的就是变化。有时候需求一来，你的代码就要跟着改，一个可能的原因就是各种代码混在了一起。比如，一个通信协议的调整需要你改业务逻辑，这明显就是不合理的。对程序员来说，识别出变与不变，是一种很重要的能力。

其次，接口是一个边界。无论是什么样的系统，清晰界定不同模块的职责是很关键的，而模块之间彼此通信最重要的就是通信协议。这种通信协议对应到代码层面上，就是接口。

很多程序员在接口中添加方法显得很随意，因为在他们心目中，并不存在实现者和使用者之间的角色差异。这也就造成了边界意识的欠缺，没有一个清晰的边界，其结果就是模块定义的随意，彼此之间互相影响也就在所难免。后面谈到 Liskov 替换法则的时候，我们还会再谈到这一点。所以，要想理解多态，首先要理解接口的价值，而理解接口，最关键的就是在于谨慎地选择接口中的方法。

至此，你已经对多态和接口有了一个基本的认识。你就能很好地理解一个编程原则了：面向接口编程。面向接口编程的价值就根植于多态，也正是因为有了多态，一些设计原则，比如，开闭原则、接口隔离原则才得以成立，相应地，设计模式才有了立足之本。

### 0202. 术语卡——函数是一等公民

了解了函数式编程产生的背景之后，我们就可以正式打开函数式编程的大门了。函数式编程第一个需要了解的概念就是函数。在函数式编程中，函数是一等公民（first-class citizen）。一等公民是什么意思呢？1）它可以按需创建；2）它可以存储在数据结构中；3）它可以当作实参传给另一个函数；4）它可以当作另一个函数的返回值。

对象，是面向对象程序设计语言的一等公民，它就满足所有上面的这些条件。在函数式编程语言里，函数就是一等公民。函数式编程语言有很多，经典的有 LISP、Haskell、Scheme 等，后来也出现了一批与新平台结合紧密的函数式编程语言，比如：Clojure、F#、Scala 等。很多语言虽然不把自己归入函数式编程语言，但它们也提供了函数式编程的支持，比如支持了 Lambda 的，这类的语言像 Ruby、JavaScript 等。

如果你的语言没有这种一等公民的函数支持，完全可以用某种方式模拟出来。在前面的例子里，我们就用对象模拟出了一个函数，也就是 Predicate。在旧版本的 C++ 中，也可以用 functor（函数对象）当作一等公民的函数。在这两个例子中，既然函数是用对象模拟出来的，自然就符合一等公民的定义，可以方便将其传来传去。

### 0203. 术语卡——领域

领域驱动设计这个名字里面，排在第一位的是领域（Domain），它就对应着要解决的问题。正如我们一直说的，软件开发是解决问题，而解决问题要分而治之。所谓分而治之，就是要把问题分解了，对应到领域驱动设计中，就是要把一个大领域分解成若干的小领域，而这个分解出来的小领域就是子域（Subdomain）。

我们在上一讲中说，领域驱动设计首先要建立起一套通用语言，这样一来，我们就拥有了各种各样的词汇，它们对应着模型。接下来，我们就要给这些词汇做个分类，而分类就是要把它们划分到不同的子域中去。这里面的关键就在于，要找出不同的关注点。没错，还是分离关注点。

比如，我要做一个项目管理软件，就需要有用户、有项目、有团队，不同的人还要扮演不同的角色。第一步，我们至少可以先把身份管理和项目管理这两件事分开，因为它们的关注点是不同的。身份管理关注的是用户的身份信息，诸如用户名密码之类的，而项目管理关注的重点是项目和团队之类的。所以，我们这里有了两个子域：身份管理和项目管理。

如果直接给你看结果，你可能会觉得很好理解。但是，划分出不同的子域还是比较容易出问题的，因为有一些概念并不容易区分。比如，用户应该怎么划分呢？放在身份管理是合适的，但项目管理也要用到用户。幸好，我们已经学习了单一职责原则，它给了我们一个重要的思考维度，变化从何而来。不同角色的人会关注不同的变化，所以，我们知道虽然我们用的词都是「用户」，但我们想表达的含义却是不同的，我们最好将这些不同的含义分开，也就是将不同的角色分开。比如，在身份管理中，它是「用户」，而在项目管理中，它就成了「项目成员」。所以，我们划分子域实际上就是在把不同的概念区分开来，让它们各归其位。

对于一个真实项目而言，划分出来的子域可能会有很多，但并非每个子域都一样重要。所以，我们还要把划分出来的子域再做一下区分，分成核心域（Core Domain）、支撑域（Supporting Subdomain）和通用域（Generic Subdomain）。

核心域是整个系统最重要的部分，是整个业务得以成功的关键。关于核心域，Eric Evans 曾提出过几个问题，帮我们识别核心域：1）为什么这个系统值得写？2）为什么不直接买一个？3）为什么不外包？如果你对这几个问题的回答能够帮你找到这个系统非写不可的理由，那它就是你的核心域。

什么是支撑域呢？有一些子域不是你的核心竞争力，但却是系统不得不做的东西，市场上也找不到一个现成的方案，这种子域就是支撑域。比如，我们要做一个排行榜功能，可能根据各种信息做排名，这种东西没有人会按照你的需要做出一个，对你来说，又是扩展自己系统的重要一步，它就是一个支撑域。还有一种子域叫通用域，就是行业里通常都是这么做，即便不自己做，也并不影响你的业务运行。比如，很多 App 要给用户发通知，这样的功能完全可以买一个服务来做，丝毫不影响你的业务运行。它就是一个通用域。我们之所以要区分不同的子域，关键的原因就在于，我们可以决定不同的投资策略。核心域要全力投入，支撑域次之，通用域甚至可以花钱买服务。

### 0204. 术语卡——loC

其实很早就听说过 Inversion of Control 和 Dependency Injection，但是似乎一直没有搞明白其中的概念，也没有机会有意识的去使用 DI（也许是用了，但是没有意识到）。重读了 Martin Fowler 的长（旧）文，有一个疑惑，专栏里面的 Spring DI 是属于哪一种类型的 IoC，看上去比较像 type 1，Constructor Injection。但是在 Martin Fowler 的文章里面说道 Spring 的开发者更推荐使用 Setter Injection（Spring 框架应该是同时支持这两种依赖注入方式的），不知道是因为框架的进展，改用了 Constructor Injection，或者只是局限于作者的这个例子。结合专栏的内容，简单的了解了一下 Spring 中的 DI。1）在 Ruby 中可以使用 dry-rb 实现依赖倒置：[Introduction to dependency injection in Ruby | by Christian Paling | Medium](https://medium.com/@Bakku1505/introduction-to-dependency-injection-in-ruby-dc238655a278)。2）但是 DHH 也说过：[Dependency injection is not a virtue in Ruby (DHH)](https://dhh.dk/2012/dependency-injection-is-not-a-virtue.html)。

### 0205. 术语卡——纯函数

我们再来看纯函数。编写纯函数的重点是，不修改任何字段，也不调用修改字段内容的方法。因为在实际的工作中，我们使用的大多数都是传统的程序设计语言，而不是严格的函数式编程语言，不是所有用到的量都是值。所以，站在实用性的角度，如果要使用变量，就使用局部变量。

还有一个实用性的编程建议，就是使用语法中不变的修饰符，比如，Java 就尽可能多使用 final，C/C++ 就多写 const。无论是修饰变量还是方法，它们的主要作用就是让编译器提醒你，要多从不变的角度思考问题。

### 0206. 术语卡——惰性求值

为什么会是这样呢？答案就在于这段代码是惰性求值的。什么叫惰性求值呢？惰性求值（Lazy Evaluation）是一种求值策略，它将求值的过程延迟到真正需要这个值的时候。惰性求值的好处就在于可以规避一些不必要的计算，尤其是规模比较大，或是运行时间比较长的计算。

其实，如果你学习过设计模式，惰性求值这个概念你应该并不陌生。有一些设计模式就是典型的惰性求值，比如，Proxy 模式，它就是采用了惰性求值的策略，把一些消耗很大的计算延迟到不得不算的时候去做。还有 Singleton 模式有时也会采用惰性求值的策略，在第一次访问的时候，再去生成对象。

### 0301. 金句卡——继承是从子类的角度往上看父类，多态是从父类的角度往下看子类

继承和多态的底层实现原理：继承是在子类里维护一个父类对象的指针，这样子类可以访问父类对象的数据；多态是在父类里维护多个子类的对象的指针，这样父类可以访问子类对象的数据。继承是从子类的角度往上看父类，多态是从父类的角度往下看子类（推荐这种视角）。

### 0302. 金句卡——面向对象编程范式提供了组织类的能力，函数式编程范式提供了组织动作的能力

用面向对象编程范式对系统结构进行搭建，用函数式编程范式对函数接口进行设计。至此，我们已经学习了函数式编程的组合。你可能会有一个疑问，我们之前在讲面向对象的时候，也谈到了组合，这里讲函数式编程，又谈到了组合。这两种组合之间是什么关系呢？其实，对比一下代码，你就不难发现了，面向对象组合的元素是类和对象，而函数式编程组合的是函数。

这也就牵扯到在实际工作中，如何将面向对象和函数式编程两种不同的编程范式组合运用的问题。我们可以用面向对象编程的方式对系统的结构进行搭建，然后，用函数式编程的理念对函数接口进行设计。你可以把它理解成盖楼，用面向对象编程搭建大楼的骨架，用函数式编程设计门窗。

### 0401. 任意卡——各个语言的特性

一些程序设计语言的特性：1）C 语言提供了对汇编指令直接的封装。2）C++ 先是提供了面向对象，后来又提供了泛型编程。3）Java 把内存管理从开发者面前去掉了，后来引入的 Annotation 可以进行声明式编程。4）Ruby 提供了动态类型，以及由 Ruby on Rails 引导出的 DSL 风格。5）Scala 和 Clojure 提供了函数式编程。6）Rust 提供了新的内存管理方式，而 Libra 提供的 Move 语言则把它进一步抽象成了资源的概念。

### 0402. 任意卡——编程范式是对程序员的能力施加了约束

编程范式不仅仅是提供了一个个的概念，更重要的是，它对程序员的能力施加了约束。1）结构化编程，限制使用 goto 语句，它是对程序控制权的直接转移施加了约束。2）面向对象编程，限制使用函数指针，它是对程序控制权的间接转移施加了约束。3）函数式编程，限制使用赋值语句，它是对程序中的赋值施加了约束。之后讲到具体的编程范式时，我们再来展开讨论，这些约束到底是什么意思。

### 0501. 人名卡——

根据这些证据和案例，找出源头和提出术语的人是谁——产生一张人名卡，并且分析他为什么牛，有哪些作品，生平经历是什么。

## 0000. 课前必读

1、软件设计，应该包括模型和规范。

2、分离关注点，发现的关注点越多越好，粒度越小越好。

3、做软件设计，请考虑可测试性。

## 0001. 软件设计到底是什么？

今天我们学习了软件设计到底是什么，它应该包括「模型」和「规范」两部分：1）模型，是一个软件的骨架，是一个软件之所以是这个软件的核心。模型的粒度可大可小。我们所说的「高内聚、低耦合」指的就是对模型的要求，一个好的模型可以有效地隐藏细节，让开发者易于理解。模型是分层的，可以不断地叠加，基于一个基础的模型去构建上一层的模型，计算机世界就是这样一点点构建出来的。2）规范，就是限定了什么样的需求应该以怎样的方式去完成。它对于维系软件长期演化至关重要。关于规范，常见的两种问题是：一个项目缺乏显式的、统一的规范；规范不符合软件设计原则。

模型与规范，二者相辅相成，一个项目最初建立起的模型，往往是要符合一定规范的，而规范的制定也有赖于模型。有了对软件设计的初步了解，我们就准备开始做设计了，但该从哪入手呢？这就是我们下一讲的内容。如果今天的内容你只能记住一件事，那请记住：软件设计，应该包括模型和规范。

一个软件需要设计，这是你一定认同的。但软件设计到底是什么，不同的人却有着不同的理解：1）有人认为，设计就是讨论要用什么技术实现功能；2）有人认为，设计就是要考虑选择哪些框架和中间件；3）有人认为，设计就是设计模式；4）有人认为，设计就是 Controller、Service 加 Model……

你会发现，如果我们按照这些方式去了解「软件设计」，不仅软件设计的知识会很零散，而且你会像站在流沙之上一般：1）今天你刚学会用 Java，明天 JavaScript 成了新宠，还没等你下定决心转向，Rust 又成了一批大公司吹捧的目标；2）你终于知道了消息队列在解决什么问题，准备学习强大的 Kafka，这时候有人告诉你 Pulsar 在某些地方表现得更好；3）你总算理解了 Observer 模式，却有人告诉你 JDK 中早就提供了原生的支持，但更好的做法应该是用 Guava 的 EventBus；4）你好不容易弄清楚 MVC 是怎样回事，却发现后端开发现在的主要工作是写 RESTful 服务，Controller 还没有用，就应该改名成 Resource 了……

我们说，软件设计要关注长期变化，需要应对需求规模的膨胀。这些在不断流变的东西可能还没你的软件生命周期长，又怎能支撑起长期的变化呢！那么回到一开始的问题，软件设计到底是什么呢？

### 1.1 核心的模型

在回答这个问题之前，我们先来思考这样一件事：软件的开发目的是什么？一个直白的答案就是，软件开发是为了解决由需求带来的各种问题，而解决的结果是一个可以运行的交付物。比如，我们在线购物的需求，是通过电商平台这个方案解决的。

那软件设计在这个过程中做的事情是什么呢？就是在需求和解决方案之间架设一个桥梁。区别于解决简单的问题，软件的开发往往是一项长期的工作，会有许多人参与其中。在这种情况下，就需要建立起一个统一的结构，以便于所有人都能有一个共同的理解。这就如同建筑中的图纸，懂建筑的人看了之后，就会产生一个统一的认识。

而在软件的开发过程中，这种统一的结构就是模型，而软件设计就是要构建出一套模型。这里所说的模型，不仅包括用来描述业务的各种实体，也包括完成业务功能的各种组件。人们写代码中常常会用到的服务（Service）、调度器（Scheduler）等概念就是一个一个的模型。

模型，是一个软件的骨架，是一个软件之所以是这个软件的核心。一个电商平台，它不用关系型数据库，还可以用 NoSQL，但如果没有产品信息，没有订单，它就不再是电商平台了。

可能有不少人一听到模型，就会情不自禁地要打退堂鼓，认为这些内容过于高大上，其实大可不必，模型的粒度可大可小。如果把模型理解为一个一个的类，是不是你就会熟悉很多了，这就是小的模型。你也可以把一整个系统当作一个整体来理解，这就是大的模型。

关于设计，你一定听说过一个说法，「高内聚、低耦合」，（模块的内聚程度越高越好，模块间的耦合程度越低越好），这其实就是对模型的要求。一个「高内聚、低耦合」的模型能够有效地隐藏细节，让人理解起来也更容易，甚至还可以在上面继续扩展。比如，我们后面课程会讲到的程序设计语言，就是提供了一个又一个的编程模型，让我们今天写程序不用再面对各种硬件的差异，还能够在此基础上继续提供新功能。

你在日常工作中用到的各种框架和技术，也是提供了一个又一个的模型，它们大幅度降低了我们的开发门槛。所以你看，整个计算机世界就是在这样一个又一个模型的叠加中，一点一点构建出来的。用一个程序员所熟悉的说法就是：模型是分层的。这就像乐高一样，由一个个小块构建出一个个大一些的部件，再用这些部件组成最终的成品。

这与一些人常规理解的 Controller、Service 那种分层略有差异。但实际上，这才是在计算机行业中普遍存在的分层。我们熟悉的网络模型就是一个典型的分层模型。按照 TCP/IP 的分层方法，网络层要构建在网络接口层之上，应用层则要依赖传输层，而我们平时使用的大多数协议则属于应用层。即便是在一个软件内部，模型也可以是分层的。我们可以先从最核心的模型开始构建，有了这个核心模型之后，可以通过组合这些基础的模型，构建出上面一层的模型。

我曾经做过一个交易系统的设计。在分析了主要的交易动作之后，我提出了一个交易原语的概念，包括资产冻结、解冻、出金、入金等少数几个动作。然后，把原先的交易动作变成了原语的组合。比如，下单是资产冻结，成交是不同账户的出金和入金，撤单则是资产解冻。

在这个结构下，由交易原语保证每个业务的准确性，由交易动作保证整个操作的事务性。从上面这个图中，你可以看出，这就是一种分层，一种模型上的分层。好，到这里我们已经对软件设计中的模型有了一个初步的认识。总结一下就是，模型是一个软件的核心；模型的粒度可大可小；好的模型应该「高内聚、低耦合」；模型可以分层，由底层的模型提供接口，构建出上层的模型。

后续我们这个课程的大部分内容都会围绕着模型来讲：怎样理解模型、建立模型、评判模型的优劣等等。学会这些知识之后，能在多大的粒度上应用它们，你就能掌控多大的模块。不过，仅仅是把软件设计理解成构建模型，这个理解还不够。模型设计也不能任意妄为，需要有一定的约束，而这个约束，就是软件设计要构建的另一个部分：规范。

### 1.2 约束的规范

如果说，软件设计要构建出一套模型，这还是比较直观好理解的。因为模型通常可以直接体现在代码中。但软件设计的另一部分 —— 规范，就常常会被忽略。

规范，就是限定了什么样的需求应该以怎样的方式去完成。比如：1）与业务处理相关的代码，应该体现在领域模型中；2）与网络连接相关的代码，应该写在网关里；3）与外部系统集成的代码，需要有防腐层……

其实，每个项目都会有自己的规范。比如，你总会遇到一些项目里的老人，他们会告诉你，这个代码应该写在这，而不应该写在那，这就是某种意义上的规范。虽然规范通常都有，但问题常常也在。

一种常见的问题就是缺乏显式的、统一的规范。规范的一个重要作用，就是维系软件长期的演化。如果没有显式的规范，项目的维系只能依靠团队成员个人的发挥，老成员一个没留神，新成员就可能创造出一种诡异的新写法，项目就朝着失控又迈出了一步。

不知道你是否接触过这样的项目，多种不同的做法并存其中：1）数据库访问，有用 MyBatis 的，有用 JDBC 的，也有用 Hibernate 的；2）外部接口设计，有用 REST 风格的，有用 URL 表示各种动作的；3）文件组织，有的按照业务功能划分（比如，产品、订单等），有的按照代码结构划分（比如，Resource、Service 等）……

没有一个统一的规范，每一个项目上的新成员都会痛斥一番前人的不负责任。然后，新的人准备另起炉灶，增加一些新东西。这种场景你是不是很熟悉呢？混乱通常就是这样开始的。如果存在一个显式的、统一的规范，项目会按照一个统一的方向行进。即便未来设计要演化、规范要调整，有一个统一的规范也要比散弹打鸟来得可控得多。

关于规范，还有一种常见问题就是，规范不符合软件设计原则。我给你讲一个让我印象深刻的故事。我曾经遇到一个网关出现了 OOM（Out of Memory，内存溢出）。这个网关日常的内存消耗高达 150G，一次流量暴增它就扛不住了。后来经过优化，把内存消耗降到了 8G。

如果单看数字，这是一个接近 20 倍的优化，大手笔啊，但这里面究竟发生了什么呢？实际上，这次优化最核心的内容就是构建了一个防腐层，将请求过来的 JSON 转换成了普通的内存对象。而原来的做法是把 JSON 解析器解析出来的对象到处使用，因为这些对象上附加很多额外的信息，导致占用了大量的内存。很遗憾，这不是大牛战天斗地的故事，只是因为旧的规范不符合软件设计原则而导致的错误：外部请求的对象需要在防腐层转换为内部对象。

### 1.3 模型与规范

有了模型，有了规范，那模型与规范是什么关系呢？模型与规范，二者相辅相成。一个项目最初建立起的模型，往往是要符合一定规范的，而规范的制定也有赖于模型。这就像讨论户型设计时，你可以按照各种方式组合不同的空间（模型），却不会把厨房与卫生间放在一起（规范）。

至此，我们已经知道了，软件设计既包含构建出一套模型，也包括制定出相应的规范。再回过头来看这节课开头的问题，你是不是对软件设计有了重新的认识呢？特定技术、框架和中间件，只是支撑我们模型的实现，而设计模式、Controller、Service、Model 这些东西也只是一个特定的实现结果，是某些特定场景下的模型。

### 黑板墙

我想请你分享一下，你的项目是如何做设计的。

防腐层是模型的一个规范，分享下我对防腐层的认知：我接触防腐层的概念是从 DDD 的限界上下文开始的。Eric 用细胞膜的概念来解释「限界」的概念，细胞膜只让细胞需要的物质进入细胞，同样，我们的代码之间业务也存在这个样一个界限，同一个对象的业务含义在不同的上下文中是不一样的。以在网上买书为例，在购买页面，我们的关注点在于这本书的名称，作者，以及分类，库存等信息；提交订单后，这本书就成为了订单上下文中的一个订单 item，我们会关注这个 item 的数量以及购买他的人是谁，以及书的配送地址等； 订单提交给仓库后，仓库会关心这本书还有没有库存，以及打包状态，分拣，物流等状态。防腐层是在限界上下文之间映射（说白了就是交互）的方式，体现在代码上就是一个对象的转换，这个转换的意义在于隔离变化，防止因为对象在一个上下文中的变化扩散到其他的上下文中。

关于规范：规范也是团队文化中很重要的一部分，以持续集成为例子，它的执行严格依赖于团队的开发纪律文化，以为了所谓赶进度而单元测试覆盖很低或者直接不写；采用分支策略方开发，一星期都合并不了主干，类似的人到处倒是，也就因为这一点，很多团队都在持续集成这个环节上掉队了。所以开发规范真的很重要，时刻谨记：混乱始于没有规范。2020-05-26

业务讨论之后进行领域设计，画出出静态模型（包括子系统、模块等）和动态结构（交互等），或者先勾勒接口（内内外系统的区隔），再做模型。实际过程有很多反复，并且会进行角色代入，看模型能否支持业务，直到模型比较稳定。作者回复：你们做得很好。2020-05-25

还需要前面有个好的产品经理或是业务专家。以及公司有个好的文化。各种频繁的插队的需求，各种前后都无法闭环的需求。都是，软件产品异常大的阻碍。2020-05-25

慢慢的，某个瞬间，突然觉得自己的工作不再是码农，而是软件设计，并且在工作中得到强烈的自我肯定。一个好的软件设计思路，首先是符合大众习惯行为、符合日常常理，其次再是数据模型设计、技术范畴设计。一个好的软件设计实现，往往可以很容易兼容正常合理的需求变更，对开发工作来说，掌握其核心，理论与实践相结合，可以事半功倍！作者回复：你把自己当做码农，你就是码农；你把自己当做优秀的程序员，你就是优秀的程序员。心理学上称之为皮格马利翁效应。2020-05-25

很多软件产品的需求都是一点点冒出来的，甚至中途需求还会去溜出去绕个弯，然后又回归，设计有种被牵着鼻子走的感觉，工期紧迭代快，结果就是设计的模型中有大量名不符实的定义，还有很多定义的补丁，实在很糟心，当然需求发展方向终会明朗，这时候就需要重构整理，包括设计和实现，同时又要应对新的业务开发，于是形成了两线或多线作战，苦啊！这样的情况除了增加团队，不知道老师有什么好的建议？作者回复：先去学《10x 程序员工作法》，先别让人给自己捣乱，有一个合理的工作计划。如果你没时间学习，没时间做改进，别的东西都不用说了。有了一个合理的安排之后，才是说要怎么改进，要怎么做得更好，消除欠下的技术债。2020-05-25

我们有一套基于 DDD 思想的程序开发模板，我们为了避免个体开发差异，所以建议大家都使用统一的开发模板。目前我面临着两个问题：1）针对某些使用简单分层架构即可解决问题的服务，是允许使用简单分层架构还是使用统一的 DDD 开发模板？2）统一开发模板在一定程度上规避了个体差异上的劣势。那么个体差异上的优势如何更好的体现呢？作者回复：把 DDD 当做一个模板，这个理解方式本身是没有问题的，它就是告诉你，如何把设计中的模型分门别类的放置，后面我们讲 DDD，差不多也是这个思路。对于任何一个系统而言，需求都是一点一点增加的，前期不做设计，后期改动起来，难度就非常大了。所以，核心的点在于，设计要做好，别看它现在简单。分层不是你的设计，而构建出你的模型才是设计。我不是特别理解你们按照 DDD 思想的开发模板到底是个什么东西，是一个开发框架，还是一个思维工具，所以，不敢妄加判断。对于一个团队而言，开发的一致性比个性要重要，因为没有人可以保证一直在一个团队工作下去。如果你真的有不错的理念，去做规范和框架的级别的优化、去做算法上的优化，不要在小的地方体现创造力，意义不大。2020-06-17

前台业务变化快，经常这次上线验证效果不好就推翻重做。对于扩展和规划的要求就更高了。现在都是做一步想三步。根据经验考虑后面会有什么变化。作者回复：不管什么系统，都有一部分内容是稳定的，一部分内容是不稳定的。所以，我们设计的重点就是把稳定的和不稳定的隔离开来。不稳定的验证不好，丢了就丢了，没什么可惜的。千万不要做过度的设计，浪费精力，后面会讲到简单设计。2020-05-26

简单一点的项目，成员相互讨论（主要讨论业务场景和流程），内心会意即可。复杂一点的项目，设计一般落脚在粒度较粗的文档上，往往也以说明业务流程为主，很少对实现过程中的细节文档化。所以，我们的项目设计，模型一般会被业务场景和流程替代。文中的「模型」和「规范」，更多取决于工程师了。作者回复：对，你说的确实符合大部分做设计的方式。这种设计的关注点在于实现功能，而非构建模型。这种做法容易让人忽略掉哪个东西是核心的，是模型，还是流程。流程是容易调整的，而模型如果变了，这个软件整个就变了。做设计的关键是，找到不变的东西。2020-05-26

文章在开篇提出的关于软件设计的问题，其实也是我现在的困惑，因为在做求职前的准备，感觉有很多东西要学，极客时间的专栏那么多，眼花缭乱。如何才能提高自己的求职成功率呢？软件开发是为了解决问题，而软件设计就是在需求和解决方案之间的桥梁。对于「软件设计就是构建出一套模型」这个说法，我感觉似乎有点过于抽象了，虽然文中列举的那个交易系统模型，确实很简洁、准确。如果单独来看「模型」和「规范（约束）」都比较容易理解，但是如果说软件设计就是设计出模型和规范来，又有些不好理解了。特意去看了一下 Wiki：Software design is the process by which an agent create a specification of a software artifact, intended to accomplish goals, using a set of primitive components and subject to constraints.

感觉上自己以前可能更看重软件开发的结果，而忽视了其中的模型和约束。在这之前，如果拿到一个项目，大概会先看看是 CS 还是 BS 的，一般会采用 MVC 或者是分层模型，然后再去看看有没有其他的开源软件可以借鉴，之后就开始码程序了，编写代码边修改，可能从整体设计上考虑的比较少。看了一下留言，发现自己之前可能局限于个体软件作坊，并没有正式或者完整的软件设计过程。那么我有一个问题：软件设计是只适用于相对复杂一些的软件开发过程么？如果程序本身比较简单，而且是那种「用完即焚」式的，是否还需要设计？另外一个问题，就是软件设计和架构设计的区别在哪里？应该不仅仅是范围大小的差别吧 。

作者回复：非常感谢你的补充！我不会为 Hello，World 做设计，因为它真的「用完即焚」，在开篇词里我说过，设计是应对需求规模的算法。需求越来越多，设计和不设计的差别就会体现出来。但是，你不学习软件设计的话，想直接应对复杂软件是不可能的。关于软件的设计过程，我们后面会讲到 DDD，你可以关注一下。软件设计和架构设计，其实是没有区别的，只不过，通常把高层一些的设计称为架构设计，但我们这里所学的设计原则同样适用于架构设计。2020-05-27

很多 IT legacy 项目，存在了 7、8 年甚至更久。对比起项目刚开始的时候，语言，框架，best practices，需求，人员变更等都往往都已经很不一样了。对着这种「祖传」项目，往往文档缺失，结构复杂，动一发而牵千全身；对这种项目做设计优化，该从哪些方面切入呢？2020-05-26

刚开始按照模型和规范走着，后来随着需求的改动，客户不停的催促，代码改动越来越乱，先把工作完成后再改规范，还是有什么好的办法。作者回复：首先，要分清楚哪些是人为的问题，哪些是设计的问题。赶工绝对是人为的问题，需要设置正确的预期，这是《10x 程序员工作法》讨论的范畴。其次，如果是设计问题，需要把分清楚哪些是变的部分，哪些是不变的部分。不变的部分花力气去设计，变的部分需要等一等，等它相对稳定一些，再花大力气去设计。规范主要是针对你需要花力气去设计的部分，混乱的部分，就先混乱着。让子弹飞一会儿。2020-05-26

向贝佐斯学习，做事情要建立在不变的东西上。模型是一个理解世界的抽象模型，就像科学理论一样。好的模型应该是稳定的，简洁的。规范也不能朝令夕改，规范就是做事的高层原则，相当于「公理」。公理要么来自于根深蒂固的人性（广义的，中性的，如懒惰，两点之间直线最短），要么就是大量经验教训的积累（如业界各公司如阿里巴巴开发手册之类）。（这里看出为什么小公司规范意识稀缺了，踩得坑不足，积累经验不足，你就是想规范也规范不起来。解决办法就是参考业界或大公司的规范，当然不能照搬。）作者回复：编码规范和设计规范还是有所差异的。编码规范的适用范围会更大一些，设计规范则适用于一个特定的项目。2020-05-26

现在在小团队，后端有两个人，需求迭代开发前，组内做设计评审，主要是数据结构和性能方面，没啥问题，就直接开发了，学习本门课程主要想为以后做储备，也会想办法将课程学到的内内容应用到实际工作中。作者回复：数据结构和性能主要是实现方面，后面会讲到，这只是设计的一部分。2020-06-26

是否设计，随着需求规模的变大，效果会凸现出来。模型是构建骨架，各自器官及关系，这种内在的东西，决定了软件的本质。运维，扩展其实是对软件做手术，设想一下，你面对一个无脊椎，各器官混在一起的生物，你敢下手吗，分分钟可能弄死他。规范也非常重要，经常听说标准先行，无规矩不成方圆，规范也是执行力的体现。规范无处不在，UI 规范，数据库设计规范，编码规范，日报 周报规范，发布规范，文档规范，只要有人的地方，有江湖就要有规范。越早认识到规范的重要性，越重要，在一开始活动之前就规范先行的意识，有规范就遵守，无规范就创建，以文档，流程方式固化下来，并持续优化。规范与文化，与最佳实践也有内在联系。我想模型定义了软件的骨架（业务决定架构，模型承载和映射业务的本质）。规范定了内部次序，约束。作者回复：理解得不错！2020-06-18

我提供一个遇到过的规范不合理的场景：我们公司的技术框架是在 [ASP.NET](http://asp.net/) 的 MVC 基础上搭建的分层的快速快发系统，很长一段时间都是还是在视图这一层去用 jQuery 来做一个一些简单的交互，因为交互简单，Controller 这一层就负责和视图通讯，许多数据都从 Context（我们这里叫做功能层）取了之后就直接放到 Controller 来用，当时是够用的。

接下来，我们开始了前后端分离，需要处理更负责的交互了，一个页面上可能是来自多个接口的数据，原来的 Controller 很难满足需求。不仅仅很难满足需求，还带来了更多的问题：比如 ASP.NET 的 MVC 根本就不是为提供服务接口而设计的，那么像跨域这种问题，就只能通过修改 web.config 的方式去做，就根本就不是解决跨域的好方法。

这些问题虽然更准确的来说算是技术债务，不过确实也是我们公司负责人搞了一个快速开发框架规范并试图用这个规范去解决所有问题导致的技术债务。我目前的工作是前端开发工程师，虽然知道了这个问题，不过我暂时没有余力去解决这个问题，感觉很无力。2020-06-04

汇总：1）我现在在项目中采用 ddd 的分层架构。（不要求领域模型设计，仅限定了基本实现规范）2）因为整个公司缺乏显示统一的规范，我希望引入 ddd 的分层架构去限定这个规范。而且，项目本身虽是微服务技术栈，但模型本质还是大单体，用 ddd 挺好。（如果是真的微服务，不需要采用 ddd 的分层，ddd 分层架构的理念应该在系统架构上去体现，落地到具体微服务包应该要对这些复杂性无感）3）起了分层的目录结构，做了下各层作用的讲解，前期大部分需求，我都定义好 api，然后让队友们来实现。结果还是不理想。问题不在于知识难不难，而在个人意愿和市场需求。相对于个人代码质量的追求，大多数人更愿意把时间放在技术上。毕竟技术面试占分更高，且武学学会了就是会了，能做到分毫不差，短期既有价值。而内功除了学会，还要积累，短期难有成效。人往往都有点浮躁。作者回复：你们的设计已经算得不错的了。2020-05-25

## 0002. 分离关注点：软件设计至关重要的第一步

今天我们学习了软件设计中至关重要的第一步：分解。大多数系统的设计做得不够好，问题常常出现在分解这步就没做好。常见的分解问题就是分解的粒度太大，把各种维度混淆在一起。在设计中，将一个模块的不同维度分开，有一个专门的说法，叫分离关注点。分离关注点很重要，一方面，不同的关注点混在一起会带来许多问题；另一方面，分离关注点有助于我们发现不同模块的共性，更好地进行设计。分离关注点，是我们在做设计的时候，需要时时绷起的一根弦。

今天，我还给你举了两种常见的关注点混淆的情况。一种是技术和业务的混淆，另一种是不同数据变动方向的混淆。希望你在日常开发中，引以为戒。好，我们已经迈出了软件设计的第一步。接下来，就该考虑如何组合了。在组合的过程中，会有很多因素影响到组合的方式。下一讲我们就来看一个非常重要却不受重视的因素：可测试性。如果今天的内容你只能记住一件事，那请记住：分离关注点，发现的关注点越多越好，粒度越小越好。

上一讲我们讲了软件开发就是在解决问题。那问题一般是如何解决的呢？最常见的解决问题思路是分而治之，也就是说，我们要先把问题拆分开。在每个问题都得到解决之后，再把这些解决好的子问题以恰当的方式组装起来。如何分解与组合，就是我们要在软件设计中考虑的问题。

然而，在软件设计这个环节中，大部分人都把焦点放在了如何组合上，却忽略了至关重要的第一步：分解。你可能会觉得：「分解？我会啊，不就是把一个大系统拆成若干个子系统，再把子系统再拆成若干个模块，一层一层拆下去嘛。」

然而，在我看来，这种程度的分解远远不够，因为分解出来的粒度太大了。粒度太大会造成什么影响呢？这会导致我们把不同的东西混淆在一起，为日后埋下许多隐患。为什么这么说呢？我来给你举个例子。

### 2.1 一个失败的分解案例

我曾经见过一个故障频出的清结算系统，它的主要职责是执行清结算。一开始我觉得，清结算系统是一个业务规则比较多的系统，偶尔出点故障，也是情有可原。但是在分析了这个系统的故障报告后，我们发现这个系统设计得极其复杂。其中有一处是这样的：上游系统以推送的方式向这个系统发消息。在原本的实现中，开发人员发现这个过程可能会丢消息，于是，他们设计了一个补偿机制。

因为推送过来的数据是之前由这个系统发出去的，它本身有这些数据的初始信息，于是，开发人员就在数据库里增加了一个状态，记录消息返回的情况。一旦发现丢消息了，这个系统就会访问上游系统的接口，将丢失的数据请求回来。

正是这个补偿机制的设计，带来了一系列的后续问题。比如，当系统业务量增加的时候，数据库访问的压力本身就很大，但在这种场景下，丢数据的概率也增加了，用于补偿的线程也会频繁访问数据库，因为它要找出丢失的数据，还要把请求回来的数据写回到数据库里。

也就是说，一旦业务量上升，本来就已经很吃力的系统，它的负担就更重了，系统出现卡顿也就在所难免了。这个补偿机制的设计是有问题的，问题的点在于，上游系统向下游推送消息，这应该是一个通信层面的问题。而在原有的设计中，因为那个状态的添加，这个问题被带到了业务层面。

这就是一个典型的分解没有做好的例子，是分解粒度太大造成的。开发人员只考虑了业务功能，忽视其他维度。技术和业务被混在了一起，随之而来的就是无尽的后患。一旦理解了这一点，我们就可以想办法解决了。既然是否丢消息是通信层面的事，我们就争取在通信层面解决它。我们当时的解决方案是，选择了一个吞吐量更大的消息队列。在未来可见的业务量下，消息都不会丢。通信层面的问题在通信层面解决了，业务层面也就不会受到影响了。果不其然，这样改造之后，系统的稳定性得到了大幅度的提升。

上面我只讲了这个故事的主线，其实，相关的事情还有一些。比如，上游系统专门为补偿而开发的接口，现在也不需要了，于是上游系统得到了简化；这个系统里那个表示状态的字段，其实还被用在了业务处理中，也引发过其他问题，现在它只用在业务处理中，角色单一了，与此相关的问题也少了。

### 2.2 分离关注点

至此，我们已经对分解粒度太大所造成的影响，有了一个初步的了解。那在做设计时，该如何考虑分解呢？传统上，我们习惯的分解问题的方式是树型的。比如，按功能分解，可分为：功能 1、功能 2、功能 3，等等，然后，每个功能再分成功能 1.1、功能 1.2、功能 2.1、功能 3.1 等等，以此类推。如果只从业务上看，这似乎没什么问题。但我们要实现一个真实的系统，就不仅仅要考虑功能性的需求，还要考虑非功能性的需求。比如，前面提到的数据不能丢失、有的系统还要求处理速度要快，等等。

这与业务并不是一个维度的事情，我们在做设计时，要能够发现这些非功能性的需求。也就是说，我们在分解问题的时候，会有很多维度，每一个维度都代表着一个关注点，这就是设计中一个常见的说法，「分离关注点（Separation of concerns）」。可以分离的关注点有非常多，你只要稍微注意一下，就能识别出来。但还有一些你可能注意不到，结果导致了混淆。最常见的一类问题就是把业务处理和技术实现两个关注点混在了一起，前面举的那个例子就是一个典型。

对于「把业务处理和技术实现混在一起」的问题，我再给你举个例子。如果现在业务的处理性能跟不上，你有什么办法解决吗？大多数程序员的第一反应是，多线程啊！没错，多线程的确是一种解决办法。但如果不加限制地让人去把这段代码改成多线程的，一些多线程相关的问题也会随之而来。比如，让人头疼的资源竞争、数据同步等等。

写好业务规则和正确地处理多线程，这是两个不同的关注点。如果我们把二者放到同一段代码里去写，彼此影响也就在所难免了。问题说明白了，解决方案才能清楚，那就是把业务处理和多线程处理的代码分开。按照我的理解，大部分程序员都不应该编写多线程程序。由专门的程序员把并发处理的部分封装成框架，大家在里面写业务代码就好了。把业务处理和技术实现混在一起，类似问题还有很多。比如我们经常问怎么处理分布式事务，怎么做分库分表等。其实，你更应该问的是，我的业务需要分布式事务吗？我是不是业务划分没有做清楚，才造成了数据库的压力？

在真实项目中，程序员最常犯的错误就是认为所有问题都是技术问题，总是试图用技术解决所有问题。任何试图用技术去解决其他关注点的问题，只能是陷入焦油坑之中，越挣扎，陷得越深。另外一个常见的容易产生混淆的关注点是不同的数据变动方向。

有人问过我这样一个问题：在 Java 应用里，做数据库访问用 Spring Data JPA 好，还是 MyBatis 好。Spring Data JPA 简化了数据库访问，自动生成对应的 SQL 语句，而 MyBatis 则要自己手写 SQL。普通的增删改查用 Spring Data JPA 非常省事，但对于一些复杂场景，他会担心自动生成 SQL 的性能有问题，还是手写 SQL 优化来得直接。是不是挺纠结的？随即我又问了他一个问题，为什么需要复杂查询呢？他告诉我，有一些统计报表需要。

不知道你是否发现了其中混淆关注点的地方？普通的增删改查需要经常改动数据库，而复杂查询的使用频率其实是很低的。从本质上说，之所以出现工具选择的困难，是因为他把两种数据使用频率不同的场景混在一起所造成的。如果将前台访问（处理增删改查）和后台访问（统计报表）分开，纠结也就不复存在了。

不同的数据变动方向还有很多，比如：1）动静分离，就是把变和不变的内容分开；2）读写分离，就是把读和写分开；3）前面提到的高频和低频，也可以分解开……

不同的数据变动方向，就是一个潜在的、可以分离的关注点。在实际的项目中，可以分离的关注点远不止这些。做设计时，你需要一直有一根弦去发现不同的关注点。分离关注点，不只适用于宏观的层面。在微观的代码层面，你用同样的思维方式，也可以帮助你识别出一些混在一起的代码。比如，很多程序员很喜欢写 setter，但你真的有那么多要改变的东西吗？实际上可能就是封装没做好而已。

分离关注点之所以重要，有两方面原因。一方面，不同的关注点混在一起会带来一系列的问题，正如前面提到的各种问题；另一方面，当分解得足够细小，你就会发现不同模块的共性，才有机会把同样的信息聚合在一起。这会为软件设计的后续过程，也就是组合，做好准备。

### 黑板墙

我想请你去了解一下 CQRS（Command Query Responsibility Segregation），看看它分离了哪些关注点，以及在什么样的场景下使用这种架构是合理的。

汇总：1）cqrs，命令与查询分离，最早是在 ddd 实战里面看到。其分离啦增删改与查询这两个关注点。2）静态上，拆分了这两块的代码。使各自可以采用不同的技术栈，做针对性的调优。动态上，切分了流量，能够更灵活的做资源分配。3）查询服务的实现。可以走从库，这有利于降低主库压力，也可以做到水平扩展。但需要注意数据延迟的问题。在异步同步和同步多写上要做好权衡。也可以都走主库，这时候查询服务最好能增加缓存层，以降低主库压力，而增删改服务要做好缓存的级联操作，以保证缓存的时效性。当然也可以走非关系型数据库，搜索引擎类的 es,solr，分布式存储的 tidb 等等，按需选择。作者回复：非常棒的分享！2020-05-27

比如说订单系统 先下单写到数据库 然后发送消息给消息队列 这两部 没法放到一个事务中去。如果用本地消息表，order 写数据库 然后 在写本地消息表 这样这两步就放到一个事务中去了 保证肯定成功，然后在有线程 读取本地消息表 发送队列 如果成功更改本地消息表状态 。从设计角度讲这就没分离关注点，这个应该怎么分呀？作者回复：我们来分析一下这个需求，下单入库和发消息给下游，这确实是两个动作，但这两个动作的顺序一定是这样吗？它们一定要在一个线程里完成吗？我们可不可以先发消息呢？比如，我们把消息发给下游之后，有一个下游接收到消息之后，再把消息入库。如果这样做的话，发消息，由消息队列保证消息不丢，下游入库，又可以保证订单持久化。你看，在这个设计中，其实，并不需要事务，所以，我们也不必为事务纠结了。2020-05-28

近期有一本书《被统治的艺术》，正好和软件设计中的职责分离策略异曲同工。我们知道明朝自朱元璋开始有一个顶层设计，就是每家每户做什么，一开始就规定好了。军队也是一个固定职业，即军户制。比如说国家需要 100 万个士兵，那就要有 100 万个军户，每户出一个兵，世世代代都是这样。如果这个兵逃了或者死了怎么办？家族里就再出一个来补充。

这会带来什么后果呢？你可以想象一下，如果儿童节的时候你正坐在家里跟妻子儿女享天伦之乐，忽然有人闯进来，把你抓走了去当兵，只是因为你家族里面的另外一个人当了逃兵或者死掉了。可见，这样的顶层设计会给自己的家族带来各种不确定性甚至家庭悲剧。人民群众想出了很多的策略来对付这样的制度。

有种设计是这样的，就是每个家族中选出一个分支代表整个家族去当兵，与之相对的是家族的其他分支需要共同出一笔钱，世世代代赡养这个当兵的分支。此外还有其他一些「福利」，比如说，如果原本他在家族中的排位比较低，那他的后代就可以在家族的各项活动中提升座次。

这个世世代代当兵的分支会比较惨，但带来的好处是这个家族中的其他分支就会少受骚扰，得以繁衍。事实上这样的策略运行得不错，有些家族好几代人一直都执行这样的策略，甚至贯穿了几乎整个明代。某种角度说，这就是一种职责分离，将国家统治的要求和家族稳定繁衍的需要分开。

作者回复：刚好最近万维钢老师讲了这本书中的内容，但你从软件设计的角度去理解这个问题，确实让人有一种耳目一新的感觉。2020-05-27

想起 Kent Beck 说的一句话，大致意思是：我不准备在这本书里讲高并发问题，我的做法是把高并发问题从我的程序里移出去。作者回复：没错，就是这样。2020-05-27

郑烨：在《软件设计之美》的中，我们谈到了分离关注点。根据大家的提问，我补充一些关于分离关注点的内容：

首先，分离关注点是一种意识，在设计中要意识到需要分离关注点。一旦自己在做设计时，出现纠结或者是觉得设计有些复杂，首先需要想想，是不是因为把不同的关注点混在了一起。这种意识是需要训练的，让自己从无意识中摆脱出来。一种可以考虑的做法是，把它与一些实践结合起来，比如，在设计评审的 DoD 中，增加一条「是否考虑了分离关注点」。

其次，分离关注点也需要从小事开始练习。比如，可以从编写小函数开始。假定我们给自己设定了一个目标，函数的代码行要小于 10 行。每次写完代码，就可以对代码进行调整。超过 10 行代码的函数，我们就要问问自己，是不是有混在一起的内容：1）如果有循环，循环里面的部分就是对单个元素的处理，可以提取到一个函数里；2）如果有 if...else，每种情况都可以单独放到一个函数里；3）如果有多个 if...else，要问问自己是不是缺少了一些模型，是不是可以用多态解决.....

1『上面的建议真的很有用，捡到金子了。（2020-09-09）』

如果经过练习，函数都能写短，那就可以开始做类的练习。把每个类写小，以此类推，逐步训练。《重构》里《代码的坏味道》可以成为我们改进的参考点。能发现多少关注点，与做了多少的练习是相关的，而练习需要时间的积累。只有在日常开发的过程中不断练习，它才能成为我们的下意识反应。在专栏后面的内容里，我们还会多次提到分离关注点，你会看到它在不同的场景下的应用，帮助你更好地发现各种关注点。2020-05-28

我觉得补偿机制还是要的吧，就算换吞吐量大的消息队列，丢失消息还是有可能出现的，只是几率小很多。只是他补偿机制设计得不合理？作者回复：如果我们分析是不是丢消息，就要看它在什么情况下丢消息。在之前的业务场景中，丢消息就是因为消息队列处理不过来，而我们换了吞吐更好的队列就不存在这个问题了。其实，我们真正需要的是可靠的信息传送通道，至于是不是消息队列不重要。如果怕丢消息，可以在生产者端重试，可以在消费者端做幂等。补偿是一个能把场景弄复杂的做法，不鼓励。2020-05-29

技术和业务混杂的情况，让我想起来一篇文章，大意是说要区分技术异常和业务异常的。也就是说，技术层面的异常信息不应该暴露给上层的业务人员。典型的例子就是大型网站的错误页面，而不是直接把后台的 npe 堆栈信息抛给用户。作者回复：这是一个很好的例子，确实要做区分。2020-05-27

能具体说说加了消息队列的数据流成什么样了？为啥能解决对消息问题呀？作者回复：这里并不是说增加了消息队列解决的问题，原有的解决方案用的也是消息队列。这里的重点是，用了一个吞吐能力更强的队列，保证了消息的不丢失，这样我们就不必专门处理消息丢失的问题了。通信的问题在通信的层面得到了解决，就不会影响到其它的代码了。2020-05-27

对内容的理解确实需要一定的经验，对我来说感受颇丰。特别是技术实现和业务处理分离。工作以来，接手过很多程序员的项目，如果技术实现又被封装成组件，这就会导致一个很苦恼的问题，业务逻辑看到一半，就由技术实现的组件去处理了。然后必须下组件源码才能看完整个业务逻辑。代码层次看起来也会觉得非常混乱，导致维护开发成本升高。真是吃够了苦呀！作者回复：技术实现被封装起来是没有问题的，怕的是没有把接口提取出来，就容易产生混乱。2020-06-17

最近听到大家的一些技术设计。有些同事在偏业务数据驱动的系统里用了 juc 里的比如原子操作。虽然对大家提升技术水平有一定益处，但从软件设计角度来说，未必是好事，应该尽力避免。作者回复：把技术和业务分开，至少意识上要先行。2020-05-29

如果将前台访问（处理增删改查）和后台访问（统计报表）分开，纠结也就不复存在了。老师请恕我愚钝，所以将高低频分开之后是分别采用 Spring Data JPA 和 Mybatis 来实现进行数据库访问吗？如果是的话，那不是相当于在同一个项目中引入了两套数据库访问规范，会不会造成开发规范上的困惑甚至混乱？如果不是的话，那正确做法又应该是什么？作者回复：如果把二者分开，这可以就是两个项目，一个前台项目，一个后台项目。两个独立的项目各自采用一套编程规范，不就很正常了。2020-05-27

分解的粒度一般到什么样的层级才能更好的分析共通性以及更好的组合呢？作者回复：这就是我建议的由来，越小越好。最小的粒度就是函数，函数写得越小越好。怎么写小呢？就是要分解出更小的粒度，这是一种练习的方法。2020-05-27

比如有一个需求，要从多数据源（mysql.kafka.redis.es）读一些数据，然后写入一个 es 中去。这种设计模型的话，我只能想到分离出读层，队列缓存层，写入层。然后这个时候是不是又要考虑重试，读没成功，写没成功，队列满了。感觉我把很多关注点混在了一起，该怎么分离呢，感谢！！

作者回复：这个思路又是把业务和技术混到了一起。我们需要先界定清楚业务上不同的职责。从业务上说，你有数据源和数据目的地，中间还有一个数据处理器，那三者的职责分别是什么呢？数据源要保证数据读取一定要成功吗？数据源读出的数据一定要有序吗？数据目的地要保证数据写入的量足够大吗？数据处理器是保证写入成功再去读数据，还是不管不顾，读了数据就往里写。等界定清楚不同的职责，再把具体的中间件匹配进去，如果中间缺少能力，自己还要来补充。2020-06-15

郑老师 我有个需求描述下（类比）： 用户购买网站会员。我目前的设计用了两张表。一张表存储用户购买会员的所有记录，另一张表 存当前的会员信息 (主要是 开始，结束时间，没有会员等级之类) 单独设计这张表的目的是为了 sql 关联查询方便，不用再判断是否过期。但有个问题：我要用定时器一直扫这表，等会员过期了要删除记录。请问郑老师 我这么做的问题在哪？ 更好的解决方式应该是什么？如果做到更细维度的拆分？

作者回复：首先，你的描述没有把业务和实现分清楚。你的业务是实现一个会员系统，具体到这里，是判断用户当前是否是会员。更具体一点的话，会涉及会员购买，主要是会员时间要延长，还会涉及到会员资格的判断，也就是当前用户是否是会员。

基于这些内容的判断，可以有不同的实现。根据你当前的实现，可以这样做：1）购买会员，如果会员信息不存在，则添加会员信息，如果会员信息存在，则修改会员结束时间。2）会员资格判别，根据用户 ID 和当前时间是否在时间范围内查询查询，如果记录存在，则是会员，否则不是。结合你提供的信息，可以考虑的点是：1）购买会员时，可以产生会员购买记录，此记录仅供后续查询使用；2）只有当会员信息表过大时，才考虑是否需要删除。

在这个实现中，把购买和会员信息分开，把会员信息是否生效与记录是否删除分开了。以上仅仅是根据你提供的信息进行的分析，如有不当之处，欢迎继续讨论。2020-06-11

还是有点抽象，比如对于前端人员，测试人员而言，如何对应具体的工作场景？作者回复：对于前端，设计的道理是一样的，现在前端也开始有框架了，就是这个原因。至于测试，如果你把自动化测试算进来，也许这些道理就是一致的了，测试也有自己的模型，有自己的模式。2020-06-07

常见的设计分层也是关注点分离，service 层做业务，dao 层涉及具体的数据库操作也就是技术实现，把技术和业务分离。但是我们往往会在 dao 里面写很多业务相关的 sql，有没有什么好的方式去分离呢？作者回复：DAO 层设计到数据操作是很正常的，但这里面需要你分清楚的一点是，DAO 层为什么会有很多业务相关的 SQL，是为了性能，还是不假思索写成了这样。通常，我建议 DAO 层比较简单，除非是要做特别的优化。真正的业务逻辑最好还是写在 Service 这一层。2020-06-02

## 0003. 可测试性： 一个影响软件设计的重要因素

今天我们学习了一个影响软件设计的重要因素：可测试性。在软件设计中，可测试性常常被人忽视，结果造成了很多模块的不可测，由此引发了很多技术债。所以，在设计中就要充分考虑可测试性。在设计中考虑可测试性，就是在设计时问一下，这个函数 / 模块 / 系统怎么测。在软件开发中，只有把一个一个的小模块做了足够的测试，我们才会有稳定的构造块，才可以在集成测试的时候，只关注最终的结果。而有了可测试性的视角，我们可以把它当作一个衡量标准去看待其他的设计或实践，也可以用它帮助我们理解软件的发展趋势。经过前几讲基础知识的铺垫，你对软件设计已经有了一个初步的了解。下一讲，我们将进入到实际的工作环节中，去了解一个软件的设计。如果今天的内容你只能记住一件事，那请记住：做软件设计，请考虑可测试性。

上一讲，我们讲了软件设计的第一步：分离关注点。作为至关重要的第一步，分离关注点常常被人忽略，严重影响了设计的有效性。这一讲，我们再来看另一个经常被很多人忽视的因素：可测试性。

在讨论可测试性之前，我们不妨先来思考一个问题：你觉得软件开发中最浪费时间的环节是什么？答案肯定不是写代码，因为写代码是一个建设的过程，谈不上是在浪费时间。在我接触过的诸多项目里，集成测试可以说是一个浪费时间的大户。

那你的项目是怎么做集成测试的呢？一个常见的测试场景是这样的：你先花了一些时间打包部署一个服务端应用，然后开始测试。测着测着，你发现一个 Bug，然后调查半天，最后发现是一个简单的错误。你就在心里暗恨，为啥写代码的时候没发现呢！

这还只是一个简单的场景，也有稍微复杂一点的。比如，有多个不同项目组的人一起联合测试。当你测出一个 Bug，然后辛辛苦苦调查半天，发现是另外一个模块出了问题，你唯一能做的就是等着那个组的同事把 Bug 改好，测试才能进行下去。更可恨的是，他们查了半天，结果也是一个简单的错误。你会在心里嘀咕，为啥写代码的时候不仔细一点呢？

在实际工作中，我们经常遇到类似的场景。你觉得这种状态正常吗？可能很多人对此习以为常。虽然难受，却不得不忍受。但我想说的是，这样的问题原本有机会得到优化。而出现这样的问题，主要原因就在于前期设计时就埋下了隐患，你根本没有考虑「可测试性」。

### 3.1 软件设计要考虑「可测试性」

我们知道，软件开发要解决的问题是从需求而来。需求包括两大类，第一类是功能性需求，也就是要完成怎样的业务功能；第二类是非功能性需求，是业务功能之外的一些需求。非功能性需求也被分为两大类，一类称为执行质量（Execution  qualities），你所熟悉的吞吐、延迟、安全就属于这一类，它们都是可以在运行时通过运维手段被观察到的；而另一类称为演化质量（Evolution  qualities），它们内含于一个软件的结构之中，包括可测试性、可维护性、可扩展性等。

做设计的时候，功能性需求自不必说，你肯定会考虑到。在非功能性需求中，执行质量是很多程序员的心头爱，一般也不会被忽略。但演化质量的地位却很低，常常为人忽略，尤其是其中的「可测试性」。我们在开发过程中欠下的很多技术债，本质上都是因为忽略了「可测试性」这个需求。

可测试性为什么如此重要？因为我们做设计，其实就是把一个软件拆分成一个一个的小模块。如果不尽可能地保证每个小模块的正确性，而只是从最外围的系统角度去验证系统的正确性，这将会是一个非常困难的过程。就和盖楼是一个道理，不保证钢筋、水泥、砖土质量合格，却想要盖出合格的大楼来，很荒唐吧！然而，很多团队的软件开发就是这么做的。

我们要保证每个小模块的正确性，就要保证每个模块在开发阶段能够测试，而想要每个模块能够测试，在设计过程中，就要保证每个模块是可以测试的，而这就是可测试性。一旦我们在可测试性上考虑不足，就会引发一系列的后续问题。比如，复杂的系统不仅仅在测试上有难度，在集成、部署等各个环节，都有其复杂性，完成一次部署往往也需要很长时间。这也就意味着，即便是一个简单的验证工作，部署的时间成本也非常昂贵。这还不包括在出问题时，我们在一个复杂系统中定位问题的成本。

我们只有把每个小模块尽可能做好，才能尽量降低对集成环境的依赖程度，从而节省后期的成本。这就相当于在前面多花了 1 块钱，却省下了后期的 10 块钱。我们回过头思考一下这节课刚开始提到的那个问题，为什么我们在集成测试场景中，会浪费那么多时间呢？因为这个系统只能在集成测试环境中进行测试，所以，即使是一些非常简单的问题，也只能在这阶段暴露。这些问题原本可以在更前面的阶段解决，比如，单元测试。

可为什么这些问题会遗留到集成测试环境呢？很多程序员给你的回答都会是，不好测。而这不好测的背后，往往就是因为在设计中没有考虑「可测试性」这个因素。那么如何在设计中考虑可测试性呢？其实就是要在设计时想一下，这个函数 / 模块 / 系统要怎么测。

当你用这个标准衡量一些系统时，可能就会发现一种典型的错误，就是设计根本没有考虑过测试。这样的系统常常只有最外层的接口可以测试，也就是说，整个系统必须集成起来才能测试。前面提到的集成测试的问题犯下的就是这种错误。

在实际工作中，很多公司为了做集成测试，要把所有的子系统全部都搭建出来，也就是一套完整的环境。这种环境要占用大量的资源，一般来说，公司不会准备很多套。这样造成的结果就是各个团队对于环境的竞争，再叠加上各个系统配合的问题，测试的效率还会进一步降低。

所以，我们在设计一个函数 / 模块 / 系统时，必须将可测试性纳入考量，以便于能够完成不同层次的测试，减少对集成环境的依赖。那么，具体该如何做呢？一方面，尽可能地给每个模块更多的测试，使构成系统的每个模块尽可能稳定，把集成测试环境更多地留作公共的验收资源。另一方面，尽可能搭建本地的集成测试环境，周边的系统可以采用模拟服务的方案。在软件开发过程中考虑测试，实际上是思考软件的质量问题，而把质量的思考前移到开发，甚至是设计阶段，是软件开发从传统进入到现代的重要一步。

### 3.2 当你有了可测试性的视角

现在你已经对软件设计中的可测试性有了一个初步的认识。其实，在了解可测试性之后，我们还可以把它作为一个衡量标准来考察已有的设计。比如，有一个设计模式叫 Singleton，通常的做法是把构造函数做成私有的。如果这个 Singleton 的类与其他组件配合，由于这个私有函数的存在，这个类无法继承，也就不能用一个子类对象去模拟它。所以，从可测试性的角度来看，Singleton 就不是一个好的设计模式。

1『这里就解释了陈烨一直不推荐使用单例模式，单例模式中对象的构造函数是私有的，没法用一个子类去继承它从而达到模拟的效果。（2020-09-10）』

再比如，TDD（Test-Driven Development，测试驱动开发）对于很多人来说都非常困难，主要有两方面原因。一方面，这些人不习惯先写测试的工作方式，但另外一方面，也是更重要的原因，是他们不知道怎么测试。

因为很多模块的设计根本没有考虑过如何做测试，要把它们单独拿出来测试，必然会遇到很多问题。举个例子，在通常的架构中，服务会调用数据库访问的代码。如果是不考虑测试的做法，代码可能写成这样：

```java
class ProductService {
  // 访问数据库的对象
  private ProduceRepository repository = new ProductRepository();
  
  public Product find(final long id) {
    return this.repository.find(id);
  }
}
```

在这里，我们要直接创建数据库访问的对象，然而，要创建数据库访问对象，就要同时把数据库连接起来，你要准备一大堆相关的东西，所以，测试的复杂度就会非常大。可是，测试这个服务目的是，关心这个服务的逻辑是不是写正确了，这与是不是用数据库没关系啊！所以，如果我考虑了可测试性，服务的依赖就变成了一个数据访问的接口：

```java
class ProductService {
  // 访问数据库的对象
  private ProduceRepository repository;
  
  public ProductService(final ProduceRepository repository) {
    this.repository = repository;
  }
  
  public Product find(final long id) {
    return this.repository.find(id);
  }
}
```

在这种代码里，我们只需要将数据访问的接口模拟出来，而用来模拟接口的 Mock 框架在各种程序语言里几乎都可以找到。我们唯一要保证的，就是模拟出来的对象要与接口定义的行为保持一致，不过，这可比准备数据库，难度系数要低多了。

1『模拟对象，只需要保证模拟对象与实际对象的「行为」保持一致就 OK 了，不需要模拟数据。（2020-09-10）』

真正懂得了可测试性，还可以帮助我们理解软件开发的趋势。有些 Java 工作经验的同学可能听说过 EJB（Enterprise Java Beans），它是 2000 年左右的开发主流。当时一个 Java 系统如果没用到 EJB，你都不好意思和人打招呼。但是，今天你很难听说有谁还在用 EJB 做新系统了。

在每次测试时，EJB 都需要部署到专门的应用服务器上。站在可测试性的角度看，它的测试成本就是极其高昂的，相应的开发成本也就变得很高。当年与 EJB 竞争的正是当今如日中天的 Spring，Spring 胜出的一个重要原因就是它简化了开发。它当年的口号正是 without EJB。这是一种重要的开发趋势：轻量级开发。而这背后，重要的思维基础，就是可测试性。后面在第五讲中，我们会讲到 SpringDI 容器的设计，你会进一步看到可测试性在其中发挥的作用。

实际上，Spring 在简化开发的道路上从未停下脚步。今天的 Java 程序员使用 Spring Boot 的时候，启动它就像启动一个普通的 Java 应用，在 IDE 里做各种调试，甚至都没有注意到它启动时，下面有一个 Tomcat。要知道，当年可是要打出一个 WAR 包，部署到 Tomcat 上。所以，曾几何时，能够连接远程的 Web 服务器是 IDE 一项重要的功能，而这项功能在今天来看，已经非常鸡肋了。

### 黑板墙

我想请你回想一下，如果以可测试性衡量一下你开发过的系统，它的可测试性如何？有哪些问题是由于最初没有考虑可测试性造成的呢？

最近有同事正好在做 PDF 的生成，也就是把业务数据从各个别的服务拉取回来，然后清洗加工成自己想要的数据，然后传递给模版引擎进行渲染，最终生成 pdf 文件上传 s3，然后通过 API 把上传的文件地址返回给客户端。想请问老师，这部分逻辑应该怎么测试？因为同事在写完代码之后只做了简单的测试（也就是直接 mock 其他的 service 的服务，然后 mock 数据返回，以及 mock 了 s3 上传 ）最后只是简单看了一下返回值是否为空就完事了。最后到环境上验证才发现好多字段的格式有问题。那像这类场景我们该怎么合理测试才能尽可能保证做到测试完整性呢？

作者回复：之所以我们要先讲分离关注点，就是因为很多人会把东西混在一起，测试当然就会很困难了。以你的场景为例，做 PDF 生成，这里面要拆分开几个不同的环节：1）从别的服务器拉取数据；2）解析外部业务数据；3）业务数据清洗成自己的数据；4）采用模板引擎进行渲染生成 PDF；5）将文件上传到 S3；6）将文件地址返回给客户端。

接下来，就是一个一个分别构建这几个不同的模块，每个模块单独测试。1）从别的服务器拉取数据：关注数据能否正确获取，获取出错该如何处理，这里需要将拉取协议进行隔离；2）解析外部业务数据：关注数据能否正确解析，无法解析的数据该如何处理；3）业务数据清洗成自己的数据：关注数据能否正确转化，业务含义不正确该如何处理；4）采用模板引擎进行渲染生成 PDF：关注渲染过程能否正常进行。需要将 PDF 作为一个生成目标进行隔离。这一过程需要人工检查生成的 PDF 格式是否正确。5）将文件上传到 S3：关注文件上传是否正确，需要将文件上传目标进行隔离，S3 只是一个目标。6）将文件地址返回给客户端：关注是否能够获取到文件地址，这里要结合上一项中的上传目标，将 S3 隔离开来。

各个都测试好之后，再进行集成测试，这里面的关注点就是这些模块联动起来是否能够正常运行，以及检查结果的正确性。2020-05-29

比如 service 层有个很长，包含复杂逻辑的 private 方法，但我又想测试他。只能通过最顶层的 public 方法作为入口，这导致需要保证大量的前提条件的正确，我们需要 mock 很多外部依赖。当 private 方法复杂并包含逻辑，其正确应当重构代码，而不是在测试做妥协，可以将需要测试的 private 方法转移到另一个对象中，成为一个 public 的方法。同时让我体会到测试驱动设计的含义。作者回复：private 方法怎么测？其实是一个伪命题。要测 private 方法，更多的是因为这个类承担了过多的职责，才会出现层层嵌套的方法，才会不好测。你的改进方法非常对，将这个方法移到另外一个类中，它成了 public 的，该怎么测，就怎么测。2020-05-29

其实难度是，现在大多开发者接触的一个已有的系统，在这个系统进行维护，修改各种 bug，以及添加一些新需求。那么问题来了，如何将一个已有系统改造成粒度小且可测试的程序？我觉得这个应该是大家关心的工程实践。作者回复：如何将一个已有系统改造成粒度小且可测试的程序？这到底是不是一个问题，其实要考虑的。很多系统的改造，是切分开来，逐步替换。我们在专栏最后，会讲到如何做一个现有系统的改造，敬请期待。2020-05-29

曾经开发过堆场应用，其中一个步骤是从远端服务器同步到本地服务器，然后再执行本地逻辑。如果每次测试本地逻辑都要从服务端拉取数据的话，就没法自动测了。当时采用的测试方法就是先抓取接口数据生成接口文件，测试就从文件中加载，再运行，最后销毁整个数据库。如果有接口相关的 bug，也同样抓取数据保存，构建一个 bug 号命名的测试方法测试 bug。后来做过系统高可用软件，采用的方法是将代码自动部署到多个 Docker 里，测试代码里依据场景（为了方便，场景还用 DSL 写）比如杀某个 Docker 来测试高可用逻辑是否正常。作者回复：很赞的做法！2020-05-29

和大家分享一下我最近发现的一个问题。最近在给手上的代码上加测试的时候我进行了如下操作：1）我在测试类中写了一个测试，因为类 A 中要执行的这个逻辑需要依赖另外一个对象 B，于是我把这个需要依赖的对象 B 从全局变量中移动到构造中，作为参数放了进去，然后再构造方法上加了注解 @Autowired。（注意： 原来的这个 @Autowired 是在这个全局变量上的）2）我在测试中 mock 了这个依赖的 B 对象，然后给到了这个 Service 的实例中去。3）写业务代码实现，让测试通过。

本来以为测试已经通过，没什么问题了，结果在集成测试启动 Spring 容器的时候，发现挂掉了，发生了循环依赖，查看代码，果然，在 B 中也 @Autowired 注入了 A ，他们两个就此开始循环。结果用 idea 的分析工具扫了一通，发现循环依赖不止于此，还有很多很多。

从这件事儿上体现出来的问题：1）滥用 @Autowired 体现出来的首先就是没有分离关注点，让一个类中做了过多的事情。现在想过来原来写过的很多代码里头都是一大堆的 @Autowired 注入 ，很多 XXXService 的代码大概率的会发生这种事情。2）其实 IDEA 编译器里边早就提醒过你了，当你在字段上使用 @Autowired 去注入的时候，会有黄线的提示，提醒你不要这么使用，推荐你使用构造器的方式去注入。而很多人的处理方式就是对这个黄线视而不见。3）如果从代码的测试性的角度来出发，你一定不会这么做，因为这么做没有办法去 mock 你的依赖。代码会丑到你自己都不想看。4）以前没想过循环依赖是怎么发生的，现在明白了：一个罪魁祸首就是滥用 @Autowired 。循环依赖本身也是一个设计上的坏味道。如果有人问我说如何解决循环依赖，我会回答他： 首先不要循环依赖。

作者回复：多谢分享如此惨痛的教训，相信你已经理解了循环依赖的问题所在。从设计的角度看，循环依赖之所以产生，一个重要的原因就是没有分清接口和实现。如果都是实现，一不小心就循环依赖了，如果分清楚接口和实现，实现依赖于接口，产生循环依赖的可能性就会大幅度降低。2020-05-31

测试前置数据，测试 API，测试完清理数据。感觉测试主要是为了防止自己或者别人改了自己的代码。作者回复：没有谁是可靠的，包括自己。有几个人能记住自己几个月前写的代码细节呢。2020-05-29

1、对于自己重构大半代码的项目，我觉得应该是有偏见的（恶心太多次了）。但我还是认为我现在的项目可测试性很差。1）项目启动太慢（服务包启动一次 7-8 分钟，war 包启动一次 20 几分钟）。虽然单测时我们可以控制扫包范围，但总会扫到一些「基础包」莫名其妙的玩意，逼着你只能扩大扫包范围，而扩大扫包范围就会让单元测试的间隔无意义的变长。（项目本身分层没规范。部分基础公共包的分层不规范，且强依赖，无法按需加载）2）工具包大量非纯函数的工具。静态方法不采用 mock 框架的高级功能是 mock 不了的，所以往往我们不会去测试工具类的逻辑。但这些工具包往往也存在文档不全或文档和功能脱节的情况。这个时候，一旦你使用不当或者工具类有 bug 那么就可能出现与预期不符的情况，而这个排查起来是比较难受的。因为这往往是你排查的最后一步，而你可能没有权限，只能看着反编译的源码，找到问题也改不了。只能改动自己的功能不用这个工具。（由此可见 DI 是多么美好的东西）3）臃肿的大类 + 强依赖中间数据结构。近百个字段的核心类，让你找个字段都很晕。中间数据（map，键值的 list）在功能间传递，缺少封装。每次要获取自己要用的数据结构都要对中间数据做转换。逻辑走完后，还要对中间数据做变动，以保证变更对外部生效。这一切的结果就是逻辑被变得复杂了，代码行数增多了。而代码行数和逻辑变多出问题的可能就变大，测试的工作量就变大。

2、其他的，诸如不要有未决行为，尽量少用全局变量，低耦合等等都是个人编码能力的事，怪不得老项目了。提高可测试性，其实我觉得就是要遵循最小依赖的原则。最好就只有入参和本地逻辑（逻辑中没有外部依赖，没有外部变量，没有外部静态方法），这样可测试性是最好的。而要做到这个也并非不可能，全在你的设计和拆分力度上。

作者回复：很好的思考，你发现的问题确实都是很严重的问题，会严重地影响开发的进展。不过，能发现这些问题，就是最好改进的起点。2020-05-29

可测试性现在是大家普遍关注的事情，公司能写单元测试的人是极少数，由于单元测试的缺失，很多问题都是暴露在集成测试，而在集成测试中发现问题会需要大量的时间来查找问题，是本身问题还是上下游服务问题导致，这就是后来引发出来的链路跟踪需求，不然就没办法定位问题。作者回复：大多数公司对于质量的思考是远远不够的，只用最后的结果说话，却不关注过程，造成的结果就是结果也不好，过程乱糟糟。2020-05-29

由于集成测试环境复杂，排错复杂，所以我们要尽量在前期，开发甚至设计阶段就要考虑测试，尽量把 bug 消灭在集成测试之前。每个模块保证接口功能正常，模块交互又是按照规范的，一般集成都问题不大，当然只是概率非常低。单元测试还有一个好处，那就是自动化。写一个功能，就运行一下单元测试。单元测试是代码功能的保障。经常对曾经一些低级的 bug 如手误少些个 ! 之类的错误深恶痛绝，觉得怎么能犯这么低级的错误。我错怪自己了，人就是这样一种粗心的动物，应该让程序来检查代码的正确性，程序检查的又快又不会出错，何乐不为？当然前提是得有单元测试。Tdd 是一种好的实践。在测试上要多下点功夫。作者回复：这个理解是对的。做好 TDD，前提是懂一点设计，否则，自己就把自己绕进去了。2020-05-29

有些项目从 controller 一直到 dao 都是一个简单的方法调用，逻辑都在 sql 里，这样如何单元测试呢？难道只能通过集成测试验证相互关联的方法里 sql 正确性了嘛……作者回复：快去看看 05！2020-06-03

singletone 模式构造函数可以是 protected 的，是可以有子类的。作者回复：严格地说，用了 protected，singleton 就不是 singleton 了，因为你制造了一个可以赋出其他值的对象。2020-06-22

如果要测试复杂查询条件的 sql，还是要依赖数据库吧。作者回复：你的目标如果是测 SQL，连数据库是可以的。但是，要把数据库和业务分开，参见后面讲 DI 容器的一节。2020-06-08

有什么好的资源关于单元测试吗？作者回复：我的单元测试并不是靠资料学出来的，那就推荐一本很多人推荐的书，《测试驱动的面向对象软件开发》（Growing Object-Oriented Software, Guided by Tests）。2020-06-02

2『已下载书籍「2020160Growing-Object-Oriented-Software」。』

为了可测试性，系统可能无形中多了很多的接口，比如数据库有 200 个表，可能会出现 200 个接口，而膨胀的接口让人看起来非常难受。这要怎么解决？作者回复：后面我们讲到封装的时候会提到，封装是基于行为的，而不是基于数据的，具体的数据表是底层实现。而测试，我们的目标应该是基于行为的。每个模块都会有一些可观察的行为，无论是通过返回值，或是通过查看的接口，这些可观察的行为就是测试的立足点。所以，你的这个问题其实更多的是思路的问题，而不是具体测试方法的问题。如果你有更具体的例子，我可以帮助你来分析一下。2020-05-31

「保证每个模块在开发阶段能够测试」，是否一定要引入测试驱动开发或者单元测试？如果对每个模块进行手工测试，或者是自动化黑盒测试呢？在瀑布开发模式，或者是普通的团队中，测试人员一般都是在整个软件基本完成之后才开始进行测试。外部测试很难在函数或者模块级别开始介入。在设计的时候，想一下这个模块要怎么测，其实就是考虑清楚这个模块要怎么调用。

之前接触过测试驱动开发，使用 Mock 框架来模拟各种外部访问资源，应该算是其中的高级技术话题。另外一个难点，是在于任务分解，所以我准备同步去学习《10X 程序员工作法》。如果没有单元测试和测试驱动开发，我觉的重构和持续集成也很难做好，主要是每次调试 bug 都需要比预计更多的时间。做软件设计的时候，考虑可测试性，其实也算是「以终为始」的一种思维方式。看了一下留言，虽然不多，但是藏龙卧虎。老师在留言里面提到做好 TDD，前提是懂一点设计。我的理解是先有 TDD，然后重构，最终得到好的设计。当然，如果有一定的经验，知道什么是好的设计，无疑可以少走一点弯路。

作者回复：可测试性和写测试，其实是两个独立的维度，首先要有可测试性，然后，再说要不要写测试。TDD 想要得到一个好的设计，前提条件是知道什么叫好的设计，所以，要先学点设计。2020-05-30

还有个问题，因为方法封装的关系，有些业务逻辑是访问级别是私有的 ，如果想在单元测试里测试这样的代码，只有暂时性的把访问级别提高到公有了吗，这个问题困扰了很久，没想到什么好的办法。作者回复：我在部落里发了一个长回答，回答这个有共性的问题，供参考。

郑烨：《软件设计之美》的的可测试性引起了一些同学更多的思考，有人关心如何测试私有方法的问题。如果顺着他们的思路想下去，确实会遇到这个问题的，但是，我们完全可以不这么想。如果我们这么思考，要提供一个类，它有哪些外在行为，这些行为应该怎样测试。如果按照这种思路想，就不会出现怎么测私有方法的问题。也许，你注意到了，这是测试驱动开发的思路，确实是这样。思考如何测试私有方法，就是一个先有代码，后写测试的思路，一定会遇到问题的。这种思路更适合对已有代码做改进。

我们再换一个角度看这个问题。之所以要牵扯私有方法的测试，一定是因为私有方法太复杂了。为什么一个类里面还会有这么复杂的私有方法呢？多半是这个类承担了过多的责任。一种思路就是根据单一职责原则，把这个类拆分了，把那个复杂的私有方法拆出来，放到另外一个类里面，这样，它就从私有方法变成了公有方法，问题就不存在了。你看，测试私有方法是一个伪命题，无论从可测试性角度看，还是从分离关注点的角度看。学习新知识，千万不要抱着自己习惯的思路不放，不要「没有困难创造，创造困难也要上」。2020-05-30

想请教老师，类似 Spring 这样的，举例子说我要测试一个业务逻辑，这个逻辑里包含了对表的操作。最好的方式是把逻辑和表操作分开测试吗，还要在测试能运行之前 Spring 要创建一堆的 Bean，如果系统规模大启动的时间就要很久，这样有简化的办法吗？作者回复：把 Spring 启动起来，这就是集成测试了，一定要把集成测试的规模缩小，多用单元测试，我在《10x 程序员工作法》里讲过了。最好的办法当然是把业务逻辑测试分开测，在第 5 讲，我们会讲到 Spring DI 容器的来源，希望你从那个部分里能够借鉴一些思路。2020-05-30

如果提成一个个的 API 后，如何测试就很好理解了，想像自己在命令窗口调用一个个 command，就是一个个 API 后执行，来 assert 返回结果就简单了。反过来其实也是在提醒我们实现功能，提接口时考虑一种最简单的通过命令行调取方式，能否实现。那么这样无论是后台执行，还是涉及界面的调用逻辑，都是可测的。作者回复：这个理解非常好！2020-05-30

现在的测试都是人工测试，造成的问题主要是频繁回归，改了代码就担心破坏了以前的功能。因为没考虑可测试性，项目里存在很多的单例。不用单例可以用什么方式呢？作者回复：后面还会提到单例，这里不妨说两句。你真的需要一个在语法上的单例吗？实际上，对于大多数系统而言，在系统内保持唯一就可以了，如果使用 DI 容器的话，缺省的对象模式就是全局唯一，所以，只要想清楚，我们需要的是什么样的单例，问题就简单了。2020-05-29

还想请教一下老师对于模块应该怎么理解？比如您给我回复的生成 pdf 的步骤里：是否把每一个步骤都作为一个模块？那是不是把内部的实现细节暴露出去了，因为对于 caller 来说，我给你数据，你帮我生成 pdf，至于你通过什么方式渲染，caller 不管也无权过问，但是如果把模块独立出去了，那是否以为着某些方法会变成 public 的？那是否说明我们把实现细节暴露出去了？

作者回复：虽然我把模块进行了分解，但并代表把细节暴露出去。你这里的 calller，它面对的还是同样的一个接口，只不过，在内部被分成了多个可以组合的模块。Caller 并不知道里面是由哪些模块组成的，以及如何组成的，这怎么算暴露细节呢？单独拆分出来的模块的方法确实要变成 public，但它们作为一个独立的模块，提供一个完成特定功能的方法，所以，有一个 public 的方法是很正常的。这里的关键点在于，什么叫把细节暴露出去，这个暴露到底是针对谁而言的。这是需要回答的问题。在没有分离关注点的时候，它是一个方法内部的细节，在分离关注点之后，它就不再是一个方法内部了，每个模块都是一个独立的模块。你怎么判断它是不是暴露细节呢？这是一个需要想清楚的问题。2020-05-29

## 0004. 结束语｜那些没讲的事儿

学习了两个专栏的小伙伴对我的风格可能有一些了解，我总是试图把尽可能多的知识以结构化的方式呈现在你面前。因为，就我自己的学习而言，我也总是可以很快学会细节的东西，但知识结构却不是一朝一夕就可以建立的。我曾把《10x 程序员工作法》比作藏经阁的目录，因为它是我已经结构化了的软件开发的各种最佳实践，而《软件设计之美》则是我构建软件设计知识大厦的一种尝试。我总是努力提供尽可能大的知识密度，保证看到这些内容的你，在学了我的专栏之后，还可以有继续扩展学习的空间。但是，在这个专栏中，虽然我把软件设计相关的核心知识都讲了一遍，可还有一些内容是我没有在专栏中呈现出来的。那么，在这个专栏的结束语中，我们就来说说那些没讲的事儿。

### 4.1 设计需要沟通

你能感受到，我在这个专栏里给你讲的大部分内容都是技术性的，然而，在真实的软件开发过程中，软件设计工作有很大一部分内容却是非技术性的，比如，沟通。也许你会觉得，设计不就是改改代码吗，跟沟通有什么关系啊？

我在专栏之初就说过，软件设计是要构建模型，打造规范。但是那时候，我没说的是，模型的理解需要沟通，规范的执行同样也需要沟通。因为无论是模型还是规范，软件设计最终是要落实到代码上的。具体落实成什么样，是依赖于人的，依赖于人的理解和人的执行。那如何才能让人的理解达成一致？唯有不断反复地沟通。

为什么有些人并不觉得沟通很重要，或许只是因为他们所做的工作是局部代码的调整，涉及到人的比较少，沟通的重要性没有那么凸显。但只要我们在成长，我们负责的模块规模就会变大，牵扯到的人就会增多。如果你想要让其他人能够理解你的设计，就需要靠沟通了。

我们都知道，好的设计一定是易于理解的，而这个理解指的就是别人如何理解。所以，一个好的设计只做到自己心知肚明是不够的，酒香也怕巷子深。一个好的设计是需要讲给别人、取得别人认同的。虽然我们说，条条大路通罗马，达到同一个目标的路径有很多，设计没有一条标准的路径。可是，当人数多起来，思想不一致几乎是一种必然。所以，只有通过沟通，我们才有可能让大家对某一种路径达成一致。

这样的话，设计才能保持一致，否则，你写结构化编程的 for 循环，我写函数式编程的 map、reduce；你留扩展点，我来硬编码，代码就注定是无法维护的。不过，如果我把沟通放在软件设计的课表上，估计很多人看到课表就直接放弃了。因为沟通这件事太不够「硬核」。而我在《10x 程序员工作法》中，把沟通反馈作为了一项重要的工作原则。后来，我从同学们的反馈中也看出，沟通确实是程序员成长过程中一个重要的阻碍。

其实，在软件设计中，确实有一个工具是关于沟通的，那就是 UML，叫作统一建模语言。不过，现在很多程序员更习惯随手画个图，因为这种表达方式更简单，这让 UML 的用武之地就少了许多。所以，有空的时候，我还是建议你去了解一下 UML，至少你要知道有几种类型的图。这样，以后你在随手画图时，不至于把静态结构和动态交互画在一起。

很多程序员会习惯性地把自己的职业只当作一个技术工种，认为只要技术足够深厚，便能够通行天下。但实际上，只要我们是在一个组织中工作，沟通能力就是非常重要的，而且，随着职位的上升，沟通能力的重要性会越发显现。所以，如果你在实际工作中发现别人很难理解你的美妙设计，一种可能是你的设计没有你以为的那么好；而另一种可能就是，你的沟通还不够好，其他人并没有理解你。

### 4.2 经验的积累

关于软件设计，我还有一件事是没法教给你的，那就是经验的积累。如果你有机会和我一起写代码，我可能会在一些地方要求你去增加一些类、把类写小；在另外一些地方要求你把一些类合并、减少类的数量；有时候，我还会告诉你这个地方要留一个扩展点，把变化隔离开来；还有的时候，我会让你别考虑扩展，先把功能实现了。

你可能会困惑，这里的一对对操作完全是相反的，到底哪个才是软件设计该做的呢？但是，如果你和我在一起工作，有了相应的上下文，你就会理解这些要求的合理之处。所以说，即便我们掌握了相同的软件设计知识，但是在一个具体的场景下，该做怎样的判断、如何作出判断，都是需要我们经验积累的。

软件设计的基础，无论是设计模式，还是设计微调的技巧，你都可以通过课程去学习，甚至可以通过短期的训练营去锻炼。但是，如果你想要把这些内容熟练地运用到实际的工作中，那就需要你有大量经验的积累，需要你经历或者见过许多不同的使用场景。不过，一切经验积累的前提条件是，先有软件设计的意识。

对于大多数人而言，软件设计是知与不知的差别。知道的人就会有意识地积累经验，而不知道的人即使做过再多的项目，也无非是不断地在重复增删改查。《软件设计之美》这个专栏首先帮助你解决了知的问题，只有知道了，你才能开启积累的道路，踏上个体成长的阶梯。

我在专栏中反复在说，软件设计关注的是长期变化。可是，实际上，没有任何一个专栏或是一个训练营可以让你真正地感受到一个软件的长期变化，唯有真实的项目可以。每当来了一个新的需求，我们就会有一个对应的解决方案。但是，我们最好先问自己一个问题，这种实现方案是不是一个好的设计呢？这么做就可以给自己的直觉思维加上一个缓冲。

普通程序员和高手之间的差别就在于此，普通程序员凭直觉做事，高手却是把专业的做法训练成直觉。所以，你能看到很多人在不经意间写出的代码就非常漂亮，而漂亮的背后，其实是一次又一次的思考和训练。我有幸在职业生涯之初就接触了软件设计，当时我所在的部门正面临着对系统的调整，所以，当时的技术负责人每天研读《设计模式》，然后就在部门里做分享，分享他的读书心得。虽然我当时还不能完全理解他在说什么，但本着对他的信任，我整个过程都听得很认真。我竟然从中听出了一些美感，我发觉软件设计是个好东西，这种印象深深地印在了我的脑海中。

从那之后，我也会有意识地去找设计的书去读，会有意识地去反复思考设计的优劣。我经常问自己的一个问题就是，如果我把这段代码重写一遍，我该怎么做。久而久之，我几乎每次都能发现自己代码写得不够好的地方，找到那些值得改进的地方。也正是因为这样，我的代码风格每隔一段时间，就会发生一些变化。尽管在外人眼中，我实现的功能都是差不多的功能。但我知道，它的设计已经变得更好了。因为它更容易测试了，也更容易扩展了。

对于一个好程序员来说，品味是尤为重要的。要想有一个好的品味，就一定要见过好东西。遗憾的是，大多数人在日常工作见到的代码都很难称得上有品味，唯一的优点就是可以运行。所以，我们要多向好的开源项目学习，这是一种帮助我们打破限制的好方法。

开源项目有很多，但是很多人的关注点一般都是这些项目如何实现了一个功能，却少有人关注它的设计，这会让我们错过很多风景。我们可以先从一些不那么复杂的项目入手，关注它的设计。

如果让我推荐，我会推荐我熟悉的，而且让我能从中感受到美感的几个项目：1）Moco；2）Google Guava；3）Spring 系列的项目。

编写代码也是一门手艺，手艺是要不断打磨锤炼的。鸟巢的每个焊接处都镌刻着焊工的名字，因为主事者希望记录下来他们对这件历史工程做出的贡献。程序员的工作天生也会被源码控制工具记录下来。所以，作为一个程序员，我希望自己写下的代码能成为自己的骄傲，而不是别人的槽点。唯有不断精进的手艺才能成为我们努力过的证明。

结束了吗？丘吉尔在阿拉曼战役庆功宴上发表的演讲中，说过这样一段话：这不是结束，甚至不是结束的开始，而可能是开始的结束。（Now this is not the end. It is not even the beginning of the end. But it is perhaps the end of the beginning.）

没错，我想说的是，这个专栏只是你学习软件开始的结束。《软件设计之美》这个专栏只是帮助你开启了软件设计的大门，但能真正让软件设计成为自己的一部分，对每个人来说，都有很长的路要走。即便我写程序已经二十多年了，我依然不敢说，自己的程序已经写到无懈可击的地步，偶尔的新需求依然会让我陷入思索。

我对《软件设计之美》的预期，就是我可以把我体验到的思考乐趣告诉你，让你产生对于软件设计的兴趣。如果你希望学了这个专栏之后，还能更进一步地学习，不妨找一找我在专栏中推荐的书，几乎每一本都值得你去深入学习，而这个专栏已经给了你一张地图，保证你不会在茂盛的软件设计丛林中迷失。与此同时，我也知道，《软件设计之美》在给你开启了新的知识大门之后，也让你产生了许多困惑。不要紧，即便这个专栏结束了，并不等于我为大家的服务结束了，你依然可以在专栏里留言提问，我会努力回复你的留言。

## 0500. 设计方法

1、建立一套业务人员和开发人员共享的通用语言。

2、战略设计，就是将不同的模型进行分组。

3、战术设计，就是按照模板寻找相应的模型。

## 0501. 领域驱动设计：如何从零开始设计一个软件？

我们讲了领域驱动设计，这是目前在软件行业内最符合软件发展趋势的一种设计方法，因为它把软件设计的起始点从技术拉到了业务。学习领域驱动设计，我们要从通用语言和模型驱动设计入手。通用语言是在业务人员和技术人员之间建立一套共有的语言，开发通用语言的一种实践是事件风暴，这是一种工作坊，通过识别领域事件找到引发事件的命令，找出与事件和命令相关的实体或聚合，帮助团队建立通用语言。DDD 的模型设计可以分为战略设计和战术设计。战略设计是高层设计，将系统拆分成领域，战术设计是低层设计，考虑如何组织不同的模型。

1『事件与命令相关的实体和聚合；战略设计将系统拆分成领域、战术设计考虑如何组织不同的模型。』

在前面的内容中，我给你讲了软件设计的各种基本工具。我们学习了程序设计语言，知道怎样把设计更好地落地；学会了各种编程范式，知道了可以用什么样的元素去做设计；我们还学习了设计原则与模式，知道了怎样组合分解出来的各个元素。工具都有了，理论也武装上了，那么我们该如何实践呢？或者说，我要去分解组合的东西是从哪而来的呢？这就需要你对设计方法有一个基本的认知了，也就是说，我们要理解，在真实世界中，解决具体问题是怎样的一个过程。那从这一讲开始，我们就来谈谈设计方法的话题，一起了解一下设计的基本过程。

首先，你知道哪些设计方法呢？我知道的一种做法是，有些人一上来会先设计数据库，因为他们觉得，程序就是数据加函数。数据呢，就要存到数据库里，剩下的就是根据需要对数据库表进行增删改查。但是从我们之前的讲解中，你可以看出，这种思路实际上是一种结构化编程的思路。

后来有人就用面向对象的思路，先来找实体，也就是对象，当然这些实体也要有一些能力。最终，这些对象还是要写到数据库里，同样也是要提供增删改查的能力。你看，这两种做法本质上没什么太大的区别，都是围绕着数据在做文章。在业务需求不复杂的年代，围绕数据做文章的做法还能满足开发的要求，但随着软件日益深入到人们日常工作和生活中，软件变得越来越复杂，这种做法就越发显得笨拙了。

对，软件会越来越复杂的。当软件变得复杂起来，如果我们靠着程序员们本能的做法，就会遇到各种问题，所以，很多人探索了不同的做法。在诸多的探索之中，有一种做法逐渐脱颖而出，它成功地解决业务软件开发中遇到的大部分问题，这就是领域驱动设计。虽然它不是万能药，但对大部分人面对的场景而言，它都能够有效地应对。

### 1.1 领域驱动设计

领域驱动设计（Domain Driven Design，简称 DDD），作为一个新的设计方法正式登上历史舞台，是从 Eric Evans 的著作《领域驱动设计》正式出版开始的。这种设计方法通过使用通用语言，让业务人员加入到设计过程中，拉近了业务人员与开发人员之间的距离，打破了组织的藩篱。同时，还提供了一套标准的建模方法，帮助团队识别业务模型，避免程序员犯下一些低级错误。

按理说，这种设计方法这么好，应该很快流行起来才对。然而真实情况是，很多程序员都不知道 DDD，一个重要的原因就是 Eric 的这本书写得实在不怎么样。要想从中读出味道，你得比较懂 DDD，但是，大多数人并不懂，这就是矛盾的地方。所以，DDD 在很长一段时间都被埋没了。

不过，后来，随着微服务的兴起，人们越发认识到，微服务的难度并不在于将一个系统拆分成若干的服务，而在于如何有效地划分微服务。这个时候，人们发现，DDD 才是最恰当的指引。关于微服务和 DDD 之间的关系，我在《10x 程序员工作法》里已经讲过了，有兴趣的可以去了解一下，这里就不再赘述了。

现在，你已经知道了 DDD 的好，准备学习 DDD 了。但你只要一打开 DDD 的书，一大堆名词就会扑面而来：限界上下文、聚合根、实体、值对象，等等。我该如何下手学习呢？这是摆在每个 DDD 学习者面前最严峻的问题。学习 DDD，就要从理解 DDD 的根基入手：通用语言（Ubiquitous Language）和模型驱动的设计（Model-Driven Design），而领域驱动设计的过程，就是建立起通用语言和识别模型的过程。

### 1.2 通用语言

通用语言，就是在业务人员和开发人员之间建立起的一套共有的语言。要知道，在从前的设计方法中，业务人员总是把问题扔过墙头，让开发人员去解决。可是，业务人员说的都是业务名词，比如：产品、订单等等，而开发人员嘴里全是技术，比如：线程、存储等等，二者除了最基础的几个概念之外，其他的内容基本是没法沟通的。所以，一道人为鸿沟就在开发人员和业务人员之间形成了。

我们在第 1 讲说过，软件设计是要在问题和解决方案架设一座桥梁，好的设计要更接近问题。开发人员对解决方案一端简直再熟悉不过了，但是对业务一端理解则通常不够充分。而通用语言所做的事情，就是把开发人员的思考起点拉到了业务上，也就是从问题出发，这就在一定程度上填平了那道人为的鸿沟。

通用语言是什么呢？就是这个业务中有哪些概念以及哪些操作。比如说，我要做一个电商平台，就要有产品、订单的概念。其中，产品就要有上架、下架、修改产品信息等操作，而订单就会有下单、撤单、修改订单等操作。在业务人员看来，这里说的都是自己擅长的事情，自己就可以有更多的发言权。在开发人员的视角，概念就是一个一个的类，操作就是一个一个的方法，也很好理解。所以，有一套通用语言，双方皆大欢喜。

但是，通用语言是从哪来的呢？也就是说，如何设计通用语言呢？最简单的做法就是让业务人员和开发人员一起，找一块白板，把各种概念都写在上面。然后，双方重新进行分类整理。这里面的重点是，让业务人员和开发人员在一起。如果只让一方出现，结果又会是原来的样子，因为你没法判断，这里面的语言对方是否听得懂。

这种做法很简单，但通常都不够系统，会存在各种遗漏。所以，有人探索出一种更正式的实践：事件风暴（Event Stroming）。事件风暴是一个工作坊，基本做法就是找一面很宽的墙，上面铺上大白纸，然后，用便利贴把识别出来的概念贴在上面。当然，前提依然是让业务人员和技术人员都参与其中。

3『事件风暴学习：[EventStorming](https://www.eventstorming.com/)。』

2『单元里发起一场事件风暴，先把一些概念给大家介绍，然后实操。』

这个实践之所以叫作事件风暴，因为它的关注点在于领域事件。领域事件是用来记录业务过程中发生过的重要事情，比如，作为电商平台的工作人员，你想知道产品是不是已经上架了，这个领域事件就是产品已上架；作为消费者，你会关心我的订单是不是下成功了，这个领域事件就是订单已下。人们做了一个动作，都会关心做过这个动作之后的结果，所以，领域事件用的描述方式都是过去式，比如：OrderPlaced。

1『这里的举的几个领域事件的例子很直观，「产品已上架」和「订单已下」。』

事件风暴这个工作坊主要分成三步：1）第一步就是把领域事件识别出来，这个系统有哪些是人们关心的结果。有了领域事件，下面一个问题是，这些事件是如何产生的，它必然会是某个动作的结果。2）第二步就是找出这些动作，也就是引发领域事件的命令。比如：产品已上架是由产品上架这个动作引发的，而订单已下就是由下单这个命令引发的。3）第三步就是找出与事件和命令相关的实体或聚合，比如，产品上架就需要有个产品（Product），下单就需要有订单（Order）。

至此，我们已经把最核心的内容找出来了。通常，在工作坊过程中，为了增强趣味性和清晰性，不同的概念会用不同的颜色的便利贴标识出来，比如，领域事件用橙色、命令用蓝色、实体 / 聚合用黄色等等。

其实，用不同的颜色建模，事件风暴并不是独一份。Peter Coad 也曾提出过一种四色建模的方法：1）粉色表示时标性对象（moment-interval）；2）黄色表示角色（role）；3）蓝色表示描述（description）；4）绿色表示人、地点、物（party/place/thing）。他还写了一本《彩色 UML 建模》（Java Modeling in Color with UML）介绍这种方法。我在 ThoughtWorks 的前同事徐昊按照自己的理解，对这种方法做了一些更新，有兴趣的话，可以去了解一下。

2『上面的书去下载一下：[彩色UML建模（豆瓣）](https://book.douban.com/subject/3354137/)；上面的文章页消化吸收并作为附件。』

3『[运用四色建模法进行领域分析 - InfoQ](https://www.infoq.cn/article/xh-four-color-modeling)

』

当然，这里的事件风暴，我只是描述了最简单的一个过程。在具体实施的过程中，还会有更多的细节。不过，最重要的还是，让不同角色的参与其中，让知识在所有人的头脑中进行构建，得到一个大家都认同的结果。

### 1.3 模型驱动设计

有了通用语言，接下来就进入模型设计阶段了。虽然有了通用语言，但是业务人员能够帮到开发人员的还是很少，他们只能告诉开发人员哪些模型是符合业务概念的。但这么多的业务模型，该如何组织呢？怎样补全欠缺的模型，使之成为一个可以落地的方案呢？这就是开发人员要想办法解决的事情了。也正是因为在通常情况下，业务模型数量众多，所以在 DDD 的过程中，我们将设计分成了两个阶段：战略设计（Strategic Design）和战术设计（Tactical Design）。

战略设计是高层设计，是指将系统拆分成不同的领域。而领域驱动设计，核心的概念就是领域，也就是说，它给了我们一个拆分系统的新视角：按业务领域拆分。比如，我把一个电商系统拆分成产品域、订单域、支付域、物流域等。拆分成领域之后，我们识别出来的各种业务对象就会归结到各个领域之中。然而，有时候，不同领域的业务对象会进行交互，比如，我要知道自己订单的物流情况。所以，要在不同的领域之间设计一些交互的方式。

而战术设计是低层设计，也就是如何具体地组织不同的业务模型。在这个层次上，DDD 给我们提供了一些标准的做法供我们参考。比如，哪种模型应该设计成实体，哪些应该设计成值对象。我们还要考虑模型之间是什么样的关系，比如，哪些模型要一起使用，可以成为一个聚合。接下来，我们还需要考虑这些模型从哪来、怎样演变，DDD 同样为我们提供了一些标准的设计概念，比如仓库、服务等等。

通过战略设计和战术设计，我们就可以把发现出来的不同业务概念各归其位了。

### 黑板墙

最后，我想请你分享一下，你们在实际工作中是如何与业务人员沟通的？

领域驱动设计可以和传统的面向数据库设计的方式结合吗，比如引入一个 model 模块用来聚合模型。作者回复：先按照一个思路走，否则，你会回到老路上去的。2020-07-29

郑老师说了实话，《领域驱动设计》这本书一般人真是读不下去，应该耽误了不少人学习 DDD。但是说实话，DDD 真是太难学了，能把 DDD 在公司里运用起来，特别是战略设计，几乎就是一个组织变革，需要有同时能够影响业务合作又能引导事件风暴这个高难度的工作坊的人才。虽然像 TW 这样的公司已经在努力推广这种设计方法了，极客时间也开了《DDD 实战课》，但是，很多公司离这个设计方法还是很远的。DDD 之后如何发展，郑老师怎么看？作者回复：DDD 其实不是难，而是概念多，缺乏一个结构理解它。另外，很多人欠缺的不是 DDD，而是设计的基础知识。这就是我在做的尝试，先铺垫设计的基础知识，然后，再讲 DDD，用一个结构化的方式帮你把 DDD 串起来。真正的难点是结合实际工作，把 DDD 完整地走一遍，看到代码就理解了。退一步，可以去看《实现领域驱动设计》的源码。2020-08-01

实体：在时间上有连续性，并且有唯一标识可以来区分的对象，具有生命周期和行为。值对象：用来描述事物的，不区分谁是谁的，不可变的对象，不具有生命周期和行为。2020-07-31

领域事件风暴，使用的是事件，动作，实体，建立基本业务模型，我认为这是时序图、状态图的另外一种表达，战略设计，很像业务架构设计，按照领域职责去划分。建立一个好的平台，需要做好职责划分，配置团队，要不就是无尽的折磨。作者回复：这个理解的角度是在新事物和已有知识建立起连接的角度，很有趣。2020-07-30

数据加函数用了好多年，现在终于想通了为啥 EF 有种 codefirst 编程模式，因为别人早就想通了面向对象编程！！！2020-07-29

各自阐述理解；消除分歧；达成共识。作者回复：总结得好。2020-07-29

## 0502. 战略设计：如何划分系统的模块？

我们主要讲了 DDD 中的战略设计。战略设计中的概念主要是为了做业务的划分和落地成解决方案。首先业务的划分，我们要把识别出来的模型做一个分类，把它们放置到不同的子域中。划分子域的出发点就是不同的关注点，也就是不同的变化来源。划分出来的子域有着不同的重要程度，我们将它们再分为核心域、支撑域和通用域。做出这种区分，主要是为了针对它们各自的特点，决定不同的投入。

3『书籍领域驱动设计精粹「DDDD」里有提到，尽量保证一个限界上下文里就只有一个子域。』

有了不同的领域划分，我们还要把这些领域映射到解决方案上，这就引出了限界上下文。限界上下文限定了模型的使用边界，它可以成为一个独立的系统。如果对应到微服务中，每一个限界上下文可以对应成一个微服务。上下文映射图定义了不同上下文之间的交互方式，如果你只能记住一种交互方式的话，就应该记住防腐层。

1『限界上下文限定了模型的使用边界，其可以作为一个独立的系统，每一个限界上下文对应于一个微服务。』

按照我们之前介绍的了解软件设计的思路，建立起通用语言之后，我们就找到了主要的模型，通过战略设计，我们可以把识别出来的模型放到不同的限界上下文中，就相当于把模型做了分组。然后，我们需要定义出一些接口，让不同的模型之间可以交互，我们也就有了一张上下文映射图。

1『上面这段话，反复去品。（2020-08-03）』

这样一来，我们就把之前学习的知识和新的知识建立起了连接。我们有了模型，有了接口，接下来就该深入到实现中。下一讲，我们就要进一步了解 DDD 的实现：战术设计。如果今天的内容你只能记住一件事，那请记住：战略设计，就是将不同的模型进行分组。

上一讲，我们已经初步认识了 DDD ，知道了支撑 DDD 最核心的就是通用语言和模型驱动设计的方法。我们在上一讲已经讲了建立通用语言的方法，接下来，就该进行模型的设计了。在模型设计中，DDD 又分成了两个阶段，战略设计和战术设计。这一讲，我们先来聊聊战略设计，下一讲再来谈战术设计。

1『原来战略设计和战术设计都是为了「构建模型」的，两者是模型设计的 2 个阶段。醍醐灌顶。（2020-08-03）』

战略设计，这个名字听上去有点高大上。而且，战略设计包含很多的概念，比如，子域、限界上下文和上下文映射图等等。这让很多人有些望而却步。虽然概念看似很多，但只要有一条主线将它们贯穿起来，这些概念也不难理解。

我们可以先把这些概念做一个划分，分为做业务的划分和落地成解决方案两个部分，也就是说，战略设计中的概念，一部分是为了将不同的业务区分开来，也就是要将识别出来的业务概念做一个划分，另一部分则是将划分出来的业务落实到真实的解决方案中。好，我们接下来就先来看看战略设计中的这些概念到底是怎么回事。

1『理解战略设计的一条主线：划分业务和实现解决方案。』

### 2.1 业务概念的划分

我们前面说过，软件开发就是在解决问题，所以，一方面，我们要知道要解决的问题是什么；另一方面，我们要知道怎么去解决问题。

我们要解决的问题就是领域问题，在 DDD 中，有几个概念是与领域相关的，比如，子域、核心域、支撑域、通用域等。其实，它们说的都是一件事，就是如何先把问题从大面上进行分解。

领域驱动设计这个名字里面，排在第一位的是领域（Domain），它就对应着要解决的问题。正如我们一直说的，软件开发是解决问题，而解决问题要分而治之。所谓分而治之，就是要把问题分解了，对应到领域驱动设计中，就是要把一个大领域分解成若干的小领域，而这个分解出来的小领域就是子域（Subdomain）。

1-2『原来「领域」对应于要解决的问题，这里提到的大领域、小领域算法把之前的困惑解答了。领域的概念做一张术语卡片。』

我们在上一讲中说，领域驱动设计首先要建立起一套通用语言，这样一来，我们就拥有了各种各样的词汇，它们对应着模型。接下来，我们就要给这些词汇做个分类，而分类就是要把它们划分到不同的子域中去。这里面的关键就在于，要找出不同的关注点。没错，还是分离关注点。

比如，我要做一个项目管理软件，就需要有用户、有项目、有团队，不同的人还要扮演不同的角色。第一步，我们至少可以先把身份管理和项目管理这两件事分开，因为它们的关注点是不同的。身份管理关注的是用户的身份信息，诸如用户名密码之类的，而项目管理关注的重点是项目和团队之类的。所以，我们这里有了两个子域：身份管理和项目管理。

1『身份管理和项目管理 2 个子域，正好数据流开发的时候可以用到。』

如果直接给你看结果，你可能会觉得很好理解。但是，划分出不同的子域还是比较容易出问题的，因为有一些概念并不容易区分。比如，用户应该怎么划分呢？放在身份管理是合适的，但项目管理也要用到用户。

幸好，我们已经学习了单一职责原则，它给了我们一个重要的思考维度，变化从何而来。不同角色的人会关注不同的变化，所以，我们知道虽然我们用的词都是「用户」，但我们想表达的含义却是不同的，我们最好将这些不同的含义分开，也就是将不同的角色分开。比如，在身份管理中，它是「用户」，而在项目管理中，它就成了「项目成员」。所以，我们划分子域实际上就是在把不同的概念区分开来，让它们各归其位。

对于一个真实项目而言，划分出来的子域可能会有很多，但并非每个子域都一样重要。所以，我们还要把划分出来的子域再做一下区分，分成核心域（Core Domain）、支撑域（Supporting Subdomain）和通用域（Generic Subdomain）。

核心域是整个系统最重要的部分，是整个业务得以成功的关键。关于核心域，Eric Evans 曾提出过几个问题，帮我们识别核心域：1）为什么这个系统值得写？2）为什么不直接买一个？3）为什么不外包？如果你对这几个问题的回答能够帮你找到这个系统非写不可的理由，那它就是你的核心域。

什么是支撑域呢？有一些子域不是你的核心竞争力，但却是系统不得不做的东西，市场上也找不到一个现成的方案，这种子域就是支撑域。比如，我们要做一个排行榜功能，可能根据各种信息做排名，这种东西没有人会按照你的需要做出一个，对你来说，又是扩展自己系统的重要一步，它就是一个支撑域。还有一种子域叫通用域，就是行业里通常都是这么做，即便不自己做，也并不影响你的业务运行。比如，很多 App 要给用户发通知，这样的功能完全可以买一个服务来做，丝毫不影响你的业务运行。它就是一个通用域。

我们之所以要区分不同的子域，关键的原因就在于，我们可以决定不同的投资策略。核心域要全力投入，支撑域次之，通用域甚至可以花钱买服务。

### 2.2 业务概念的落地

通过划分子域，区分核心域、支撑域和通用域，我们把 DDD 在问题层面的概念已经说清楚了。接下来，就要进入到解决方案层面了。

我们现在有了切分出来的子域，怎样去落实到代码上呢？首先要解决的就是这些子域如何组织的问题，是写一个程序把所有子域都放在里面呢，还是每个子域做一个独立的应用，抑或是有一些在一起，有一些分开。这就引出了领域驱动设计中的一个重要的概念，限界上下文（Bounded Context）。

限界上下文，顾名思义，它形成了一个边界，一个限定了通用语言自由使用的边界，一旦出界，含义便无法保证。比如，同样是说「订单」，如果不加限制，你很难区分它是用在哪种场景之下。而一旦定义了限界上下文，那交易上下文的「订单」和物流上下文的「订单」肯定是不同的。原因就在于，订单这个说法，在不同的边界内，含义是不一样的。

1『上面的例子又是值得反复品。「订单」这个对象，必须在特定的限界上下文里。反过来看，如果之前划分好的限界上下文里冒出来两个同样名称但观念不同的对象，那么其中一个必定不属于这个限界上下文。』

注意，子域和限界上下文不一定是一一对应的，可能在一个限界上下文中包含了多个子域，也可能在一个子域横跨了多个限界上下文。

1『哈哈，很有价值的信息。可能在一个限界上下文中包含了多个子域，也可能在一个子域横跨了多个限界上下文。再次强调一下，书籍领域驱动设计精粹「DDDD」里有提到，尽量保证一个限界上下文里就只有一个子域。这两个观点应该是根据不同的上下文场景给出的建议，因开发中没有遇到相应的场景，目前还无法理解透彻。（2020-08-05）』

前面我们说了限界上下文是在解决方案层面的，所以，很自然地，我们就可以把限界上下文看作是一个独立的系统。很多团队做微服务的时候，最纠结的问题就是如何划分服务边界，而限界上下文的出现刚好与微服务的理念契合，每个限界上下文都可以成为一个独立的服务。限界上下文的重点在于，它是完全独立的，不会为了完成一个业务需求要跑到其他服务中去做很多事，而这恰恰是很多微服务出问题的点，比如，一个业务功能要调用很多其他系统的功能。

有了对限界上下文的理解，我们就可以把整个业务分解到不同的限界上下文中，但是，尽管我们拆分了系统，它们终究还是一个系统，免不了彼此之间要有交互。比如，一个用户下了订单，这是在订单上下文中完成的。那接下来，用户要去支付，这是在支付上下文中完成的。我们肯定要通过某种途径让订单上下文的一些信息发送到支付上下文里的。

所以，我们就要有一种描述方式，将不同限界上下文之间交互的方式描述出来，这就是上下文映射图（Context Map）。DDD 给我们提供了一些描述这种交互的方式，比如：1）合作关系（Partnership）；2）共享内核（Shared Kernel）；3）客户 - 供应商（Customer-Supplier）；4）跟随者（Conformist）；5）防腐层（Anticorruption Layer）；6）开放主机服务（Open Host Service）；7）发布语言（Published Language）；8）各行其道（Separate Ways）；9）大泥球（Big Ball of Mud）。

之所以有这么多不同的交互方式，主要是为了让你在头脑中仔细辨认一下，看看限界上下文之间到底在以怎样的方式进行交互。当然这么多交互方式，想一次性记住也是不现实的，有些甚至是你要规避的，比如大泥球。如果说这么多交互方式你必须要记住一个的话，那就是防腐层（Anticorruption Layer）。

防腐层是最具防御性的一种关系，简言之，就是指我们要在外部模型和内部模型之间建立起一个翻译层，将外部模型转化为内部模型。我在第 1 讲给你讲了一个因为没有建立防腐造成的问题。所以，但凡有可能，就要建立防腐层，将外部模型完全隔离开。

当我们知道了不同的限界上下文之间采用哪种交互方式之后，不同的交互方式就可以落地为不同的协议。现在最常用的几种协议有 REST API、RPC 或是消息队列，我们可以根据实际情况进行选择。在我们定义好不同的限界上下文，将它们之间的交互呈现出来之后，我们就得到了一张上下文映射图（Context Map）。上下文映射图是可以，而这往往是很多团队欠缺的。

1『不同限界上下文之间的映射关系落地为不同的协议，几个最常见的协议有：REST API、RPC 或是消息队列。』

### 黑板墙

想听郑老师讲讲更简便一些的模型设计方法，例如，四色建模法，我不知道是不是？作者回复：四色建模并不是简便，从完整性的角度，它不如DDD。想了解四色建模，你可以去看看我推荐的那本书和那篇文章。2020-08-01

有一点不太明白，在不同边界上下文交互过程中，防腐层是封装了具体的远程调用协议和将外部数据进行格式装换？作者回复：交互方式和数据协议，都可以通过防腐层处理掉。2020-07-31

通用语言、战略设计、战术设计，好似一个三部曲，从上层到下层，层层细化和分解。感觉通用语言和战略设计对于接触和使用不久的新人是要不断踩坑的，希望郑老师能分析一些过去很多年的一些详细的实际案例，理论结合实际，更能体会其中的奥妙。作者回复：讲设计，困难的一点就在于背景太多，要想理解一个设计，通常要先理解背景。讲太细了，就会牵扯到很多具体的业务，怕透露太多。选择什么粒度的内容其实我也一直比较纠结。2020-08-03

一套微服务里有一个服务专门负责操作数据库同时又带有业务。其他系统需要发送 RPC 请求调用该系统完成数据库操作。请问老实这样合理吗？作者回复：听上去不太合理，各个服务都应该是一个完整独立的。这种把所有的入库都放在一起的操作，为啥还要做微服务呢？2020-07-31

1『郑烨的思维导图用的 Xmind。』

## 0503. 战术设计：如何像写故事一样找出模型？

今天，我们讲了 DDD 中的战术设计，我们把战术设计当作了一个故事模板。让你先去识别角色，也就是找到实体和值对象。一个简单的区分就是，能通过唯一标识符识别出来的就是实体，只能通过字段组合才能识别出来的是值对象。然后我们应该找到角色之间的关系，也就是聚合。操作聚合关键点在于找到聚合根。当聚合根不存在时，聚合中的对象也就不再有价值了。有了角色及其关系，接下来就是找到各种动词，让故事生动起来。这里，我们讲到了动作，也就是领域服务，以及动作的结果，也就是领域事件，还有创建对象的工厂和保存对象的仓库。这些内容构成了我们最核心的业务逻辑。一些额外的工作，我们可以放到外围来做，这就是应用服务。

通过这几讲关于 DDD 的学习，你知道了如何识别出各种对象。通过前面设计原则、设计模式的讲解，你知道了如何组织这些对象。至此，我已经把设计相关的主要知识给你讲过一遍了，你现在应该知道如何做设计了。那现在我们已经有了这样的基础，我们就可以做自己的设计了。从下一讲开始，我们就来体验一下，如何在真实的项目中做设计。如果今天的内容你只能记住一件事，那请记住：战术设计，就是按照模板寻找相应的模型。

在上一讲中，我们讲了 DDD 中的战略设计，学习如何将识别出来的不同模型放到不同的限界上下文中。那么，接下来，我们就该做更具体的工作了，也就是如何设计模型。在 DDD 中，把具体的模型找出来的做法有一个更响亮的名字：战术设计。

战术设计同样也包含了很多概念，比如，实体、值对象、聚合、领域服务、应用服务等等。有这么多概念，我们该如何区分和理解他们呢？我们同样需要一根主线。其实，我们可以把战术设计理解成写一个故事。你知道怎样去写个故事吗？写故事通常都是有一定套路的。我们要先构建好故事的背景，然后，要设定不同的角色，接下来，创建角色之间的关系，最后，我们要安排人物之间互动起来，形成故事。

1『理解战术设计的主线：写一个故事。』

对于战术设计而言，故事的背景就是我们面对的领域问题，剩下的就是我们在这个故事背景下，要找出不同的角色，找出角色之间的关系，让它们互动起来，这样，我们就有了故事，也完成了战术设计。接下来，我们就来看看，战术设计这个故事模板，我们应该怎么填？

### 3.1 角色：实体、值对象

我们的首要任务就是设计角色，在战术设计中，我们的角色就是各种名词。我们在初学面向对象的时候，课本上的内容就告诉我们要识别出一个一个的模型，其实，就是让我们识别名词。识别名词也是很多人对于面向对象的直觉反应。有一些设计方法会先建立数据库表，这种做法本质上也是从识别名词入手的。我们在战术设计中，要识别的名词包括了实体和值对象。

什么是实体呢？实体（Entity）指的是能够通过唯一标识符标识出来的对象。我们都知道，在业务处理中，有一类对象会有一定的生命周期。我以电商平台上的订单为例，它会在一次交易的过程中存在，而在它的生命周期中，它的一些属性可能会有变化，比如说，订单的状态刚开始是下单完成，然后在支付之后，变成了已支付，在发货之后就变成了已发货。

但是这个订单始终都是这个订单，因为这个订单有唯一的标识符，也就是订单号，订单号作为它的标识符能将它标识出来。你可以通过订单号查询它的状态，可以修改订单的一些信息，比如，配送的地址。像这种通过唯一标识符标识出来的对象，就是实体。其实，大多数程序员对于实体并不陌生，因为在各种设计方法中，都有相应的方法识别实体。你甚至可以简单粗暴地将它理解成数据库里存储的对象，虽然这种理解并不完全正确。

还有一类对象称为值对象，它就表示一个值。比如，订单地址，它是由省、市、区和具体住址组成。它同实体的差别在于，它没有标识符。之所以它叫值对象，是因为它表现得像一个值。值对象可能会有很多属性，而要想判断值对象是否相等，我们就要判断这些属性是否相等。对于两个订单地址来说，只有省、市、区和具体住址等多个属性都相同，我们才认为它们是同一个地址。

实体的属性是可以变的，只要标识符不变，它就还是那个实体。但是，值对象的属性却不能变，一旦变了，它就不再是那个对象，所以，我们会把值对象设置成一个不变的对象。在前面讲函数式编程的不变性时，我给你介绍了不变性的诸多好处，这里也完全适用于值对象。

1『把函数式编程范式里「不变性」有点应用到「值对象」上，再比如在 JS 里用 const 来声明「值对象」。』

那你现在应该懂了，我们为什么要将对象分为实体和值对象？其实主要是为了分出值对象，也就是把变的对象和不变的对象区分开。在传统的做法中，找出实体是你一定会做的一件事，而在不同的模型中，区分出值对象是我们通常欠缺的考虑。

一方面，我们会把一些值对象当作实体，但其实这种对象并不需要一个标识符；另一方面，也是更重要的，就是很多值对象我们并没有识别出来，比如，很多人会用一个字符串表示电话号码，会用一个 double 类型表示价格，而这些东西其实都应该是一个值对象。

之所以说这里缺少了对象，原因就在于，这里用基本类型是没有行为的。在 DDD 的对象设计中，对象应该是有行为的。比如，价格其实要有精度的限制，计算时要有自己的计算规则。如果不用一个类将它封装起来，这种行为就将散落在代码的各处，变得难以维护。

其实，我们在讨论面向对象的封装时就已经说过了，只有数据的对象是封装没做好的结果，一个好的封装应该是基于行为的。在 DDD 的相关讨论中，经常有人批评所谓的「贫血模型」，说的其实就是这种没有行为的对象。你可以回头复习一下第 15 讲，我就不在这里赘述了。

### 3.2 关系：聚合和聚合根

选定了角色之后，接下来，我们就该考虑它们的关系了。在传统的开发中，我们经常会遇到一个难题。比如，如果我有一个订单，它有自己对应的订单项。问题来了，我取订单的时候，该不该把订单项一起取出来呢？取吧，怕一次取出来东西太多；不取吧？要是我用到了，再去一条一条地取，太浪费时间了。这就是典型的一对多问题，只不过，在其他场景中，主角就变成了各种其他的对象。不过，这也是一种用技术解决业务问题的典型思路。我们之所以这么纠结，主要就是因为我们考虑问题的出发点是技术，如果我们把考虑问题的出发点放到业务上呢？

战术设计就给了我们这样一个思考的维度：聚合。聚合（Aggregate）就是多个实体或值对象的组合，这些对象是什么关系呢？你可以理解为它们要同生共死。比如，一个订单里有很多个订单项，如果这个订单作废了，这些订单项也就没用了。所以，我们基本上可以把订单和订单项看成一个单元，订单和订单项就是一个聚合。

学习 DDD 时，有人会告诉你，聚合要保证事务（Transaction）一致性。简言之，就是要更新就一起更新，要删除就一起删除。只要你理解了它们是一个整体，你就不难理解为什么这些对象要一起操作了。不过，一个聚合里可以包含很多个对象，每个对象里还可以继续包含其它的对象，就像一棵大树一层层展开。但重点是，这是一棵树，所以，它只能有一个树根，这个根就是聚合根。

聚合根（Aggregate Root），就是从外部访问这个聚合的起点。我还以上面的订单和订单项为例，在订单和订单项组成的这个聚合里，订单就是聚合根。因为你想访问它们，就要从订单入手，你要通过订单号找到订单，然后，把相关的订单项也一并拿出来。

1『很有感触，那么在数据流开发中，领域对象（模型）：工艺提仪表条件，这个子域的建模过程中，仪表位号应该是聚合根，通过仪表位号关联到设备，通过仪表位号关联到管段号，通过仪表位号关联到工作介质......』

其实，我们可以把所有的对象都看成是一种聚合。只不过，有一些聚合根下还有其他的对象，有一些没有而已。这样一来，你就有了一个统一的视角看待所有的对象了。所以，我们也可以用统一的标准要求聚合，比如，聚合不能设计得太大。你有没有发现，这其实就是单一职责原则在聚合上的应用。

那如果不同的聚合之间有关系怎么办？比如，我要在订单项里知道到底买了哪个产品，这个时候，我在订单项里保存的不是完整的产品信息，而是产品 ID。还记得吗？我们在前面说过，实体是有唯一标识符的。如果需要，我们就可以根据产品 ID 找出产品信息。

1『聚合里只保存另一个聚合里某个实体的唯一标识字段即可。这不就是关系型数据库里各个表的主键么。』

有了对于聚合的理解，做设计的时候，我们就要识别出哪些对象可以组成聚合。所以，我们的一对多问题也就不再是问题了：是聚合的，我们可以一次都拿出来；不是聚合的，我们就靠标识符按需提取。当你纠结于技术时，先想想自己是不是解错了问题。

### 3.3 互动：工厂、仓库、领域服务、应用服务

我们现在有角色了，也确定关系了。接下来，我们就要安排互动了，也就是说，我们要把故事的来龙去脉讲清楚了。还记得第 27 讲的事件风暴吗？我们在其中识别出了事件和动作，而故事的来龙去脉其实就是这些事件和动作。因为有了各种动作，各种角色才能够生动地活跃起来，整个故事才得以展开。

动作的结果会产生出各种事件，也就是领域事件，领域事件相当于记录了业务过程中最重要的事情。相对于 DDD 中的其他概念，领域事件加入 DDD 大家庭是比较晚的，但因为其价值所在，它迅速地就成了 DDD 中不可或缺的一个重要概念。因为领域事件是一条很好的主线，可以帮我们梳理出业务上的变化。同时，在如今这个分布式系统此起彼伏的时代，领域事件可以帮助我们让系统达成最终一致的状态。

那各种动作又是什么呢？拿就是我们在写作中常用到的动词。在战术设计中，领域服务（Domain Service）就是动词。只不过，它操作的目标是领域对象，更准确地说，它操作的是聚合根。动词，是我们在学习面向对象中最为缺少的一个环节，很多教材都会教你如何识别名词。在实际编码中，我们会大量地使用像 Handler、Service 之类的名字，它们其实就是动词。

你可能会问，按照前面的说法，动作不应该在实体或值对象上吗？确实是这样的，能放到这些对象上的动作固然可以，但是，总会有一些动作不适合放在这些对象上面，比如，要在两个账户之间转账，这个操作牵扯到两个账户，肯定不能放到一个实体类中。这样的动作就可以放到领域服务中。

1『不能放到实体类的动作，放到领域服务里。』

还有一类动作也比较特殊，就是创建对象的动作。显然，这个时候还没有对象，所以，这一类的动作也要放在领域服务上。这种动作对应的就是工厂（Factory）。这个工厂其实就是设计模式中常提到的工厂，有了设计模式的基础之后，你理解起来就容易多了。需要注意的是，由于聚合的存在，聚合里的各种子对象都要从聚合根创建出来，以便保证二者之间的关联。比如，订单项的产生应该从订单上的订单项工厂方法创建出来。而聚合根本身的产生，就可以由领域服务来扮演工厂的角色。

1『创建对象的动作（工厂），放到领域服务里。还有一个关键点，聚合里的各种子对象都要从聚合根创建出来。』

对于这些领域对象，无论是创建，还是修改，我们都需要有一个地方把变更的结果保存下来，而承担这个职责的就是仓库（Repository）。你可以简单地把它理解成持久化操作（当然，在不同的项目中，具体的处理还是会有些差别的）。

其实，很多人熟悉的 CRUD，可以对应成一个一个的领域服务。如果我们用战术设计的做法来表示，应该是这样：1）创建（Create），从工厂中创建出一个对象，然后，保存到仓库中；2）查询（Read），通过仓库进行查询；3）修改（Update），通过仓库找到要修改的对象，修改之后，存回到仓库中；4）删除（Delete），通过仓库找到要删除的对象，然后，在仓库中删除。

当然，这种简单的映射并不好，没有体现出业务含义，这里只是为了帮助你把已有知识和新知识之间架设起桥梁。当我们把领域服务构建起来之后，核心的业务逻辑基本就成型了。但要做一个系统，肯定还会有一些杂七杂八的东西，比如，用户要修改一个订单，但首先要保证这个订单是他的。在 DDD 中，承载这些内容的就是应用服务。

应用服务可以扮演协调者的角色，协调不同的领域对象、领域服务等完成客户端所要求的各种业务动作，所以，也有人把它称之为「工作流服务」。一般来说，一些与业务逻辑无关的内容都会放到应用服务中完成，比如，监控、身份认证等等。说到这里，我们已经说出了应用服务和领域服务之间的区别。应用服务和领域服务之间最大的区别就在于，领域服务包含业务逻辑，而应用服务不包含。至于哪些东西算是业务逻辑，就要结合具体的项目来看了。

1『一些与业务逻辑无关的内容都会放到应用服务中完成，比如，监控、身份认证等等。』

至此，我已经把战术设计这个故事模板给你讲了一遍，DDD 也算完整地讲了一遍了。你现在应该对 DDD 的各种基础概念之间是个什么关系、如果要做领域驱动设计，要有怎样一个步骤等有一个基本的认识了。当然，仅凭三讲的篇幅，我们想要完整地理解领域驱动设计几乎是不可能的。但是你现在至少有了一个框架，当你再去学习 DDD 中那些让人眼花缭乱的知识时，你就不会轻易地迷失了。

Vaughn Vernon 写过两本关于 DDD 的书，是现在市面上比较好的 DDD 学习材料。建议你先阅读《领域驱动设计精粹》，这本书可以帮你快速入门；然后你再看《实现领域驱动设计》，这本书很厚，但讲得要更细致一些。当然，想要真正想学会 DDD，还是需要你在实际项目中进行练习。

### 黑板墙

感觉郑老师最厉害的地方就是讲出了 why，而不单是说 how。很多文章会说「实体有唯一标识符」，很正确又无用。只有结合了「是聚合的，我们可以一次都拿出来；不是聚合的，我们就靠标识符按需提取」，我才有了恍然大悟的感觉。2020-08-03

结合张逸老师的《领域驱动设计实践》，完美。作者回复：我和张逸是多年老友，他太能写了。2020-08-10

1『上面的这本书没找到。』

我们平时工作中的那种不怎么复杂的公司内务管理系统可以用 DDD 的思想设计和开发，合适吗？如果没打算微服务的话。作者回复：这种普通的业务系统，用 DDD 是非常合适的。这和微服务没有关系，你可以把所有子域都放在一个限界上下文里。2020-08-05

感觉应用服务才是业务的实现者，领域服务是提供者，老师如何理解上面的。作者回复：从大部分人习惯的角度看，确实是这样的，因为应用服务常常对应着你的 API。但核心是领域服务才是核心，是不可替换的，而应用服务则可能根据实际的情况发生改变。2020-08-03

想到两点，请老师指正。1）订单和订单项的例子中，订单项也是一个实体，而不是值对象吧，因为订单项中的各个属性有可能被修改，比如价格或数量，但它还是这个订单项。无论是存储在 mongodb 的一张 table 中，还是 mysql 里面的两张 table 中。2）结合老师的分析，我又想到了另一个例子，比如当前这边文章（Article）和文章评论（ArticleComment）。从聚合概念上分析，文章是作者创建的，而评论是读者创建的，但如果文章被删除了，那么这些评论也就跟着要删除，所以他们不同生但共死。从识别聚合上分析，获取文章时，也无法一次性把所有评论获取到。作者回复：这个理解没问题，非常棒！2020-08-11

不是聚合的，我们就靠标识符按需提取。用 CQRS 落地 DDD 的话，如果按标识符去查询模型获取数据，有可能获取的不是最新的数据（因为写模型更新了，但查询模型更新是有延迟的），像这种极限情况会有什么问题吗？难道应该去通过命令去查询写的模型？怎么去理解和解决这种情况呢？作者回复：CQRS 的话，你追求的是最终一致性，读这端拿到的你就应该认为它是最新数据。显然，如果你的目标是强一致，就别考虑 CQRS。2020-08-05

## 0600. 巩固篇

1、注意发现身边的小问题，用一个程序库或工具解决它。

2、一个更好的设计从拒绝低水平重复开始，把工作做成有技术含量的事情。

3、改进既有设计，从做一个正常的设计开始，小步向前。

## 0601. 程序库的设计：Moco 是如何解决集成问题的？

Moco 的源码：[dreamhead/moco: Easy Setup Stub Server](https://github.com/dreamhead/moco)。

今天我给你讲了 Moco 的设计过程。一个好的软件也好，程序库也罢，都是从实际的问题出发的。阻碍一个程序员写出好的程序库的原因，往往是没有找到一个好问题去解决。程序员不能只当一个问题的解决者，还应该经常抬头看路，做一个问题的发现者。有了问题之后，需要把问题拆解成可以下手解决的需求，让自己有一个更明确的目标。然后，我们才是根据这个需求找到一个适当的解决方案。一个通用的解决方案需要不断地抽丝剥茧，抛开无关的部分，找到核心的部分，这同样根植于分离关注点。

如果最后的解决方案是一个程序库，那么，我们用测试把程序库要表达的内容写出来，就是最直接的。有了测试，就锁定了目标，剩下的就是让测试通过。一个好的设计，应该找到一个最小的核心模型，所有其他的内容都是在这个核心模型上生长出来的，越小的模型越容易理解，相对地，也越容易保持稳定。这一讲，我讲了一个程序库的设计。下一讲，我们再来看看如何设计一个应用。如果今天的内容你只能记住一件事，那请记住：注意发现身边的小问题，用一个程序库或工具解决它。

经过前面内容的讲解，我终于把软件设计的基础知识交付给你了，如果你有一定的经验，相信有很多东西你已经可以借鉴到日常工作中了。但是对于一些同学来说，这些知识恐怕还是有些抽象。那在接下来的几讲中，我会给你讲几个例子，让你看看如何在日常的工作中，运用学到的这些知识，巩固一下前面所学。

我在第 9 讲说过，学习软件设计，可以从写程序库开始。所以，我们的巩固篇就从一个程序库开讲。这是我自己维护的一个开源项目 Moco，它曾经获得 2013 年的 Oracle Duke 选择奖。Moco 是用来做模拟服务器的，你既可以把它当作一个程序库用在自动化测试里，也可以把它单独部署，做一个独立的服务器。我们先来看一个用 Moco 写的测试，感受一下它的简单吧！

```java
public void should_return_expected_response() {
  // 设置模拟服务器的信息
  // 设置服务器访问的端口
  HttpServer server = httpServer(12306);
  // 访问/foo 这个 URI 时，返回 bar
  server.request(by(uri("/foo"))).response("bar"); 
  
  // 开始执行测试
  running(server, new Runnable() {
    // 这里用了 Apache HTTP库访问模拟服务器，实际上，可以使用你的真实项目
    Content content = Request.Get("http://localhost:12306/foo")
      .execute()
      .returnContent();
      
    // 对结果进行断言
    assertThat(content.asString(), is("bar"));
  });
}
```

这一讲，我就来说说它的设计过程，让你看看一个程序库是如何诞生以及成长的。

### 1.1 集成的问题

不知道你有没有发现，阻碍一个人写出一个程序库的，往往是第一步，也就是要实现一个什么样的程序库。因为对于很多人来说，能想到的程序库，别人都写了，再造一个轮子意义并不大。但是，这种思路往往是站在理解结果的角度。其实，程序库和所有的应用一样，都是从一个要解决的问题出发。所以，在日常的繁忙工作中，我们需要偶尔抬头，想想哪些问题正困扰着我们，也许这就是一个程序库或者一个工具的出发点。

曾经有一个问题困扰了我好久，就是集成。还记得在我初入职场时，有一次，我们开发的系统要与第三方厂商的系统进行集成。可是，怎样才能知道我们与第三方集成的效果呢？我们想到的办法就是模拟一个第三方服务。于是，作为当时的新人，我就承担起编写这个模拟服务的任务。那个时候还真是年少无知，居然自己写了一个 HTTP 服务器，然后又继续在上面写了应用协议。那时候的我完全没有编写程序库的意识，只是有人要求我返回什么样的应答，我就改代码，返回一个什么应答。在我的职业生涯中，集成并不少见，只是后来我的经验多了，这种编写模拟服务的事就交到了别人的手上，我就成了那个让别人改来改去的人。

2012 年，我加入到一个海外合作的项目中，这个项目也有一个模拟的 HTTP 服务。开发人员根据自己的需要去改动代码，让这个模拟服务返回不同的应答。之后，他们再打出一个包，部署到一个 Web 服务器上。显然，这比我当年一个人维护模拟服务器要进步很多了，至少它不用考虑 HTTP 协议层面的问题了。

不过，依旧要自己部署模拟服务这一点，让我突然想起当年开发模拟服务时的景象。这么多年过去了，模拟服务却依然如此麻烦，没有得到任何好转，也许我可以做点什么。比起当年做软件开发的懵懂的我，工作了十多年的我，显然已经有了更多的知识储备。

### 1.2 从问题到需求，再到解决方案

那问题有了，我要怎么解决这个问题呢？我需要先把它变成一个可以下手解决的需求。首先，我要考虑的是，我希望这个模拟服务做成什么样子呢？1）它可以支持配置，这样的话，我就不用每次都调整代码了；2）它可以独立部署，因为部署到应用服务器上的方式实在不够轻量级；3）它可以是一个通用的解决方案，因为我已经在多个不同的场景下遇到类似的问题。

除了这些正常的需求之外，我还有一个额外的小需求，就是希望它有一个有表达性的 DSL。因为我当时刚刚翻译完《领域特定语言》，特别想找个机会练练手。以我当时的知识水平来看，配置肯定不是问题，这是任何一个程序员都可以做到的。独立部署，应该也可行，虽然当时还不流行嵌入式的 Web 服务器，但我还知道有 Netty 这样的网络编程框架，我稍微做了一点调研就发现，用它实现一个简单的 Web 服务器并不难。

2『竟然也是 Martin Fowler 的书，以下载书籍「2020159领域特定语言 | 2020159Domain-Specific-Languages」。』

问题就是，我怎样能把它做成一个通用的方案？

在设计中，其实最难的部分就在这里。一个特定的问题总有一个快速的解决方案，而要想做成一个通用方案，它就必须是一个通用的模式。这就需要我们把问题抽丝剥茧，把无关的信息都拿掉，才可能看到最核心的部分。而进行这种分析的的根基，同样是我们在前面说过的分离关注点。

我找到的核心问题就是，模拟服务到底是做什么的呢？其实，它就是按照我预期返回相应的应答。对，一方面，我要表达出预期；另一方面，它要给出返回的结果。当我想明白这一点之后，一段代码浮现在我的脑海中：

```java
server.request("foo").response("bar");
```

对，这就是这个模拟服务器最简单的样子。当请求是「foo」的时候，它就给出对应的应答「bar」，这个结构非常适用于 HTTP 这种请求应答的结构。这段代码简直太合我的胃口了，因为它还是一段内部 DSL，声明出这个模拟服务器的行为，我的额外需求也得到了满足。

如果代码真的可以做成这个样子，那它应该就可以写在单元测试里了。和现在一比，动辄需要启动整个应用，做人工的集成测试，这简直是一个巨大的飞跃。而且，从开发效率上看，这简直就是数量级的提升。不过，上面只是给出了设置服务器的样子，如果我们要把它写到单元测试里，还要考虑到如何去启动和关闭服务器。于是，一段单元测试的代码就浮现了出来：

```java
public void should_return_expected_response() {
  HttpServer server = httpServer(12306);
  server.request("foo").response("bar");
  running(server, new Runnable() {
    Content content = Request.Post("http://localhost:12306")
      .bodyString("foo", ContentType.TEXT_PLAIN)
      .execute()
      .returnContent();
    assertThat(content.asString(), is("foo"));
  });
}
```

这就是 Moco 的第一个测试了。有了测试，我就该考虑如何让测试通过了。同时，测试帮我锁定了具体的目标，我还知道了可用的技术，剩下的就是把它实现出来了。对于程序员而言，实现反而是最简单的。就这样，我花了一个周末的时间，翻着各种文档，让第一个测试通过了。如此一来，Moco 在实现上的技术难度就被突破了。

### 1.3 基础设计的诞生

接下来，我就要考虑 Moco 可以提供怎样的功能了。Moco 首先是一个 HTTP 的模拟服务器，所以，它需要对各种 HTTP 的元素进行支持。HTTP 的元素有哪些呢？其实，无非就是 HTTP 协议中可以看到的 HTTP 协议版本、 URI、HTTP 方法、HTTP 头和 HTTP 内容等等这些东西。

问题来了，如果我们要把 Moco 实现成一个通用的解决方案，我们就需要任意地组合这些元素，我们该如何设计呢？你可能已经想到了，在前面我们讲函数式编程的组合性时，已经提到了要设计可以组合的接口。是的，Moco 就是这么做的。下面是一个例子，如果我们请求 /foo 这个 URI，请求的内容是 foo，那就返回一个 bar，我们还要把这个应答的状态码设置成 200。

```java
server
  .request(and(by("foo"), by(uri("/foo"))))
  .response(and(with(text("bar")), status(200)));
```

在这里，传给 request 和 response 的就不再是一个简简单单的文本，而是一个元素的组合。所以，传给 request 的，我称之为 RequestMatcher，也就是对请求进行匹配，匹配成功则返回 true，反之返回 false。而传给 response 的，我称之为 ResponseHandler，也就是对应答进行处理，在这里面设置应答中的各种元素。这就是 Moco 最核心的两个模型。从 Moco 的第一个版本形成开始，一直没有变过。

```java
interface RequestMatcher {
  boolean match(Request request);
}

interface ResponseHandler {
  void writeToResponse(Response response);
}
```

从这段代码上，你还可以看到用来组合各个元素的 and。学过前面函数式编程的内容，想必你也知道了该如何实现它。除了 and，我还提供了 or 和 not 这样的元素，方便你更好地进行表达。

### 1.4 扩展设计

有了基础设计之后，其实 Moco 已经是一个可用的程序库了。从理论上来说，它已经能够完成 HTTP 模拟服务器所有的需求了。事实上，当我拿出了 Moco 的第一个版本，就有同事在实际的项目中用了起来。如同所有开源项目一样，只要有人用，就会有人给出反馈，你就需要去解决它。Moco 就这样，不经意间开启了自己的生命周期。

我在开篇词就说过，软件设计是一门关注长期变化的学问。长期意味着会有需求源源不断地扑面而来。每当有新问题的到来，软件就要去应对这个新的变化，这也是考验软件设计的时候。

第一个变化就是，有人提出要有一个外部的配置文件。Moco 所要做的调整，就是增加一个配置文件，然后要在配置文件和核心模型之间做一个映射。这个变化其实在核心模型上没有任何的改变。学了前面的课程，你也知道，这就相当于给 Moco 增加了一种外部 DSL，只不过，这个 DSL 的语法我采用了 JSON。

正是因为 JSON 配置文件的出现，Moco 有了一个全新的用法，就是把 Moco 当作了一个独立的模拟服务器。后来的很多人其实更熟悉的反而是这种用法，而把 Moco 用在单元测试的这种场景比例就要低一些。也是因为这个独立模拟服务器的用法，Moco 也不再局限于 Java，不同的程序设计语言编写的应用都可以与之进行交互，Moco 的使用范围得到了扩展。

随后，还有人提出了更多功能性上的需求，让 Moco 的能力也得到了极大的提升：1）有些被模拟的服务不稳定，Moco 支持了一个 proxy 功能，将请求转发给被模拟服务。如果这个服务失效了，就使用本地缓存的信息；2）有些应答里的字段是根据请求的内容来的，Moco 支持了 template 功能，让使用者自己决定怎样使用哪个信息；3）有时还要对请求的内容，进行各种匹配。比如，URI 在同一个根目录下，就进行一样的处理，Moco 支持了 match 功能，让使用者自己可以写正则表达式，对请求进行匹配；4）有人为了方便管理，希望把所有的应答内容放到一个目录下，Moco 支持了 mount 功能，把一个目录挂载在一个 URI ；5）现在的 REST 开发是主流，Moco 支持了 REST 能力，能够定义资源，更方便地将同一资源的内容定义在一起……

所有这些内容都是在基础的模型上扩展出来的，基本上都不需要去改动基础模型。不过，有一个功能的拓展影响了基础模型，就是 template。因为它需要根据请求的内容来决定应答的内容，这让原本各自独立的 request 和 response 开始有了关联。为了适应 template 的需求，我在 ResponseHandler 的接口上增加了 Request，把请求信息带了进来：

```java
class SessionContext {
    private final Request request;
    private final Response response;
    ...
}

interface ResponseHandler {
  void writeToResponse(SessionContext context);
}
```

也是由于这个调整，让 Moco 后来有了可以支持录制回放的能力：

```java
server
  .request(by(uri("/record")))
  .response(record(group("foo")));
  
server
  .request(by(uri("/replay")))
  .response(replay(group("foo")));
```

在这个设置中，我们发给 /record 这个地址的内容就可以记录下来，然后，访问 /replay 这个地址的时候，我们就可以得到刚才记录的内容。由此，Moco 由原来只提供静态设置的模拟服务器，变成了一个能够动态配置的模拟服务器，能力得到了进一步提升。至此，你已经看到了 Moco 是怎么一点一点长大的。与 2012 年刚刚起步时相比，今天的 Moco 的能力已经强大了许多，但它的内核依然很小，代码量也不大。如果你希望研究一个有设计的代码，不妨从 Moco 入手，这个专栏讲到的不少内容都可以在 Moco 中看到影子。

Moco 就是根据请求给出应答，只要理解了这么一个简单的逻辑，你就完全可以理解 Moco 在做的事情，其他的东西都是在这个基础上生长出来的。

### 黑板墙

我想请你抬头看一下路，看看你在开发的过程中，发现过哪些阻碍研发过程的问题呢？

真的很精辟，开发工作是很讲究套路的，从问题，需求，方案，设计，发现问题很关键，太多开发，眼睛里看不到问题，重复开发，功能不复用，不扩展，性能差，开发效率慢，系统质量低，工作中有太多的痛点，痛点即是问题，不追求问题本质，不勤于思考的开发，就是推代码，能跑就行，不管后续维护。如果发现不了问题，更谈不上解决问题，解决方案和设计，就是解决问题，需要积累经验，不断学习，实践，提升解决问题的能力，只有把发现问题和解决问题都做好的开发，才能成为架构师或者 leader，更上一层楼。作者回复：总结得很好！2020-08-05

作为程序猿学习能力应该是自带属性，实际工作中，从解决问题出发，锻炼自身的软件设计和开发能力，这是一个层次。把问题抽象出来提供一个通用的解决方案，并提供程序库出来，这又是一个层次。自己和自己维护的代码一起进化，这应该是每一个开发者所追求的。2020-08-05

记得不错的话，spring mvc test 里面也有相似的概念，如 RequestMatcher，ResponseHandler, 今天才明白原来这是一种函数式编程的 dsl。moco 已 clone, 学习一下。作者回复: RequestMatcher 和 ResponseHandler 是模型，函数式的 DSL 是接口。2020-08-05

在日常工作中，常常因为查 bug 导致阻碍开发进度，其实也是旧项目单元测试没做好，但是有一部分原因是集成测试没做，有些问题需要整个系统和外部系统串起来完整的调用才能定位问题。我想写一个易于集成测试的 DSL，可以将测试人员写好的测试用例的描述内容作为集成测试的逻辑组装。大多数情况下都是测试人员在写自己的测试代码，通过系统的 http 接口调用进行测试。很难覆盖到系统和外部系统之间的调用，往往出问题的也是不同团队间的系统间调用，不同系统间调用老师有什么好的建议吗。2020-08-09

## 0602. 应用的设计：如何设计一个数据采集平台？

今天我通过一个指数系统的应用给你讲了一个应用的设计过程。在这里，你知道了想要做好设计，目标就不能局限于只把功能实现出来，而是我们要去不断发现可能存在的各种问题。简言之，只要你认为会出现重复，它就是一个值得我们去思考解决的问题。我还给你讲了如何衡量应用的设计水平，就是看它符合下面哪个标准：1）没有自动化；2）开发员修改代码实现；3）开发员修改配置实现；4）业务员修改配置实现。

程序员常常给人写代码，实现自动化，却常常忽略了自己工作中可以自动化的部分。作为一个懒惰的程序员，我们需要发现日常工作中繁琐的地方，让自己从低水平的重复中解脱出来。一件事是不是有技术含量往往不取决于事情本身，而取决于我们怎么做它。这两讲我们讲的都是怎么去设计一个新东西，但在实际工作中，有时候，我们还会面对一个既有的系统，这样的系统该如何改进呢？我们下一讲来谈。如果今天的内容你只能记住一件事，那请记住：一个更好的设计从拒绝低水平重复开始，把工作做成有技术含量的事情。

上一讲，我给你讲了 Moco 的设计，这是一个程序库级别的设计。除了开发一个程序库，在日常工作中，还有一种工作是程序员们非常熟悉的，就是开发一个应用。与之对应的设计就是应用设计。也许你会说，应用设计不就是按照之前讲的 DDD 的方法，先通过事件风暴建立通用语言，然后，再找出子域和划分出限界上下文，最后，再按照模板找出各种对象吗？

是的，设计的基本过程确实是这样的。不过，DDD 的方法只能保证我们设计出一个可以接受的方案。如果你想有一个更有扩展性的设计方案，就需要多花一点时间去构建一个更好的模型。这一讲，我就以一个金融指数系统为例，给你讲一下如何更好地设计一个应用。

### 2.1 一个指数系统

在金融系统中，有一个概念叫指数，用来表示金融市场的活动，比如有股票指数、期货指数等等。比较著名的指数有道琼斯指数、标准普尔指数。这个世界上的指数多得数不胜数，每个金融机构都会有自己的指数，而且，它们还会不断推出新的指数。

那指数是怎么算出来的呢？如果以股票为例，就是获取一堆股票的价格，然后根据一个公式算出一个结果。比如，我们有一个公式，A0.2+B0.3+C*0.5，我们把公式里的数据部分称为指标，也就是公式中的 A、B、C，这个公式表示这三种指标分别占比 20%、30% 和 50%。

这个公式就是三个不同的指标按照不同的占比进行求和。假设 A 指标的价格是 5 元、B 指标是 2 元、C 指标是 1 元，按照公式可以算出 520%+230%+1*50%=2.1，这个算出来的 2.1 就是指数的值。价格是实时变化的，而公式是固定的。指数在问世之初，我们需要不断调整这个公式里面各个指标的参数，以便能更好地反映市场的变化。问题来了，我们要怎样设计一个这样的指数系统呢？一个不假思索的设计就是，针对一个具体的指数进行开发。我们就要把指数计算中涉及的各种数据实时取过来，然后根据设置的公式去做计算。

如果我们只有一个指数，这么做也许是可以接受的。但我们要开发的是一个指数系统，这意味着我们会有很多个指数。两个不同的指数可能会用到同样的指标，如果我们按照开发一个指数的方法，不同的指标数据要获取好多遍，从某种意义上来说，这就是一种重复。所以，一个好的做法就是，先做职责划分，把不同职责的部分划分出来。正如我在这个专栏中一直说的，我们不能把各种不同的关注点混在一起，这是很多系统出问题的根源所在。

那从上面的需求描述中，我们可以把指数的计算过程分成两个部分：1）一部分是需要实时获取的数据，比如，前面说到的各种价格；2）一部分是根据公式进行计算出最终的结果，也就是指数最终的值。

这种拆分解决了前面设计中存在的问题，使得指标数据获取和公式计算分开了，同样的数据就可以用在多个公式中，数据的获取和公式的计算就不用同步进行了。而且，把计算过程拆成了两个部分之后，我们就可以针对这两个部分，分别进行细化了：1）对于指标数据获取的部分，我们要解决数据获取可能出现的问题，比如，不同的数据来源如何管理、不同数据源的数据格式是怎样的、如果数据源不可用，我们该怎么办等等；2）对于公式计算的部分，我们关心的问题则是计算要用到哪些指标、每个指标当前可用的值是多少、如果公式中有不可用的指标数据时，系统该怎么处理等等。

既然我们把系统拆分成了两个部分，还有一个问题就是，如何把这两个部分连接起来。其实，指标数据获取部分的输出，就是公式计算部分的输入，那指标数据获取部分的输出是什么呢？我们在前面分析过，指标数据获取要实时获取，无论采用轮询的方式，还是采用数据上报的方式。这种数据的特点就是，它有一个值，还有一个时间。正是因为这种特点，数据会形成一个序列，所以，我们将这种数据称为时序数据。

指标数据获取部分的输出其实就是这种时序数据，只不过，针对每一种指标都会产生一个时序数据序列，而这些不同的时序数据也正是公式计算部分的输入。既然是时序数据，也就有了时间的信息，我们的公式计算部分就可以根据时序数据的时间做一些处理了。比如，怎么判定一个指标不可用呢？如果判断一个指标最新的数据与当前时间的差值过大，我们就可以判断在这次计算中，该指标的数据不可用。

有了对于时序数据的认识，结合前面所说的数据获取和公式计算不再是同步进行的这一点，指标数据获取和公式计算两个部分就完全解耦了，二者之间可以只通过时序数据进行交互。

### 2.2 更上一层楼

现在，我们已经把数据获取和公式计算分成了两个部分，这应该是常规设计中都可以想到的。很多设计者做设计也可能就此打住，开始动手写代码了。但是，有时候我们还可以更进一步。我们可以继续分析一下，看看还有什么可以进一步改进的地方。

我先问你一个问题，公式计算你打算怎么做？你可能会想，这难道不是业务人员给我什么样的公式，我就用写代码的方式把它实现出来吗？这么做肯定是可以把公式实现出来，这一点是毋庸置疑的。但是，正如我前面所说，指数往往要经过一个调整的过程。因为业务人员自己也常常不确定设置的参数是否合理。用写代码的方式实现公式，也就意味着，每次业务人员要调整一个参数，你都需要去改代码。在可以预见的未来，你的工作基本上都会与调整参数相关，而这件事一点技术含量都没有。

对我们程序员而言，一件事是不是有技术含量往往不取决于事情本身，而取决于我们怎么做它。换言之，问题是一样的，但不同的解决方案却会带来不同的效果。业务人员提出的是问题，解决方案是由技术人员给出的，千万别混淆问题和解决方案。

当你可以预见一件事将来会很繁琐、会不断重复，而且会持续相当长的时间，这时候我们就需要重新审视我们的解决方案了。最原始的解决方案是没有自动化的方案，对于任何一个系统而言，我们最好要知道没有自动化的时候，这个问题是如何解决的。这和我们前面说到的，理解一个模型来龙去脉的思路是一致的。

当然，我们现在大多数情况下接触的都是一个已经自动化的方案，但方案之间还是存在着差别。在自动化方案中，最原始的做法是开发人员自己修改代码的方案，这种做法会导致开发人员大量的时间投入，属于严重消耗时间的做法。其次是开发人员修改配置，虽然这种做法只修改配置，但通常还会涉及到重新打包发布的过程，只能说它比修改代码要强一点。比较好的做法是，业务人员修改配置，开发人员完全不参与其中。一方面，业务人员自己最知道自己想要什么；另一方面，没有开发人员的参与，反馈周期就缩短了。

虽然这几种方法在业务的角度是越来越好的，但在设计上，却是要求越来越高的。比起没有自动化的方案，自动化的方案需要投入一些力量去做设计。相比于修改代码，修改配置就意味着要留下扩展的接口。而能够做到让业务人员而不是开发人员修改配置，配置的接口就应该是一个业务的接口，比如，要有一个配置界面。

如果我们用这几个标准评估一下我们现在的方案，显然，我们现在的方案还处于开发人员修改代码的阶段，这说明我们还有向上努力的空间。不过，我们给出的只是一个衡量标准，并不意味着这个台阶要一步一步上，因为我们可以一步就提升到最高标准，一步到位给业务人员提供一个配置的接口。

问题来了，我们要给业务人员提供一个配置接口，它应该长啥样呢？我们知道，这个指数设计的关键就是这个指数的公式。在前面的那个例子里面，它的公式是 A0.2+B0.3+C*0.5。如果我们能够让业务人员在配置接口上这样配置，问题就解决了。

在这里，A、B、C 分别代表一个指标，也就是说，我们只要能够让业务人员指定指标以及指定计算公式，剩下的问题就简单了，就是根据公式计算出相应的结果就好了。说起来很简单，但怎么把 A0.2+B0.3+C*0.5 变成一个可执行的公式，对一些程序员来说，还是有一定难度的。解析文本执行这件事是编译原理的基本功，不过只要你能理解这里需要一点编译原理的知识就很可以了，如果欠缺知识，就去学习相关知识好了。

实际上，公式的解析是编译原理入门的知识，难度系数比设计一门程序设计语言要小多了。而且，现在有编译器前端的工具，比如，Java 世界的 Antlr，它可以直接生成对应的语法树结构，我们只要负责去编写对应的执行部分就好了。

也许你发现了，我们实际上已经构建出了一门 DSL，一门属于指数计算这个特定领域的外部 DSL。前面讲 DSL 的时候，我们就说过，把设计做到极致就可以构建出一门 DSL。在这里，我们也看到了，了解 DSL，实际上也给我们增添了一个可以前进的方向。

把公式构建出来之后，我们仔细分析，还会有一个有趣的发现。你可以想一下，公式计算的结果是什么？因为我们说，它是在利用多个指标的时序数据做计算，所以它得到的结果，其实也是一个时序数据。这样，我们发现了另一个有趣的事，公式计算的得到其实也是一个指标。如此一来，公式计算的结果也可以作为另外一个公式的输入，形成更为复杂的复合公式。显然，由于复合公式的出现，这个系统的处理能力又上了一个台阶。

不知道你是否想起了什么，没错，它和设计模式中的组合模式如出一辙。你看，我们学习到的基础知识在这里都用上了。虽然我们这里讨论的是一个金融中会用到的指数系统，但当我们把模型经过一番整理之后，你会发现它不仅仅局限于指数系统中。比如，如果你在开发的是一个物联网系统，上报上来的数据，往往也要经过一些计算和聚合，那这个模型显然也是适用的。

再比如，你开发了一个 APM（Application Performance Management，应用性能管理）类的应用，采集上来的数据往往也要经过一番计算再展示出来，这个模型同样适用。所以，当我们可以构建出一个好的模型时，它本身就有着更大的适用范围。

### 黑板墙

我想请你回想一下，参照今天的内容，在你现在的工作中，有哪些可以从设计上改进的内容呢？

说的非常好，和我现在做的风控预警系统类似，同样适用于你说的这个通用模型，开发人员一定要有抽象能力，设计模式是一种特定场景的模型，同类应用系统也有通用的模型，采集、计算、分析、监测、预警、报告，如果你做的系统有这样的功能，那么就可以应用通用设计模型。

你说的编码实现，到开发人员配置，到业务人员配置，我们称为配置化，低代码，无代码化，这些目的都是快速响应需求，减少重复，减少开发投入的好方法，也是通用方法，我们同样应用于多个业务系统，我们有一个系统，要投入三分之二人力，支持开发，测试，我们做到了业务自主配置，开发完全解放出来了，因为这些工作就是低级重复，需要大量沟通，配置工作。开发人员要就是为解决问题的，一定避免低级，简单，重复工作，能自动化就不要手工，能自助化，就不要人工协作，对提升水平没有任何帮助，时间还浪费了，随着年龄增长，水平没有进步，本质上其实是在退步！作者回复：非常棒的分享！2020-08-07

分离关注点，把不同的职责划分出来。业务人员提出问题，技术人员提供解决方案，是否有技术含量取决于技术人员怎么去实现解决方案。一个好的设计要从拒绝低水平重复开始。作者回复：总结得不错。2020-08-07

## 0603. 应用的改进：如何改进我们的软件设计？

今天我给你讲了如何改进一个既有软件的设计。一个软件放在时间长河中会有很多东西发生改变，即便是当初还算不错的设计，随着时间的累积，也可能积重难返。改进一个软件的设计，首先，要确定改进的目标。改进的目标就是，重新设计这个软件，它应该设计成什么样子，让设计还原到它应有的本来面貌。寻找改进的起点，一部分可以从需求入手，还有一部分要从梳理接口入手。设计改进的难点在于不要回到老路上，要做正常的设计，尤其是要把分解做好。有了改进目标之后，接下来就是要找到一条改进路径，选择怎样的路径都是有道理的，但有两个关键点是非常重要的，一个是每步改进的动作要小；一个是要让相关利益人达成共识。如果今天的内容你只能记住一件事，那请记住：改进既有设计，从做一个正常的设计开始，小步向前。

前面两讲，我们分别讲了如何从头开始设计一个程序库和应用。但是在实际工作中，有很多时候，我们的工作并不是从头设计一个应用，而是改进一个既有项目的代码。既有项目的代码意味着什么呢？意味着各种问题。

我们一直在说，软件设计是一门关注长期变化的学问。越是在商业上成功的软件，存续的时间往往越长。存续的时间越长，往往就会有更多的麻烦。我们先不说有些项目一开始就没有设计，一路混乱向前。即便是一个最初有着还算不错设计的项目，随着时间的积累、人员的更替、把前人的做法当作惯例等等事情的发生，项目的设计就会逐渐变得不堪重负。

我在前面的课程中也举过一些例子，虽然每人只改了一点点，最后却是积重难返。这就是一个项目缺乏设计守护的结果。好的守护可以使设计更持久，遗憾的是，大多数项目做得并不好。除了上面这几点，还有一点就是，新的技术和框架会不断涌现，旧代码往往是不能有效使用这些新东西的。比如，Java 世界今天开发的主流是 Spring Boot，然而十年前，它还不存在。

虽然那时候已经有了 Spring，但那时候的主流开发方式还是打出一个 WAR 包，再部署到 Tomcat 上。所以，新出现的很多技术会提供更简单的做法，替换掉旧代码中笨拙的部分。所以，到底怎么才能让自己的项目在设计上不断地演进，跟上时代发展的步伐，不断焕发新的活力呢？对于任何一个开发团队而言，这都是一个值得考虑的问题。那么，这一讲，我们就来谈谈如何改进既有项目的设计。

### 3.1 从目标开始

在我的另外一个专栏《10x 程序员工作法》中，我讲过一个类似的主题，如何面对遗留系统。那里面的主要观点就是我们应该找到一个目标，然后小步改进，逐步向这个目标接近。在那一讲中，我讲的重点主要在于改进的过程，而在这里，我打算从设计的角度再来审视一下这个问题。既然都是我的专栏，所以二者在解决问题上的思路一致的，都要先从找到目标开始。

大多数团队一说起改进，一般想的都是功能性方面的目标。比如，我原来的系统能支持 100 万的用户，现在要支持 1000 万的用户。这种改进固然是我们需要考虑的，甚至是迫不得已的。但这种改进解决的是实现，因为不同量级的系统根本就不是一个系统，承载的用户量发生了变化，其实是一种需求的变化。但是，这种改变并不会让你的设计变好。

既然我们已经决定要改进了，就应该好好地把设计改进一下，而不只是把功能重新实现一遍。因为功能实现是你无论如何都必须做的，都是为别人做的，而设计的改进才是你为了自己做的，因为在未来的一段日子里维护这些代码的人是你。如果我们要做设计的改进，设定好改进设计的目标就显得尤为重要。

那设计改进的目标应该是什么呢？你可以先问一下自己这样一个问题，如果有机会从头设计这个系统，它应该是什么样子呢？这个问题可能会让很多程序员一下子愣住，因为他们每天都陷于忙碌的工作中，做的工作都是各种微调、各种打补丁，眼中只有一个具体微观的世界，却不曾有一个整体的思考。

是的，从头来过，它应该是什么样子。这是一个简单的问题，也是一个困难的问题。简单在于，它的字面意思很好理解。困难却在于，很多人一听到这个问题，直觉就要回避：1）我的系统已经这么沉重了，怎么可能重来？2）我有那么多的需求要做，哪有时间重做一遍？3）我的系统那么复杂，重做一遍，出了问题谁来负责？

我承认，这些都是很现实的问题。但是，我的意思并不是让你真的一上来就动手，从零开始把系统重写一遍。这里的重点在于，我们要找到改进的目标，也就是一个系统本来应有的面貌。这就是为什么我们前面要学习那么多设计一个系统的知识，否则，我们没有一个设计知识的沉淀，所谓的「重新设计」，弄不好我们就会回到原来的老路上去。

这时候，或许你突然想到一个严重的问题了，开启一次系统改进，如何处理人们的共识好像也是一件困难的事情，但这根本不是一个设计问题。想要真正地开启一次改进，就要让人们意识到，设计一个系统和实施一次系统改进是两个完全不同的问题，可以分阶段地进行。

我们只有把系统设计成它应有的样子，才算是确定了我们的目标。有了目标之后，接下来，我们才能制定改进路径，而把现有的系统一点一点从旧有的样子改动成新的样子，这是实施的过程。好！我假设你已经搞定了周边人的共识，准备着手进行改进了。

### 3.2 改进的过程

现在你要重新设计这个系统了，或许你会想，这有什么难的？不就是照着原来的需求，重新来一遍吗？如果你真的还有原来的需求，能让你照着设计一遍。我真的只能说，你太幸运了。在大部分真实的项目中，一个既有系统的情况是，没有人能够说出它到底承载了哪些需求。当然，主干部分是人人都知道的，但主干常常是九牛一毛，而更多的细节隐藏在代码中了。一个长期存在的系统，开发者可能已经换了好几拨。了解当年那些需求的人可能早已不知所踪了，导致的结果就是，每一个工作在这个项目上的人都是只见树木不见森林。

在这种情况下，我们该怎么办呢？我给你一个入手的起点，就是接口。在第 4 讲学习怎样理解一个系统的设计时，我们曾经说过，想要理解一个系统的设计，可以按照模型、接口和实现的这个框架去理解，其中，接口是模型能力的体现。

对于一个系统而言，接口也是使系统内部状态发生改变的原因，系统中的所有变化必然都是从某个接口开始的。既然没有人能够清楚地说明系统的现状，那么，我们从接口入手，了解系统的现状是一个非常现实的做法。毕竟，接口是不会骗人的。

不过，这里的接口不仅包括我们传统意义上的接口，也包括各种后台服务。前面我们讲了很多构建模型的内容，有了这个基础，我们再看后台服务，就会发现，后台服务只不过是按照某种规则触发模型的接口。比如，定时服务，就是定时地去调用模型的接口。所以，我们也要把这种接口梳理出来。有了对于这些接口的了解，我们就对这个系统呈现哪些能力有一个认识了，就相当于获得了一份需求描述。基于这个认识，我们来构建我们新的设计。

接下来，我们就要重新设计了，这个改进设计的难点就是不要回到老路上。我们需要按照一个正常设计的思路去走，该分离关注点的分离关注点，该重新组合的要重新组合。之所以我要提示这一点，就是因为思维的惯性实在是太大了。比如说，在原有的系统内有一个叫订单的概念，我们就会习惯性地使用订单，而不是把商品订单、支付订单等概念分开。

一般而言，既有项目的设计有一个很大的问题就是各种信息混在一起，而能够把不同的信息拆分开来，对于设计而言，就是一个巨大的进步。做好了新的设计，也就为我们后续的行动找到了新的方向。接下来，我们要做的是，对比新旧设计，找到一条改进路径。永远不要指望一个真实的项目停下来，一步到位地进行改进。我们能够做的，唯有小心翼翼，一步一步向着目标前进。对于不同的项目，选择的路径可能是不同的，有人会选择关键路径上的关键模块进行改进，也有人会选择影响较小的模块先进行探索，无论是哪种方案都是可以的。一个关键点就在于，动作要小。

学习过我的两个专栏的同学可能已经充分理解了我对小步前行的喜爱了。任何一个大动作，往往都意味着很长时间无法完成。在这个过程中，所有人都会提心吊胆。如果不能看到成果，很多人的信心都会随时间流失。所以，在软件设计的改进过程中，积小胜为大胜才是一个合理的选项。

还有一个关键点，要让所有相关利益人有一个共识。我又一次说到了共识，软件开发虽然是一个技术活，但归根结底还是一项团队活动，是一项人的活动。既然涉及到诸多参与者，就一定要让大家形成一个共识。所以，系统改进，尤其是一个规模比较大的系统改进，一定要让所有人有共识。无论是开会也好，宣讲也罢，让大家对于改进的原因和改进的计划有个共同的预期是至关重要的。更加具体的改进过程，我在《10x 程序员工作法》中有更细节的讨论，有兴趣的话，可以去参考一下。

虽然我在这里讲的是一个系统的改进过程，其实，同样的思路也可以运用在更小的模块中。只不过，更小模块意味着更少的接口、更低的复杂度以及更少的相关利益人。事实上，我反而鼓励你从小模块入手，一步到位去改进整个系统，难度系数是更大的，而小模块可以帮助你积累更多改进的经验，无论是设计，还是与人打交道。

### 黑板墙

我想请你回想一下，你的系统在设计上存在着哪些问题，你打算怎么改进它呢？

我们正在重构一个 40 多万行的应用，这个应用的开发，产品，业务都走光了，现在团队有的开发要重写，有的开发的意见是不动老代码，两种意见，我都是反对的，全部重写不现实，一个跑了 5 年的系统，需求根本没人弄的清楚，就算弄清楚需求，重写代码，就能做的更好？设计水平达到了吗？另外，不动老代码不现实，很多新需求，虽然是新需求，正因为设计的不好，不得不动老代码。面对这样的困境，我们还是采用小幅重构的办法，我们做了重构方案，目标清晰可落地，效果可检视。我们对重构进行分类。

1、瘦身，瘦身就是把系统的各种接口，页面接口，服务接口，job，通过监控统计已经下线的功能，把代码删除掉，最近一年没有访问的请求，把代码删除掉。另外，通过表，sql 反向梳理，就是表里没有新数据，sql 最近一年没有执行过，把这样的代码都删除掉。

2、重构，精准重构，1 个是性能，梳理接口，统计超过一定阀值的接口，根据成本收益原则，确定优先级，分布实施，1 个是功能复杂度，统计最近 1 年每个源代码文件提交的次数，我们的依据是开放封闭原则，一个类被频繁修改，就说明设计存在问题了。

3、新需求，新应用，对于业务领域是个全新的子域，我们坚决开发新应用解决，另外我们计划做服务标准化，对于新接口和服务，通过一个新应用实现。同样的遵守开放封闭原则。

我们已经重构了半年，下半年还要重构，我认为明年也要重构，重构得到领导的大力支持，我相信也是提升团队设计，开发水平的机会，加油吧！作者回复：非常棒的分享，感谢你让大家看到实践者前行的足迹！2020-08-10

我非常赞同从改进一个小的模块设计开始，不断地小步前行的做法。我最近也是在重构项目，虽然是 APP 项目，但这个项目很大，安装包已经有 200M。因为需求复杂，经历人员也比较多，结构设计也没有统一，有使用 rxjava，dagger，MVP 等等框架，交互层和业务层的逻辑交织在一起，改一个 bug 相当得耗时间。现在第一步做法是梳理模块，统一每个模块对外的接口，这个改动目前来说是最小的，也是更进一步改造的基础。曾多次问自己如果重新开始我会怎么设计这样的问题。其实回答这个问题可以帮你更好的理解现有系统的业务逻辑，也是你重构的目标，重新设计它是一个理想状态，不可能一下子就达到，但是可以不断地逼近目标。作者回复：感谢分享！2020-08-10

个人补充：项目质量的好坏，与公司发展情况，项目价值息息相关。在业绩不好的条件下，举债前行就是合理的。所以我们讨论项目质量，谈设计和重构，都是建立在价值和公司业务发展需要的前提条件下的。（反之，逆势而为有违天和，事倍功半）课后题：1）问题：最大的问题就是缺少共同设计。2）解决思路：开发与产品间的沟通应该基于统一、公开的业务建模。3）问题描述：产品和开发之间沟通都是基于一个个零散发散的功能点。在系统和业务间没有做一定的模型抽象。导致开发不了解业务全貌，产品不理解系统现状。进而在知识传承的成本就很大。往往新产品出的功能很难兼容现有系统（复用已有能力和兼容其他已有功能）; 新的开发也很难看清系统的全貌。（进而问题就多，问题多团队氛围就比较差，就容易扯皮）4）价值：产品需要开发通过模型勾勒出系统的现状，屏蔽掉实现的复杂度。开发需要产品通过模型屏蔽掉无关的业务复杂性，串联整体业务脉络，快速准确的理解业务全貌。如此也有利于新人介入，知识传承。5）外在问题：因为不是一个人的事，所以天时地利很重要，同样的时间也可以做很多事情，没必要吃力不讨好不是。作者回复：能够理解我写的内容都是吃过亏的人。2020-08-10

公司以前业务是 2C，后来钱烧完了，开发人员走的差不多，现在做 2B。但把各个服务拆的非常细，几十个微服务，几个人维护，现在也不敢做的大的改动。想了想问题：1）微服务拆分的太多，各种服务之间 RPC 调用经常超时。2）各个服务报错之后，没有事务和补偿机制，存在数据不一致问题。3）微服务相关调用，一个服务挂了，好多功能停摆，无法用。4）监控体系没有做，各种服务的状态和接口的调用情况不清晰。5）服务熔断、链路追踪等没有。有时候，我在想，2B 业务量不大，不如保持现在各个微服务的样子，只是不再一个个部署了，合并到一个进程里面跑算了（相当于模块化开发，把 RPC 调用禁掉）。只是有点回到老路的样子，大家有些不甘心。作者回复：微服务应该是结果，而不应该成为目标。2020-08-10

10 年 + 复杂系统改善坑：1）需要同步修改的点无法确定，如：上层接口变化导致下游未同步、数据源变化（分析人员方了）；2）面条逻辑，数据库、后台服务、前台、网关均有逻辑。3）神一般坏味道，if 能在屏幕左侧写到右两屏的那种。4）红线需求层出不穷。5）替换了依赖组件版本、修改底层一行代码，平台直接起不来。然后，我们的解决方案大致如下。

止损：1）建立规范，防止代码分层不明确、代码风格迥异。2）防止平台出现大变动。3）更新底层、尽量以新的能力承载，然后慢慢迁移到新的实现方式。4）外部基础组件版本不允许变化。

搭建安全网：1）建立后台服务接口监控。2）建立核心业务流程自动化测试流程，防止挂的太离谱。3）建立验收环境，上线版本必须在该环境进行验收测试。

落地实施：1）先拆基础服务，文件、消息等。2）新业务关联性不强，另起炉灶。3）将代码中的阈值一律移入配置管理，不允许写代码中。4）业务侧发起，哪些功能不要的，直接砍、删——做好长期战斗准备。5）建立核心业务平台标准接口 (业务上做调整)，外部平台陆续迁移新接口。6）数据库中单表超 20 个业务含义字段的都是危险分子，分析职责权属。7）让资深业务、测试、开发周期性来培训团队系统都有撒撒撒，他们重点关注的撒撒撒。

重构项目需要有愚公移山的精神，然后每次就来一点点。作者回复：非常赞的分享！2020-08-17

微服务应该是结果，而不应该成为目标。怎么理解这个呢？作者回复：不要为了微服务而去微服务，如果拆分的结果是微服务，那就微服务了。2020-08-20