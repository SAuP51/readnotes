# 2020029吴咏炜的VimR02

## 记忆时间

[VIM 中文帮助: Vim 的各种窍门](https://yianwillis.github.io/vimcdoc/doc/tips.html#using-xxd)

## 0201关于字符编码行你所需要知道的一切.md

这一讲我们讨论了什么是文本，包括：1）文本是用行结尾符隔开的、使用某种特定编码的字符序列。2）UTF-8 是目前最主流的编码方式，但我们仍然可以对个别文件使用不同的编码。3）字符和字形在 Unicode 下并不是简单的一一对应，我们需要语言相关信息才能保证正确的显示。4）目前主流的行尾格式是 Unix 和 DOS，Vim 都支持，并且可以自动判断。5）Vim 支持设置特定的行宽，然后据此来进行断行，且对代码注释、数字列表等文本形式有特殊支持。6）虽然 Vim 是文本编辑器，但在需要的时候，我们也可以使用 Vim 来查看和编辑二进制文件。7）本讲我们对 vimrc 配置文件有一处小修改，对应的标签是「l11-unix」和「l11-windows」。

从今天开始，我们进入提高篇和拓展篇的学习。在提高篇，我会带你对 Vim 的高级用法和技巧进行专项突破，让你可以对 Vim 做深度定制，应对复杂的工作也不在话下。在拓展篇，我会介绍一些针对性较强的内容，适合特定场景下的 Vim 使用。为了平衡一般性和特殊性，让你拥有更舒适的学习体验，拓展篇将会与提高篇交叉发布。如果一时用不到相关的知识，拓展的内容可以暂时延后学习。但一旦你需要这些知识时，你会发现，哦，原来如此，Vim 是可以这么使用的！

Vim 是一个文本编辑器，很多人甚至把它称为「编辑器之神」。在基础篇中，你已经了解了很多用 Vim 编辑文本的常用技巧。可是你有没有想过，到底什么才算是文本？在提高篇的第一讲，我们就先来细细分析一下，关于文本你需要知道的一切知识。这会让你更好地理解编辑时出现的一些奇怪问题（如「乱码」），并予以恰当解决。

### 1.1 什么是文本

从二元论的角度看，计算机文件可以分为文本文件（text file）和二进制文件（binary file），但这个分法并没有对文本做出清晰的界定。从实用的角度，我们大致可以这么区分：1）文本文件里存放的是用行结束符（EOL，即 End of Line）隔开的文本行，二进制文件里则没有这样的明确分隔符。2）文本文件可以通过简单、直接的算法转换为人眼能够识别的文字，而二进制文件里含有不能简单转化为文字的信息。

1『记得 Unix 编程艺术中有提到多用「纯文本」来存储信息，很多地方提到这么一点。（2020-09-22）』

我这个描述当然还是有点含糊。事实上，计算机判定一个文件是不是文本文件，并不是件容易的事情，特别是在这个文件含有非 ASCII 字符的时候。曾有一些操作系统（如古老的 Apple DOS），会明确区分文件的类型，但现代的操作系统基本上在文件系统层面完全不关心文件的类型和里面的内容了。因为操作系统不对文件类型进行限定，会更加灵活。

但我们还是需要关心的，因为 Vim 最适合编辑的，就是文本文件了。从实用的角度，我对文本文件的判定通常是：一个文本文件可以直接输出到终端上，或在简单的编码转换后输出到终端上，显示为一行或多行可识别的字符，并且不包含乱码。

想要理解这句话，你得先知道什么是字符？什么是编码？什么是行和行结束符？下面我就来为你一一解说。

### 1.2 字符和编码

从文件系统的角度看，文件的内容就是一堆比特（bit）而已。把比特对应到字符的方法，就是编码（encoding）。在目前的主流操作系统里，通常八比特是一个基本单位，也就是字节（byte）。最基本的编码方式，就是把一个字节对应到一个字符。

1-2『这里对编码的定义，是目前看到的最简单直接的，做一张术语卡片，哈哈。』——已完成

目前的大部分编码方式，在 0－127 的范围里，字节值和字符的对应关系是基本相同的。除了个别字符外，编码的基本方式都和 ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）兼容，如下图所示：

注意，头 32 个字符和最后一个字符是控制字符，其中大部分现在已经很少有人使用了，但还有一些我们今天仍然会在不同的场合遇到，如马上就会讨论的 LF 和 CR。

ASCII 是美国标准，里面只有基本的拉丁字母，对其他国家来讲可能就不合适。比如对欧洲国家来说，ASCII 既没有带变音符的拉丁字母（如 é 和 ä ），也不支持像希腊字母（如 α、β、γ）、西里尔字母（如 Пушкин）这样的其他欧洲文字，使用起来很不方便。很多其他编码方式使用了 128－255 的字节值范围作为扩展，总共最多是 256 个字符，一次允许一套方式生效，称之为一个代码页（code page）。这种做法，只能适用于文字相近、且字符数不多的国家。比如，下图表示的 ISO-8859-1（也称作 Latin-1）和后面的 Windows 扩展代码页 1252（下图中绿框部分为 Windows 的扩展），就只能适用于西欧国家。

最早的中文字符集标准是 1980 年的国标 GB2312，其中收录了 6763 个常用汉字和 682 个其他符号。至于我们平时用到的编码 GB2312，它更准确的名字其实是 EUC-CN，是一种与 ASCII 兼容的编码方式。它用单字节表示 ASCII 字符而用双字节表示 GB2312 中的字符；由于 GB2312 中本身也含有 ASCII 中包含的字符，在使用中逐渐就形成了「半角」和「全角」的区别。

国标字符集后面又有扩展，这个扩展后的字符集就是 GBK，是中文版 Windows 使用的标准编码方式。GB2312 和 GBK 所占用的编码位置可以参看下面的图（由 John M. Długosz 为 Wikipedia 绘制）：GBK 编码的第一字节和第二字节分布。

图中 GBK/1 和 GBK/2 为 GB2312 中已经定义的区域，其他的则是 GBK 后面添加的字符，总共定义了两万多个编码点，支持了绝大部分现代汉语中还在使用的字。

显然，多个不同的编码方式是不利于信息交换的。我们在打开文本文件时看到的「乱码」，最常见的情况就是文件的编码和打开文件的工具以为的编码不同。毕竟，只要出现了非 ASCII 字符，解释方式就多了。对我们来说，常见的情况是 Latin-1/Windows-1252（西欧文字）、GBK（简体中文）、Big5（繁体中文），今天还增加了 UTF-8。

我们终于说到了 UTF-8，它的全称是 8-bit Unicode Transformation Format，8 比特的 Unicode 转换格式。Unicode 自发明伊始，就是为了统一编码问题，但它的最早编码方式，UCS-2，存在两个重大问题：1）和 ASCII 不兼容，不能在现有软件和文件系统中直接使用。2）在储存 ASCII 为主的字符时，存在一字节变两字节的空间浪费。

Ken Thompson 在 1992 年和 Rob Pike（罗勃·派克）一起发明了 UTF-8，解决了这两个问题（牛人就是牛人啊）。到了今天，UTF-8 已经成了互联网和 Unix 世界里文本文件（含 HTML 和 XHTML）的主流编码方式。但是，Windows 下的文本文件，由于历史原因，可能还大量使用着传统的编码方式（很错误地被叫做 ANSI）；对于中文 Windows，这个传统编码就是 GBK 了。

抛开编码方式的细节（从网上你可以找到足够多的关于 Unicode 和 UTF-8 的资料），我们需要牢牢记住的是，UTF-8 是 Unicode 里最重要的编码方式，可以把一到四字节长度的字节序列映射成为一个 Unicode 字符。目前我们使用的任何字符都可以用 UTF-8 表示，因而 UTF-8 是我们在 Vim 中使用的内部编码（选项 encoding）。我们在第 2 讲中给出 fileencodings 选项设置，就是为了在读写文件时把文件内容进行适当的转换。这个选项表示的是自动检测使用的编码；而在文件被 Vim 载入后，文件的编码会出现在选项 fileencoding 里。如果 fileencoding 选项为空，则表示文件保存时不做任何转换。

关于编码，我们暂时讨论到这里。下面我们讨论一下字符（character）和字形（glyph）。

### 1.3 字符和字形

Unicode 设计时的一个决定，目前看起来有点短视，那就是对中日韩文字中使用到的汉字进行了「统一」。如果字源相同，它们在 Unicode 中就只占据一个编码点。于是，一个字符可能就有多个字形。这个问题，我在第 2 讲中已经展示过了，它也是我们可能需要在图形界面 Vim 中单独设置宽字符字体（guifontwide）的原因。

跟中文字符集中「半角」和「全角」的概念有点像，Unicode 中也有字宽的概念。和简单的半角与全角的区别不同，Unicode 里除了窄字符和宽字符，还有模糊宽度（ambiguous width）字符。这些字符的宽度根据上下文而定：在东亚文字里一般是宽字符，而在西方文字里一般是窄字符。最常用的模糊宽度字符有（「U+」后面跟十六进制数值是用来表示 Unicode 字符所占编码点数值的通常方法）：

```
U+00B0：「°」
U+00B7：「·」
U+00D7：「×」
U+00F7：「÷」
U+2014：「—」
U+2018：「‘」
U+2019：「’」
U+201C：「「」
U+201D：「」」
U+2103：「℃」
```

对于某一特定字体，它们的宽度当然就是确定的；尤其使用变宽字体（大部分英文字体，不同字符宽度不同）时，如在极客时间的正文里，这个模糊宽度没有什么意义。对于使用等宽字体（程序员一般使用的字体，Vim 只能用等宽字体）的文本编辑器，到底是把这些字符显示成跟 ASCII 字符一样的「单」宽度，还是显示成跟汉字一样的「双」宽度，就是一个需要考虑的问题了。

稍微展开一点点，这个模糊宽度，在我们日常生活中还是造成了一点麻烦的。非常常见的一个排版错误，就是由于使用的软件（在中文 Windows 下的）的字体选择规则，西文中的 「’」误用了中文字体展示，导致这个符号展示出来的字间距过宽。一个相反的麻烦，是中文中写「·」希望两侧留空很足，但在另外一些环境下，永远优先选择西文的字体（如大部分的手机操作系统），导致需要手工两侧加空格才能有比较理想的排版效果……

扯远了，这些毕竟不是 Vim 的问题。Vim 里的解决方式是提供选项 ambiwidth，可以设为 single（默认值）或 double，表示 Vim 到底把这些字符的宽度当成是占一个字符还是两个字符，你想怎么样都可以。对于终端 Vim，由于 Vim 不能决定显示的字体，这个选项只能决定光标在这些字符上应当移动的列数，用户必须自己保证在终端里的设定和 Vim 的设定是一致的；否则，可能导致眼睛看到的编辑位置和实际编辑位置不一致。虽然 macOS 的终端应用、Linux 的 GNOME Terminal 和 Windows 下的 PuTTY 都提供了如何处理模糊宽度字体的设定（关键字是「模糊」或「ambiguous」），但鉴于这些软件的字体选择策略，选择「宽」容易导致显示问题，所以我的建议是保留缺省的「窄」设定。

2『字符和字形做一张术语卡片。』——已完成

对于图形界面的 Vim，ambiwidth 选项同时也决定了显示这些模糊宽度字符是使用 guifont 选项还是 guifontwide 的设定。在这种情况下，把 ambiwidth 设成 double 才比较有意义：

修改 ambiwidth 主要影响的是一行的长度，而 Vim 具有根据行长来进行断行的功能。下面，我们先来看一下什么是行。

### 1.4 行

从 Vim 和 Unix 的角度看，一个文本文件由多行构成，每一行都以一个行结束符（EOL）结束。根据传统习惯，这个 EOL 在存盘时使用的字符是 LF，编码值是 10（U+000A）。这只是 Unix 格式。常用的还有 DOS 格式（也包括了 Windows），以及老的 Mac 格式。

在 DOS 格式里，行尾就不只使用 LF 这一个字符了，在 LF 前面会多一个 CR，编码值为 13（U+000D）。这个用法的来源是以前的打字机，CR 表示机架归位（carriage return），LF 表示换行（line feed）。在使用 CR LF 作为行结束符的系统里，CR 只负责光标回到第一列，而 LF 负责光标向下一行。

老的 Mac 则使用单个 CR 字符作为行结束符，但苹果从 Mac OS X（2001 年）开始就使用了 Unix 风格的行结束符。所以，目前我们遇到的文本文件，应当都使用 LF 或 CR LF 作为行结束符了。这也是 Vim 的 fileformats 选项的意义：它的默认值通常是 unix, dos（Unix 环境下）或 dos, unix（Windows 环境下），即会自动检测 Unix 和 DOS 行尾；如果检测不到，则以第一个风格设置作为默认值。

fileencodings 有一个对应的文件相关的 fileencoding 选项，跟它一样，fileformats 也对应有一个文件相关的 fileformat 选项，表示当前文件的行尾风格。需要注意的是，如果一个文件里既有 LF 行尾、又有 CR LF 行尾的话，Vim 会把文件当成 Unix 格式，于是文件里会出现最后一个字符显示成「^M」（通常为蓝色，表示是控制字符，跟正常文本不同）的情况。如果你想保留这种行尾，那不需要做任何事情。但绝大多数情况下，你会希望把行尾统一成 Unix 风格或 DOS 风格。此时，你可以使用下面两种方法之一：1）使用 `:e ++ff=dos` 命令强制以 DOS 行尾加载文件；此时文件的行尾格式是 dos。2）使用 `:% s/\r$//` 命令删除行尾多余的 CR 字符；此时文件的行尾格式保持 unix 不变。

此外，再说明一下，Unix/Vim 的传统是任何一行都以行结束符终结，包括最后一行。使用 Vim 编辑的文本文件，最后一个字符通常是 LF（除非使用 Mac 行尾风格，则结尾是 CR）。Windows 上大部分文本编辑器则允许最后一行不以行结束符结束；这样的文件在 Vim 打开时，Vim 默认会给出一个 `[noeol]` 的提示。在存盘时，Vim 则会自动在最后添加一个行结束符。

除了 Vim，很多 Unix 工具都会有类似的要求。比如，用于文件比对的命令行工具 diff，它在文件比对时如果输出下面的信息，就是表示文件之一没有用行尾结束符来结束：

```
\ No newline at end of file
```

2『行的概念做一张术语卡片。』——已完成

### 1.5 断行

中文文本文件的行文习惯，通常是在一段之中不空行，一段结束了再换行。文本编辑器需要做的，是在行长超过屏幕宽度时自动折行。Vim 虽然也能在这种情况下自动折行，但 Vim 的更惯常用法是欧洲字母文字和源代码的做法，行长有一定的限制（根据惯例，常用值是 72、80、120），到了指定的行长则应当进行断行，用一个空行来明确表示分段。这也是 Markdown 格式里的标准做法：单个换行符仅相当于空格而已。（这个额外插入的空格就是中文一段之中不换行的原因。）

Vim 有一个文本宽度的选项 textwidth，表示插入文字时的最大行宽度。这个选项的全局默认值为 0，表示不进行限制，但 Vim 脚本可能会设置它，你也可以自己在 vimrc 等地方对其进行设置。我自己的设置是文件相关的，如：

```
au FileType changelog  setlocal textwidth=76
```

这个设置，加上对行进行格式化的命令 gq，可以让你方便地对（英文）文本进行整理。gq 命令跟 c、d 等命令一样，可以先在可视模式下选定文本，也可以在命令之后跟动作键。对于源代码，它的妙处在于它知道什么是注释，什么是列表：

动图——设置行宽为 64、使用数字列表，然后格式化注释

1『这里的知识点直觉上很重要，但目前弄不懂。（2020-09-22）』

如果对这些功能有兴趣的话，请查看相关的帮助：`:help gq` 和 `:help fo-table`。我这儿特别要指出的是：1）要能够在无空格的中文之中断行，我们需要有 `:set formatoptions+=m`。2）选项 ambiwidth 会影响行宽的判断，如左右弯引号的宽度算 1 还算 2。3）在 Vim 8.2.0901 之前，Vim 断行时不考虑中文标点符号的规则；要使用 gq 对中文文本断行，最好升级到这个版本或更高版本。

### 1.6 编辑二进制文件

到这里，你已经知道什么是文本和关于文本的基本知识了。Vim 当然是一个文本编辑器，但在某些情况下，它也是可以用来编辑二进制文件的。有几个工具在你必须用 Vim 编辑二进制文件时会有帮助。

首先，Vim 有个 binary 选项和一个 -b 命令行参数。当你通过 -b 命令行参数，或 `:e ++binary …` 命令来打开文件时，binary 选项会自动被设置（用户不应该手动设置该选项）。这个选项保证了，Vim 在读取和存储文件时，不会做会影响文件内容的转换和修改。

不过，即使有这个选项，二进制文件打开后仍然是一堆乱码，这当然是正常的。你除了可以在里面搜索文本之外，还可以利用 Vim 的 Tools（工具）菜单下的「Convert to HEX」（转换成十六进制）和「Convert Back」（转换回）两项，来对二进制文件进行编辑。下面的两张图显示了打开二进制文件后的样子和使用了「Convert to HEX」后的样子：

图片——用二进制模式打开一个 PNG 文件；转换成 HEX 格式后的结果。

不管你是要检查文件中的具体字节内容，还是要修改某个字节，HEX 格式都更方便一些。当然，如果你要把修改写回硬盘的话，一定要先使用「Tools> Convert Back」。如果你有专门的二进制编辑工具的话，Vim 的这个功能可能不那么有用。如果正好你没有安装其他的二进制文件编辑工具，那这个功能还是可以救救急的。要是你使用的不是图形界面，菜单里的这两个命令可以用 `:%!xxd 和 :%!xxd -r` 来手工替代。

### 黑板墙

文中提到的内容，你都应该手工尝试一下。除此之外，如果你平时接触到 GBK/GB18030 和 UTF-8 之外的其他文本编码的话，你可以考虑查看一下插件 [mbbill/fencview: Auto detect CJK and Unicode file encodings](https://github.com/mbbill/fencview)（注意，在 Windows 下你现在也不需要下载 iconv.dll 了：Vim 8 的 Windows 安装包中现在已经包含了 libiconv-2.dll）。如果你使用的是 Linux 或 macOS 的话，可以键入 iconv -l 来看一下 libiconv 支持的编码方式：Vim 内部就是使用 libiconv 来实现编码转换的。过去我们会有一些文件用后缀表示文件编码，比如 .gb 是 gbk 编码，.big5 是 big5 编码，.nfo 是 cp437 编码，你能想出如何正确载入这些文件的方法吗？

一直不明白 setloca 和 set 的区别，老师能说一下么。作者回复：setlocal 设置的是当前缓冲区的选项。你可以全局 tabstop 是 8，但当前缓冲区的 tabstop 是 4。只要这个想象支持本地设置即可。这讲的基本都支持。2020-08-18

`au FileType changelog setlocal textwidth=76`，这里是 changelog 类型的 file，vim 才能修改 textwidth？另外，思考题最后一问，感觉像是 vim 内部存有一个文件后缀名映射到具体编码的 mapping，然后打开文件会根据文件的后缀名和映射关系来确定所使用的文本编码方式？作者回复：是 changelog 类型，上面的脚本才会去设置为文本宽度为 76，这个类型的一个标准宽度吧。「另外」部分，请复习第 8 讲。2020-08-20

## 0202语法加亮和配色方案颜即正义.md

我们现在来总结一下今天学到的内容：1）Vim 使用正则表达式来匹配代码，把代码分到不同的「语法项目」里。2）语法项目可以跟加亮组进行链接，加亮组可以针对终端和图形界面定义不同的显示方式。3）主流的终端可以显示 256 色，某些终端已经可以跟图形界面一样显示 RGB 真彩。4）我推荐了 gruvbox、jellybeans 和 desertEx 三个配色方案；当然，你也可以自己在网上找其他好的配色方案。5）SyntaxAttr.vim 可以显示语法加亮组的细节，可以用来帮助调试语法加亮和配色方案。6）Vim 的加亮效果可以输出成 HTML 文件，也可以复制到剪贴板中成为带语法加亮的富文本，方便在办公文档中使用。本讲我们的配置文件有一些改动，对应的标签是 l12-unix 和 l12-windows。

语法加亮这个功能，我们都非常熟悉。和 vi 刚出现的时代不同，它现在已经成为编程的基本功能了。在我们使用的各种代码编辑器中，都有语法加亮的功能。我们甚至可以拿一句俗语反过来说：没见过猪跑，还能没吃过猪肉么？但是，你有没有想过，语法加亮到底是怎么实现的呢？今天，我们就不仅要尝尝不同「风味」的猪肉，还要进一步看看猪到底是怎么跑的 —— 这样，我们才能选择，然后调整出，最符合自己口味的大菜。

### 2.1 语法加亮

在第 8 讲里，我们已经提到，Vim 的语法加亮依靠的是在 syntax 目录下的运行支持文件。今天，我就通过例子给你解说一下，Vim 里如何实现语法加亮，然后语法加亮又如何映射到屏幕上的颜色和字体。我们先来看一个比较简单的例子，xxd。

xxd 这个名字看起来，是不是有点陌生又有点熟悉？其实，我们在第 11 讲还刚讲过 xxd：它是一个把二进制文件转换成地址加十六进制数值再加可读 ASCII 文本的工具，它的输出格式在 Vim 里也被称作 xxd。不过，在用菜单项或 `:%!xxd` 命令转换之后，Vim 并不会自动使用 xxd 格式。要应用 xxd 格式的语法加亮，我们需要使用自动命令（可以参考 :help using-xxd），或者手工使用命令 `:setf xxd`。下图是对上次的二进制文件使用了 xxd 语法加亮的效果：使用了 xxd 语法加亮的效果。

这个格式的语法加亮足够简单，我们就拿它来分析一下。不过，我有个小建议，你在看具体的语法加亮代码前，先花几秒钟的时间看一下图，自己分析一下里面有几种不同的语法加亮效果。下面我们就来逐步看一下 syntax/xxd.vim 的内容。首先是开头和结尾部分：

```
" quit when a syntax file was already loaded
if exists("b:current_syntax")
  finish
endif

…

let b:current_syntax = "xxd"

" vim: ts=4
```

最后一行的模式行，设定了这个文件使用的 tab 宽度。剩余部分基本上算是语法文件的固定格式了，有一个检查缓冲区变量（使用前缀 b:）、防止语法文件重复载入的条件判断，并在结尾设定这个缓冲区变量为语法的名称。剩余部分可以分为两段。第一段是语法匹配：

```
syn match xxdAddress            "^[0-9a-f]\+:"      contains=xxdSep
syn match xxdSep    contained   ":"
syn match xxdAscii              "  .\{,16\}\r\=$"hs=s+2 contains=xxdDot
syn match xxdDot    contained   "[.\r]"
```

这儿定义了 4 种不同的「语法项目」，其中 1、2 和 3、4 还互相有包含（「contains」）和被包含（「contained」）的关系。1）xxdAddress。它是地址匹配，所以匹配条件是从行首开始的一个或更多的十六进制字符后面跟一个冒号。2）xxdSep。它是分隔符，仅匹配 xxdAddress 中的冒号部分，也算是地址的一部分。3）xxdAscii。它是右边的 ASCII 字符部分，条件是两个空格后面跟最多 16 个字符，然后是可选的 CR 字符（\= 和 \? 效果相同），然后必须是一行结束。4）xxdDot。它是对「.」和 CR 字符的特殊匹配，可以留意一下上面图里「.」和其他字符的加亮效果的不同之处。同样，这个句点也属于 ASCII 字符部分。

上面的正则表达式都比较简单，唯一之前没出现过的是第 3 个正则表达式后面的 hs=s+2：它的含义是语法加亮的起始位置是模式匹配部分的开始位置再加 2（可查看 :help :syn-pattern-offset），这是在语法加亮文件里的常用特殊语法。上面的代码可以从 xxd 格式的内容中找出 4 种不同的语法格式。如何展示这些语法，就要看下面的第二段代码了：

```
" Define the default highlighting.
if !exists("skip_xxd_syntax_inits")

 hi def link xxdAddress Constant
 hi def link xxdSep     Identifier
 hi def link xxdAscii   Statement

endif
```

外面的条件语句不是惯用法，我们可以忽略。里面重要的是三个 hi def link 语句，拼写完整的话是 highlight default link（可参见帮助 `:help :highlight-link`）。这三个语句建立了默认的语法加亮链接组，也就是，在用户没有自己在 vimrc 配置文件中使用 highlight link 来修改语法加亮时，默认的语法项目和加亮组之间的关系。目前，地址 xxdAddress 使用常数 Constant 的加亮方式，冒号分隔符 xxdSep 使用标识符 Identifier 的加亮方式，ASCII 文本 xxdAscii 使用语句 Statement 的加亮方式。

那 xxdDot 到哪儿去了呢？答案是，它没有加亮组，因为我们不需要对其进行特殊加亮。虽然 Vim 会认出它使用了特殊的语法格式，在显示上它和中间的十六进制数值一样，没有任何语法加亮效果。Constant、Identifier、Statement 这些加亮组，又应该以何种方式展示呢？这就是配色方案要做的事情了。如果说语法加亮是逻辑问题的话，那配色方案就是个审美问题。你要个性化的话，就靠配色方案了。

### 2.2 配色方案

类似地，配色方案里包含的也是一些模板语句加上色彩的定义。比如，在配色方案 koehler 里，跟 xxd 相关的核心色彩定义是：

```
set background=dark
hi Normal      guifg=white  guibg=black
hi Constant       term=underline  cterm=bold ctermfg=magenta  guifg=#ffa0a0
hi Identifier     term=underline   ctermfg=brown  guifg=#40ffff
hi Statement      term=bold  cterm=bold ctermfg=yellow  gui=bold  guifg=#ffff60
```

首先，这个配色方案设定背景为 dark，深色（允许的另外一个值是 light，浅色背景）。这会调整缺省的颜色组，使得文字色彩在深色背景上显示比较友好。但这不会在终端里真正改变背景（仍要靠下面的背景色设定），因此，如果你在浅色背景的终端里使用这个配色方案，会显得不太友好。有些比较好的配色方案会采用相反的做法，根据目前是深色还是浅色背景，采用不同的配色。

对于「正常」（Normal）的加亮组，这个配色方案采用了最直截了当的前景白、背景黑。可以预见，这个配色会比较醒（cì）目（yǎn）。对于 Constant 加亮组，这个配色方案就稍微复杂点了，分了单色终端、色彩终端和图形界面的不同配色。古老的单色终端里使用下划线（应该已经没人用吧，所以以后我就忽略这种设定了）；色彩终端下使用粗体和紫色前景；图形界面指定了前景色为 RGB 色彩 #ffa0a0，亮棕色。

Identifier 加亮组也类似，色彩终端下使用棕色前景，图形界面下前景色则是 RGB 色彩 #40ffff，亮青色。Statement 加亮组在色彩终端和图形界面下都使用粗体，色彩终端使用黄色前景色，图形界面使用前景色是 RGB 色彩 #ffff60，亮黄色。

使用这个配色方案在图形界面和色彩终端下的效果，如下面的截图所示：1）图形界面下 koehler 配色方案的效果。2）色彩终端下 koehler 配色方案的效果。

### 2.3 配色方案在终端下的优化

说到这里，我们有必要来讨论一下 Vim 里允许使用的色彩数量。在图形界面 Vim 里，色彩是 Vim 本身调用系统的编程接口来控制的，可以使用 RGB 的所有 16,777,216 种不同颜色。但在终端里，Vim 会受到终端能力的限制，只能根据终端的能力来显示色彩。根据终端的类型，我们可以分为 4 种情况：

第 1 种是最古老的是单色终端，没有颜色，只能使用下划线、粗体等效果。效果定义使用 term=… 的形式。今天，我们应该基本碰不到这样的环境了。

第 2 种是 8/16 色终端，允许使用最基本的八种颜色（黑、红、绿、黄、蓝、紫、青、白），以及这些颜色的较亮变体（即使 8 色终端一般也能在前景色上使用加亮的变体）。我们可以使用 cterm=… 定义粗体等效果（由于兼容性问题，不常用），用 ctermfg=… 和 ctermbg=… 定义前景和背景色，其中可以使用英文色彩名称或序号（见 :help cterm-colors）。鉴于序号在不同的环境里可能是不同的，我们一般使用色彩名称。如果你使用非图形界面终端，可能会遇到这种情况，但这应当也很不常见了吧。这些颜色虽然是标准的，但很多终端允许用户调整这些颜色，以达到最好的色彩组合效果。比如，下图是 macOS 里终端应用的一个设置界面，其中的「ANSI 颜色」就是用户可以调整的 16 种「标准色」：

图片——macOS 终端应用的文本设置界面。

第 3 种是 256 色终端，用户可以选择预先定义的 256 种颜色之一，这在目前的终端里是非常主流的方式了。你可以在网上很方便地找到脚本来输出这些颜色，效果如下图所示：

图片——在 iTerm2 下使用脚本输出的 256 种颜色。

要选择这 256 种颜色中的一种，方式不太直观：你需要使用 ctermfg=… 和 ctermbg=…，并直接写出这 256 种颜色之一的编号。这 256 种颜色都可以算是标准的，它们的标准 RGB 值有明确的定义。头 16 种颜色就是上面的「ANSI 颜色」，在终端里常常可以直接调整，图中也可以看到和前面图里的颜色已经有明显的不同。虽然界面只提供了头 16 种颜色的调整，但为了达到最佳的显示效果，你也可以编程修改这 256 种颜色的调色板。

第 4 种是支持真彩（truecolor）的终端，跟编程修改 256 色的调色板相比，这是更简单的做法。下面是部分比较常见的支持 RGB 真彩的终端（此处是一个更完整的列表）：1）GNOME-Terminal（Linux）。2）iTerm2（macOS）。3）mintty（Windows）。4）命令提示符（Windows 10 版本 1703 及以后；在命令提示符里使用 Vim，如果不启用真彩支持，颜色可能完全错误！）

在这些终端里，终端 Vim 就能显示跟图形界面 Vim 同样多的颜色数，因而能达到最佳色彩效果。你仍需手工打开（默认关闭的）Vim 选项 termguicolors。此后，Vim 就会使用你在  guifg 和 guibg 中写的 RGB 色彩，也就是说，把终端当图形界面一样看待（在色彩方面）。鉴于真彩终端的一个惯例是设置环境变量 COLORTERM 为 truecolor 或 24bit，我们可以在 vimrc 配置文件中进行检查：

```
if has('termguicolors') &&
      \($COLORTERM == 'truecolor' || $COLORTERM == '24bit')
  set termguicolors
endif
```

不过，这个检查方式仅限于类 Unix 平台。对于 Windows，Vim 提供了另外一个专门的特性检查项：

```
if has('vcon')
  set termguicolors
endif
```

### 2.4 推荐配色方案

上面我们分析的 koehler，算是 Vim 内置的配色方案中比较中规中矩的一个，可用，但不那么好看。如果你想要一个漂亮的配色方案，还是不应该在内置配色方案里寻找。一个广受好评的 Vim 配色方案是 gruvbox（包管理器中的安装名称是「morhetz/gruvbox」）。它不仅是一个支持深色背景和浅色背景的配色方案，而且还特意确保自己能和 Vim 的一些最流行插件兼容。下面是这个配色方案的示意截图：

我觉得 gruvbox 在深色背景下还是挺漂亮的。它的颜色总体偏暖，而你如果喜欢深色背景下较为清冷的色彩，我觉得 jellybeans（包管理器中的安装名称是「nanotech/jellybeans.vim」）还不错：

不过，这两种方案我都是偶尔使用，我使用更多的还是明白（mbbill）设计的 desertEx（包管理器中的安装名称是「mbbill/desertEx」）的一个版本。它的特点是无加亮的普通文字对比度设得比较低，读起来比较轻松（但加亮部分效果仍然比较强烈）。如果你想试试这个方案的话，可以自己安装尝试一下：

图片——浅色背景下的 gruvbox 效果图；深色背景下的 gruvbox 效果图；使用深色背景的 jellybeans 效果图；desertEx 效果图（非最新版本）

3『

[morhetz/gruvbox: Retro groove color scheme for Vim](https://github.com/morhetz/gruvbox)

[nanotech/jellybeans.vim: A colorful, dark color scheme for Vim.](https://github.com/nanotech/jellybeans.vim)

[mbbill/desertEx: A desert based scheme with enhanced colors.](https://github.com/mbbill/desertEx)

』

### 2.5 检查 / 调试配色方案

如果你想自己对配色方案进行调整的话，有一个小工具肯定会非常有用，那就是 vim-scripts/SyntaxAttr.vim。不过，这个插件不会自己添加键映射，需要你在用包管理器安装之后，自己在 vimrc 配置文件中加入类似下面的语句：

```
nnoremap <Leader>a :call SyntaxAttr()<CR>
```

这样，我们就能用 \a 来检查光标下面的语法高亮详情了。下面是一个示例：检查光标下文本的加亮组。

从上面可以看到，constexpr 属于 cppStorageClass 语法加亮组（这是在 syntax/cpp.vim 中定义的），并且被链接到了 Type 加亮组。后面的 guifg 和 gui 设定就是 Type 加亮组的内容：使用色彩 tan1（RGB 值为 #ffa54f），特殊效果为粗体（bold）。在你自己设计、调试语法文件或配色方案时，你会发现这个工具非常有用。

### 2.6 输出加亮效果

作为一个文本编辑器，Vim 只接受文本的复制和粘贴。如果你想要在一个（非 Markdown）文档中展示有语法加亮的代码，Vim 也是可以用来产生这样的代码的 —— 通过 HTML 输出。

Vim 默认就提供了 :TOhtml 命令（参见第 4 讲中讨论的系统内置插件），可以把当前展示的语法加亮效果输出为一个 HTML 文件。你可以根据最终文档的要求，选择合适的深色或浅色配色方案，然后使用该命令来输出 HTML。这个命令默认输出整个文件，你也可以自己在可视模式下选定范围，或者用逗号隔开的行号选定范围，这样 :TOhtml 命令就只会输出选定范围的 HTML 代码。

这个方式灵活是挺灵活，但不能直接把带色彩加亮的文本贴到文档里去，终究还是不太方便。令人欣慰的是，早就有人找到了在各个平台上把 HTML 代码转成剪贴板富文本的方法。我最近对一个 Vim 插件 vim-copy-as-rtf 作了点改造，使其可以在我们现在讲的三大主流平台（macOS、Linux 和 Windows）上都可以直接复制出带语法加亮的代码。在 macOS 和 Windows 上，没有特别的配置要求；在 Linux 桌面环境下，我们要求系统必须装有 xclip 工具。这样，我们只需要在使用 TOhtml 的地方，把命令改成 CopyRTF 就能把加亮的代码复制到系统的剪贴板中。

### 黑板墙

想一想，如果希望颜色在 8/16 色终端下和 256 色终端下都有效，并且在 256 色终端下使用 256 色的配置，该怎么做？在自己尝试解决这个问题之后，可以看一下 jellybeans 里面的颜色定义，了解它是如何解决在不同终端下面的颜色一致性问题的。

今天收获最大的就是这个 `termguicolors` 参数了。有了它，vim 的显示效果立马提升了好几个档次。最近也折腾过 256 色，但总感觉配置的颜色跟实际显示的有些偏差。对于在 tmux 中使用 vim 的同学来说，这篇文章可能会有帮助：[How to use true colors in vim under tmux?](https://github.com/tmux/tmux/issues/1246)。2020-08-21

老师给的这 3 个配色方案是直接用插件下载安装后就可以生效吗？我试了一下，下载了第 3 个插件（mbbill/desertEx）下来，Mac 下的图形界面的配色还是没有改变。试着在配置文件里加了 set bg=dark 还有 syntax on，但是不起作用。用 vim-scripts/SyntaxAttr.vim 插件查看 .vimrc 文件中的关键字，输出是：

```
group: vimCommand->Statement guifg=#ffff60(#ffff60) gui=bold
```

主要是 Mac 图形界面的关键字是深紫色，高亮和不高亮区别不是特别明显。还是想弄个清晰一点的配色，望老师指点。作者回复：在你的 vimrc 中用 colorscheme 命令选择配色方案了吗？可以先直接在 Vim 里手敲命令试验效果，用「colorscheme desertEx」、「colorscheme gruvbox」这样的命令。2020-08-28

作者回复：我完全不知道你的问题出在哪里，怎么回答你？我只能说的，我的 sudo vim 是没问题的。但我一般也不这么用，因为容易出权限问题。如果我需要用 root 权限编辑的话，我更愿意先 sudo su -l，再进行编辑。2020-08-24

## 0203YouCompleteMe自动完成.md

在本讲中，我们主要介绍了 YouCompleteMe 这个重量级插件，包括其安装和配置。我们可以看到，在插件的帮助下，我们可以获得不输于集成开发环境的自动完成体验，同时，仍然享受 Vim 的快速启动和强大编辑功能。最后我们花了一点点时间介绍了 RTags 工具和 vim-rtags 插件，它在你写 C 族语言而不能使用 clangd 引擎时会特别有帮助。YCM 的参数和键映射我写到了示例配置文件里，对应的标签是 l13-unix 和 l13-windows。

在集成开发环境里，自动完成是一个非常重要的功能。可是 Vim 并不能真正理解你输入的代码，因此它自身无法提供自动完成的功能。不过，Vim 仍然提供了一些接口，允许第三方的软件实现这样的功能，并和 Vim 自身进行集成。[ycm-core/YouCompleteMe: A code-completion engine for Vim](https://github.com/ycm-core/YouCompleteMe)（简称 YCM）就是这样的一个第三方软件，今天，我就为你详细介绍一下它。

YCM 对 C++ 程序员最为适合，它可以提供其他工具实现不了的功能。而且，它也适用于很多其他语言，包括 C 家族的各种语言和其他常用的语言，如 Python、Java 和 Go 等。即使在 YCM 不直接支持你使用的语言的时候，它仍然能通过标识符完成功能提供比没有 YCM（和其他语言支持插件）时更好的编辑体验。因此，我推荐你使用这个插件。

### 3.1 功能简介

首先我来介绍一下 YCM 的基本功能吧。根据它的主页（我的翻译）：

YouCompleteMe 是一个快速、即输即查、模糊搜索的 Vim 代码完成引擎。它实际上有好几个完成引擎：1）一个基于标识符的引擎，可以在任何编程语言中工作。2）一个强大的基于 clangd 的引擎，可以为 C/C++/Objective-C/Objective-C++/CUDA（C 家族语言）提供原生的语义代码完成。3）一个基于 Jedi 的完成引擎，可以支持 Python 2 和 3。4）一个基于 OmniSharp-Roslyn 的完成引擎，用来支持 C#。5）一个基于 Gopls 的完成引擎，支持 Go。6）一个基于 TSServer 的完成引擎，支持 JavaScript 和 TypeScript。7）一个基于 rls 的完成引擎，支持 Rust。8）一个基于 jdt.ls 的完成引擎，支持 Java。9）一个通用的语言服务器协议（LSP）实现，用来支持任何其他有 LSP 服务器的语言。10）还有一个基于 omnifunc 的完成器，使用 Vim 的全能补全（omnicomplete）系统提供的数据来为很多其他语言提供语义完成。

其实，Vim 里的自动完成插件并不止这一个，但 YCM 是比较成熟也比较全面的。虽说它的安装配置有一定的复杂性，但比起另外一些要求你独立安装、配置语言服务器的方案，它至少能一次性搞定插件和你需要的语言支持，所以反而算是简单的了。我最近的主要开发语言是 C、C++、Python 和 Vim 脚本，因此这也算是个很完美的匹配了。下面是一个简单的示例，展示了 YCM 的效果。

总体上，你只要在 YCM 给你提示的时候，敲 `<Tab>` 来选择合适的选项，然后继续往下输入就行。由于 YCM 使用模糊匹配，你只要输入你希望的标识符中的每一段中的若干字符，就可以快速把候选项减到你要的内容敲一两下 `<Tab>` 就能出来。事实上，我后来发现，在 `std::` 后只要输入 mu 就足以让 `make_unique` 成为第一选择了。

不过，这里面最让我吃惊的还是，clangd 引擎居然能在我只提供部分头文件的情况下（完全不提供是不行的），自动帮我插入正确的头文件并保持其字母序排列。这个功能我以前还真还没有见过！

### 3.2 安装

#### 3.2.1 Ubuntu 下的 apt 安装

如果你使用一个较新的 Linux 发布版，有可能系统本身已经自带了 YCM。虽然这个版本多半会有点老，但对于有些人来说，可能也够用了。毕竟，Linux 下的包安装确实方便。我们就先以 Ubuntu 为例，来介绍 Linux 包管理器下的安装过程。首先，我们需要使用 apt 命令来安装 YCM，命令是：

```
sudo apt install vim-youcompleteme
```

这步成功之后，YCM 就已经被安装到了你的系统上。不过，在你个人的 Vim 配置里，仍然还没有启用 YCM。要启用的话，可以输入下面的命令：

```
vim-addon-manager install youcompleteme
```

这个命令之后，你会在你的 `～/.vim/plugin` 目录下看到 youcompleteme.vim 的符号链接。这样，安装就算完成了。

#### 3.2.2 手动安装

如果你的系统不直接提供 YCM，或者你想要使用最新版本的 YCM，那你就需要手工编译安装了。安装之前，你需要确保你的系统上有 CMake、Python 3 和平台主流的 C++ 编译器，即 Linux 上的 GCC，macOS 上的 Clang，及 Windows 上的 MSVC。如果要安装其他语言（如 Java 和 Go）的支持，也同样要准备好相应语言的环境，这些在 YCM 的主页上有介绍，我就先不多说了。

因为 YCM 是一个需要编译组件的插件，所以我不建议你用 Vim 的包管理器来安装，那样会出什么错都搞不清楚。大致安装过程是：1）选择安装目录。2）签出 YCM。3）根据你需要使用的语言使用合适的选项，来进行编译安装。下面，我们就快速地过一下。

首先，我们需要给 YCM 一个独立的安装目录。这个目录应该在 pack 下面，但不要放在包管理器使用的目录下，以免发生冲突。我的选择是「我的」，my。因为希望 YCM 直接启动，所以最后需要放到这个目录的 start 子目录下。换句话说，Unix 上的 `～/.vim/pack/my/start`，Windows 上的 `～\vimfiles\pack\my\start`。

然后，我们就应当在这个目录下签出 YCM。可以在进到这个子目录里面后，使用下面的命令（Windows 下面去掉「\」全部写一行，或者把「\」换成「^」）：

```
git clone --recurse-submodules \
          --shallow-submodules \
    https://github.com/ycm-core/YouCompleteMe.git
```

最后就是编译安装了。主要工作由 install.py 来完成，但如果我们不提供额外的选项，YCM 不会安装上面说的那些特定语言的语义完成引擎。我们需要显式地提供相应语言的选项：

```
--clang-completer，基于 libclang 的老 C 族语言引擎

--clangd-completer，基于 clangd 的新实验 C 族语言引擎

--cs-completer，C# 引擎

--go-completer，Go 引擎

--rust-completer，Rust 引擎

--java-completer，Java 引擎

--ts-completer，JavaScript 和 TypeScript 引擎

--all，除 clangd 外的上述索引引擎
```

1『

进入「YouCompleteMe」文件夹后，编译命令：

```
./install.py --clangd-completer
./install.py --go-completer
./install.py --rust-completer
./install.py -java-completer
./install.py --ts-completer
```

想了想还是全装了，反正电脑配置高，哈哈。（2020-09-22）

```
./install.py --all
```

卡在 go 语言上，因为目前 mac 上还没装 go 的编译器，以后补上。（2020-09-23）

』

关于 clangd，我多说一句。虽然这个引擎被标为实验状态，但它的易用性和功能确实比老的引擎有了巨大的提升。同样是上面的代码，如果用老的 libclang 引擎的话，效果是这样的：使用 libclang 的自动完成示例（动图）。

我们可以看到：1）老版本不会添加 #include 结束的 > 或 "。2）老版本不会自动添加头文件。3）老版本不会提供函数原型提示。4）老版本不会在输入中时刻提醒当前有错误（这倒不算是件坏事）。

所以，如果你编译和使用 clangd 支持没有问题，那就用它吧。对我来说，使用 libclang 引擎可能有两个理由：1）clangd 支持编译不过（我遇到过）。2）机器配置低，clangd 太慢了（我的机器上能感到性能差异，但 clangd 的响应速度完全可以接受）。你可以同时安装这两个引擎，然后通过你的 vimrc 配置文件来选择使用哪一个，使用 `let g:ycm_use_clangd = 0` 就是使用老引擎，这个值设为 1 或者干脆不设，则是使用新引擎。

另外一个要提醒你的地方是，编译环境应尽可能干净，不要暴露出自己用的第三方库的路径。我就碰到过因为环境变量里设了 Boost 库的包含路径，从而导致 YCM 编译出错的情况。YCM 自己已经包含了所需的依赖库，系统的和用户自己安装的类似库如果版本不合适的话，反而会对 YCM 造成干扰。（此外，也告诉你一下我编译 clangd 时遇到的失败情况，也供你参考一下。我的原因是自己编译了 Python 3，由于系统上缺了一些开发包，导致 Python 功能不完整，到运行 YCM 的安装脚本时才暴露出来。我很高兴我后来花点时间解决了问题，因为 clangd 的功能真的强大很多。）

### 3.3 配置

#### 3.3.1 项目配置

像我上面的简单例子，YCM 是可以不需要配置就能直接工作的。但如果环境稍微复杂一点，C/C++ 程序就可能会出现识别错误。原因通常是以下三种：1）头文件没找到，可能是因为项目内部路径比较复杂，也可能是因为编译器的头文件不是在 Clang 查找的默认位置下面。2）项目需要特别的宏定义。3）项目需要特定的 C 或 C++ 标准，或特定的编译器选项。这些情况如果出现的话，你需要让 YCM 了解项目的相应信息。

YCM 在 clangd 下的推荐做法是在源代码或其某个父目录下放一个 CMake 输出的 `compile_commands.json` 文件（可在 cmake 命令行上加上 `-DCMAKE_EXPORT_COMPILE_COMMANDS=1` 来产生此文件）。这种方式最为通用和严格，因为 CMake 输出的这个编译命令文件里包含每一个源文件的编译命令，因此只要你的 CMake 配置是正确的，YCM 通常就能正确识别，哪怕你每个文件的编译选项不同都没有关系。它可以给 YCM 提供完整的项目编译信息，使得查找一个符号的引用成为可能。如果你的工程里，这个文件产生在一个 build 目录下的话，别忘了你需要在项目的根目录下执行类似下面的命令：

```
ln -s build/compile_commands.json .
```

使用 `compile_commands.json` 也有缺点。CMake 在这个编译命令文件里放置的是绝对路径，因此，把源代码放在一个共享位置供不同的系统使用就会有麻烦。此外，只有少数 CMake 产生器支持 `CMAKE_EXPORT_COMPILE_COMMANDS`，特别是，Windows 上默认的 Visual Studio 产生器不支持输出这个文件。抛开这些问题，如果项目比较大的话，clangd 的「编译」会消耗 CPU 和内存，也是一个可能的负面因素。但我们同时要记住，这种开销是让 YCM 能看到整个项目而不只是单个文件的代价。

如果因为某种问题你决定不使用编译命令文件这一方法，那 YCM 的经典做法是在文件所在目录或其父目录下寻找一个名字叫 .ycm_extra_conf.py 的文件。找到之后，它就会弹出一个提醒，提示用户是不是要载入这个文件，运行其中的代码来得到需要的配置信息。

图片——YCM 的配置载入提示

虽然这个恼人的提示可以关掉，但这实际上会带来潜在的安全问题，毕竟 YCM 是会运行其中的 Python 代码的。此外，写这个文件也算是件麻烦事吧，尤其对不熟悉 Python 的人而言。

在 2014—2015 年期间，有人维护了一个叫 ycmconf 的插件，以一种我喜欢的方式解决了这个问题。不过，今天再直接用这个插件，就有点问题了。所以我在 GitHub 上复刻了这个插件，并进行了更新。如果你使用 YCM 进行 C 系语言的自动完成，那我推荐你安装 adah1972/ycmconf 这个插件。

这个插件支持两种简单的方式来配置 C/C++ 的自动识别：1）使用 CMake 输出的 `compile_commands.json` 文件（由于 YCM 目前已经直接支持该文件，这只对较老版本的 YCM 有意义）。2）使用上一讲（拓展 2）里用的 `.clang_complete` 配置文件。

目前我当然是以第 2 种方式来使用这个插件了：手写一个 `.clang_complete` 很简单，非常适合临时写的小程序。但它的问题是，这个文件对整个目录有效。所以如果你在其中写了像 `-std=c++14` 这样的选项，选择某一特定 C++ 标准，那这个选项对于 C 文件就是错的了，YCM 就会抱怨。不过解决起来也很容易，像上面说的情况，让 C 文件单独占一个子目录或者平行目录都可以消除此问题。不管是哪种方法，你都需要确保配置文件在源代码的目录下或其父目录下。YCM 和 ycmconf 的搜索规则都是从源代码的所在位置往上找有没有满足文件名约定的文件，并在找到第一个时终止。

#### 3.3.2 全局配置

YCM 有很多命令，但它默认只对少量的功能进行了键映射，其中最重要的就是 `<Tab>` 了。在使用中，我觉得自动修正和跳转功能值得单独进行一下键映射：

```
nnoremap <Leader>fi :YcmCompleter FixIt<CR>
nnoremap <Leader>gt :YcmCompleter GoTo<CR>
nnoremap <Leader>gd :YcmCompleter GoToDefinition<CR>
nnoremap <Leader>gh :YcmCompleter GoToDeclaration<CR>
nnoremap <Leader>gr :YcmCompleter GoToReferences<CR>
```

自动修正功能可以参考下图的演示。（动图——YCM 自动修正功能的演示）

自动修正的范围很广，小到修正一个拼写错误或者漏写名空间这样的问题，大到提供安全方面或代码风格现代化的调整（它可以利用你的 [Clang-Tidy — Extra Clang Tools 12 documentation](https://clang.llvm.org/extra/clang-tidy/) 配置来向你报告错误和提供修正建议）。有了它，编码工作真的轻松了许多。

我们这儿有四种跳转：1）GoTo，无脑跳转，最常用的就是这个功能，如果能跳转到定义，就跳转到定义，否则就跳转到声明。2）GoToDefinition，顾名思义，就是跳转到定义。3）GoToDeclaration，专门跳转到声明。4）GoToReferences，可以用来查出一个符号被引用的地方（libclang 引擎不支持该命令）。

注意，对 C 族语言来说，只有让 clangd 看到你的项目的 `compile_commands.json` 文件，才能使用 GoToReferences 这个命令查找整个项目里符号被引用的地方；否则，你只能查出当前 Vim 里可见的引用，而非整个项目。

YCM 有很多配置参数，有些在默认状态下工作得不是很好。我通常会配置下面这些：

```
let g:ycm_auto_hover = ''
let g:ycm_complete_in_comments = 1
let g:ycm_filetype_whitelist = {
      \ 'c': 1,
      \ 'cpp': 1,
      \ 'python': 1,
      \ 'vim': 1,
      \ 'sh': 1,
      \ 'zsh': 1,
      \ }
let g:ycm_goto_buffer_command = 'split-or-existing-window'
let g:ycm_key_invoke_completion = '<C-Z>'
```

第一项 `ycm_auto_hover` 用来禁用光标在一个符号上长期停留出现的自动文档提示。未禁用时的效果如下图：YCM 的自动浮动提示。这个自动提示不能说一点用都没有，但它很容易成为写代码时的干扰，所以我还是把它禁用了。

第二项 `ycm_complete_in_comments` 表示我希望在写注释的时候也能启用自动完成 —— 毕竟注释里通常也要写代码里的变量、函数名什么的。

第三项 `ycm_filetype_whitelist` 用来仅对白名单列表里的文件类型才启用 YCM。没有这一项，YCM 在打开一些特殊类型的文件时可能会报错，有时候也会导致打开的延迟。我就明确一下，让它只在我常用的源代码类型里才启用。

第四项 `ycm_goto_buffer_command` 用来告诉 YCM，当跳转的目的文件尚未打开时，用分割窗口的方式打开新文件；如果已经打开则跳转到相应的窗口。其他的可能值是 'same-buffer'，在同一个缓冲区的位置打开（除非这个位置因为文件修改的原因不能被替换），及 'split'，除非跳转目的在同一个文件，永远在新分割的窗口打开。

第五项 `ycm_key_invoke_completion` 用来定义手工启用语义完成的按键。在你输入时，YCM 会自动尝试标识符匹配，而当你输入 .、->、:: 或这个按键时，YCM 则会启用语义完成，来给出当前上下文中允许出现的符号。这个按键默认是 `<C-Space>`，在某些操作系统上是不能用的（如 Mac 和老的 Windows），所以我改成了 `<C-Z>`。你也可以选择你自己喜欢的按键（但要注意映射冲突问题：Vim 里在插入模式下的可用键不多，事实上只有在终端下容易出问题的 `<C-S>` 和 `<C-Z>` 在 Vim 里没有默认功能）。

### 3.4 使用

说了这么多，实际上 YCM 大部分使用方法我也已经提到了。它基本上只要你使用 `<Tab>` 就能使用，你如果不理睬它的提示，它也不会对你造成什么干扰（我遇到过一些 Vim 的插件，虽然能提供些有用的提示，但是会侵入式地影响正常输入，那就只能删除 / 禁用了）。其他最重要的功能，我们也已经进行了按键映射，上面也都有了初步的描述。

还有一个可能有用的命令，不能通过按键映射，那就是重命名的重构。这个命令需要你把光标移到要修改的符号上，然后输入的命令里要有新的名称。比如，如果你要把一个 foo 符号重命名成 bar，需要把光标移动 foo 上面，然后输入：

```
:YcmCompleter RefactorRename bar
```

命令虽然略长，但你一样可以用 `<Tab>` 来自动完成，所以你多打不了几个字符的。YCM 默认只在屏幕底部显示当前行的问题，并且显示很可能被截断。要看到所有的代码问题，可以使用命令 `:YcmDiags`。此外 YCM 还有一些调试命令，一般不需要使用，我这边就不介绍了。你可以自己在帮助文档里查看。

### 3.5 RTags（选学）

因为有段时间我只能用 libclang 引擎，不能查找符号的引用，因此我安装了另外一个开源工具，RTags，来弥补这一缺憾。在使用 clangd 的情况下，RTags 已经不那么必要了。它仍然提供了一些特别的功能，并且 Linux 发布版里可能仍只提供了 libclang 引擎的 YCM，因此我就把这部分作为选学提供了，相当于本讲内部的一个小加餐。爱折腾并且使用非 Windows 环境（RTags 尚不支持 Windows）的小伙伴们可以把这部分读完，其他人就跳到内容小结吧。

#### 3.5.1 安装

这次我就只讲自己构建安装的大概过程了。如果你的平台支持二进制安装，相信你应该可以自己搞定了。首先我们要安装 [Andersbakken/rtags: A client/server indexer for c/c++/objc[++] with integration for Emacs based on clang.](https://github.com/Andersbakken/rtags) 本身。安装前，我们需要确认所在的平台有 CMake、C++ 编译器和 libclang 的开发包。这些都有了之后，我们选一个目录，执行下面的命令就可以编译安装了：

```
git clone --recursive https://github.com/Andersbakken/rtags.git
cd rtags
mkdir build
cd build
cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -DCMAKE_BUILD_TYPE=Release ..
make -j4
sudo make install
```

在这些命令都正常执行之后，你就已经把 RTags 的命令安装到了 `/usr/local` 下面。随后我们安装 RTags 和 Vim 集成的插件。这个比较简单，用你的包管理器安装 `lyuts/vim-rtags` 即可。在配置文件里，我通常只做一处调整：

```
let g:rtagsUseLocationList = 0
```

这是因为 vim-rtags 默认使用位置列表（location list）而不是快速修复窗口。我们之前没有介绍过位置列表，我就快速引用一下文档：

位置列表是一个窗口局部的快速修复列表。由 `:lvimgrep`、`:lgrep`、`:lhelpgrep`、`:lmake` 等命令产生，它们生成位置列表而不是对应的 `:vimgrep`、`:grep`、`:helpgrep`、`:make` 生成的快速修复列表。位置列表和窗口相关联，而每个窗口都要单独的位置列表。一个位置列表只能和一个窗口相关联。位置列表和快速修复列表相互独立。

我通常不怎么使用位置列表，主要是为了简单，可以使用固定的快捷键。

#### 3.5.2 运行和项目配置

RTags 是一个客户端 / 服务器端架构的程序。但它不是用 TCP/IP，而是 Unix 域套接字，一个用户只能运行一个服务器，可以支持多个客户端。启动服务器端的命令非常简单，就是：

```
rdm &
```

我这儿用了 &，让 rdm 在后台运行，但输出仍能直接从终端上看到。在我们刚开始学习使用 RTags 时，我们仍需多多监控 rdm 的输出。在某个项目中启用 RTags，最简单的方式就是使用 CMake 输出的 compile_commands.json 文件。我们只需要在这个目录下执行以下命令：

```
rc -J .
```

随后我们就能看到运行 rdm 的那个窗口屏幕哗哗地翻滚，忙着「编译」代码。等到 rdm 忙完了，项目索引就算完成了。而当你修改代码时，rdm 会看到你修改，然后就会自动编译相关的文件，保持索引为最新。有没有注意到我上面编译 RTags 的命令已经生成了 compile_commands.json 文件？所以，如果你没有现成的其他 CMake 项目，你可以用这个项目本身来进行搜索。

#### 3.5.3 使用

如果我们使用默认的 vim-rtags 键映射的话，我们只需要把光标移到一个符号上面，然后输入 \rf（理解为 find references）即可。下面是一个示例：Vim-rtags 的使用示例。这个结果出来的速度比用 `:grep` 可快多了！它还有很多其他命令，可以用来查找定义、查找父类、查找子类、显示调用树，等等。有些功能在 YCM 里并没有对应物，这也是 RTags 的价值了。你可以在 vim-rtags 的主页上查看学习所有这些命令及其快捷键。

### 黑板墙

今天学完之后的主要任务，当然就是把 YouCompleteMe 装起来、配置好了。它的使用反而是相当简单的，大部分情况下使用 `<Tab>` 就行。至于 RTags，Unix 下的 C++ 程序员们可以根据自己的兴趣，决定是否捣腾一下。这个工具还是有点可玩性的。

说一下用后感吧，跳转的速度和精度上比 vscode 和 clion 要迅速很多，就是快捷键比较多，得多用熟能生巧才行。另一个就是得 `ctags+cscope+YCM+rtags` 一起用才能得到最好的跳转体验。基本就是 `C-] \gt \rj \rT` 轮番上阵，哈哈！整体感觉还是非常良好的，不过如果 CLion 没那么卡和吃内存就好了，CLion 的类继承关系这一块的体验很好，不知道 vim 这一块有没有类似的操作，另外 CLion 的调试也很适合小白使用。但 Clion 经常用着用着就卡死了，尴尬。当然如果 vim 实在玩不转，vscode 和 CLion 还是可以作为替代的，哈哈。最后一点就是高亮配色方案的事，老师好像比较喜欢朴素的色调，但我看多色调习惯了，最后用了 `octol/vim-cpp-enhanced-highlight` 这个插件，但感觉还是挺一般的。不知道有没有大神有啥推荐的配置。作者回复：无论如何，cscope 没有使用的必要了吧，如果你用 C++ 的话。如果用上编译数据库的话，YCM 基本已经满足需求了。ctags 和 rtags 勉强有部分补缺的作用，cscope 我看不出来有啥用处。类继承你是说查看有什么子类吗？这个在 rtags 里有，但如果要跟商业软件比界面的漂亮，那肯定是没戏的。我试了你说的这个插件，还有点意思。但是，跟其他类似插件一样，单纯依赖名字的加亮，在 C++ 里玩不转 —— 把我的很普通的成员变量 next 都当成标准库里的函数名称来加亮了。朴素点，不是为了朴素，而只是不愿看到错误行为时的无奈之举。如果有插件能进行完全正确的加亮，又不会拖慢编辑的速度，我干吗不用呢？2020-09-03

ubuntu 环境按照老师的命令安装 rtags 失败，报错。

```
rtags/src/rct/rct/Apply.h:46:10: error: unknown
type name 'size_t'; did you mean 'std::size_t'?
```

最后直接下载 release 2.3.8 的 tarball 编译成功。作者回复：如果是编译不过，那你可能得向作者报告 bug 了。2020-08-31

安老师给的步骤安装了 YCM，试着编辑了 javascript 文件，感觉有几个地方不是太清楚：1）YCM 中的跳转（GoTo）貌似只能在单个文件中跳转，不能跳转到其它的文件中去？有些时候，如果需要跳转到函数，只能跳转到前面的定义和声明，无法跳转到后面的定义和声明。当无法跳转的时候，右下方会出现 `KeyError: 'file'` 的错误，或者是提示你使用命令不恰当的错误。2）YCM 支持回跳吗？就是跳转到一个定义或者声明处，然后再回到跳转前的地方，感觉这个对浏览代码时特别有用。是不是除了安装 YCM，还得相应安装配套的其它插件（比如 C++ 的话就需要 rtags）。

作者回复：我对 YCM 的 JavaScipt 支持没有细节了解，只能凭经验随便说两句了。1）在 C++ 里，如果没有编译命令文件的支持，也只能支持到差不多程度，但从来没见过跳不到「后面」的情况，毕竟，工具应该是把整个文件的符号分析出来的。2）Vim 的 `<C-O>` 键是跳回，这个跟插件无关，哪儿都可以用。应该按照 YCM 的要求，安装时使用 --ts-completer 选项就行。如果效果不好，那是能力问题。像 C++ 用 rtags 属于老版本引擎能力不足，rtags 本身和 YCM 没有任何集成关系。用了 clangd 引擎就基本上不需要 rtags 了。对于 JavaScript，也许你可以严肃考虑一下 coc.nvim 这个选项。完成引擎本身的开发方式也决定了它的重点，YCM 明显是偏向 C++ 的。而 coc.nvim 本身就依赖于 node.js，在 JavaScript 上如果强于 YCM，我完全不会意外，虽然我没有用过。2020-08-31

我有两个疑问：1）截图里是否使用了 statusline 的插件，我的用了老师的配置，没有显示 [+] /utf-8 / 当前行百分比。2）老师平时写代码会使用括号自动补全吗。作者回复: 1）不是插件，就是手工设置了 statusline。没讲这个是因为大部分人应该会去使用 Airline（后面会讲），大概不会手工设了。现在手机上看不了当前配置，应该就是 [_vimrc.html](http://wyw.dcweb.cn/vim/_vimrc.html) 的样子加上 fugitive 提供的 Git 信息。2）括号补全是个看似很小、实际很复杂的功能。你希望它很自动，同时又希望可以盲打，还能不影响删除之类的操作，都做好不容易。前不久我看到一个看似不错的补全插件，都已经写了一段推荐文字了，结果在编辑某段 Vim 脚本时发现会导致我根本无法删除我想要删除的部分。那就卸载了。不好用的功能不如不用。2020-08-26

有些功能确实很吸引人。比如自动补全时自动用正则过滤候选词。曾经我也折腾过 ycm，但由于有些东西不会用，自己没调通，最终也放弃了。要是能早些看到这篇文章，应该会少走不少弯路。对于老师说的这个重构变量名需要手敲的问题，`:YcmCompleter RefactorRename bar`，在 golang 中有个小插件解决了这个问题，它是用快捷键在命令行触发一个提示框，告知你想把当前光标下的变量重命名为啥，等你输入完毕按回车后再替换。这个功能实现起来应该也不复杂。如果这个重构功能还蛮常用的话，可以折腾一下。如果重命名常用的话，也可以自己定义个短命令，如：`:command -nargs=1 RR YcmCompleter RefactorRename <args>`。2020-08-26

