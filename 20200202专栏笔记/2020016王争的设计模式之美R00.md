## 记忆时间

## 卡片

### 0101. 反常识卡——

这本书的主题核心，就是最大的反常识卡，并且注意时间脉络。

### 0201. 术语卡——代码的可读性

软件设计大师 Martin Fowler 曾经说过：「Any fool can write code that a computer can understand. Good programmers write code that humans can understand.」Google 内部甚至专门有个认证就叫作 Readability。只有拿到这个认证的工程师，才有资格在 code review 的时候，批准别人提交代码。可见代码的可读性有多重要，毕竟，代码被阅读的次数远远超过被编写和执行的次数。

我个人认为，代码的可读性应该是评价代码质量最重要的指标之一。我们在编写代码的时候，时刻要考虑到代码是否易读、易理解。除此之外，代码的可读性在非常大程度上会影响代码的可维护性。毕竟，不管是修改 bug，还是修改添加功能代码，我们首先要做的事情就是读懂代码。代码读不大懂，就很有可能因为考虑不周全，而引入新的 bug。

既然可读性如此重要，那我们又该如何评价一段代码的可读性呢？我们需要看代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。你应该也能感觉到，从正面上，我们很难给出一个覆盖所有评价指标的列表。这也是我们无法量化可读性的原因。实际上，code review 是一个很好的测验代码可读性的手段。如果你的同事可以轻松地读懂你写的代码，那说明你的代码可读性很好；如果同事在读你的代码时，有很多疑问，那就说明你的代码可读性有待提高了。

### 0202. 术语卡——

### 0203. 术语卡——

### 0301. 人名卡——

根据这些证据和案例，找出源头和提出术语的人是谁——产生一张人名卡，并且分析他为什么牛，有哪些作品，生平经历是什么。

维基百科链接：有的话。找一个他的 TED 演讲，有的话。

### 0401. 金句卡——

最后根据他写的非常震撼的话语——产生一张金句卡。

### 0501. 任意卡——

最后还有一张任意卡，记录个人阅读感想。

### 0601. 行动卡——

行动卡是能够指导自己的行动的卡。

## 模板

### 1. 逻辑脉络

用自己的话总结主题，梳理逻辑脉络，也就是在这个专栏的整个地图里，这一章节所在的节点。

### 2. 摘录及评论

## 0000开篇词.md

如果说「数据结构与算法之美」是教你写出高效的代码，那这个设计模式专栏就是教你写出高质量的代码。

1、程序员的看家本领你得练好。

写代码可以说是程序员天天要干的事情，要是代码都写不好，最基本的看家本领都练不好，成天堆砌烂代码，写代码还有啥意思呢？那还干啥程序员啊！写出「能用」代码的人比比皆是，但是，并不是每个人都能写出「好用」的代码。只会写能用的代码，我们永远成长不成大牛，成长不成最优秀的那批人。

后来我熟练掌握了各种编写高质量代码的技巧、方法和理论，我发现，实际上，写烂代码和好代码花费的时间是差不多的。当你把写高质量代码培养成一种开发习惯之后，在你在编写代码的时候，自然就有一种代码质量意识，自然而然就可以写出不错的代码。即便在我离开 Google 加入其他公司之后，项目的代码质量因为各种原因有所妥协，但我起码知道什么样的代码是高质量代码，丝毫不影响我具备写出高质量代码的能力。

我相信，很多工程师都很重视代码质量，毕竟谁也不想写被人吐槽的烂代码。但是，就我的了解来看，毫不夸张地讲，很多工程师，甚至一些 BAT 的员工，代码都写得惨不忍睹。一方面，在目前这种快糙猛的开发环境下，很多工程师并没有太多时间去思考如何写高质量代码；另一方面，在烂代码的熏陶下，在没有人指导的环境里，很多工程师也搞不大清楚高质量代码到底长什么样。

这就导致很多工程师写了多年代码，代码功力一点都没长进，编写的代码仍然只是能用即可，能运行就好。平日的工作就是修修补补、抄抄改改，一直在做重复劳动，能力也一直停留在「会干活」的层面，就像高速路上的收银员，只能算是一个「熟练工」。

2、一个人闷头看书效果并不好。

当然，也有一些比较上进的工程师，会去找设计模式、编码规范、重构等类型的书籍去看，学习如何编写高质量的代码。实际上，我也买了很多这类的书籍来看，从这些经典的书籍中，我也学到了很多编程技巧和提高代码质量的方法。

不过，这些书籍都有一个特点，那就是比较偏重理论讲解，喜欢拿猫、狗之类生活中的例子来举例。当然，这样的例子也有优点，那就是能在简短的时间和篇幅内，很好地帮你理解原理。但同时也存在一个严重的问题，那就是过于脱离真实的软件开发。而且例子本身没有难度，你一看就觉得懂了，但是看完之后，可能还是不清楚如何将理论落地到实际的项目编码中。

比如，我们都知道著名的 KISS 原则（Keep It Simple and Stupid）。这个原则理解起来很简单，一看貌似就懂了，那我问你，怎样的代码才算是足够简单呢？怎样才算不够简单需要优化呢？估计很多人都回答不上来，因为大部分书籍都没有讲清楚。

除此之外，一个人自己闷头看书，在很多时候效果并不好。一方面，每个人的理解能力是不一样的。对于同一本书，不同理解能力的人看完之后收获也是不一样的。跟着有经验的老师学比闷头自己看书要更高效、收获更多、成长更快。另一方面，编码本身就是一门实践课，光闷头看书本理论肯定是不够的，更重要的是在实践中学习如何应用这些理论。

3、一对一手把手指导才最有效。

1『又见学徒模式。』

从我的经验来看，我觉得最有效、最快速提高编码能力的方法就是，找一个比你资深的工程师，一对一、手把手地指导你写代码。你提交代码，他来指出你的问题，你再优化，这样一来一往，要不了多久，你就会发现，自己的代码能力突飞猛进。

但是，理想很丰满，现实很骨感。且不说能不能找到这样有资格指导你的人，即便能找到，他愿不愿意、有没有时间来手把手指导你，还是另外一回事。而我比较幸运，在毕业之后就加入了 Google，得到了顶尖工程师的指导，一对一地给我 review 代码，手把手地指导我如何优化代码。正因如此，在 Google 的那段时间也成为了我编码能力提高最快的一段时间。

所以，在设计专栏的初期，我就在想，如果我能模拟这样一个一对一、手把手、就真实项目代码讲解的场景，是不是就能让专栏有别于千篇一律的书籍，从而能真正提高你的代码能力呢？基于这样一个想法，我们接下来就来看，我是如何设计整个专栏内容的。

## 0001尽早地学习并掌握设计模式相关知识.md

为什么要学习设计模式相关的知识，主要有这样五点：1）应对面试中的设计模式相关问题；2）告别写被人吐槽的烂代码；3）提高复杂代码的设计和开发能力；4）让读源码、学框架事半功倍；5）为你的职场发展做铺垫。

很多程序员都已经意识到基础知识的重要性，觉得要夯实基础，才能走得更远，但同时对于如何将基础知识转化成开发「生产力」仍然有些疑惑。所以，你可能看了很多基础的书籍，比如操作系统、组成原理、编译原理等，但还是觉得很迷茫，觉得在开发中用不上，起码在平时的 CRUD 业务开发中用不上。实际上，这些基础的知识确实很难直接转化成开发「生产力」。但是，它能潜移默化地、间接地提高你对技术的理解。

不过，我觉得，设计模式和操作系统、组成原理、编译原理等这些基础学科是不一样的。它虽然也算是一门基础知识，但是它和数据结构、算法更像是一道儿的，相比那些更加基础的学科，设计模式能更直接地提高你的开发能力。我在开篇词里也说了，如果说数据结构和算法是教你如何写出高效代码，那设计模式讲的是如何写出可扩展、可读、可维护的高质量代码，所以，它们跟平时的编码会有直接的关系，也会直接影响到你的开发能力。

### 1.2 告别写被人吐槽的烂代码

我们经常说，「Talk is cheap. show me the code. 」实际上，代码能力是一个程序员最基础的能力，是基本功，是展示一个程序员基础素养的最直接的衡量标准。你写的代码，实际上就是你名片。

尽管我已经工作近十年，但我一直没有脱离编码一线，现在每天也都在坚持写代码、review 指导同事写代码、重构遗留系统的烂代码。这些年的工作经历中，我见过太多的烂代码，比如命名不规范、类设计不合理、分层不清晰、没有模块化概念、代码结构混乱、高度耦合等等。这样的代码维护起来非常费劲，添加或者修改一个功能，常常会牵一发而动全身，让你无从下手，恨不得将全部的代码删掉重写！

当然，在这些年的工作经历中，我也看到过很多让我眼前一亮的代码。每当我看到这样的好代码，都会立刻对作者产生无比的好感和认可。且不管这个人处在公司的何种级别，从代码就能看出，他是一个基础扎实的高潜员工，值得培养，前途无量！因此，代码写得好，能让你在团队中脱颖而出。

所以，我的专栏，不仅仅只是讲解设计模式，更加重要的是，我会通过实战例子，手把手教你如何避免刚刚提到的代码问题，告别被人诟病的烂代码，写出令人称道的好代码，成为团队中的代码标杆！而且，写出一份漂亮的代码，你自己也会很有成就感。

### 1.3 提高复杂代码的设计和开发能力

大部分工程师比较熟悉的都是编程语言、工具、框架这些东西，因为每天的工作就是在框架里根据业务需求，填充代码。实际上，我刚工作的时候，也是做这类事情。相对来说，这样的工作并不需要你具备很强的代码设计能力，只要单纯地能理解业务，翻译成代码就可以了。

但是，有一天，我的 leader 让我开发一个跟业务无关的比较通用的功能模块，面对这样稍微复杂的代码设计和开发，我就发现我有点力不从心，不知从何下手了。因为我知道只是完成功能、代码能用，可能并不复杂，但是要想写出易扩展、易用、易维护的代码，并不容易。

如何分层、分模块？应该怎么划分类？每个类应该具有哪些属性、方法？怎么设计类之间的交互？该用继承还是组合？该使用接口还是抽象类？怎样做到解耦、高内聚低耦合？该用单例模式还是静态方法？用工厂模式创建对象还是直接 new 出来？如何避免引入设计模式提高扩展性的同时带来的降低可读性问题？…… 各种问题，一下子挤到了我面前。

而我当时并没有对设计模式相关的知识（包括设计模式、设计原则、面向对象设计思想等）有太多的了解和积累，所以一时间搞得我手足无措。好在因此我意识到了这方面知识的重要性，所以在之后很多年的开发中，我都一直刻意锻炼、积累这方面的能力。面对复杂代码、功能、系统的设计和开发，我也越来越得心应手，游刃有余。写出高质量代码已经成为了我的习惯，不经意间写出来的代码，都能作为同事学习、临摹的范例，这也成为了我职场中最引以为豪的亮点之一。

### 1.4 让读源码、学框架事半功倍

对于一个有追求的程序员来说，对技术的积累，既要有广度，也要有深度。很多技术人早早就意识到了这一点，所以在学习框架、中间件的时候，都会抽空去研究研究原理，读一读源码，希望能在深度上有所积累，而不只是略知皮毛，会用而已。

从我的经验和同事的反馈来看，有些人看源码的时候，经常会遇到看不懂、看不下去的问题。不知道你有没有遇到过这种情况？实际上，这个问题的原因很简单，那就是你积累的基本功还不够，你的能力还不足以看懂这些代码。为什么我会这么说呢？

优秀的开源项目、框架、中间件，代码量、类的个数都会比较多，类结构、类之间的关系极其复杂，常常调用来调用去。所以，为了保证代码的扩展性、灵活性、可维护性等，代码中会使用到很多设计模式、设计原则或者设计思想。如果你不懂这些设计模式、原则、思想，在看代码的时候，你可能就会琢磨不透作者的设计思路，对于一些很明显的设计思路，你可能要花费很多时间才能参悟。相反，如果你对设计模式、原则、思想非常了解，一眼就能参透作者的设计思路、设计初衷，很快就可以把脑容量释放出来，重点思考其他问题，代码读起来就会变得轻松了。

实际上，除了看不懂、看不下去的问题，还有一个隐藏的问题，你可能自己都发现不了，那就是你自己觉得看懂了，实际上，里面的精髓你并没有 get 到多少！因为优秀的开源项目、框架、中间件，就像一个集各种高精尖技术在一起的战斗机。如果你想剖析它的原理、学习它的技术，而你没有积累深厚的基本功，就算把这台战斗机摆在你面前，你也不能完全参透它的精髓，只是了解个皮毛，看个热闹而已。

因此，学好设计模式相关的知识，不仅能让你更轻松地读懂开源项目，还能更深入地参透里面的技术精髓，做到事半功倍。

### 黑板墙

作者反复解释了下学好 dp 的重要性。以前重构过一个 p2p 客户投资后奖励活动【放心，平台未跑路，老板是用心做事的人】。刚开始，他们真的是 if else 的去写每一个活动。我去了后。主要就是参考 yii 框架的实现方法。做了以下解藕，把购买后的奖励分为四块。1）通过配置 rules 来确认是否有奖励资格（首次）。2）清算出奖多少，奖给谁（通常会带上推荐人）（固定额，阶梯算法，比例值，vip 等级等）。3）创建出奖励执行类，（红包，现金，抽奖券 ，积分等） 并执行奖励。4）发送通知 （站内信，短信，微信，邮件 ） （通知会在通知里挂接广告）。离开那公司时特意查了一下，公司共发布了 1700 条个奖励项，给客户返利约 900 万。2019-11-04

1『原来经常听到的 DP 是设计模式的术语。』

做游戏开发相关的工作，日常用到非常多的设计模式，比如：1）对于游戏的设置，ui 和 scene 等等各种 manager 管理类都要用到单例模式。2）创建游戏中各种角色的各种工厂模式还有对象池。3）处理游戏角色的各种状态的有限状态机要用到状态模式。4）在优化复杂游戏场景时会用到享元模式。5）还有游戏引擎本身就用到的组件模式。......2019-11-04

个人认为设计模式主要解决的是扩展和耦合问题。日常使用：1）使用代理模式进行共性化处理，比如说 AOP 思想，将非业务功能和业务功能解耦。a）事务的处理 @Translation。b）系统间上下文的传递 ThreadLocal + restTemplate#intercept 等等。2）使用工厂 + 策略：a）不同优惠种类的计算。b）定制化功能的解耦。3）观察者模式：这个模式的思想，我觉得非常的重要，你可以在许多中间件（mq、zookeeper、netty 等等）乃至生活中都能看到它的影子。a）通过领域事件解耦业务。b）理解 eventloop、epoll 等等。c）通过 watch 实现动态配置、HA 等等。4）责任链模式：pipeline 思想。a）filter。b）理解 netty 中的各种 handler。2019-11-04

单例、工厂、模板、策略。基本的套路就是：单例的工厂类负责创建策略类，但是每个策略类都有共同特性，所以用到了模板模式。类关系就是每个策略类实现策略接口并继承模板类。交由单例的工厂来管理。也有人说这就是模板。跟策略没关，但我认为确实也是策略。场景：医疗系统，药品分为中药，西药，医疗器械等等不同类别，每种类别计算价格方式由相同的算法和不同的算法组成，所以我用了模板和策略。补充：其实最后我发现 spring 有依赖搜索，直接注入 map 就行了。完全不用自己写工厂管理。2019-11-04

老师能不能讲讲函数式编程思想，设计模式都是基于面向对象的，而现在更流行函数式编程。作者回复：函数式编程感觉还是没面向对象流行。2019-11-04

设计模式的重要性看法：1）可以使得代码编写更优雅。2）对学习一些开源框架有很大帮助。3）程序的可扩展性、维护性更好，系统解耦。基于上面的看法结合实际项目说明：1）在新老系统接割的项目中，进行数据回写，用到了策略模式，根据不同的接口码值，进行不同的策略回写。2）在银行前置系统中，用到了模板设计模式，对接不同的三方通道，在模板中定义某些特定的步骤，并加上 hook，具体步骤子类实现。3）责任链模式，在网关系统中用到的 filter 就是责任链模式，把一个请求依次的在过滤器链上进行传输。4）装饰器模式，在普通的微服务提供的 restful 接口中，在请求返回的时给对象添加一些额外的职责。5）门面设计模式，对外提供统一的接口，例如在 springcloud 中提供统一的 feinclient 接口，所有外部系统都通过 feinclient 接口进行接入，从而不关心内部接口的调用实现。6）还有命令设计模式，原来在看工作流的时候不知道这个模式，看的云里雾里，后来才知道原来整个框架用到了命令设计模式，一下子就明朗了很多。所以学习设计模式很重要。还有单例模式、工厂模式等，以上大概就是在工作中用到的设计模式，分享一下，如有不对请指正。2019-11-11

用到过模板模式，单例模式。1）模板模式应用场景：在一个项目的规则引擎中，一个规则引擎有一系列规则过滤，这个过滤步骤基本上是确定的，只是某些步骤在不同的场景下需要相互替换，模板方法定义了方法调用顺序，需要用到一个钩子，让子类去实现这个方法。模板模式解决问题：解决了以后可拓展的问题，如果以后需要在新场景下新增规则方法，只需新增一个类，实现钩子方法即可，不需改动既有代码。2）单例模式应用场景：用于加载项目中需要的配置文件的资源类。单例模式解决问题：解决了资源共用，避免创建出大量资源对象，节省了 JVM 内存资源。2019-11-04

使用经验：1）策略模式：解决开发、测试、预发布、生产环境不同的数据来源、不同的数据处理方式，以及不同的图片加载方式。2）建造者模式：网络通信协议，非常规意义上的 http 请求，更多是 Socket 通信，需要处理大量的参数传递，包装，解析。2019-11-05

## 0002从哪些维度评判代码质量的好坏.md

1、如何评价代码质量的高低？代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁等，这些词汇是从不同的维度去评价代码质量的。它们之间有互相作用，并不是独立的，比如，代码的可读性好、可扩展性好就意味着代码的可维护性好。代码质量高低是一个综合各种因素得到的结论。我们并不能通过单一的维度去评价一段代码的好坏。

2、最常用的评价标准有哪几个？最常用到几个评判代码质量的标准是：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。

3、如何才能写出高质量的代码？要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等等，这也是我们后面课程学习的重点。

在我的工作经历中，每当同事评论起项目代码质量的时候，听到的最多的评语就是：「代码写得很烂」或者「代码写得很好」。用「好」「烂」这样的字眼来描述，非常地笼统。当我具体问到底如何烂、如何好的时候，尽管大部分同事都能简单地罗列上几个点，但往往都不够全面、非常零碎，也切不中要害。

当然，也有一些工程师对如何评价代码质量有所认识，比如，好代码是易扩展、易读、简单、易维护的等等，但他们对于这些评价的理解往往只停留在表面概念上，对于诸多更深入的问题，比如，怎么才算可读性好？什么样的代码才算易扩展、易维护？可读、可扩展与可维护之间有什么关系？可维护中「维护」两字该如何理解？等等，并没有太清晰的认识。

对于程序员来说，辨别代码写得「好」还是「烂」，是一个非常重要的能力。这也是我们写出好代码的前提。毕竟，如果我们连什么是好代码、什么是烂代码，都分辨不清，又谈何写出好代码呢？所以，今天我们就聊一聊关于代码质量评判的相关问题，希望你在学完今天的内容之后，对代码质量的评判有个更加清晰、更加透彻的认识和理解。

### 2.1 如何评价代码质量的高低？

实际上，我们很难通过其中的某个或者某几个词汇来全面地评价代码质量。因为这些词汇都是从不同维度来说的。这就好比，对于一个人的评价，我们需要综合各个方面来给出，比如性格、相貌、能力、财富等等。代码质量高低也是一个综合各种因素得到的结论。我们并不能通过单一的维度去评价一段代码写的好坏。比如，即使一段代码的可扩展性很好，但可读性很差，那我们也不能说这段代码质量高。

除此之外，不同的评价维度也并不是完全独立的，有些是具有包含关系、重叠关系或者可以互相影响的。比如，代码的可读性好、可扩展性好，就意味着代码的可维护性好。而且，各种评价维度也不是非黑即白的。比如，我们不能简单地将代码分为可读与不可读。如果用数字来量化代码的可读性的话，它应该是一个连续的区间值，而非 0、1 这样的离散值。

不过，我们真的可以客观地量化一段代码质量的高低吗？答案是否定的。对一段代码的质量评价，常常有很强的主观性。比如，怎么样的代码才算可读性好，每个人的评判标准都不大一样。这就好比我们去评价一本小说写得是否精彩，本身就是一个很难量化的、非常主观的事情。

正是因为代码质量评价的主观性，使得这种主观评价的准确度，跟工程师自身经验有极大的关系。越是有经验的工程师，给出的评价也就越准确。相反，资历比较浅的工程师就常常会觉得，没有一个可执行的客观的评价标准作为参考，很难准确地判断一段代码写得好与坏。有的时候，自己觉得代码写得已经够好了，但实际上并不是。所以，这也导致如果没有人指导的话，自己一个人闷头写代码，即便写再多的代码，代码能力也可能一直没有太大提高。

### 2.2 最常用的评价标准有哪几个？

仔细看前面罗列的所有代码质量评价标准，你会发现，有些词语过于笼统、抽象，比较偏向对于整体的描述，比如优雅、好、坏、整洁、清晰等；有些过于细节、偏重方法论，比如模块化、高内聚低耦合、文档详尽、分层清晰等；有些可能并不仅仅局限于编码，跟架构设计等也有关系，比如可伸缩性、可用性、稳定性等。为了做到有的放矢、有重点地学习，我挑选了其中几个最常用的、最重要的评价标准，来详细讲解，其中就包括：可维护性、可读性、可扩展性、灵活性、简洁性（简单、复杂）、可复用性、可测试性。接下来，我们逐一讲解一下。

#### 2.2.1 可维护性（maintainability）

我们首先来看，什么是代码的「可维护性」？所谓的「维护代码」到底包含哪些具体工作？落实到编码开发，所谓的「维护」无外乎就是修改 bug、修改老的代码、添加新的代码之类的工作。所谓「代码易维护」就是指，在不破坏原有代码设计、不引入新的 bug 的情况下，能够快速地修改或者添加代码。所谓「代码不易维护」就是指，修改或者添加代码需要冒着极大的引入新 bug 的风险，并且需要花费很长的时间才能完成。

我们知道，对于一个项目来说，维护代码的时间远远大于编写代码的时间。工程师大部分的时间可能都是花在修修 bug、改改老的功能逻辑、添加一些新的功能逻辑之类的工作上。所以，代码的可维护性就显得格外重要。维护、易维护、不易维护这三个概念不难理解。不过，对于实际的软件开发来说，更重要的是搞清楚，如何来判断代码可维护性的好坏。

实际上，可维护性也是一个很难量化、偏向对代码整体的评价标准，它有点类似之前提到的「好」「坏」「优雅」之类的笼统评价。代码的可维护性是由很多因素协同作用的结果。代码的可读性好、简洁、可扩展性好，就会使得代码易维护；相反，就会使得代码不易维护。更细化地讲，如果代码分层清晰、模块化好、高内聚低耦合、遵从基于接口而非实现编程的设计原则等等，那就可能意味着代码易维护。除此之外，代码的易维护性还跟项目代码量的多少、业务的复杂程度、利用到的技术的复杂程度、文档是否全面、团队成员的开发水平等诸多因素有关。

所以，从正面去分析一个代码是否易维护稍微有点难度。不过，我们可以从侧面上给出一个比较主观但又比较准确的感受。如果 bug 容易修复，修改、添加功能能够轻松完成，那我们就可以主观地认为代码对我们来说易维护。相反，如果修改一个 bug，修改、添加一个功能，需要花费很长的时间，那我们就可以主观地认为代码对我们来说不易维护。

你可能会说，这样的评价方式也太主观了吧？没错，是否易维护本来就是针对维护的人来说的。不同水平的人对于同一份代码的维护能力并不是相同的。对于同样一个系统，熟悉它的资深工程师会觉得代码的可维护性还不错，而一些新人因为不熟悉代码，修改 bug、修改添加代码要花费很长的时间，就有可能会觉得代码的可维护性不那么好。这实际上也印证了我们之前的观点：代码质量的评价有很强的主观性。

#### 2.2.2 可读性（readability）

软件设计大师 Martin Fowler 曾经说过：「Any fool can write code that a computer can understand. Good programmers write code that humans can understand.」Google 内部甚至专门有个认证就叫作 Readability。只有拿到这个认证的工程师，才有资格在 code review 的时候，批准别人提交代码。可见代码的可读性有多重要，毕竟，代码被阅读的次数远远超过被编写和执行的次数。

我个人认为，代码的可读性应该是评价代码质量最重要的指标之一。我们在编写代码的时候，时刻要考虑到代码是否易读、易理解。除此之外，代码的可读性在非常大程度上会影响代码的可维护性。毕竟，不管是修改 bug，还是修改添加功能代码，我们首先要做的事情就是读懂代码。代码读不大懂，就很有可能因为考虑不周全，而引入新的 bug。

既然可读性如此重要，那我们又该如何评价一段代码的可读性呢？我们需要看代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。你应该也能感觉到，从正面上，我们很难给出一个覆盖所有评价指标的列表。这也是我们无法量化可读性的原因。

2『提高可读性的方法：代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。可读性做一张术语卡片。』——已完成

实际上，code review 是一个很好的测验代码可读性的手段。如果你的同事可以轻松地读懂你写的代码，那说明你的代码可读性很好；如果同事在读你的代码时，有很多疑问，那就说明你的代码可读性有待提高了。

#### 2.2.3 可扩展性（extensibility）

可扩展性也是一个评价代码质量非常重要的标准。它表示我们的代码应对未来需求变化的能力。跟可读性一样，代码是否易扩展也很大程度上决定代码是否易维护。那到底什么是代码的可扩展性呢？

代码的可扩展性表示，我们在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码。说直白点就是，代码预留了一些功能扩展点，你可以把新功能代码，直接插到扩展点上，而不需要因为要添加一个功能而大动干戈，改动大量的原始代码。关于代码的扩展性，在后面讲到「对修改关闭，对扩展开放」这条设计原则的时候，我会来详细讲解，今天我们只需要知道，代码的可扩展性是评价代码质量非常重要的标准就可以了。

#### 2.2.4 灵活性（flexibility）

灵活性也是描述代码质量的一个常用词汇。比如我们经常会听到这样的描述：「代码写得很灵活」。那这里的「灵活」该如何理解呢？

尽管有很多人用这个词汇来描述代码的质量。但实际上，灵活性是一个挺抽象的评价标准，要给灵活性下个定义也是挺难的。不过，我们可以想一下，什么情况下我们才会说代码写得好灵活呢？我这里罗列了几个场景，希望能引发你自己对什么是灵活性的思考。1）当我们添加一个新的功能代码的时候，原有的代码已经预留好了扩展点，我们不需要修改原有的代码，只要在扩展点上添加新的代码即可。这个时候，我们除了可以说代码易扩展，还可以说代码写得好灵活。2）当我们要实现一个功能的时候，发现原有代码中，已经抽象出了很多底层可以复用的模块、类等代码，我们可以拿来直接使用。这个时候，我们除了可以说代码易复用之外，还可以说代码写得好灵活。3）当我们使用某组接口的时候，如果这组接口可以应对各种使用场景，满足各种不同的需求，我们除了可以说接口易用之外，还可以说这个接口设计得好灵活或者代码写得好灵活。

从刚刚举的场景来看，如果一段代码易扩展、易复用或者易用，我们都可以称这段代码写得比较灵活。所以，灵活这个词的含义非常宽泛，很多场景下都可以使用。

#### 2.2.5 简洁性（simplicity）

有一条非常著名的设计原则，你一定听过，那就是 KISS 原则：「Keep It Simple，Stupid」。这个原则说的意思就是，尽量保持代码简单。代码简单、逻辑清晰，也就意味着易读、易维护。我们在编写代码的时候，往往也会把简单、清晰放到首位。

不过，很多编程经验不足的程序员会觉得，简单的代码没有技术含量，喜欢在项目中引入一些复杂的设计模式，觉得这样才能体现自己的技术水平。实际上，思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。这也是一个编程老手跟编程新手的本质区别之一。

除此之外，虽然我们都能认识到，代码要尽量写得简洁，符合 KISS 原则，但怎么样的代码才算足够简洁？不是每个人都能很准确地判断出来这一点。所以，在后面的章节中，当我们讲到 KISS 原则的时候，我会通过具体的代码实例，详细给你解释，「为什么 KISS 原则看似非常简单、好理解，但实际上用好并不容易」。

#### 2.2.6 可复用性（reusability）

代码的可复用性可以简单地理解为，尽量减少重复代码的编写，复用已有的代码。在后面的很多章节中，我们都会经常提到「可复用性」这一代码评价标准。比如，当讲到面向对象特性的时候，我们会讲到继承、多态存在的目的之一，就是为了提高代码的可复用性；当讲到设计原则的时候，我们会讲到单一职责原则也跟代码的可复用性相关；当讲到重构技巧的时候，我们会讲到解耦、高内聚、模块化等都能提高代码的可复用性。可见，可复用性也是一个非常重要的代码评价标准，是很多设计原则、思想、模式等所要达到的最终效果。

实际上，代码可复用性跟 DRY（Don’t Repeat Yourself）这条设计原则的关系挺紧密的，所以，在后面的章节中，当我们讲到 DRY 设计原则的时候，我还会讲更多代码复用相关的知识，比如，「有哪些编程方法可以提高代码的复用性」等。

#### 2.2.7 可测试性（testability）

相对于前面六个评价标准，代码的可测试性是一个相对较少被提及，但又非常重要的代码质量评价标准。代码可测试性的好坏，能从侧面上非常准确地反应代码质量的好坏。代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。关于代码的可测试性，我们在重构那一部分，会花两节课的时间来详细讲解。现在，你暂时只需要知道，代码的可测试性非常重要就可以了。

### 2.3 如何才能写出高质量的代码？

我相信每个工程师都想写出高质量的代码，不想一直写没有成长、被人吐槽的烂代码。那如何才能写出高质量的代码呢？针对什么是高质量的代码，我们刚刚讲到了七个最常用、最重要的评价指标。所以，问如何写出高质量的代码，也就等同于在问，如何写出易维护、易读、易扩展、灵活、简洁、可复用、可测试的代码。

要写出满足这些评价标准的高质量代码，我们需要掌握一些更加细化、更加能落地的编程方法论，包括面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。而所有这些编程方法论的最终目的都是为了编写出高质量的代码。

比如，面向对象中的继承、多态能让我们写出可复用的代码；编码规范能让我们写出可读性好的代码；设计原则中的单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出可复用、灵活、可读性好、易扩展、易维护的代码；设计模式可以让我们写出易扩展的代码；持续重构可以时刻保持代码的可维护性等等。具体这些编程方法论是如何提高代码的可维护性、可读性、可扩展性等等的呢？我们在后面的课程中慢慢来学习。

### 黑板墙

这块我一直没细分好，经常和同事开玩笑说「代码品味」（尊重大脑的特性，写出可便于维护的代码。程序 = 数据结构 + 算法，算法分 control 相关和 logic 相关。合理的把 control 相关与 logic 相关进行分离就是非常好的套路 ，时间久了，看到违和感重的代码就很敏感了，主要是要求别把代码写死写散，像 dry 等基础原则都没遵守的，烂用全局变量的，创建对象没用框架的 createObj 的，没支持依赖注入的，直接 code review 时会指出 ）。如何才能写出高质量的代码？做中学。我只说我自己，我在每完成一份工作后，都要拿出很大一部分时间来优化重构，自己改自己的代码。「主要套路来源，代码整洁之道，重构 - 改善即有代码设计」这算是我自律的一部分，我很珍惜工作中的开发实践。纯理论的东西学多了，人会飘飘乎乎的，需要实操来落地。2019-11-04

除了小争哥提到的七个评价标准，我认为还有一个评价标准：易 debug。在日常工作中，经常要追查各种线上 case，代码是否易于 debug，会非常影响工程师的追查效率。比如是否有打印详细的日志，是否有 debug 干涉点可以在 debug 模式下打印详细的线上请求信息便于快速定位问题。当然，这一点也可以放在可维护性中。2019-11-05

个人感觉，有的时候为了提高代码的可扩展性和可复用性就会抽象出好多的接口，类和方法。然后代码的简洁性和可读性就降低了。不知道我这样的感觉对不对？作者回复：是的，扩展性和可读性有的时候是相冲突的，后面会讲到的。2019-11-12

怎么感觉您说的可维护性和可拓展性是同一个东西，都是让未来修改某个功能，某个 bug 或者新增功能需求更简单？是不是维护性更针对于现有功能的维护修改，拓展性更针对与未来新增需求的修改？作者回复：扩展主要是指添加功能，维护更广些，添加、修改...可读性和可扩展性都影响到代码的可维护性。除此之外，这些判定标准本身就有点重合，文章中也提到了。2019-11-04

我对好代码理解：1）具备统一的代码规范：类、方法、变量命名达意；代码核心逻辑注释清晰；（可以遵循《阿里巴巴 Java 开发手册》）2）代码模块分层清晰：类似框架层面 controller、service、handler、mapper 各司其职。而在单独的业务开发中也应该借鉴，如争哥说的高内聚、低耦合的特点。3）每个方法代码不易过长，复杂的业务逻辑应该拆分成多个职责单一对方法，进而降低难度，也即保证可读性和灵活性。4）详尽的 wiki 文档 和 业务主流程图。很多互联网公司最流行的就是「口口相传」，对刚接锅的兄弟简直是场灾难，只能一点点啃代码，极大降低工作效率。5）单元测试 junit test。高质量代码必备，该点与第 2、第 3 点是息息相关。个人觉得能写出好的 junit test case 才能真正显示码代码功力。2019-11-07

## 0003面向对象设计原则设计模式编程规范重构的关系.md

在上一节课中，我们讲到，要具备编写高质量代码的能力，你需要学习一些编程方法论，其中就包含面向对象（我们可以把它看成一种设计思想）、设计原则、设计模式、编程规范、重构技巧等。而我们整个专栏的内容也是围绕着这几块展开讲解的。所以，今天我就先来简单介绍一下这几个概念，并且说一说它们之间的联系。

### 3.1 面向对象

现在，主流的编程范式或者是编程风格有三种，它们分别是面向过程、面向对象和函数式编程。面向对象这种编程风格又是这其中最主流的。现在比较流行的编程语言大部分都是面向对象编程语言。大部分项目也都是基于面向对象编程风格开发的。面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。

所以，在专栏的最开始，我们会详细地讲解面向对象编程的相关的知识，为学习后面的内容做铺垫。对于这部分内容，你需要掌握下面这 7 个大的知识点：1）面向对象的四大特性：封装、抽象、继承、多态。2）面向对象编程与面向过程编程的区别和联系。3）面向对象分析、面向对象设计、面向对象编程。4）接口和抽象类的区别以及各自的应用场景。5）基于接口而非实现编程的设计思想。6）多用组合少用继承的设计思想。7）面向过程的贫血模型和面向对象的充血模型。

### 3.2 设计原则

设计原则是指导我们代码设计的一些经验总结。设计原则这块儿的知识有一个非常大的特点，那就是这些原则听起来都比较抽象，定义描述都比较模糊，不同的人会有不同的解读。所以，如果单纯地去记忆定义，对于编程、设计能力的提高，意义并不大。对于每一种设计原则，我们需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景。只有这样，我们才能在项目中灵活恰当地应用这些原则。

对于这一部分内容，你需要透彻理解并且掌握，如何应用下面这样几个常用的设计原则：1）SOLID 原则 - SRP 单一职责原则。2）SOLID 原则 - OCP 开闭原则。3）SOLID 原则 - LSP 里式替换原则。4）SOLID 原则 - ISP 接口隔离原则。5）SOLID 原则 - DIP 依赖倒置原则。6）DRY 原则、KISS 原则、YAGNI 原则、LOD 法则。

### 3.3 设计模式

设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。大部分设计模式要解决的都是代码的可扩展性问题。设计模式相对于设计原则来说，没有那么抽象，而且大部分都不难理解，代码实现也并不复杂。这一块的学习难点是了解它们都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用。

经典的设计模式有 23 种。随着编程语言的演进，一些设计模式（比如 Singleton）也随之过时，甚至成了反模式，一些则被内置在编程语言中（比如 Iterator），另外还有一些新的模式诞生（比如 Monostate）。在专栏中，我们会重点讲解 23 种经典的设计模式。它们又可以分为三大类：创建型、结构型、行为型。对于这 23 种设计模式的学习，我们要有侧重点，因为有些模式是比较常用的，有些模式是很少被用到的。对于常用的设计模式，我们要花多点时间理解掌握。对于不常用的设计模式，我们只需要稍微了解即可。

我按照类型和是否常用，对专栏中讲到的这些设计模式，进行了简单的分类，具体如下所示。

1、创建型。常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。不常用的有：原型模式。

2、结构型。常用的有：代理模式、桥接模式、装饰者模式、适配器模式。不常用的有：门面模式、组合模式、享元模式。

3、行为型。常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。

### 3.4 编程规范

编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节。即便你可能对设计原则不熟悉、对设计模式不了解，但你最起码要掌握基本的编码规范，比如，如何给变量、类、函数命名，如何写代码注释，函数不宜过长、参数不能过多等等。

对于编码规范，考虑到很多书籍已经讲得很好了（比如《重构》《代码大全》《代码整洁之道》等）。而且，每条编码规范都非常简单、非常明确，比较偏向于记忆，你只要照着来做可以。它不像设计原则，需要融入很多个人的理解和思考。所以，在这个专栏中，我并没有花太多的篇幅来讲解所有的编码规范，而是总结了我认为的最能改善代码质量的 20 条规范。如果你暂时没有时间去看那些经典的书籍，看我这些就够了。

除此之外，专栏并没有将编码规范单独作为一个模块来讲解，而是跟重构放到了一起。之所以这样做，那是因为我把重构分为大重构和小重构两种类型，而小重构利用的知识基本上就是编码规范。除了编码规范，我们还会介绍一些代码的坏味道，让你知道什么样的代码是不符合规范的，应该如何优化。参照编码规范，你可以写出可读性好的代码；参照代码的坏味道，你可以找出代码存在的可读性问题。

### 3.5 代码重构

在软件开发中，只要软件在不停地迭代，就没有一劳永逸的设计。随着需求的变化，代码的不停堆砌，原有的设计必定会存在这样那样的问题。针对这些问题，我们就需要进行代码重构。重构是软件开发中非常重要的一个环节。持续重构是保持代码质量不下降的有效手段，能有效避免代码腐化到无可救药的地步。

而重构的工具就是我们前面罗列的那些面向对象设计思想、设计原则、设计模式、编码规范。实际上，设计思想、设计原则、设计模式一个最重要的应用场景就是在重构的时候。我们前面讲过，虽然使用设计模式可以提高代码的可扩展性，但过度不恰当地使用，也会增加代码的复杂度，影响代码的可读性。在开发初期，除非特别必须，我们一定不要过度设计，应用复杂的设计模式。而是当代码出现问题的时候，我们再针对问题，应用原则和模式进行重构。这样就能有效避免前期的过度设计。

对于重构这部分内容，你需要掌握以下几个知识点：1）重构的目的（why）、对象（what）、时机（when）、方法（how）；2）保证重构不出错的技术手段：单元测试和代码的可测试性；3）两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次）。

希望你学完这部分内容之后，不仅仅是掌握一些重构技巧、套路，更重要的是建立持续重构意识，把重构当作开发的一部分，融入到日常的开发中。

### 3.6 五者之间的联系

关于面向对象、设计原则、设计模式、编程规范和代码重构，这五者的关系我们前面稍微提到了一些，我这里再总结梳理一下。

1、面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。

2、设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，「开闭原则」是很多设计模式（策略、模板等）的指导原则。

3、设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。

4、编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。

5、重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。

实际上，面向对象、设计原则、设计模式、编程规范、代码重构，这五者都是保持或者提高代码质量的方法论，本质上都是服务于编写高质量代码这一件事的。当我们追本逐源，看清这个本质之后，很多事情怎么做就清楚了，很多选择怎么选也清楚了。比如，在某个场景下，该不该用这个设计模式，那就看能不能提高代码的可扩展性；要不要重构，那就看重代码是否存在可读、可维护问题等。

### 黑板墙

今天课堂讨论的话题有两个。1）在今天讲到的内容中，你觉得哪一部分内容对提高代码质量最有效？为什么？2）除了我罗列的这些内容之外，你还知道哪些可以提高代码质量的方法？我们知道，最经典的设计模式书籍是 GoF 的《设计模式》，它的中文全称是《设计模式：可复用面向对象软件的基础》，英文全称是「Design Patterns: Elements of Reusable Object-Oriented Software」。为什么它在标题中会特意提到「面向对象」呢？

函数是相对比较小的可复用单位。面向对象把可复用单位提升到类层次。设计模式把可复用单位提升到框架层次。2019-11-04

我觉得今年对我来说，是重新认识「面向对象」的一年。今年事我工作的第三年了，年初的时候误打误撞的学了一段时间的 DDD，让我瞬间感受到了什么才是面向对象编程，之前自己做的都是用面向对象的语言写面向过程的代码。究其原因，可能是 MVC 三层架构的影响，太多人的代码里头只剩下了 pojo 这种贫血模型。封装，继承，多态，抽象是啥，早就忘干净了。

在软件设计方面，很多人习惯了一开始就设计数据库表结构，结果就是代码逻辑跟数据库构成了强耦合，数据库一改，代码基本上会被改个彻底。在这种情况下，我们用的 java 面向对象的语言，结果却写的是面向过程的代码，这种代码基本没有可维护，可扩展，更没有可测试性一说。所以，面向对象的这个词语，被太多的人只是挂在嘴边上了，落实到代码里边，就成了面向过程。

在意识到这个问题后，我花了一段时间重新回顾了一遍面向对象的知识，并试图用来改进代码质量，这个过程是充满坎坷的，我总结了一些自己的体会：1）要真正落地面向对象编程，面向对象设计是前提，没有面向对象的设计意识，写着写着就成了面条代码。2）以前只知道封装、继承、多态，全然忽视了最重要的抽象，抽象是封装、继承、和多态的基础。合理的抽象源于对业务主体的合理分析和认识。合理的抽象，应该是自洽的，易于理解的。3）关于组合和聚合的关系，最核心的区别就是生命周期的区别，组合关系中，整体和部分是一个整体，离开了整体，部分没有意义，同时产生，同时销毁，而聚合关系中，部分单独存在也可以是有意义的。4）别滥用继承，继承的作用更多的时候使用多态的特性。

关于 UML ：在工作的过程中，试着画过 UML 图，UML 图有着自己一条完整的语言和生态，学习成本还是相当高的，问题在于，即使用了标准的 UML 图，如果沟通过程中，对方不懂，也依然效果不大，所以我对 UML 的感觉就是：能看懂，会画基本的即可，没必要太追求标准化，虽然如此，但是 UML 还是很重要的，它的意义是提供一种面向对象设计的表达方式，是学习面向对象设计中不可缺少的一部分（个人理解）。2019-11-11

个人认为重构对提高代码质量最有效，原因：1）重构的基础就是面向对象、设计原则、设计模式、编程规范；2）重构是一个持续的过程，能够兼顾项目进度、项目开发效率和项目质量，既可以避免前期的过度设计，又能避免后期代码腐化，从而保证代码的质量不下降以致不断提高代码质量；3）通过单元测试等相关手段，保证重构的正确性。4）重构可从代码层次、项目阶段、开发周期、人员规模等不同纬度进行。其他提高代码质量的方法：1）阅读高质量框架代码，先模仿；2）代码 Review，定期总结；3）技术分享，倒逼输出，看了、做了都不如说给比人听更有效果；4）工具检查（如 lint、leakcanary 等），开发过程中避免常识性错误和隐藏问题。为什么它在标题中会特意提到「面向对象」呢？因为设计原则、设计模式实现大部分都是基于面向对象的特性（封装、抽象、继承、多态）实现的。2019-11-06

面向对象的特征也未必包含「继承」这一点吧，比如 Go 语言就没有提供「继承」这个特性，取而代之的是，推荐使用「组合」。但不能说它不支持面向对象编程。那么我们在探讨「面向对象」这个范式时，需要更深刻的去思考「面向对象」的本质是什么。而不是用 Java 中的概念来一以概之。2019-11-05

再好的理论，应用不到实际中也是白费。所以对于提升代码质量，最有效的是编码规范，其次是设计原则，再次是代码重构，最后才是面向对象和设计模式。整个排序是按照我理解的难易程度来进行的。一般一个项目都是多人开发，多人并行开发中，考虑到团队中技术水平不一，保持代码质量最好的方式就是先制定编码规范，大家最容易达成一致并遵守。其次是设计原则，因为它相对来讲更明确，违反设计原则基本等于硬伤，更容易得到认同。代码重构是需要长期去做的，甚至不是在开发过程中而是在维护过程中去做的，所以排在第三位。后面两项更多的要考虑实际情况，不同水平的人甚至相同水平的人都会有自己不同的理解，比较难以达成统一，项目排期足够还好，一旦排期不足，很可能在当时没那个成本去谈论这些。第二个问题老师已经回答了，因为面向对象的特性是其他的基石。建议老师在后续课程中，除了讨论如何提升自己的代码质量，也讨论一下在一个多人团队中如何提升团队的代码质量，有哪些比较好的手段可以去应用。包括在项目排期比较紧的时候，可以有哪些方式去保证代码质量。作者回复：嗯嗯，加餐里有讲到的。2019-11-15

编码规范和设计原则解决的是可读性和可维护性，而面向对象是一种设计方法或者说是一种抽象思维，更符合人类的思考方式，所以它们的属性偏向于静态的概念；代码重构和设计模式是一种动态的概念，是具体的执行方法，当然代码重构本身就包含了：编码规范，设计原则，设计模式。另外，面向对象和设计模式本身就有着紧密的联系，设计模式是解决特定问题的有效方法，是经验的总结。2019-11-06

从依赖关系上看，设计模式 & 编码规范依赖设计原则，设计原则依赖面向对象 | 面向过程 | 函数式编程，也就是面向对象这种设计思想是基础，作为工程师，我们直接打交道的是设计模式和编码规范，这是我们落地设计原则和面向对象设计思想的地方，看问题抓本质，那么我们讲面向对象编程到底在讲什么呢？我的理解是通过封装、继承、多态和抽象这些特性完整表达一件事情，可以是名词也可以是动词。直观的例子是如何把大象装进冰箱这个案例，面向过程是：1）打开冰箱；2）把大象装进去；3）把冰箱关上，依次完成这些过程就能把大象装进冰箱。好，我们看看面向对象怎么处理这个问题，1）冰箱你给我把门打开；2）冰箱你给我把大象装进去；3）冰箱你给我把门关上。看起来是否没啥区别，这里每个动作都多了执行者，也就是这里的冰箱，也就是冰箱会有三个功能：开门、装大象、关门，也就是每一个动作都必然会有一个执行者，执行者怎么产生呢？不就是对象本身么，冰箱是一个对象，大象也是一个对象，冰箱具有装大象的能力，怎么装呢，开门、装大象和关门啊！发现了么，面向对象隐藏了装大象的细节，冰箱的开门、装大象和关门都是对象本身的功能（方法），理解了面向对象后才能更好理解设计原则设计模式这些东西，这些都是一些写出高质量代码的经验总结，说白了就是套路，我理解设计原则可以帮助我们看懂一些开源框架的代码，学习 Apache 大佬们是怎么写代码的，从而内化为自己的能力。最后想说一点高质量代码的实践，多考虑异常和兜底场景，给代码留出足够的安全边际，所以说健壮性很重要啊。2020-02-14

对于重构，我有话（槽）要说（吐）：我是做企业项目外包的，我们给客户交付的项目大多在客户方面庞杂缺少弹性的 IT 合规性要求和业务快速变动的现实的双重夹击下痛苦地演进着。重构意味着不改变系统已有功能的情况下优化项目代码，但面临着合规性和流程的限制导致这类无业务功能更新的发布不会被甲方 IT 放行；另一方面不断的新需求的变更又不断地劣化着已有代码的系统架构以及业务代码的设计。不知道有没有面临同样问题的同学，在无法改变现有大环境的前提下进行有限的优化？我们现在能做的也就是在每一次追加的新需求变更时进行小幅度的改善，但这无法受到任何工作流程的保护和管理，仅能靠程序员个人的良心来做。另外，如何保证重构不会因为代码结构的变化引入新的 bug 呢？单元测试以及覆盖率较高的自动化测试吗？作者回复：单元测试是一个非常有效的手段，后面的章节中会讲到。2019-11-05

回答：1）针对第一个问题，我觉得重构挺重要的。看过《Head First 设计模式》，以及今天老师也说了，设计模式其实不是滥用，是有需要的时候用，不能过度使用。那这些判断从哪来，就是从一步步的重构而来。程序和功能都是从易到难，从简单到复杂，这就形成大家总结的设计模式，都是无数前人的经验总结。因为编码经验还不够，所以除了老师的这些讲解，我暂时还没想到其他更多的。2）面向对象，真是个神器的东西。因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。所以，很多时候编程就是对面向对象一个深刻运用的过程，我师傅就和我说，Java 开发，一切皆对象，我觉得到现在为止，还是挺在理的。2019-11-15

接口是对行为的抽象，是某一类行为所具有的共性或者需要遵循的标准，比如策略模式，定义了一组不同方式方法的抽象实现，而抽象类是是对公共行为的一种复用，将相同的逻辑，行为复用在抽象类中，比如模板模式，定义了公共实现，不同的实现延迟到子类当中去。个人感觉面向对象是一切设计原则设计模式的基础，依赖倒置与里氏替换依赖的的也是面向对象的抽象与多态，最开始上学的时候其实对编程感觉是懵懂的，也看过设计模式，当时看懂了，其实不会用，后来工作了才发现，当你自己主动的注意自己的代码，自己的逻辑，希望写的代码可复用，简单高效的时候，回过头来，这些已经是设计原则，设计模式了，在读这些文章或者书籍感觉更有味道了。2019-11-10

写单元测试是有效提高代码质量的一种方式。并且你在写出能够可测试，易于测试的代码的时候，已经在不断的修改你的代码。并且在编写各种测试用例的时候，你已经将各种边界条件或者特殊情况已经考虑进去了。最终的代码覆盖率也能提醒你哪些部分是还没有经过测试的。所以，写单元测试吧！2019-11-09

关于编码规范：阿里巴巴 java 开发规范，官方已提供了 idea、eclipse 插件，详情可以访问官方链接：[p3c/README.md at master · alibaba/p3c](https://github.com/alibaba/p3c/blob/master/README.md)。此外还有 FindBugs、PMDPlugin、CheckStyle、JavaNCSS、sonarlint，可以多管齐下，为你保驾护航。2019-11-08

## 0902设计模式重构编程规范等相关书籍推荐.md

1、《设计模式》。学习设计模式，不知道 GoF 的《设计模式》估计会被人笑话的。这本书是设计模式的开山之作。经典的 23 种设计模式最早就诞生于这本书。这本书很薄，只有 200 多页。但是，我个人觉得，这本书还是比较晦涩难懂的。回想起来，我在读大学的时候，就读过几遍此书，但每次都是一知半解，读一遍忘一遍。如果你是设计模式的初学者，不建议从这本书看起。如果你对设计模式已经有所了解，还是蛮推荐你去看下这本经典书的。

2、《Head First 设计模式》。如果说刚刚提到的《设计模式》是最经典的设计模式书籍，那《Head First 设计模式》就是最通俗易懂的。这本书看起来很厚，但每页里的内容并没有那么密集。这本书最大的特点就是口语化、场景化。整本书围绕几个人的对话来展开。里面的例子比较脱离实践，但比较容易看懂。如果你之前对设计模式没有太多了解，这本书无疑是你的首选。

3、《Java 与模式》。这本书可能并没有那么多人知道，出版的时间也比较久远，而且是跟 Java 语言比较紧耦合，里面很多例子都是在剖析 JDK 里的设计模式。不过这可能是最贴近实战的一本设计模式书籍了，里面包含的实战案例，应该是目前我读过的设计模式书籍中最多的。不过，我个人觉得文笔稍微有些晦涩，有些内容可能要反复读一下才能理解。如果你熟悉 Java 语言，在我推荐的其他书籍都看完的前提下，没事的时候可以看看这本书。

4、《深入浅出面向对象分析与设计》。这本书跟《Head Frist 设计模式》都是出自「Head First」系列，写作风格也相同，不过也略显啰嗦。从书名中我们就可以看出，这本书主要是讲面向对象分析和设计。实际上，很多关于面向对象分析和设计书籍都侧重讲 UML，讲得真的好的书籍却并不多。除此之外，我觉得面向对象分析和设计的理论知识并不多，关键还是实践。所以，如果你工作比较忙，看我的专栏就足够了。如果你特别想系统地学一下的话，看看这本书也完全足够了。

5、《代码大全》。这是一本有近千页大部头。不过，这本书讲的东西很杂，不是很聚焦，涵盖了软件开发方法、编程技巧、编码规范、重构等等诸多方面。书如其名，这本书其实更像是软件开发方面的工具类的百科全书。在读过我推荐的其他书籍之后，这本书快速地翻一遍就可以了。

6、《代码整洁之道》。这本书非常值得推荐。它主要是讲编码规范，除此之外，还讲到了一些有关设计原则、单元测试、并发编程的东西。因为内容比较侧重编码规范，所以每个知识点都非常明确，能够很容易落地指导你的开发，能够立竿见影地改善你的代码质量。

7、《编写可读代码的艺术》。从书名我们就可以看出，本书主要是教你如何写出可读性好的代码，实际上也是在讲比较偏向细节的编码规范。它的内容跟《代码整洁之道》有部分重复，但是推荐你也看一下。《代码整洁之道》《代码大全》《编写可读代码的艺术》三本书是讲编码规范方面的三大著作。看完这三本书，基本的编码规范你就掌握全了。

8、《重构》。这本书的作者是 Martin Fowler，他写了很多跟软件开发相关的经典书籍。这本《重构》无疑是他最经典的作品。书中讲到了诸多代码的坏味道，并且给出了相应的改进方法，是作者一手开发经验的总结输出。我推荐本书的原因倒不是说书里面的内容有多真知灼见、让人耳目一新，而是这本书的内容总结得非常全面，很适合帮你去做一个整体、系统的梳理。

9、《重构与模式》。我们之前讲过，设计模式一个重要的应用场景就是代码重构。这本书主要讲如何应用设计模式来重构代码，改善代码设计。如果说《重构》是讲如何做低层次的重构，那这本书就是在讲如何做高层次的重构，也就是我们专栏中要讲到的小重构和大重构。这本书非常推荐你读一下，它能让你知道，为什么要用设计模式，如何有的放矢地应用设计模式，而非只是无痛呻吟。

10、《修改代码的艺术》。如果说《重构》那本书是从编码规范上来讲如何重构，《重构和模式》是从设计模式上来讲如何重构，那这本书可以粗鲁地归为从面向对象设计思想、设计原则上来讲重构。除此之外，这本书更偏向于教你如何来重构，不像上面两本书那样聚焦，所以是一个很好的补充。这三本书合起来称为重构「三部曲」。这本书的示例代码是用 C++ 写的，不过也很容易看懂，很推荐你读一下。

### 黑板墙

这两本不应该缺：[敏捷软件开发：原则模式与实践](https://book.douban.com/subject/1140457/)，java 的必读 [Effective Java](https://book.douban.com/subject/27047716/)，其实如果不提编码规范（其实我更喜欢顺着英文的说法叫做风格指南或者约定之类的，规范不规范的，很像扣帽子，其实很多时候很难用对不对来评价，但高下之分还是很明显的），而且代码大全都算进来了，那 [程序员修炼之道，从小工到专家](https://book.douban.com/subject/5387402/) 不得不列吧，这列起书单来，发现好书还真是不少，比如 [UML 和模式应用](https://book.douban.com/subject/1792387/)，这本书我觉得 UML 在其次，主要是少有的系统介绍 GRASP 的书，就像 uncle bob 那本老书系统介绍 SOLID 一样；还有一本，[OOD 启思录](https://book.douban.com/subject/1178238/)，看过的都会感受到它的力量的... 这么说起来，其实这些书互相推荐的数目里面还能挖掘出很多捏。2019-12-01

《设计模式之蝉（第二版）》很不错。代码整洁之道读了三遍，收益颇多。我还建议阅读码农翻身和程序员修炼之道从小工到专家。2019-12-01

## 0903聊一聊Google是如何做Code-Review的.md

### 3.1 为什么国内企业不重视 Code Review？

在专栏第 80 讲中，我列举了 Code Review 的重要性，在项目中执行 Code Review 会带来哪些好处，以及如何克服一些常见的难题，在项目中启动 Code Review 等等。今天，我们想再继续这个话题，和你聊一下 Code Review。不过，我刚才也说了，今天的内容会相对轻松一些，我会主要给你讲讲我在 Google 做 Code Review 的一些经验和心得。

我们都知道，Google 在 Code Review 方面做得非常好，可以说是很多公司学习的榜样。从我个人的经历来说，我的技术成长相当大的一部分得益于当年在 Google 的 Code Review。所以，我也希望更多的同行能意识到 Code Review 的重要性，能够在项目中推行 Code Review，受益于 Code Review。

但据我了解，国内的大部分公司都不怎么接受 Code Review，在开发中，根本没有 Code Review 的流程。所以，我一直思考，到底是什么原因，导致这么优秀的一种开发模式，在国内的技术圈内没有被发扬光大。很多人会认为，主要原因是，项目工期紧，没时间做 Code Review。我觉得这只是表面的原因，最根本的原因还是缺少技术文化传承。

我们知道，普遍而言，越是大公司里的工程师，技术能力会越强，技术影响力会越大。这些公司的工程师，即便跳槽去其他公司，一般都会担任核心成员或者 Leader 的角色。但是，在国内，即便像 BAT 这些输出有影响力工程师最多的一线公司，也没有很好地实践 Code Review，相对应的，这些公司的工程师也就没有一手的 Code Review 的经验和感受，更无法了解到 Code Review 的好处，也更不会在团队、公司，甚至技术圈中去推行 Code Review 了。

打个不恰当的比方，这些一线互联网公司的工程师一直接受着「996」狼性文化价值观的熏陶，即便跳槽去其他公司，作为资深员工或者技术 Leader，他们也会带领新的团队开始 996，最终导致整个 IT 行业的加班氛围都很浓，不加班反倒会显得不正常。用 996 作类比，如果 BAT 这些比较有技术影响力的公司，内部对 Code Review 很认可，执行得非常好，从这些公司往外输出的工程师，就会像我一样，大力传播 Code Review。星星之火可以燎原，慢慢地，整个技术圈就会接受并且推行 Code Review 了。

实际上，据我所知，不只是我，只要是从 Google 跳槽出来的工程师，到了其他公司之后，都特别热衷于传播 Code Review。而且，只要是被 Google 工程师带领过的团队，在开发流程中严格执行过 Code Review 的团队，对 Code Review 都无比认可。所以，我个人觉得，很多人不认可、不推行 Code Review，最直接的原因还是没有经历过 Code Review，没有有经验的人来带。

实际上，才开始接触 Code Review 的时候，我也比较反感。我刚毕业就进入了 Google，在此之前，上学的时候，尽管也写了很多代码，也参与过一些垂直课题的研发，但是，那时候的开发只是为了完成功能，从来没有考虑过代码质量问题、代码设计问题，更别提 Code Review 了。现在想想，自己当时对 Code Review 的认知水平，跟现在很多国内工程师的认知其实是差不多的。

所以，在一开始进入 Google 的时候，对于 Code Review 我也是不怎么接受的。我第一次提交的代码不足百行，就被 Leader Review 出了 n 多问题，而且大部分问题都非常细节，比如变量的命名不够达意、注释不够规范、多了一个空行、少了一个空格之类的。对于这些琐碎的细节，我当时心里挺排斥的，心想：我是来「造火箭」的，为什么成天纠结于这些「拧螺丝」的事情呢？

现在回去想想，当时的想法真的挺幼稚的。如果站在团队协作的角度来看，对于一个长期维护、多人参与、代码比较多的项目来说，代码的可读性、可维护性等与质量相关的问题，是非常重要的。所以，Code Review 作为保证代码质量的最有效手段之一，也就非常有必要了。如此吹毛求疵地执行 Code Review，看似非常极端，但也表明了公司强硬的态度、坚定的立场，就是要把 Code Review 执行彻底。这也是 Code Review 没有在 Google 流于形式的一个很大的原因。

在入职一段时间后，来来回回经过多次 Code Review 之后，我的代码质量整体提高了很多，被 Review 出的问题也越来越少了，我也切身地体会到 Code Review 的好处。因此，慢慢地，对这件事，我从排斥变得认可。与此同时，我也慢慢地开始 Review 别人的代码了。

### 3.2 Google 是如何进行 Code Review 的？

在 Google，我们把每次提交的代码片段叫做一个 CL，全称是 Change List。它就相当于 GitHub 中的 PR（Pull Request）。每个 CL 都要至少一个 Owner 和一个具有 Readability 的同事 Approve，才能提交到代码仓库中。其中，Owner 一般都是技术 Leader 或者项目负责人，而 Readability 是一个证书，表示你具有了写出可读代码、符合编码规范代码的能力。Readability 会细化到每种编程语言，比如 Java Readability、C++ Readability 等。

如果你想申请某种语言的 Readability，你就要提交一段至少包含 100 行代码、并且稍微有点复杂的 CL 给 Readablity 评审委员会。评审委员会会指派一个资深工程师 Review 你的代码，给你一些修改建议，然后，你需要根据修改建议对代码进行修改，再提交 Review。这样来来回回几次之后，他觉得没问题了，就会给你颁发 Readability。有了 Readability 之后，你的 Review 才真的能起到 Approve 的作用。当然，即便没有 Readability，你对同事代码的 Review 本身也是有价值的。所以，并非只有 Readability 的人才能 Review 别人的代码。

在 Google，每种编程语言都有对应的编码规范。但是，Code Review 本身并没有统一的 Check list。在 Code Review 的时候，除了编码规范可以参考之外，大部分都是靠工程师自身的经验来 Review。不过，Review 考虑的也无外乎这样几个常见的方面：代码结构是否合理、代码是否容易理解、业务是否正确、异常考虑是否全面、是否有隐藏的 bug、线程是否安全、性能是否满足业务需求、是否符合编码规范等等。

Code Review 听起来很复杂，要考虑的点很多，但实际上，等到你做熟练了之后，并不会花费太长的时间。一个 CL 从提交 Review 到最终合并到代码仓库，一般也就需要一天的时间。当然，对于一些比较大的 CL、比较复杂的 CL、有比较多争议的 CL，以及一些新手的 CL，可能会花费比较多的时间。但是，大部分情况下，我们都不提倡太大的 CL。太大的 CL 对代码审查者来说是很大的负担，Review 过程会很慢，会导致代码迟迟提交不上去。

对于比较复杂的 CL，我们一般建议要写好文档，或者通过类似 Jira 这样的项目工具，详细描述 CL 的前因后果、上下文背景。这样，代码审查者就能一眼看懂代码包含的设计意图。对于争议比较多的 CL，我们建议直接当面沟通，这样也更加有效率。对于一些新手的 CL，因为他们对编码规范等不熟练，可能来来回回要改好几次，才能满足要求，但这个过程是每个新人都要经历的，多改几次就好了。

实际上，Code Review 并不神秘，如果你想了解更多关于 Code Review 的事情，可以去读一读 Google 官方公布的 Code Review 最佳实践。当然，如果有什么疑问，你也可以在留言区问我。

让国内大部分 IT 从业人士认识到 Code Review 的重要性，形成 Code Review 的技术文化，可能还需要一个漫长的时间。不过，我特别希望，你在学完专栏之后，能够意识到 Code Review 的重要性。有朝一日，当你成了领导，有了话语权、影响力之后，能够推动在团队、公司内进行 Code Review，甚至为 Code Review 在整个国内技术圈中发扬光大贡献一份力量。

### 黑板墙

国内 code review 难推广的一个原因可能也和文化有关，老外习惯直来直往评价和就事论事，中国人为人处世讲究委婉，要面子，特别同级别同事间往往不好意思直接指出别人的问题。作者回复：说的太对了。2020-06-24

原因：1）缺少追求卓越的氛围。先 run 的理念退化成了能 run 就行。2）招聘要求上基本都会有代码设计能力，编码规范，甚至代码洁癖的项。但实际上基本不提，顶多背几个设计模式。那么编码能力就变得很鸡肋，因为它与薪资几乎无关。叫好不叫坐大概就是这个意思。3）重构本是小步快跑，但我看到的大部分都是重写，而非重构。这就导致认知中的重构成本很高，进而就会排斥。而只写代码不重构代码，在编码能力的提升上是很缓慢的。如果把识别坏代码的能力看作是一把尺子。经常重构的人，这把尺子的精度是一毫米，只写功能的人精度只有一分米。那么在识别坏味道评估改动点时就会很模糊，模糊就更不敢下手，恶性循环。

办法：1）氛围，国内的开源项目先开始讲究，带个氛围。2）将编码能力和算法放在同等位置看待。其实编码能力强的人，往往意味着思路清晰，讲究。这种人工作能力一般差不了。3）普及重构理应小步快跑的理念。把事情拆小，把小事情做好，都很重要。重构需要会拆解工作，然后也别看重构手法简单，刻意训练后也会有质变。（重构是提高普遍认知的有效手段，只有认知上去了 codereview 才能被 重视）2020-06-24

## 0904聊一聊Google那些让我快速成长的地方.md

我一直强调，在项目中实践、由点及面的学习，是提高技术最有效的途径。但是，好的技术氛围、培养机制，也能打破通过项目单一成长的限制，获得更多项目之外的收获。很多公司，特别是一些大公司，在关注员工工作效率、工作产出的同时，也十分关注员工的个人成长、职场发展。今天，我就和你聊一聊 Google 有哪些让我快速成长的地方。

### 4.1 完善的培训课程

Google 内部的课程是非常多的。有些是线下分享，有些是线上录播课程。在内容方面，课程也多种多样，有新技术的 DogFood（比如我当年就参加过 Go 语言的），有入门级的 101 教程（比如针对后端工程师的前端入门课），还有比较有深度的系列教程（比如 AI 相关的课程）。所有的课程，只要你感兴趣，都可以自由选择来学习。而且，最近我还听说，Google 有个「G2G」学习计划，全称是 Googler to Googler，意思就是 Googlers 之间互相学习。只要你有值得分享的东西，都可以录制成视频分享给其他同事。同理，你也可以从其他同事那里学习他们分享的技术。

总之，Google 内部有大把的优质课程供你学习，这点对于好学的人来说，是非常幸福的一件事情。而且，得益于以结果为导向的企业文化，Google 非常鼓励员工自我充电学习，不像有些公司反对员工占用上班时间来学习。

### 4.2 公开的文档和代码

除了各种线下和线上的课程之外，Google 还有另外一块非常宝贵的学习资料，那就是文档和代码。在 Google，除了特别核心的一些代码，比如跟搜索质量相关的代码，几乎所有的文档和代码都是公开的，你可以随意查看某个感兴趣的项目的设计文档和代码，比如 Google Adwords 的文档和代码等等。你可能会说，Google 就不怕员工泄露代码吗？在这一点上，Google 相对是比较信任员工的。毕竟在招聘入口上做了过滤，员工本身的素质都不差，这点我们在下一篇加餐中还会讲到。

我们知道，Google 有非常多优秀的开发框架，有些是开源的，有些是还没有公布、只限内部使用的。不管你对哪个开发框架感兴趣，你都可以在公司内部获取到一手的文档资料。通过阅读别人的文档，除了学习这些框架如何使用之外，我们还能学到很多关于设计、架构、解决方案等方面的经验和知识。

实际上，我觉得，代码公开最大好处并非是，你没事的时候就可以阅读别人的代码，毕竟泛泛地去读，效率也不会很高，收获也并不会很大，读完就忘了。相反，我一直强调，带着问题去学习是更有效的一种学习方法。所以，我觉得代码公开最大的好处是，当你想要实现某个功能的时候，或者为实现某个功能绞尽脑汁的时候，你只需要搜索一下代码仓库，就可以找到很多类似的优质代码做参考。对于很多新人或者初级工程师来说，参考别人的设计和实现，这样一方面可以提高开发速度、保证代码质量，另一方面也可以从高手那里学习好的设计思路和实现技巧，提高自己的设计和实现能力。

相反，据我所知，很多公司的代码都是限制访问的，员工只能查看一小部分相关项目的代码，极端情况下，只能阅读自己参与的项目的代码。相对而言，Google 就「大方」很多。除了 Code Review 之外，我觉得，从 n 多 Google 高手的代码中学习设计和实现，是提高代码水平的另一个非常重要的渠道，也是让我代码能力成长最快的地方之一。

### 4.3 清晰的成长路径

除了有那么多课程、文档、代码来供我们自我学习之外，Google 也非常关注员工的个人成长，希望能跟员工共同进步，而不只是将员工当成达成目标的工具。所以，在不同的阶段，公司会帮组员工制定不同的成长计划。

我们知道，像国内的一些大公司，比如 BAT，在新员工入职的时候，一般都会有集中几天的入职培训。我当年加入 Google 的时候并没有这样的培训。我只参加过一次 TGIF（Thanks God It’s Friday）上 NewGoogler 的欢迎仪式。

Google 虽然没有集中的培训，但对于新入职的员工，公司会有一个新人的学习计划，主要涉及编码规范、单元测试、Code Review、开发工具、行为准则等方面的内容。我觉得，这一点对新人来说还是挺友好的。新人可以根据指引，一步一步完成学习计划里的内容，不会因为刚入职还未参加项目，而觉得无事可做。除此之外，在新员工入职时，公司还会分配一个同事作为 mentor（导师）。任何工作、生活中的问题，你都可以向他请教，帮助你快速地融入公司。

除此之外，在工作中，每隔半年，你的 Leader 还会跟你一块制定 OKR，也就是接下来半年你要做的事情，除了工作内容，这里面还会包含你的个人成长部分，比如你可以学习数据挖掘相关的知识，把这部分内容直接写到 OKR 中，这部分甚至可以跟你的工作没有任何关系，只是你对自己的自我提升。

不仅如此，你的 Leader 还会帮你制定升职计划。如果你有意申请下一轮晋升，领导一般会提前跟你一块规划，如何来做才能达成这个目标，比如做什么项目、做哪些有影响力的事情、管理多大的团队等等，也会有意安排一些帮你晋升的事情给你做。

为了不让工程师一直呆在舒适区，Google 还非常鼓励内部转岗，希望员工不要一直做一个项目，鼓励员工跳出舒适区，换岗到其他团队，用不熟悉的语言、不熟悉的技术，去做一些不熟悉的项目。虽然我们知道，内部转岗机制也并非 Google 所特有的，很多公司都有，但是，真的执行得很顺畅的却不多。大部分公司都是跟风喊喊口号，员工真的要转岗的时候，条条关卡、困难重重。

上面的这些机制，貌似也没有什么特别的，很多公司都有。我要特别说的是，在 Google，一对一的沟通非常多，特别是跟自己的 Leader 或者 Manager，一般一两周就有一次，聊一聊自己这周的工作、想法、迷惑。这种沟通也能让你把工作、个人成长中的困难、疑问，及时反馈给领导，领导也可以及时地了解你的想法，对你进行指导，这也能避免很多工程师闷头干活，感觉不爽就立刻离职的情况。

### 黑板墙

回答：1）用近三个月的时间，在迭代中持续重构了近一半的项目代码。并与产品和测试配合，将原有的黑盒业务代码重构，输出白皮书，并最终借着多渠道接入将单流程项目切换成可配置流程的项目。期间没有少发一个需求，也没有额外申请一天用于重构。2）影响就是，对持续重构，有信心了。将大的工作拆细，逐步迭代完成，有勇气了。对边界的界定，项目分层，代码归属更明确了。码代码考虑的东西更多了。代码置顶向下的搭建方式更熟练了。写出来的代码去重，可读和可扩都有不错的长进。

题外话：最近在想两个问题。1）为什么公司的项目烂得出奇。有一个自洽的结论。烂是因为不重视，不重视是因为价值不高，价值不高是因为公司的商业模式只是用到这个软件平台而不是依托这个软件平台。所以站在公司的角度看，公司的价值增长是因为商业模式中其它元素的价值增长，而资金和精力应该往价值增长高的元素流。故而软件平台相对不重要，研发中心不重要，项目不重要，代码质量不重要。反过来想，如果这个软件平台是价值增长高的元素，那么质量自然会上去（要么现在要么将来，在合适的时候）。2）业务开发将来会怎么样。随着云原生的发展，技术复杂性与业务在不断的分离透明。也许不久的将来，业务项目只有业务复杂性这一问题。那么业务开发的门槛会越来越低。并且结合一定的规范约定和类似元编程的手段，是能让初级开发写出中高级开发差不多水平的代码的。那么中高级开发的生存空间是不是越来越窄了？搬砖会不会不再是自嘲了。2020-06-26

## 0905听一听小争哥对Google工程师文化的解读.md

### 5.1 什么是工程师文化？

我觉得，很多人对「工程师文化」这个词有误解，以为它是一个描述词，甚至是褒义词，表示工程师占主导的公司文化。实际上，我觉得，「工程师文化」是一个名词，你可以类比饮食文化、穿衣文化来理解，它指的是技术团队的价值观（这个团队最看重什么，比如效率、质量等等），更直白点讲就是做事风格。

每个技术团队都有自己的工程师文化，不管这种文化有没有被书面或者口头上表达出来。不过，工程师文化包含很多方面，就像人的价值观一样，有爱情观、金钱观、人生观等等。所以，它很难用一句话来总结。但因为某些公司的工程师文化中的某些方面比较突出、比较有个性，我们常用这些特殊点来「以偏概全」地代指，比如某些公司的工程师文化是「狼性文化」「奋斗文化」「996 文化」「PPT 文化」「养老院文化」等等。

工程师文化会潜移默化地影响团队中的每个人，不认同这种文化的人会选择离开，最终留下的人价值观都会趋同。形成好的工程师文化的主要目的是，公司希望通过文化而非管理和流程，来驱动团队中的每个人，步调一致地工作和交流。

### 5.2 Google 的工程师文化是什么？

为什么很多公司都要学习 Google 的工程师文化呢？我觉得主要原因是，Google 凝聚了很多优秀的人才，并且往外输出了很多优秀的技术和产品，侧面上证明了 Google 工程师文化的优秀，所以，很多公司也希望能借鉴 Google 的工程师文化，把自己的技术团队也打造成像 Google 的技术团队那样，执行力强、工作效率高、创新能力强的优秀团队。目标很明确，就是要打造优秀的技术团队。但要达成这样的目标，首先要理解 Google 的工程师文化是什么样的。

实际上，不同的人对 Google 工程师文化的理解是不同的。有些人把 Google 的工程师文化理解为，重视代码质量、重视效率、工匠精神、技术驱动、扁平化管理等等，还有些人甚至理解为，昂贵的电脑和座椅、按摩和报销等各种福利、少开会不加班、免费一日三餐、无限供应的零食等等。

当然，上面提到的这些在 Google 都是真实存在的。不过，这都是表象。如果只是学这些表面上的东西，「抄不到」Google 工程师文化的本质和精髓，我们也就很难打造成像 Google 一样的工程师文化了。那 Google 工程师文化的本质是什么呢？我觉得，如果用一句话来描述的话，那就应该是「尖子生」文化。

这里所说的「尖子生」，跟我们上学时候的「尖子生」是一个意思。不知道你学校里有没有「尖子生班」？或者你有没有在「尖子生班」待过？一般来说，「尖子生班」的同学在各个方面都表现得非常优秀，而且，这种优秀不仅仅体现在学习上面，其他非学习相关的活动也表现得很好。最值得一提的是，这种优秀是自发形成的，不需要老师的督促和刻意的培养。

类比到 Google 的工程师文化，Google 可以算作工程师中的「尖子生班」。我们知道，Google 用人条件很苛刻、招聘要求很高，身边的同事个个都具有光鲜的背景和履历，称为」尖子生「不足为过。这些最顶尖的工程师聚集在一起，不出意外的情况下，稍加引导，就能形成优秀的工程师文化，高产出、高效率、高创新是必然的。至于前面提到的其他方面，比如重视代码质量、工匠精神、重视效率等等，更是不在话下。

### 5.3 如何打造像 Google 一样的工程师文化？

表面上的东西很容易「借鉴」，比如为员工购买昂贵的电脑和座椅，但要想打造像 Google 一样的工程师文化，本质上还是要在」人「上下功夫。招聘最优秀的人才，给足钱、自由和尊重，这些人必然就会发挥最大的价值。

乔布斯曾经说过，A 类工程师招聘 A 类工程师，B 类工程师只能招聘 C 类工程师。之所以这么说，是因为 A 类工程师有足够的能力来正确地辨别 A、B、C 类工程师，有足够的自信去接纳跟自己一样优秀、甚至更加优秀的人才。所以，为了严把人才入口，我们一定要让公司内最优秀的工程师来负责招聘。

当然，并不是每个公司都可以像 Google 这样，有足够的背景去吸引最优秀的工程师、有足够的投入去招聘最优秀的工程师。但是，我们仍然可以招聘一小撮足够优秀的工程师，让这小部分工程师影响公司里更多的人，带动起我们想要的工程师文化。这就好比，打造一个全是尖子生的尖子班很难，但我们可以在班级里找几个学习榜样，让这一小撮榜样带动起整个班级的学习氛围。

除了在招聘上下功夫，在人才培养上，我们要尽可能留住最符合公司工程师文化的员工，让他们在公司内部有好的职场发展，避免劣币驱逐良币。比如，我们的工程师文化是「马屁文化」，如果你是领导，就要让经常拍你马屁的人升职加薪，慢慢地其他人就会效仿，不接受的人就会离职，「马屁文化」就逐渐形成了。

实际上，我们也不一定非得追求将公司的工程师文化，打造成像 Google 的一样，毕竟每个公司都有自己的特点，都有自己的发展阶段，完全照抄也不现实。我个人觉得，相对于外企来说，国内企业中跟「人」相关的文化，普遍做得不是太让人满意，比如，以人为本，以结果为导向，讨论就事论事，奖惩公开透明，不搞上下级关系等等，先把这些跟」人「相关的文化搞好，跟」技术「相关的文化，比如重视代码质量、工匠精神、追求效率等等，搞起来就相对容易多了。

## 0906如何学习设计模式之美专栏.md

《设计模式之美》专栏相对于我的另一个专栏《数据结构与算法之美》来说，内容看似更容易，实际上却更难。为什么这么说呢？从我写作的角度来说，《设计模式之美》要更加有难度。因为《数据结构与算法之美》的知识点都比较明确，一篇讲一个数据结构或算法。我只需要把原理、实现讲清楚，再举个实战的例子就基本大功告成了。

但是，《设计模式之美》中的知识点就没那么明确了。每个知识点到底该如何讲，并没有太多的参考。特别是专栏的前一部分，设计原则和思想，我在写专栏的时候参考了大量的书籍和资料。不瞒你说，大部分现有资料都讲得很浅，而且「互相借鉴」的痕迹也很明显。如果你之前对设计原则、思想、模式有所了解，或者看过挺多相关的书籍，应该能发现，我的专栏跟其他书籍的讲解还是有比较大的区别，这其中融入了我很多自己的思考和见解，这也是我的专栏与其他书籍区别最大的地方。

相对应的，从你学习的角度来说，《设计模式之美》也更有难度。它的难跟算法的难还不大一样。算法是原理难、实现难，最后才是应用难。而设计模式正好相反，原理、实现都挺简单的，基本上你一看就会觉得懂了，但是真正的能把它用到项目中，还是比较难的。对于很多人来说，你问他个具体的设计原则、思想、模式的原理和实现，他都能回答得头头是道，但是，在实际的项目开发中，写出来的代码质量还是很差。这种情况出现的原因还是相关的知识点都过于抽象，通俗点讲就是有点「假大空」，不够具体、不太能落地，导致理论和实践容易脱节。

所以，有些小伙伴总感觉《设计模式之美》学起来比《数据结构与算法之美》要简单，容易看懂，实际上这是种错觉。如果你也有这种感觉，那你要警醒了，因为你可能并没有真正读懂专栏的精髓。说了这么多，接下来我就讲讲，我为什么说你可能没有体会到文章的精髓，以及到底该如何来学习这个专栏。

### 6.1 建立完善的知识体系

你可能已经注意到，虽然这个专栏的名字叫《设计模式之美》，但专栏内容并不局限于此。实际上，整个专栏是围绕着教你如何编写高质量代码来设计的。在整个专栏中，我试图给你建立完善的知识体系，所以，从内容上来讲，涵盖了编写高质量代码的方方面面，比如面向对象、设计原则、设计思想、编码规范、重构技巧、设计模式。虽然在有限的 100 篇文章、50 万字内，我可能没法儿把每一个知识点都讲解得无比详细、全面，但我整理的这份知识框架，相当于给你指出了一个深入研究的方向，你可以按图索骥，积累起来会更快。先建立整体的知识框架，再慢慢深入、各个攻破，这也是学习任何一门新技术、新知识最有效的方法。所以，这里给你布置一个小任务，闭上眼睛，想一想整个专栏都会讲哪些内容？已经讲过的设计原则和思想，都讲了哪些内容？你能想起来多少？

### 6.2 建立代码质量意识

实际上，建立正确的技术认知和技术观，比单纯学技术、学知识点更重要。我举个例子，专栏中讲到单元测试的时候，并没有讲跟某个测试框架相关的技术点。因为我觉得这些很容易通过看文档学习，而我也不可能写得比文档更全面、更权威。实际上，通过那节课，我想要让你了解的是单元测试的好处，让你真正意识到单元测试的重要性，从心底认可这件事。还有，我在讲到重构的时候，也一直在强调要建立持续重构意识。整个专栏也都是在传递给你代码质量的重要性，让你意识到好代码和差代码的差别在哪里。

在学完专栏的时候，如果某些原则、思想、模式你记不大清了，那也没关系，只要你能在写代码的时候，能不由自主地去思考代码质量，有意识地去打磨代码，对代码质量有所追求了，那就说明你入门了，也就达到了我们专栏学习的目的。至于具体的知识点，随着时间的推移有所忘记，实际上并不碍事，多看几遍，多实践实践就好了。

这里，我也问你一个问题，你可以想一想，你写代码或者读别人代码的时候，是否开始思考代码质量问题呢？如果还没有，那再给你布置一个任务，在今后的一个月内，写代码前、中、后，都思考一下代码的扩展性、可读性、可维护性、可测试性等代码质量问题，看看自己编写的代码是否符合这些质量要求，有没有需要继续优化重构的地方。

### 6.3 主动学习而非被动学习

「师傅领进门，修行靠个人」，这句话说得特别好。同样听一个老师讲课，一个班级里面总有人会考 90 分，甚至满分，也会总会有人考不及格。差距在哪里呢？道理很简单，那就是你有没有用心学习。

类比到我们的专栏学习中，如果你只是走马观花地看一遍、跟听小说一样听一遍，收获肯定是甚微的，也就会出现常说的「过不几天就忘了」的情况。因为这是一种被动学习方法，左耳朵进右耳朵出，脑子里怎么会留住东西呢？相反，如果你能学会主动学习、主动思考，遇到不会的、理解不了的知识点，自己主动去思考一下、查查资料，或者跟同事讨论一下，试着把专栏里的内容自己总结一下，认真思考每一个课后题，这样的学习效果要比被动学习强好几倍。

关于这一点，我也给你留个作业：找一篇你觉得还没有透彻理解的文章，花上一天的时间，把里面的代码自己实现一遍，把文章的重点内容自己思考、整理，输出成文章。你可以看看，这样是否要比单纯看一遍收获更多呢？

### 6.4 多读几遍更有收获

《设计模式之美》专栏的内容都不难理解，每篇文章仅有四五千字，十几分钟的音频，但是，多读几遍你就会发现，每读一遍都会有不同的收获。如果你只是看一遍、听一遍，怎么能达到像我一样对知识点的理解程度呢？我自己在写专栏的时候，可是查阅了大量的文章和资料。有的时候，一篇文章我要写好几天，这期间有长时间、高强度的阅读、思考和揣摩。你如果都不愿意花跟我一样多的时间，怎么能期望跟我有一样的水平呢？

一个人的认知和理解能力是受限于他的经历和经验的。如果你刚毕业不久，开发经验不多，看专栏的时候，难免会抓不住重点或者理解得不够透彻。那该怎么办呢？我的建议是，千万不要把学习专栏看成一蹴而就的事情，看完一遍就丢在一边了，而是要反反复复进行学习。看一遍理论之后，你可以在项目中尝试着实践一下，然后回过头来再看一遍，直到没有新的知识点可以汲取为止。这个过程可能需要持续很长时间，可能是 1 年、2 年甚至是 3 年、5 年，但只有这样，你才能积累出真正的能力、建立真正的竞争壁垒，而不只是学一些快餐知识、填补眼前的焦虑。

在《数据结构与算法之美》专栏中，我也说过，你要做一个长一点的学习计划。实际上，学习《设计模式之美》专栏也是如此，毕竟这两门课都是比较基础的，而且跟我们平时的开发比较相关，多花点时间在基础的知识上，收益要远大于学习很多花哨的新技术、新框架。

关于这一点，我再给你布置一个作业：找专栏中一篇文章，反复读上 10 遍（当然是带着思考去读哈）。你看看是不是比只读一遍要理解得更透彻？是不是之前不能理解的地方自然就理解了呢？是不是每次读的时候都有新的收获？

### 6.5 学会把代码写到极致

我经常说，写 100 段烂代码都不如写 1 段好代码，对代码能力的提高大。实际上，这个道理也可以应用到任何学习工作中，堆量只需要时间，但并不是每个人都能把事情做到极致，而能把一件事情做到极致的人，往往也能把其他很多事情做到极致。这也是为什么，很多人在某一行业做得很好，跨行去做另一个看似不相干的事情也同样能做得非常好。牛人往往都是能把一件事情做到极致的人。如果所有的事情都只能做到一般好，那你注定也只能做一个平凡的人。关于这一点，我也布置一个作业给你：找一段你觉得写得很烂的代码，花上一个礼拜的时间，反复思考如何优化，把它优化到足够好。
