# 2020016王争的设计模式之美R01

## 记忆时间

## 0101当谈论面向对象的时候我们到底在谈论什么.md

1、什么是面向对象编程？面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。

2、什么是面向对象编程语言？面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。

3、如何判定一个编程语言是否是面向对象编程语言？如果按照严格的的定义，需要有现成的语法支持类、对象、四大特性才能叫作面向对象编程语言。如果放宽要求的话，只要某种编程语言支持类、对象语法机制，那基本上就可以说这种编程语言是面向对象编程语言了，不一定非得要求具有所有的四大特性。

4、面向对象编程和面向对象编程语言之间有何关系？面向对象编程一般使用面向对象编程语言来进行，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。

5、什么是面向对象分析和面向对象设计？简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等等。

考虑到各个水平层次的同学，并且保证专栏内容的系统性、全面性，我会循序渐进地讲解跟设计模式相关的所有内容。所以，专栏正文的第一个模块，我会讲一些设计原则、设计思想，比如，面向对象设计思想、经典设计原则以及重构相关的知识，为之后学习设计模式做铺垫。

在第一个模块中，我们又首先会讲到面向对象相关的理论知识。提到面向对象，我相信很多人都不陌生，随口都可以说出面向对象的四大特性：封装、抽象、继承、多态。实际上，面向对象这个概念包含的内容还不止这些。所以，今天我打算花一节课的时间，先大概跟你聊一下，当我们谈论面向对象的时候，经常会谈到的一些概念和知识点，为学习后面的几节更加细化的内容做一个铺垫。

特别说明一下，对于今天讲到的概念和知识点，大部分我都是点到为止，并没有展开详细讲解。如果你看了之后，对某个概念和知识点还不是很清楚，那也没有关系。在后面的几节课中，我会花更多的篇幅，对今天讲到的每个概念和知识点，结合具体的例子，一一做详细的讲解。

### 1.1 什么是面向对象编程和面向对象编程语言？

面向对象编程的英文缩写是 OOP，全称是 Object Oriented Programming。对应地，面向对象编程语言的英文缩写是 OOPL，全称是 Object Oriented Programming Language。面向对象编程中有两个非常重要、非常基础的概念，那就是类（class）和对象（object）。这两个概念最早出现在 1960 年，在 Simula 这种编程语言中第一次使用。而面向对象编程这个概念第一次被使用是在 Smalltalk 这种编程语言中。Smalltalk 被认为是第一个真正意义上的面向对象编程语言。

1980 年左右，C++ 的出现，带动了面向对象编程的流行，也使得面向对象编程被越来越多的人认可。直到今天，如果不按照严格的定义来说，大部分编程语言都是面向对象编程语言，比如 Java、C++、Go、Python、C#、Ruby、JavaScript、Objective-C、Scala、PHP、Perl 等等。除此之外，大部分程序员在开发项目的时候，都是基于面向对象编程语言进行的面向对象编程。

以上是面向对象编程的大概发展历史。在刚刚的描述中，我着重提到了两个概念，面向对象编程和面向对象编程语言。那究竟什么是面向对象编程？什么语言才算是面向对象编程语言呢？如果非得给出一个定义的话，我觉得可以用下面两句话来概括。

面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。

一般来讲，面向对象编程都是通过使用面向对象编程语言来进行的，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。这里听起来是不是有点绕？不过没关系，我们在后面的第 7 节课中，会详细讲解这个问题。

除此之外，从定义中，我们还可以发现，理解面向对象编程及面向对象编程语言两个概念，其中最关键的一点就是理解面向对象编程的四大特性。这四大特性分别是：封装、抽象、继承、多态。不过，关于面向对象编程的特性，也有另外一种说法，那就是只包含三大特性：封装、继承、多态，不包含抽象。为什么会有这种分歧呢？抽象为什么可以排除在面向对象编程特性之外呢？关于这个问题，在下一节课详细讲解这四大特性的时候，我还会再拿出来说一下。不过，话说回来，实际上，我们没必要纠结到底是四大特性还是三大特性，关键还是理解每种特性讲的是什么内容、存在的意义以及能解决什么问题。

而且，在技术圈里，封装、抽象、继承、多态也并不是固定地被叫作「四大特性」（features），也有人称它们为面向对象编程的四大概念（concepts）、四大基石（cornerstones）、四大基础（fundamentals）、四大支柱（pillars）等等。你也发现了吧，叫法挺混乱的。不过，叫什么并不重要。我们只需要知道，这是前人进行面向对象编程过程中总结出来的、能让我们更容易地实现各种设计思路的几个编程套路，这就够了。在之后的课程讲解中，我统一把它们叫作「四大特性」。

### 1.2 如何判定某编程语言是否是面向对象编程语言？

如果你足够细心，你可能已经留意到，在我刚刚的讲解中，我提到，「如果不按照严格的定义来说，大部分编程语言都是面向对象编程语言」。为什么要加上「如果不按照严格的定义」这个前提呢？那是因为，如果按照刚刚我们给出的严格的面向对象编程语言的定义，前面提到的有些编程语言，并不是严格意义上的面向对象编程语言，比如 JavaScript，它不支持封装和继承特性，按照严格的定义，它不算是面向对象编程语言，但在某种意义上，它又可以算得上是一种面向对象编程语言。我为什么这么说呢？到底该如何判断一个编程语言是否是面向对象编程语言呢？

还记得我们前面给出的面向对象编程及面向对象编程语言的定义吗？如果忘记了，你可以先翻到上面回顾一下。不过，我必须坦诚告诉你，那个定义是我自己给出的。实际上，对于什么是面向对象编程、什么是面向对象编程语言，并没有一个官方的、统一的定义。而且，从 1960 年，也就是 60 年前面向对象编程诞生开始，这两个概念就在不停地演化，所以，也无法给出一个明确的定义，也没有必要给出一个明确定义。

实际上，面向对象编程从字面上，按照最简单、最原始的方式来理解，就是将对象或类作为代码组织的基本单元，来进行编程的一种编程范式或者编程风格，并不一定需要封装、抽象、继承、多态这四大特性的支持。但是，在进行面向对象编程的过程中，人们不停地总结发现，有了这四大特性，我们就能更容易地实现各种面向对象的代码设计思路。

比如，我们在面向对象编程的过程中，经常会遇到 is-a 这种类关系（比如狗是一种动物），而继承这个特性就能很好地支持这种 is-a 的代码设计思路，并且解决代码复用的问题，所以，继承就成了面向对象编程的四大特性之一。但是随着编程语言的不断迭代、演化，人们发现继承这种特性容易造成层次不清、代码混乱，所以，很多编程语言在设计的时候就开始摒弃继承特性，比如 Go 语言。但是，我们并不能因为它摒弃了继承特性，就一刀切地认为它不是面向对象编程语言了。

实际上，我个人觉得，只要某种编程语言支持类或对象的语法概念，并且以此作为组织代码的基本单元，那就可以被粗略地认为它就是面向对象编程语言了。至于是否有现成的语法机制，完全地支持了面向对象编程的四大特性、是否对四大特性有所取舍和优化，可以不作为判定的标准。基于此，我们才有了前面的说法，按照严格的定义，很多语言都不能算得上面向对象编程语言，但按照不严格的定义来讲，现在流行的大部分编程语言都是面向对象编程语言。

所以，多说一句，关于这个问题，我们一定不要过于学院派，非要给面向对象编程、面向对象编程语言下个死定义，非得对某种语言是否是面向对象编程语言争个一清二白，这样做意义不大。

### 1.3 什么是面向对象分析和面向对象设计？

前面我们讲了面向对象编程（OOP），实际上，跟面向对象编程经常放到一块儿来讲的还有另外两个概念，那就是面向对象分析（OOA）和面向对象设计（OOD）。面向对象分析英文缩写是 OOA，全称是 Object Oriented Analysis；面向对象设计的英文缩写是 OOD，全称是 Object Oriented Design。OOA、OOD、OOP 三个连在一起就是面向对象分析、设计、编程（实现），正好是面向对象软件开发要经历的三个阶段。

关于什么是面向对象编程，我们前面已经讲过了。我们现在再来讲一下，什么是面向对象分析和设计。这两个概念相对来说要简单一些。面向对象分析与设计中的「分析」和「设计」这两个词，我们完全可以从字面上去理解，不需要过度解读，简单类比软件开发中的需求分析、系统设计即可。不过，你可能会说，那为啥前面还加了个修饰词「面向对象」呢？有什么特殊的意义吗？

之所以在前面加「面向对象」这几个字，是因为我们是围绕着对象或类来做需求分析和设计的。分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。它们比其他的分析和设计更加具体、更加落地、更加贴近编码，更能够顺利地过渡到面向对象编程环节。这也是面向对象分析和设计，与其他分析和设计最大的不同点。

看到这里，你可能会问，那面向对象分析、设计、编程到底都负责做哪些工作呢？简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。今天，我们只是简单介绍一下概念，不展开详细讲解。在后面的面向对象实战环节中，我会用两节课的时间，通过一个实际例子，详细讲解如何进行面向对象分析、设计和编程。

### 1.4 什么是 UML？我们是否需要 UML？

讲到面向对象分析、设计、编程，我们就不得不提到另外一个概念，那就是 UML（Unified Model Language），统一建模语言。很多讲解面向对象或设计模式的书籍，常用它来画图表达面向对象或设计模式的设计思路。

实际上，UML 是一种非常复杂的东西。它不仅仅包含我们常提到类图，还有用例图、顺序图、活动图、状态图、组件图等。在我看来，即便仅仅使用类图，学习成本也是很高的。就单说类之间的关系，UML 就定义了很多种，比如泛化、实现、关联、聚合、组合、依赖等。

要想完全掌握，并且熟练运用这些类之间的关系，来画 UML 类图，肯定要花很多的学习精力。而且，UML 作为一种沟通工具，即便你能完全按照 UML 规范来画类图，可对于不熟悉的人来说，看懂的成本也还是很高的。

所以，从我的开发经验来说，UML 在互联网公司的项目开发中，用处可能并不大。为了文档化软件设计或者方便讨论软件设计，大部分情况下，我们随手画个不那么规范的草图，能够达意，方便沟通就够了，而完全按照 UML 规范来将草图标准化，所付出的代价是不值得的。

所以，我这里特别说明一下，专栏中的很多类图我并没有完全遵守 UML 的规范标准。为了兼顾图的表达能力和你的学习成本，我对 UML 类图规范做了简化，并配上了详细的文字解释，力图让你一眼就能看懂，而非适得其反，让图加重你的学习成本。毕竟，我们的专栏并不是一个讲方法论的教程，专栏中的所有类图，本质是让你更清晰地理解设计。

### 黑板墙

今天我们要讨论的话题有两个：1）在文章中，我讲到 UML 的学习成本很高，沟通成本也不低，不推荐在面向对象分析、设计的过程中使用，对此你有何看法？2）有关面向对象的概念和知识点，除了我们今天讲到的，你还能想到其他哪些吗？

在这篇文章中，「面向对象编程」一词多义，不同的场景、语境下，解释不同。文章中没有点到这一点，我这里稍微补充说明一下：1）文章前半部分，面向对象编程指的是一种编程风格或者范式。2）文章后半部分，在讲到面向对象分析、设计、编程的时候，面向对象编程是一种行为。2019-11-11

UML 中定义了类之间的关系：泛化、实现、关联、聚合、组合、依赖，试问下小伙伴们，你们都能搞清楚这几个的区别吗？能否准确的用不同的箭头、图线来画出来吗？即便你能画出来，团队里的小伙伴都能看懂吗？ 不过，关于类之间的关系，我后面会在实战篇中讲到的，但是，我会简化成四种关系，更好理解。2019-11-11

关于 UML 推荐一本书《Java Modeling In Color With UML》和一个神器：[ZenUML - Workspace](https://app.zenuml.com/)。2019-11-11

我理解的是要因场景而异，但是最终的目的都是降低沟通的成本。场景 1：在大多数人对 UML 不是很熟练的情况下，如果采用 UML 来进行沟通，大家在理解上一定会存在 Gap，无形之中会提高学习和沟通的成本，在这种情况下，建议不使用 UML。举个例子，《实现领域驱动》的作者一开始是使用 UML 和领域专家沟通，作者认为 UML 很简单，但是许多领域专家或开发人员并不能很好地理解，最后又出现了 ES（事件风暴）的形式来替代。场景 2：如果需要准确传达设计意图，还是需要 UML 这样的通用设计工具的，目的也是降低沟通的成本。例如，架构师的设计理念想准确传达给工程师，如果使用 UML 工具，可以避免模糊意图，带来额外的沟通成本。敏捷宣言的第一条就是「个体和沟通」高于「流程和工具」。所以要因人而异，因场景而异，在专栏里「很多类图我并没有完全遵守 UML 的规范标准」的策略，我想是一个不错的折中。2019-11-11

对于 UML（统一建模语言），我个人觉得它的作用还是很大的，因为它可以帮助开发人员更好的去分析一个软件的设计过程，通过它的哪些表示的方法吗，会让人的思路更加的清晰，如果是一个软件的负责人，那么使用 UML 来分析问题，我觉得再好不过。软件开发是一个工程问题，就好比盖房子，只有每一步都规划好，分析好，设计好，盖出来的房子才好，总之，我个人觉得值得花时间去学 UML！2019-11-12

确实很多公司使用 UML 的频率比较低，大厂也是这样。另外我自己对 Google 的了解是对代码要求很高，那么代码交付还有文档的要求想必也很高，不知道 Google 公司在文档上面会不会大量使用 UML，如果不用的话，有没有更好的方式或语言来维护高质量的文档作者回复：好像没有多少人画 uml，文档主要还是聚焦于业务和更上层的架构设计、技术难点说明，实现直接看代码。2019-11-12

我们是围绕着对象或类来做需求分析和设计的。分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。它们比其他的分析和设计更加具体、更加落地、更加贴近编码，更能够顺利地过渡到面向对象编程环节。这也是面向对象分析和设计，与其他分析和设计最大的不同点。曾经面试的时候被问到，领域驱动设计和数据表驱动设计有什么区别，我觉得王老师的这句话总结的很到位。2019-11-11

汇总：1）对 uml，真正掌握确实有难度，很容易忘记，原因可能是自己并没有真正的理解设计这件事，比如说 uml 中是用泛化还是实现不是问题的本质，本质是对于一个特定问题，要如何设计才是尽可能最好的；这中间有两层：将自己的想法转成可表达的设计和将可表达的设计让别人也能理解你的意图，而 uml 就是一种可表达的方式，至于是不是 uml 并不重要；但是 uml 有一套规范，而且知名度高，大家多少都有一些了解，所以就成了一种大家相互沟通的通用语言，所以学 uml 是需要的。我现在是傻傻分不清泛化、实现、关联、聚合、组合、依赖和他们的表达形式。2）想到了编程范式，虽然不是它不是面向对象独有的东西，OO 只是众多范式中的一种。2019-11-11

不是来挑刺的，发现有更好的论述与大家分享。下面内容总结自邵维忠和杨芙清院士的著作《面向对象的系统设计（第 2 版）》，主要看第 20 页，解答了我当年的疑惑：面向对象分析不能简单说是要搞清楚做什么，系统分析！= 需求分析。面向对象分析是指系统分析，它既是对「做什么」问题的进一步明确，也是相当程度上涉及到「怎么做」的问题。重点来了，OOA 产生的系统模型与实现条件无关，OOD 产生的系统模型针对具体的实现平台。2020-05-13

UML 确实很复杂，我认为使用 UML 表达出设计的意思即可，没有必要完全遵从 UML 的规范。比如我目前的工作中，用到的 UML 好像只有类图、时序图、用例图三种。对于类图，也只用到过继承、实现、依赖三种关系。时序图刚刚使用时恨不得将每个类的每个方法的调用关系都画出来，结果不仅使得时序图看上去很复杂，连自己过段时间再看也觉得太复杂了，结果是辛苦半天却事倍功半，后来时序图也是越画越简单，只要能表达出调用关系即可。2020-02-26

## 0102封装抽象继承多态分别可以解决哪些编程问题.md

1、关于封装特性。封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。

2、关于抽象特性。封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。

3、关于继承特性。继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。

4、关于多态特性。多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。

上一节课，我简单介绍了面向对象的一些基本概念和知识点，比如，什么是面向对象编程，什么是面向对象编程语言等等。其中，我们还提到，理解面向对象编程及面向对象编程语言的关键就是理解其四大特性：封装、抽象、继承、多态。不过，对于这四大特性，光知道它们的定义是不够的，我们还要知道每个特性存在的意义和目的，以及它们能解决哪些编程问题。所以，今天我就花一节课的时间，针对每种特性，结合实际的代码，带你将这些问题搞清楚。

这里我要强调一下，对于这四大特性，尽管大部分面向对象编程语言都提供了相应的语法机制来支持，但不同的编程语言实现这四大特性的语法机制可能会有所不同。所以，今天，我们在讲解四大特性的时候，并不与具体某种编程语言的特定语法相挂钩，同时，也希望你不要局限在你自己熟悉的编程语言的语法思维框架里。

### 2.1 封装（Encapsulation）

首先，我们来看封装特性。封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。这句话怎么理解呢？我们通过一个简单的例子来解释一下。

下面这段代码是金融系统中一个简化版的虚拟钱包的代码实现。在金融系统中，我们会给每个用户创建一个虚拟钱包，用来记录用户在我们的系统中的虚拟货币量。对于虚拟钱包的业务背景，这里你只需要简单了解一下即可。在面向对象的实战篇中，我们会有单独两节课，利用 OOP 的设计思想来详细介绍虚拟钱包的设计实现。

```java
public class Wallet {
  private String id;
  private long createTime;
  private BigDecimal balance;
  private long balanceLastModifiedTime;
  // ...省略其他属性...

  public Wallet() {
     this.id = IdGenerator.getInstance().generate();
     this.createTime = System.currentTimeMillis();
     this.balance = BigDecimal.ZERO;
     this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  // 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅
  public String getId() { return this.id; }
  public long getCreateTime() { return this.createTime; }
  public BigDecimal getBalance() { return this.balance; }
  public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }

  public void increaseBalance(BigDecimal increasedAmount) {
    if (increasedAmount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException("...");
    }
    this.balance.add(increasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  public void decreaseBalance(BigDecimal decreasedAmount) {
    if (decreasedAmount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException("...");
    }
    if (decreasedAmount.compareTo(this.balance) > 0) {
      throw new InsufficientAmountException("...");
    }
    this.balance.subtract(decreasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }
}
```

从代码中，我们可以发现，Wallet 类主要有四个属性（也可以叫作成员变量），也就是我们前面定义中提到的信息或者数据。其中，id 表示钱包的唯一编号，createTime 表示钱包创建的时间，balance 表示钱包中的余额，balanceLastModifiedTime 表示上次钱包余额变更的时间。

我们参照封装特性，对钱包的这四个属性的访问方式进行了限制。调用者只允许通过下面这六个方法来访问或者修改钱包里的数据。

```java
String getId()
long getCreateTime()
BigDecimal getBalance()
long getBalanceLastModifiedTime()
void increaseBalance(BigDecimal increasedAmount)
void decreaseBalance(BigDecimal decreasedAmount)
```

之所以这样设计，是因为从业务的角度来说，id、createTime 在创建钱包的时候就确定好了，之后不应该再被改动，所以，我们并没有在 Wallet 类中，暴露 id、createTime 这两个属性的任何修改方法，比如 set 方法。而且，这两个属性的初始化设置，对于 Wallet 类的调用者来说，也应该是透明的，所以，我们在 Wallet 类的构造函数内部将其初始化设置好，而不是通过构造函数的参数来外部赋值。

1『透明的意思就是不知道细节。』

对于钱包余额 balance 这个属性，从业务的角度来说，只能增或者减，不会被重新设置。所以，我们在 Wallet 类中，只暴露了 increaseBalance() 和 decreaseBalance() 方法，并没有暴露 set 方法。对于 balanceLastModifiedTime 这个属性，它完全是跟 balance 这个属性的修改操作绑定在一起的。只有在 balance 修改的时候，这个属性才会被修改。所以，我们把 balanceLastModifiedTime 这个属性的修改操作完全封装在了 increaseBalance() 和 decreaseBalance() 两个方法中，不对外暴露任何修改这个属性的方法和业务细节。这样也可以保证 balance 和 balanceLastModifiedTime 两个数据的一致性。

对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持。这个语法机制就是访问权限控制。例子中的 private、public 等关键字就是 Java 语言中的访问权限控制语法。private 关键字修饰的属性只能类本身访问，可以保护其不被类之外的代码直接访问。如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的，那任意外部代码都可以通过类似 wallet.id=123; 这样的方式直接访问、修改属性，也就没办法达到隐藏信息和保护数据的目的了，也就无法支持封装特性了。

封装特性的定义讲完了，我们再来看一下，封装的意义是什么？它能解决什么编程问题？

如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但从另一方面来说，过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性。比如某个同事在不了解业务逻辑的情况下，在某段代码中「偷偷地」重设了 wallet 中的 balanceLastModifiedTime 属性，这就会导致 balance 和 balanceLastModifiedTime 两个数据不一致。

除此之外，类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反，如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多。这就好比，如果一个冰箱有很多按钮，你就要研究很长时间，还不一定能操作正确。相反，如果只有几个必要的按钮，比如开、停、调节温度，你一眼就能知道该如何来操作，而且操作出错的概率也会降低很多。

### 2.2 抽象（Abstraction）

讲完了封装特性，我们再来看抽象特性。封装主要讲的是如何隐藏信息、保护数据，而抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。在面向对象编程中，我们常借助编程语言提供的接口类（比如 Java 中的 interface 关键字语法）或者抽象类（比如 Java 中的 abstract 关键字语法）这两种语法机制，来实现抽象这一特性。

这里我稍微说明一下，在专栏中，我们把编程语言提供的接口语法叫作「接口类」而不是「接口」。之所以这么做，是因为「接口」这个词太泛化，可以指好多概念，比如 API 接口等，所以，我们用「接口类」特指编程语言提供的接口语法。对于抽象这个特性，我举一个例子来进一步解释一下。

```java
public interface IPictureStorage {
  void savePicture(Picture picture);
  Image getPicture(String pictureId);
  void deletePicture(String pictureId);
  void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);
}

public class PictureStorage implements IPictureStorage {
  // ...省略其他属性...
  @Override
  public void savePicture(Picture picture) { ... }
  @Override
  public Image getPicture(String pictureId) { ... }
  @Override
  public void deletePicture(String pictureId) { ... }
  @Override
  public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }
}
```

在上面的这段代码中，我们利用 Java 中的 interface 接口语法来实现抽象特性。调用者在使用图片存储功能的时候，只需要了解 IPictureStorage 这个接口类暴露了哪些方法就可以了，不需要去查看 PictureStorage 类里的具体实现逻辑。

实际上，抽象这个特性是非常容易实现的，并不需要非得依靠接口类或者抽象类这些特殊语法机制来支持。换句话说，并不是说一定要为实现类（PictureStorage）抽象出接口类（IPictureStorage），才叫作抽象。即便不编写 IPictureStorage 接口类，单纯的 PictureStorage 类本身就满足抽象特性。

之所以这么说，那是因为，类的方法是通过编程语言中的「函数」这一语法机制来实现的。通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。比如，我们在使用 C 语言的 malloc() 函数的时候，并不需要了解它的底层代码是怎么实现的。

除此之外，在上一节课中，我们还提到，抽象有时候会被排除在面向对象的四大特性之外，当时我卖了一个关子，现在我就来解释一下为什么。抽象这个概念是一个非常通用的设计思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供「函数」这一非常基础的语法机制，就可以实现抽象特性、所以，它没有很强的「特异性」，有时候并不被看作面向对象编程的特性之一。

抽象特性的定义讲完了，我们再来看一下，抽象的意义是什么？它能解决什么编程问题？

实际上，如果上升一个思考层面的话，抽象及其前面讲到的封装都是人类处理复杂性的有效手段。在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息。

除此之外，抽象作为一个非常宽泛的设计思想，在代码设计中，起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则（对扩展开放、对修改关闭）、代码解耦（降低代码的耦合性）等。我们在讲到后面的内容的时候，会具体来解释。

换一个角度来考虑，我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。举个简单例子，比如 getAliyunPictureUrl() 就不是一个具有抽象思维的命名，因为某一天如果我们不再把图片存储在阿里云上，而是存储在私有云上，那这个命名也要随之被修改。相反，如果我们定义一个比较抽象的函数，比如叫作 getPictureUrl ()，那即便内部存储方式修改了，我们也不需要修改命名。

### 2.3 继承（Inheritance）

学习完了封装和抽象两个特性，我们再来看继承特性。如果你熟悉的是类似 Java、C++ 这样的面向对象的编程语言，那你对继承这一特性，应该不陌生了。继承是用来表示类之间的 is-a 关系，比如猫是一种哺乳动物。从继承关系上来讲，继承可以分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。

为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，比如 Java 使用 extends 关键字来实现继承，C++ 使用冒号（class B : public A），Python 使用 paraentheses()，Ruby 使用 <。不过，有些编程语言只支持单继承，不支持多重继承，比如 Java、PHP、C#、Ruby 等，而有些编程语言既支持单重继承，也支持多重继承，比如 C++、Python、Perl 等。

为什么有些语言支持多重继承，有些语言不支持呢？这个问题留给你自己去研究，你可以针对你熟悉的编程语言，在留言区写一写具体的原因。继承特性的定义讲完了，我们再来看，继承存在的意义是什么？它能解决什么编程问题？

继承最大的一个好处就是代码复用。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复写多遍。不过，这一点也并不是继承所独有的，我们也可以通过其他方式来解决这个代码复用的问题，比如利用组合关系而不是继承关系。

如果我们再上升一个思维层面，去思考继承这一特性，可以这么理解：我们代码中有一个猫类，有一个哺乳动物类。猫属于哺乳动物，从人类认知的角度上来说，是一种 is-a 关系。我们通过继承来关联两个类，反应真实世界中的这种关系，非常符合人类的认知，而且，从设计的角度来说，也有一种结构美感。

继承的概念很好理解，也很容易使用。不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。为了了解一个类的功能，我们不仅需要查看这个类的代码，还需要按照继承关系一层一层地往上查看「父类、父类的父类……」的代码。还有，子类和父类高度耦合，修改父类的代码，会直接影响到子类。

所以，继承这个特性也是一个非常有争议的特性。很多人觉得继承是一种反模式。我们应该尽量少用，甚至不用。关于这个问题，在后面讲到「多用组合少用继承」这种设计思想的时候，我会非常详细地再讲解，这里暂时就不展开讲解了。

### 2.4 多态（Polymorphism）

学习完了封装、抽象、继承之后，我们再来看面向对象编程的最后一个特性，多态。多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。对于多态这种特性，纯文字解释不好理解，我们还是看一个具体的例子。

```java
public class DynamicArray {
  private static final int DEFAULT_CAPACITY = 10;
  protected int size = 0;
  protected int capacity = DEFAULT_CAPACITY;
  protected Integer[] elements = new Integer[DEFAULT_CAPACITY];
  
  public int size() { return this.size; }
  public Integer get(int index) { return elements[index];}
  //...省略n多方法...
  
  public void add(Integer e) {
    ensureCapacity();
    elements[size++] = e;
  }
  
  protected void ensureCapacity() {
    //...如果数组满了就扩容...代码省略...
  }
}

public class SortedDynamicArray extends DynamicArray {
  @Override
  public void add(Integer e) {
    ensureCapacity();
    int i;
    for (i = size-1; i>=0; --i) { //保证数组中的数据有序
      if (elements[i] > e) {
        elements[i+1] = elements[i];
      } else {
        break;
      }
    }
    elements[i+1] = e;
    ++size;
  }
}

public class Example {
  public static void test(DynamicArray dynamicArray) {
    dynamicArray.add(5);
    dynamicArray.add(1);
    dynamicArray.add(3);
    for (int i = 0; i < dynamicArray.size(); ++i) {
      System.out.println(dynamicArray.get(i));
    }
  }
  
  public static void main(String args[]) {
    DynamicArray dynamicArray = new SortedDynamicArray();
    test(dynamicArray); // 打印结果：1、3、5
  }
}
```

多态这种特性也需要编程语言提供特殊的语法机制来实现。在上面的例子中，我们用到了三个语法机制来实现多态。1）第一个语法机制是编程语言要支持父类对象可以引用子类对象，也就是可以将 SortedDynamicArray 传递给 DynamicArray。2）第二个语法机制是编程语言要支持继承，也就是 SortedDynamicArray 继承了 DynamicArray，才能将 SortedDyamicArray 传递给 DynamicArray。3）第三个语法机制是编程语言要支持子类可以重写（override）父类中的方法，也就是 SortedDyamicArray 重写了 DynamicArray 中的 add() 方法。

通过这三种语法机制配合在一起，我们就实现了在 test() 方法中，子类 SortedDyamicArray 替换父类 DynamicArray，执行子类 SortedDyamicArray 的 add() 方法，也就是实现了多态特性。

1『醍醐灌顶，多态对应于「子类替换父类」，哈哈。（2020-07-30）』

对于多态特性的实现方式，除了利用「继承加方法重写」这种实现方式之外，我们还有其他两种比较常见的的实现方式，一个是利用接口类语法，另一个是利用 duck-typing 语法。不过，并不是每种编程语言都支持接口类或者 duck-typing 这两种语法机制，比如 C++ 就不支持接口类语法，而 duck-typing 只有一些动态语言才支持，比如 Python、JavaScript 等。

接下来，我们先来看如何利用接口类来实现多态特性。我们还是先来看一段代码。

```java
public interface Iterator {
  String hasNext();
  String next();
  String remove();
}

public class Array implements Iterator {
  private String[] data;
  
  public String hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法...
}

public class LinkedList implements Iterator {
  private LinkedListNode head;
  
  public String hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法... 
}

public class Demo {
  private static void print(Iterator iterator) {
    while (iterator.hasNext()) {
      System.out.println(iterator.next());
    }
  }
  
  public static void main(String[] args) {
    Iterator arrayIterator = new Array();
    print(arrayIterator);
    
    Iterator linkedListIterator = new LinkedList();
    print(linkedListIterator);
  }
}
```

在这段代码中，Iterator 是一个接口类，定义了一个可以遍历集合数据的迭代器。Array 和 LinkedList 都实现了接口类 Iterator。我们通过传递不同类型的实现类（Array、LinkedList）到 print(Iterator iterator) 函数中，支持动态的调用不同的 next()、hasNext() 实现。

具体点讲就是，当我们往 print(Iterator iterator) 函数传递 Array 类型的对象的时候，print(Iterator iterator) 函数就会调用 Array 的 next()、hasNext() 的实现逻辑；当我们往 print(Iterator iterator) 函数传递 LinkedList 类型的对象的时候，print(Iterator iterator) 函数就会调用 LinkedList 的 next()、hasNext() 的实现逻辑。

刚刚讲的是用接口类来实现多态特性。现在，我们再来看下，如何用 duck-typing 来实现多态特性。我们还是先来看一段代码。这是一段 Python 代码。

```py
class Logger:
    def record(self):
        print(“I write a log into file.”)
        
class DB:
    def record(self):
        print(“I insert data into db. ”)
        
def test(recorder):
    recorder.record()

def demo():
    logger = Logger()
    db = DB()
    test(logger)
    test(db)
```

从这段代码中，我们发现，duck-typing 实现多态的方式非常灵活。Logger 和 DB 两个类没有任何关系，既不是继承关系，也不是接口和实现的关系，但是只要它们都有定义了 record() 方法，就可以被传递到 test() 方法中，在实际运行的时候，执行对应的 record() 方法。

也就是说，只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，这就是所谓的 duck-typing，是一些动态语言所特有的语法机制。而像 Java 这样的静态语言，通过继承实现多态特性，必须要求两个类之间有继承关系，通过接口实现多态特性，类必须实现对应的接口。

2『实现多态的 3 个手段，基于继承、基于接口、基于 duck-typing，多使用后两种。做一张术语卡片。』——已完成

多态特性讲完了，我们再来看，多态特性存在的意义是什么？它能解决什么编程问题？

多态特性能提高代码的可扩展性和复用性。为什么这么说呢？我们回过头去看讲解多态特性的时候，举的第二个代码实例（Iterator 的例子）。在那个例子中，我们利用多态的特性，仅用一个 print() 函数就可以实现遍历打印不同类型（Array、LinkedList）集合的数据。当再增加一种要遍历打印的类型的时候，比如 HashMap，我们只需让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、next() 等方法就可以了，完全不需要改动 print() 函数的代码。所以说，多态提高了代码的可扩展性。

如果我们不使用多态特性，我们就无法将不同的集合类型（Array、LinkedList）传递给相同的函数（print (Iterator iterator) 函数）。我们需要针对每种要遍历打印的集合，分别实现不同的 print() 函数，比如针对 Array，我们要实现 print(Array array) 函数，针对 LinkedList，我们要实现 print(LinkedList linkedList) 函数。而利用多态特性，我们只需要实现一个 print() 函数的打印逻辑，就能应对各种集合数据的打印操作，这显然提高了代码的复用性。

除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等。关于这点，在学习后面的章节中，你慢慢会有更深的体会。

### 黑板墙

1、你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。

2、你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？

争哥对面向对象的总结完美符合 What/How/Why 模型，我按照模型作下梳理。1）封装：隐藏信息，保护数据访问；暴露有限接口和属性，需要编程语言提供访问控制的语法；提高代码可维护性、降低接口复杂度、提高类的易用性。2）抽象：隐藏具体实现，使用者只需关心功能，无需关心实现；通过接口类或者抽象类实现，特殊语法机制非必须。提高代码的扩展性、维护性，降低复杂度，减少细节负担。3）继承：表示 is-a 关系，分为单继承和多继承；需要编程语言提供特殊语法机制。例如 Java 的「extends」，C++ 的「:」；解决代码复用问题。4）多态：子类替换父类，在运行时调用子类的实现；需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing；提高代码扩展性和复用性。3W 模型的关键在于 Why，没有 Why，其它两个就没有存在的意义。从四大特性可以看出，面向对象的终极目的只有一个：可维护性、易扩展、易复用，降低复杂度等等都属于可维护性的实现方式。2019-11-14

Java 不支持多重继承的原因。多重继承有副作用：钻石问题（菱形继承）。假设类 B 和类 C 继承自类 A，且都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 会继承哪一个呢？这里就会产生歧义。考虑到这种二义性问题，Java 不支持多重继承。但是 Java 支持多接口实现，因为接口中的方法，是抽象的（从 JDK1.8 之后，接口中允许给出一些默认方法的实现，这里不考虑这个），就算一个类实现了多个接口，且这些接口中存在某个同名方法，但是我们在实现接口的时候，这个同名方法需要由我们这个实现类自己来实现，所以并不会出现二义性的问题。2019-11-13

封装就是让代码遵守开闭原则的重要手段。当调用类，关注过多实施类的继节时，一个需求的变化，可能引发多个依赖模块都发生了级联的改动，而一但调用类过度的知道了太多了实施类的细节（然后各种调用类代码再一散落），这时程序也相应地变得出各种毛病出来，既然这样，把实现的方法封装起来多好，让调用端少操点心。Law of Demeter 有个别名，就叫最少知道原则，争哥说的第二个意义，感觉就是在描述遵守迪米特法则的好处。

再乱想一下，人体，不就是最好的的封装么，给你物料的入口（吃），出口（拉），还给你调节增强的接口（训练） 有多少人，并不知道其内部细节，不照样过着精彩的一生。还有，调用类，总想知道更多被调用类的信息，以期更精准的控制，这种代码风格，就是完美主义病，而完美主义的并发症就是拖延症，以及极高的复杂度造成项目越写越混乱。

抽像讲的是如何隐藏信息，而抽像讲的是隐藏方法的具体实现，让调用者只关心方法提供了哪些功能即可。通常借 interface 和 abstract class 来实现抽像这一特性。当 implement 某接口时，只要知道接口干了啥，即可，无需要关心实施类的细节实现。

抽你的意义，能解决啥问题。1）处理复杂性的有效手段。人脑承受信息有限，抽像做为不关注实现细节的套路，正好管用。2）抽像指导了很多的 oo 原则 ，凡时对实现进行封装抽离的，都可以叫抽像，例如 malloc()。3）定义类时，要有抽像思维，不要在方法中，暴露太多细节。（建议一层抽象层，让功能分解得更细，让意图和实现分享）

个人理解：（抽象处理的复杂度是人月神话里描述的本质复杂度（Essential Complexity），也是尊重人脑的认知学的 ，大脑的特性是很烂的（ 抽像的工具包记重点，归纳特性，忽视细节）。再瞎想一下，抽像是将很多的知道点给封装起来了（encoding 成为一个模型），归纳法便是抽象的重要实现套路，也是支撑及发展文明的利器。抽像在开发中的意义 ，是让具体的实施类，在合适的场所下编写 （最好满足 sru）, 然后通过合理的 ood，去调用或运行时 create 具体的子类对象，去实现。拜抽象所赐，一种各有分工，又能有序协同的场景就出来了。其三，个人套路包，我沟通时，当和建议相同方向时，就往抽像了说，当想有差异时，就很细节说。（套路是双韧剑，就看你如何用了），我个人发现很多营销大的套路，抽像来看和传销是一至的，有些技术大牛的工作套路，和某著名贪官一模一样。（例如，把话说明白了再干，明确职责）

继续用来表示类之间是 is -a 关系。猫是动物，于是就拥有的动物的自带属性行为。（移动速度，移动距离） 进一步的，动物属生物（于是） 有了生命的共有属性，年龄。有些语言单继续，有些多继承。

意义和解决问题。1）符合认知美感 。2）减少重复 coding。问题：重要隐患，父子类，大量方便藕合。个人理解：继续和不停的复杂粘贴代码是两个极度，复制代码虽散但各管各的，继续父一改，子跟着改，而复制代码这事，是问题是，实现一个细节后，其它的相联代码，都要不停的改。而继随相反，一改全刷了，除非你子类完全重写了，而一些不成熟的开发，前期的父类往往考虑不周，后期一折腾，悲剧从此开场。再者复制粘贴代码，两段代码关联太轻，基本上就是要一处一处的改，而复制这事，就关联得太重了。一但重了，就往往产生大量的不必要的负担。我学设计模式最开心的就是，基于原则，而不是基于规则，不同场景就用不同的套路。基于职责太重这事，我是很反感用多重继续的。需要啥，再组合一个类多好。多关联一个类，死不了人的。搞出菱形继随这种蛋疼的东西，又要不停的去关注细节，活着会很累的。

多态。（个人觉得 oo 中最有趣的一块）多态指子类替代父类。三种语法机制。（父可以）实现多态，除继续外，还有利用接口类语法，duck-typing。个人理解：理解不深。有感觉描述不出来，就觉得，继续把事搞死了，多态就要死的东西搞活。于是支持这种把事搞活的套路出来。2019-11-14

c 语言通过结构体来实现封装，只是 c 的结构体没有关键字来控制结构体内部成员的访问权限问题，属于一种比较粗的封装。另外 C 中通过 void*+ 结构体 + 函数指针也是可以实现多太的。Linux 内核代码好多都是用了面向对象编程思想。C++ 中引入 public protected private 关键字来进行访问控制权管理。C++ 中没有 Java 中的 interface 关键字来描述接口类，但也是可以通过虚函数基类来进行的 Java 中的接口类的。C++ 是直接支持多继承的，但这个特性也被好多人诟病。2019-11-13

JavaScript 不支持多继承，多继承理论上都存在「菱形问题」，也就是说如果 class D 继承了 class B 和 class C，class B 和 class C 都继承了 class A，class A 中有一个方法 add，B 和 C 都重写了 add 方法，当 D 去调用 add 方法时 就会出问题，不知道调用哪个方法了。理论上是可以通过 Mixin 的方式来实现多继承。通过一些「合并」算法来「部分」解决「菱形问题」。参考 [JavaScript 中的多继承 - 前端 - 掘金](https://juejin.im/entry/5ac46b6c5188255570063b71)。

JavaScript 支持封装，抽象，继承，多态。封装 ES6 的话，通过 public protected private 等关键字来实现，ES5 的话通过「函数作用域」，this，原型链来实现，ES6 的 class 本质上也是 function 的语法糖。抽象可以通过 this 指针和原型链的形式来实现。继承通过原型链来实现，或者说基于封装的特性来实现。多态通过原型链的方式，子类覆写父类的方法来实现。2019-11-15

多继承会带来菱形继承的问题。例如一个类的两个父类，都继承了同一个祖父类，两个父类都 override 了祖父类的方法，这时候孙子类就不知道如何调用了。Java 8 的 interface 可以有方法默认实现，这应该可以算是曲线救国的多继承吧。2019-11-13

Python 相关：1）抽象：抽象是编程语言的共有特点，甚至是计算机科学的特点，从变量，函数，类，模块，包等概念都是不同层次的抽象。抽象和把大象装进冰箱分三步是一个道理，它给出了思路，指明了方向，省略了细节。我们用层层抽象来应对计算机系统的复杂性。Python 主要的抽象工具是函数和类，模块和包也算吧，毕竟也是隐藏了细节。2）封装：Python 不支持严格意义上的封装，没有 private、protected 等访问修饰符，这样做是为了保证动态语言最大的灵活性，同时 Python 里很多理念都是约定大于定义的，私有的属性需要大家守约，不要去随意访问，这也是 Python 被吐槽的地方吧，大型项目约束力不够。3）继承：Python 支持多重继承，主要是因为它没有类似于 Java 的「接口类」的语法吧，用多重继承可以定义一些纯功能性的类，减少类的层级。4）多态：Python 的多态就是鸭子类型了，鸭子类型的背后是所谓「协议」，协议是非正式的接口，是一种特性，表现为一个或多个相关的方法，比如迭代器协议，序列协议。实现了迭代器协议就和 Java 中实现了 Iterator 接口一样。2019-11-13

请问 c++ 的 template 算不算 duck-typing？ 比如定义一个模版，A\<T>，用到函数 T.Load ()。然后有类 B 和 C 都有成员函数 Load()。那么都可以通过使用 A\<B> 和 A\<C> 来使用模版，而 B，C 之间不需要继承关系。作者回复：从你的描述来看，有点类似的。2019-11-17

python 是支持多继承的，对于多继承的二义性问题，有一套 MRO（Method Resolution Order）机制来解决，简单说就是排序。目前是采用 C3 算法，对继承关系建树后，使用拓扑排序得到序列；在 python2.2 之前也有用 DFS 去获取继承序列，但 DFS 会出现继承不到子类对于父类的重写，而后更新为 C3 算法，解决了本地优先级及单调性的问题。2019-11-12

python 支持多重继承，带来钻石继承问题主要是两点：一是父类方法的调用顺序，二是父类方法会被执行多次。对问题一，python 使用了 C3 算法，在避免同一类被调用多次的前提下，使用广度优先和从左到右的原则寻找需要属性和方法，使用 funcitonname.\_\_mro\_\_可以查看调用顺序。对问题二，python 在子类重写方法时，使用 super().methodname() 语句，super 本质上是一个类，内部记录着 MRO 信息，也是用 C3 算法保证一个类只会被搜寻一次。2019-11-15

最近在探索 DDD 的时候有个问题，当涉及 db 或 api 时该怎么设计。比如你上面提到的账户调增，理论上有个人的账户都会有个新的对象，但假如调增要调用 api，那这个 api 需要这个账户类持有么？那每次创建对象还要 set 进去？感觉不是很舒服。作者回复：感觉还是一种数据驱动或者 db 驱动的设计思维方式。实际上，对于一些复杂业务逻辑的开发，db 中数据的读和存只是很小的一部分。2019-11-15

Swift 不支持多重继承，原因应该和其他不支持多重继承的原因一样，为了避免多重继承额外引入的复杂度。Swift 支持封装、抽象、继承、多态：对封装的语法支持是通过 fileprivate 关键字隐藏不暴露的变量和方法；对抽象的支持是通过 protocol 关键字；对继承的支持是 class A: ClassB，对多态的支持是子类重写父类的方法。2019-11-14

ava 不支持多继承，弊端之一的菱形问题就不赘述了，我认为多继承带来的另外一个问题就是复杂性的增加，我们在写程序之前，常常会按照「接口 -> 抽象类 -> 实现类 -> 拓展实现类」这样的模式，这样设计出来的一组类是与某一个「业务」强相关的，如果可以多继承，以上流程就可以在任一环节继承其他一组类，这样的设计会造成更高的复杂性与耦合性，之后理解与维护的成本会更高。2019-11-13

## 0103面向对象相比面向过程有哪些优势.md

在上两节课中，我们讲了面向对象这种现在非常流行的编程范式，或者说编程风格。实际上，除了面向对象之外，被大家熟知的编程范式还有另外两种，面向过程编程和函数式编程。面向过程这种编程范式随着面向对象的出现，已经慢慢退出了舞台，而函数式编程目前还没有被广泛接受。在专栏中，我不会对函数式编程做讲解，但我会花两节课的时间，讲一下面向过程这种编程范式。你可能会问，既然面向对象已经成为主流的编程范式，而面向过程已经不那么推荐使用，那为什么又要浪费时间讲它呢？

那是因为在过往的工作中，我发现很多人搞不清楚面向对象和面向过程的区别，总以为使用面向对象编程语言来做开发，就是在进行面向对象编程了。而实际上，他们只是在用面向对象编程语言，编写面向过程风格的代码而已，并没有发挥面向对象编程的优势。这就相当于手握一把屠龙刀，却只是把它当作一把普通的刀剑来用，相当可惜。

所以，我打算详细对比一下面向过程和面向对象这两种编程范式，带你一块搞清楚下面这几个问题（前三个问题我今天讲解，后三个问题我放到下一节课中讲解）：1）什么是面向过程编程与面向过程编程语言？2）面向对象编程相比面向过程编程有哪些优势？3）为什么说面向对象编程语言比面向过程编程语言更高级？4）有哪些看似是面向对象实际是面向过程风格的代码？5）在面向对象编程中，为什么容易写出面向过程风格的代码？6）面向过程编程和面向过程编程语言就真的无用武之地了吗？

### 3.1 什么是面向过程编程与面向过程编程语言？

如果你是一名比较资深的程序员，最开始学习编程的时候，接触的是 Basic、Pascal、C 等面向过程的编程语言，那你对这两个概念肯定不陌生。但如果你是新生代的程序员，一开始学编程的时候，接触的就是面向对象编程语言，那你对这两个概念可能会比较不熟悉。所以，在对比面向对象与面向过程优劣之前，我们先把面向过程编程和面向过程编程语言这两个概念搞清楚。

实际上，我们可以对比着面向对象编程和面向对象编程语言这两个概念，来理解面向过程编程和面向过程编程语言。还记得我们之前是如何定义面向对象编程和面向对象编程语言的吗？1）面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。2）面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。

类比面向对象编程与面向对象编程语言的定义，对于面向过程编程和面向过程编程语言这两个概念，我给出下面这样的定义。1）面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。2）面向过程编程语言首先是一种编程语言。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。

不过，这里我必须声明一下，就像我们在之前讲到的，面向对象编程和面向对象编程语言并没有官方的定义一样，这里我给出的面向过程编程和面向过程编程语言的定义，也并不是严格的官方定义。之所以要给出这样的定义，只是为了跟面向对象编程及面向对象编程语言做个对比，以方便你理解它们的区别。

定义不是很严格，也比较抽象，所以，我再用一个例子进一步解释一下。假设我们有一个记录了用户信息的文本文件 users.txt，每行文本的格式是 name&age&gender（比如，小王&28& 男）。我们希望写一个程序，从 users.txt 文件中逐行读取用户信息，然后格式化成 name\tage\tgender（其中，\t 是分隔符）这种文本格式，并且按照 age 从小到大排序之后，重新写入到另一个文本文件 formatted\_users.txt 中。针对这样一个小程序的开发，我们一块来看看，用面向过程和面向对象两种编程风格，编写出来的代码有什么不同。

首先，我们先来看，用面向过程这种编程风格写出来的代码是什么样子的。注意，下面的代码是用 C 语言这种面向过程的编程语言来编写的。

```c
struct User {
  char name[64];
  int age;
  char gender[16];
};

struct User parse_to_user(char* text) {
  // 将text(“小王&28&男”)解析成结构体struct User
}

char* format_to_text(struct User user) {
  // 将结构体struct User格式化成文本（"小王\t28\t男"）
}

void sort_users_by_age(struct User users[]) {
  // 按照年龄从小到大排序users
}

void format_user_file(char* origin_file_path, char* new_file_path) {
  // open files...
  struct User users[1024]; // 假设最大1024个用户
  int count = 0;
  while(1) { // read until the file is empty
    struct User user = parse_to_user(line);
    users[count++] = user;
  }
  
  sort_users_by_age(users);
  
  for (int i = 0; i < count; ++i) {
    char* formatted_user_text = format_to_text(users[i]);
    // write to new file...
  }
  // close files...
}

int main(char** args, int argv) {
  format_user_file("/home/zheng/user.txt", "/home/zheng/formatted_users.txt");
}
```

然后，我们再来看，用面向对象这种编程风格写出来的代码是什么样子的。注意，下面的代码是用 Java 这种面向对象的编程语言来编写的。

```java
 public class User {
  private String name;
  private int age;
  private String gender;
  
  public User(String name, int age, String gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
  }
  
  public static User praseFrom(String userInfoText) {
    // 将text(“小王&28&男”)解析成类User
  }
  
  public String formatToText() {
    // 将类User格式化成文本（"小王\t28\t男"）
  }
}

public class UserFileFormatter {
  public void format(String userFile, String formattedUserFile) {
    // Open files...
    List users = new ArrayList<>();
    while (1) { // read until file is empty 
      // read from file into userText...
      User user = User.parseFrom(userText);
      users.add(user);
    }
    // sort users by age...
    for (int i = 0; i < users.size(); ++i) {
      String formattedUserText = user.formatToText();
      // write to new file...
    }
    // close files...
  }
}

public class MainApplication {
  public static void main(String[] args) {
    UserFileFormatter userFileFormatter = new UserFileFormatter();
    userFileFormatter.format("/home/zheng/users.txt", "/home/zheng/formatted_users.txt");
  }
}
```

从上面的代码中，我们可以看出，面向过程和面向对象最基本的区别就是，代码的组织方式不同。面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。看完这个例子之后，你可能会说，面向对象编程和面向过程编程，两种风格的区别就这么一点吗？当然不是，对于这两种编程风格的更多区别，我们继续往下看。

### 3.2 面向对象编程相比面向过程编程有哪些优势？

刚刚我们介绍了面向过程编程及面向过程编程语言的定义，并跟面向对象编程及面向对象编程语言做了一个简单对比。接下来，我们再来看一下，为什么面向对象编程晚于面向过程编程出现，却能取而代之，成为现在主流的编程范式？面向对象编程跟面向过程编程比起来，到底有哪些优势？

#### 3.2.1 OOP 更加能够应对大规模复杂程序的开发

看了刚刚举的那个格式化文本文件的例子，你可能会有这样的疑问，两种编程风格实现的代码貌似差不多啊，顶多就是代码的组织方式有点区别，没有感觉到面向对象编程有什么明显的优势呀！你的感觉没错。之所以有这种感觉，主要原因是这个例子程序比较简单、不够复杂。

对于简单程序的开发来说，不管是用面向过程编程风格，还是用面向对象编程风格，差别确实不会很大，甚至有的时候，面向过程的编程风格反倒更有优势。因为需求足够简单，整个程序的处理流程只有一条主线，很容易被划分成顺序执行的几个步骤，然后逐句翻译成代码，这就非常适合采用面向过程这种面条式的编程风格来实现。

但对于大规模复杂程序的开发来说，整个程序的处理流程错综复杂，并非只有一条主线。如果把整个程序的处理流程画出来的话，会是一个网状结构。如果我们再用面向过程编程这种流程化、线性的思维方式，去翻译这个网状结构，去思考如何把程序拆解为一组顺序执行的方法，就会比较吃力。这个时候，面向对象的编程风格的优势就比较明显了。

面向对象编程是以类为思考对象。在进行面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当我们有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。

除此之外，面向对象编程还提供了一种更加清晰的、更加模块化的代码组织方式。比如，我们开发一个电商交易系统，业务逻辑复杂，代码量很大，可能要定义数百个函数、数百个数据结构，那如何分门别类地组织这些函数和数据结构，才能不至于看起来比较凌乱呢？类就是一种非常好的组织这些函数和数据结构的方式，是一种将代码模块化的有效手段。

你可能会说，像 C 语言这种面向过程的编程语言，我们也可以按照功能的不同，把函数和数据结构放到不同的文件里，以达到给函数和数据结构分类的目的，照样可以实现代码的模块化。你说得没错。只不过面向对象编程本身提供了类的概念，强制你做这件事情，而面向过程编程并不强求。这也算是面向对象编程相对于面向过程编程的一个微创新吧。

实际上，利用面向过程的编程语言照样可以写出面向对象风格的代码，只不过可能会比用面向对象编程语言来写面向对象风格的代码，付出的代价要高一些。而且，面向过程编程和面向对象编程并非完全对立的。很多软件开发中，尽管利用的是面向过程的编程语言，也都有借鉴面向对象编程的一些优点。

#### 3.2.2 OOP 风格的代码更易复用、易扩展、易维护

在刚刚的那个例子中，因为代码比较简单，所以只用到到了类、对象这两个最基本的面向对象概念，并没有用到更加高级的四大特性，封装、抽象、继承、多态。因此，面向对象编程的优势其实并没有发挥出来。

面向过程编程是一种非常简单的编程风格，并没有像面向对象编程那样提供丰富的特性。而面向对象编程提供的封装、抽象、继承、多态这些特性，能极大地满足复杂的编程需求，能方便我们写出更易复用、易扩展、易维护的代码。为什么这么说呢？还记得我们在上一节课中讲到的封装、抽象、继承、多态存在的意义吗？我们再来简单回顾一下。

首先，我们先来看下封装特性。封装特性是面向对象编程相比于面向过程编程的一个最基本的区别，因为它基于的是面向对象编程中最基本的类的概念。面向对象编程通过类这种组织代码的方式，将数据和方法绑定在一起，通过访问权限控制，只允许外部调用者通过类暴露的有限方法访问数据，而不会像面向过程编程那样，数据可以被任意方法随意修改。因此，面向对象编程提供的封装特性更有利于提高代码的易维护性。

其次，我们再来看下抽象特性。我们知道，函数本身就是一种抽象，它隐藏了具体的实现。我们在使用函数的时候，只需要了解函数具有什么功能，而不需要了解它是怎么实现的。从这一点上，不管面向过程编程还是是面向对象编程，都支持抽象特性。不过，面向对象编程还提供了其他抽象特性的实现方式。这些实现方式是面向过程编程所不具备的，比如基于接口实现的抽象。基于接口的抽象，可以让我们在不改变原有实现的情况下，轻松替换新的实现逻辑，提高了代码的可扩展性。

再次，我们来看下继承特性。继承特性是面向对象编程相比于面向过程编程所特有的两个特性之一（另一个是多态）。如果两个类有一些相同的属性和方法，我们就可以将这些相同的代码，抽取到父类中，让两个子类继承父类。这样两个子类也就可以重用父类中的代码，避免了代码重复写多遍，提高了代码的复用性。

最后，我们来看下多态特性。基于这个特性，我们在需要修改一个功能实现的时候，可以通过实现一个新的子类的方式，在子类中重写原来的功能逻辑，用子类替换父类。在实际的代码运行过程中，调用子类新的功能逻辑，而不是在原有代码上做修改。这就遵从了「对修改关闭、对扩展开放」的设计原则，提高代码的扩展性。除此之外，利用多态特性，不同的类对象可以传递给相同的方法，执行不同的代码逻辑，提高了代码的复用性。

所以说，基于这四大特性，利用面向对象编程，我们可以更轻松地写出易复用、易扩展、易维护的代码。当然，我们不能说，利用面向过程风格就不可以写出易复用、易扩展、易维护的代码，但没有四大特性的帮助，付出的代价可能就要高一些。

#### 3.2.3 OOP 语言更加人性化、更加高级、更加智能

人类最开始跟机器打交道是通过 0、1 这样的二进制指令，然后是汇编语言，再之后才出现了高级编程语言。在高级编程语言中，面向过程编程语言又早于面向对象编程语言出现。之所以先出现面向过程编程语言，那是因为跟机器交互的方式，从二进制指令、汇编语言到面向过程编程语言，是一个非常自然的过渡，都是一种流程化的、面条式的编程风格，用一组指令顺序操作数据，来完成一项任务。

从指令到汇编再到面向过程编程语言，跟机器打交道的方式在不停地演进，从中我们很容易发现这样一条规律，那就是编程语言越来越人性化，让人跟机器打交道越来越容易。笼统点讲，就是编程语言越来越高级。实际上，在面向过程编程语言之后，面向对象编程语言的出现，也顺应了这样的发展规律，也就是说，面向对象编程语言比面向过程编程语言更加高级！

跟二进制指令、汇编语言、面向过程编程语言相比，面向对象编程语言的编程套路、思考问题的方式，是完全不一样的。前三者是一种计算机思维方式，而面向对象是一种人类的思维方式。我们在用前面三种语言编程的时候，我们是在思考，如何设计一组指令，告诉机器去执行这组指令，操作某些数据，帮我们完成某个任务。而在进行面向对象编程时候，我们是在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道。可以这么说，越高级的编程语言离机器越「远」，离我们人类越「近」，越「智能」。

这里多聊几句，顺着刚刚这个编程语言的发展规律来想，如果一种新的突破性的编程语言出现，那它肯定是更加「智能」的。大胆想象一下，使用这种编程语言，我们可以无需对计算机知识有任何了解，无需像现在这样一行一行地敲很多代码，只需要把需求文档写清楚，就能自动生成我们想要的软件了。

### 黑板墙

在文章中我讲到，面向对象编程比面向过程编程，更加容易应对大规模复杂程序的开发。但像 Unix、Linux 这些复杂的系统，也都是基于 C 语言这种面向过程的编程语言开发的，你怎么看待这个现象？这跟我之前的讲解相矛盾吗？

使用任何一个编程语言编写的程序，最终执行上都要落实到 CPU 一条一条指令的执行（无论通过虚拟机解释执行，还是直接编译为机器码），CPU 看不到是使用何种语言编写的程序。对于所有编程语言最终目的是两种：提高硬件的运行效率和提高程序员的开发效率。然而这两种很难兼得。

C 语言在效率方面几乎做到了极致，它更适合挖掘硬件的价值，如：C 语言用数组 char a [8]，经过编译以后变成了（基地址＋偏移量）的方式。对于 CPU 来说，没有运算比加法更快，它的执行效率的算法复杂度是 O (1) 的。从执行效率这个方面看，开发操作系统和贴近硬件的底层程序，C 语言是极好的选择。

C 语言带来的问题是内存越界、野指针、内存泄露等。它只关心程序飞的高不高，不关心程序猿飞的累不累。为了解脱程序员，提高开发效率，设计了 OOP 等更「智能」的编程语言，但是开发容易毕竟来源于对底层的一层一层又一层的包装。完成一个特定操作有了更多的中间环节，占用了更大的内存空间，占用了更多的 CPU 运算。从这个角度看，OOP 这种高级语言的流行是因为硬件越来越便宜了。我们可以想象如果大众消费级的主控芯片仍然是单核 600MHz 为主流，运行 Android 系统点击一个界面需要 2 秒才能响应，那我们现在用的大部分手机程序绝对不是使用 JAVA 开发的，Android 操作系统也不可能建立起这么大的生态。2019-11-16

我们以历史的时间线看看这两种语言的演进过程。1）1969 年贝尔实验室提出 Unix 操作系统。2）1972 年贝尔实验室的 Dennis Ritchie 开发 C 语言。3）1973 年他用 C 语言重写了 Unix。4）1991 年 Linus Torvalds 提出 Linux。另外一条线面向对象语言的发展：1）1972 年第一个面向对象的编程语言是 Simula 发布。2）1996 年，Java1.0 发布，流行的主要原因是 jvm，Write Once, Run Anywhere（编写一次，到处安装 JRE）。

从时间上看，面向对象概念的提出晚于面向过程。C 语言因商业应用成熟要比面相对象的编程语言早。C 语言的流行主要是因为 Unix 和 Linux 操作系统的实现基于 C 语言。类 Unix 系统可以运行在服务器，嵌入式设备，移动设备上。一个东西的好坏要综合考虑：面向过程和面向对象各有各的优缺点。一门编程语言的提出是为了解决某些特定的问题。面向对象和面向过程在应用上各有各的位置。2019-11-15

操作系统虽然是用面向过程的 C 语言实现的 但是其设计逻辑是面向对象的。C 语言没有类和对象的概念，但是用结构体（struct）同样实现了信息的封装，内核源码中也不乏继承和多态思想的体现。面向对象思想，不局限于具体语言。2019-11-15

读过 linux 内核源码和 python 解释器源码的应该都明白，所谓面向过程的 C 语言照样可以实现面向对象的思想，有很多设计都是非常优雅的，付出的代价并不高，我并不认为面向对象编程语言做相同的事情付出的代价会更低。编程思想、设计模式跟语言是没有关系的，编程思想和设计模式是指导我们编程的，而编程语言只是一种实现工具罢了。2019-11-17

操作系统的源码一直没读过，但我认为如此复杂的系统设计，（站在现在的时间点）用面向对象风格（或实现相同目的其他方式）来编写代码是更合适的，而且从 Linux 的模块化分来看，推测有类似的实践。老话说，机器能读懂所有代码，但人不一定。对于机器来说，每一次业务调用流程都是序列化的，机器并不在乎面向对象，但人在乎。正如本文所讲，编程语言离机器越来越远，离人越来越近。为了迁就人，我们使用了执行效率更低的语言，有了更多的中间环节，占用了更大的内存空间，换来的是这个行业的蓬勃发展以及让人类的便捷生活和能力延伸。2019-11-15

老师举的文件那个例子，使用面向对象编程那个，不是封装了函数，用函数对操作过程进行了抽象了吗，为什么老师说没有用到封装、抽象这些特性？C 语言虽然是面相过程语言，但是面向过程语言也可以写面向对象的，另外，C 语言更贴近底层一些，写操作系统的话还是有性能上的优势。作者回复：你指出的这点很好。关于封装，有两种理解，一种是狭义的面向对象特性：封装是一种信息隐藏，需要把数据和方法放到一起，而 c 语言实现的代码，数据和方法是分离的。封装的另一种广义的理解，可以包含你指的封装函数。抽象实际上我们前面章节中也讲到过，比较没有特异性，有的时候不看做面向对象的特性。2019-11-15

我理解 C++ 的出现主要是为了 C 语言中的泛型编程问题。而 Java 的出现是为了抽象对计算机的依赖，更专注于业务。对于计算机底层 C/C++ 可能更适合，而 C 的对于程序员来说自由度是最大的。再看 Linux 的发展，1991 年，林纳斯基于 Unix 的编写的，可能他更善于这个语言，他编写 git 的时候也是用的 C。Unix 选择 C 也是由于自己擅长的原因。2019-11-15

老师前几节讲的都是基本概念，每读一遍就感觉加深了一层印象和理解。学习本节最大的感受，面向对象和面向过程之间相互对比更容易理解，他们最大的区别。1）代码的组织单元：面向对象是类和对象，面向过程是函数和数据。2）是否支持四大特性以及对四大特性的支持程度，面向过程不支持继承和多态，在封装和抽象上，面向对象要更加深刻一些。面向对象对类抽象，面向过程抽象成方法，面条式的执行过程，流水线的操作方式。通过访问控制，面向对象对外暴露有限的成员属性和方法。总体来说，面向对象编程更适合人的思维习惯，能够客观反映代码和真实世界的关系。我的一点体会，不知道对不对，过一段时间再来回顾一次，看到时候的理解会不会更深。2019-11-15

OOP 更能应付复杂流程的程序开发，自己是深有体会。去年做了一个功能，第一版着急上线，就照着流程图翻译，最后就是一组顺序执行的方法集。if 分支特别多。上线后有空，自己重构了一版。这次是翻译了泳道图：data\_provider、rule\_filter\_chain、data\_consumer 和 data\_writer。

data\_provider 提供 3 种类型的数据。每种类型数据有 2 种规则。匹配规则后，会有一些数据处理，如与订单绑定、返佣记录等。最后是将这些数据持久化到数据库。处理过程还使用了多态特性，因此在调用 rule\_filter\_chain、data\_consumer、data\_writer 处的代码都特别精简，都是从 Map 获取处理对象，然后直接调用方法。

现在回看，重构时自己关注最多也是思考最多的是每个阶段的类对象，它的职责是什么。如入参是什么，业务逻辑处理，处理后的出参是什么。实现完这些类后，就真的是像搭积木一样将这些类串起来就可以了。就跟文章说的一样：业务建模、翻译需求为类、类之间交互。重构后的代码逻辑清晰了，也更简洁了。整个业务也更容易理解了。但是有一点，重构之后，类文件也增加了挺多。但是相比一个类几百上千行代码，我更喜欢简短的类。适当的增加一些类文件，也是能接受的。2020-01-09

我的理解不矛盾，理由如下：1）操作系统更多的是和硬件打交道，需要考虑到语言本身翻译成机器语言的成本和执行效率，尤其总要。2）如 linux 内核、总线、文件系统网络等的设计，也是具有面向对象过程的思想，很好的支持了常见的文件系统的挂在、内核的升级和对硬件的热插拔、网络等的处理，常见的服务器多数都是 linux，为啥不用 window，我的理解和设计实现有很大的关系，尤其是网络、安全、权限、标准等等。3）linux 操作系统，本身就是一个大的抽象，属于一个硬件和高级软件连接的桥梁。2019-11-16

go 语言的函数式编程算面向过程吗？作者回复：不算，是一种新的编程范式。2020-01-07

老师没讲函数编程，但我看了一下相关的优点，感觉函数式编程的优点是除了继承 oop 的优点外还有并发和无状态这两个特点，而这种特点和现在云服务切合度很高，但现在问题是对人的要求高。2019-11-17

思考，其实用什么语言来做什么软件，和几个方面有关系。1）软件诞生的时代，在它产生的时候，面向对象编程思想不是主要的趋势；2）发布软件的方式，如以开源的方式发布，它的成熟也要和其他开发者的水准相关，在当时的时代，太过超前的思想，没有很多人的参与，也诞生不了出名的软件；3）适用性，操作系统，更多的还是和计算机打交道，虽然思想上面向对象更适合人的思维，但是操作系统这一层，符合计算机思想的编程语言更适用，面向对象编程语言更适合开发应用软件，符合一般程序员的思维，更多的是跟操作系统打交道，等于中间有一种层级的关系。操作系统更像一个抽象的中间层。2019-11-15

面向过程编程范式是先考虑数据和处理数据的函数，函数和数据是分离的，main 函数开始初始化数据调用 func 处理数数据。面向对象编程范式：先根据需求抽象出类，粒度大的名词是类，粒度小的名称划分到类的属性，类的行为是方法，通过数据访问权限 private 和 public 保护属性的可见性和 get、set 方法保护数据的赋值和输出；先抽象出接口不用想实现就可以写代码，抽象出基类用继承实现代码复用。然后再用类「组合」和「依赖」进行搭积木完成现在业务逻辑。同时可以方便的利用多态实现扩展。范式是完成需求的思考过程和组织代码的方式，跟用什么语言关系不是很大。2020-05-11

在思想上：面向对象最重要的优势，他是以解决描述真实世界的需求为出发点的。而面向过程是以命令计算机如何执行为出发点的。所以，面向对象语言相对而言，比面向过程语言解决真实世界的问题效率更高。（当然，对于计算机则不同）

在技术上：面向对象晚于面向过程诞生，吸收并加强了前者的优秀特性，如抽象，面向过程的抽象是方法，函数的抽象。而面向对象则通过「类」这一特性提供更高纬度的抽象。可以帮助开发人员，先将复杂问题拆解为小的模块问题，在将主要的问题明确后，在专注于业务细节。

面向对象还基于类这一概念，提供了封装特性，将方法和数据绑定，实现了将数据访问权限控制，提高了数据安全性和可维护性。面向对象的继承概念还是要依托于类的概念，可以将多处的相同代码归集到一个类中，在其他要使用的地方通过继承就能获得相同能力。多态，一个函数，可以有多种实现方法。这就像我们生活中，做晚餐这件事，可以做多种做法，煎炒烹炸都行。只有遵照基本的条件就行。2020-05-05

也算是经历了从汇编到 c 到 c++ 再到 java 的过程。确实像作者所说，从偏向机器的思维慢慢过渡到了偏向人类的思维，这似乎也顺应了这个时代的发展潮流。写 c 的时代，我们要非常关注内存的分配，占用，释放，指针是否越界，程序会不会跑飞等问题。现在还记得研究生时候写过一段代码，一运行电脑就自动关机（然而代码的目的不是为了关机！）工作后越来越多的用了 java，有了 jvm，似乎只有在性能调优的时候才会想想堆栈情况，其余时候真的不用再考虑太多，按照业务模块分解功能，专注业务实现就可以了。也因此，程序员越来越高产，门槛也越来越低。然而，知其然而也知其所以然的程序员越来越少了，这样虽然看上去写了不少代码，堆砌了很多新的框架组建，但根基并不牢靠。所以真的需要多一些作者这样的课程，来帮助大家慢下节奏，沉下心多思考。2019-12-23

说白了其实还是要弄清楚 3 点：1）面向对象编程与面向对象编程语言是不是一样的。2）面向过程编程与面向过程编程语言是不是一个东西。3）是不是使用了面向对象语言写出的代码就是面向对象编程 、是不是使用了面向过程语言编程就体现不了面向对象编程的思想。这几点在前几节课讲基础的时候，老师讲的很明白了，在此自己举例子自己总结说明以下：

第一：Java 是一门面向对象的语言，封装，继承，多态，抽象是面向对象语言的特性，当然 Java 在语法上面对这四大特性也很好的支持，但是是不是我们用 Java 写代码了，我们就会面向对象的编程思想了，我感觉不是，在很多 Java 的代码中，完全没有用到这几大特性，因为没用到，所以对开闭、里氏替换、依赖倒置等设计原则没有体现过，反过来讲，我们为什么写代码需要有设计原则，为什么需要有好的设计原则，是因为业务代码的逻辑几乎不会是一成不变的，所以在变化的时候，我们应该变化仅仅需要变化的部分，而不是推倒重来，所以我们需要设计原则来建立基础的模型，需要封装、继承、多态、抽象这些支持设计原则的最基本特性。第二：C 语言是一门面向过程的编程语言，但是使用 c 语言编程的 Unix 系统，我感觉体现了面向对象编程的思想比如 Unix 系统的驱动设计，就是面向对象编程思想的体现。

最后总结来看：选用什么样的语言来实现产品，来实现业务，跟很多因素有关，个人的能力，接入的快慢，公司的要求等等。境界到了，语言对模型建立的影响应该很小了，这句话不知道说的对不对？因为我还远远没到这个境界，自己认为的。2019-11-16

为什么 Unix、Linux 是使用 C 这种面向过程编程语言开发的？1）历史原因。从二进制指令、汇编语言、面向过程编程语言、面向对象编程语言的发展历程来看，二进制指令和汇编语言由于不具备可移植性，并且不适用于开发大规模复杂程序，而 OOPL 比 POPL 出现得要晚。2）Unix/Linux 具备硬件管理的功能，而硬件运行的特点就是指令化、流程化，这一点与面向过程编程不谋而合。

我对未来编程语言的畅想：更加人性化、更加高级、更加智能，这一定是编程语言的发展方向，现在就已经出现了 AI 助力编程的消息了。对于小争哥所想象的，根据需求规格说明书直接生成代码的编程方式。我觉得有一种方式更容易落地实现。由人类描述代码的设计思路，然后由智能化的编译器生成相应的代码。比如，人类描述 23 种设计模式，然后编译器实现。当然，由于 23 种设计模式只在一些经典问题中才会使用，所以对于一些不需要使用设计模式的编码场景，会需要使用类似的东西进行描述。我把这种编程风格称为面向思路编程。其实，需求规格说明书也是一种表达，但是这种表达太过于接近业务。我不太相信几十年里能够做到。然而，面向思路编程是一种对于具体代码编码的描述，这种描述与业务需求描述无关。2019-11-15

我觉得面向对象是一种思维方式，之前学习 DDD 和 \<Thinking in uml>，吸收到的一点就是拿到业务需求的时候，原来是脑子里面构建出来，并且还要思考业务顺序的前后影响。

```
if (业务规约 1){
    A do something;
} else if (业务规约 2){
    B do something;
}
```

现在的思维方式是，看到上面的业务描述，拿出本子记录。这个业务里面有 A 对象，有一个功能 say()，哪些数据是归 A 管理的；这个业务里面有 B 对象，有一个功能 hello()，哪些数据是归 B 管理的。所以我觉得面向对象思维，和你用什么语言写是太直接的关系。当然会限制你的实现。比如说虚拟文件系统，我觉得就是面向对象的一种体现，可以支持 ext、fat32 等等，就是一种继承的体现。

有一个问题想问一下老师：目前我接触的项目实体都是贫血模型，虽然分析业务的时候，会努力向面向对象靠近，但是业务代码实现的时候。基本是每个分析的对象，功能包装进一个 service，但是数据还是在贫血实体内。有点类似 DDD 的聚合根（和实际 DDD 思想差的比较远），但是所有实体方法都是以服务的形式提供。但是一下子换成充血模型的话，对团队整体代码和一些跨 n 个实体的业务方法，实现起来又有问题。也没太想明白这个阶段怎么样比较合适。想听听老师是怎么看待这个问题的。2019-11-15

操作系统底层虽然是使用面向过程编程语言开发的，但是面向对象的思想却深入其中。像是 Linux Kernel，它又分成各个子系统，同时又有分离、分层的概念。比如开发一个设备的驱动，只需要分配一个对应的核心层的结构体，对结构体的成员做出该设备特定的设置即可，而设备驱动的很多方法都可以使用核心层的代码；这个过程其实就类似于面向对象编程的继承。可见对于复杂的系统的开发，面向对象的风格还是远胜于面向过程的。操作系统底层为何需要使用 C 语言，我觉得一方面是基于其效率考虑，另一方面则是为了增强在不同体系架构之间的可移植性吧，因为不同的体系架构其汇编指令是不同的，而 C 代码在底层可以很好的和汇编代码结合。2019-11-15

## 0104哪些代码设计看似是面向对象实际是面向过程的.md

