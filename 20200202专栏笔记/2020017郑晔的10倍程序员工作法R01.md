# 2020017郑晔的10倍程序员工作法R01

## 记忆时间

## 卡片

### 0101. 主题卡——思考框架：现状、目标和实施路径

你以为的「终」可能不是终，因为你只是站在自己的角度；你以为自己做了任务分解，在我看来，可能还不够，因为我希望你能够做到微操作；你以为的沟通反馈就是说话聊天，我想告诉你很多技术实践的存在也是为了沟通反馈；你以为自动化就是写代码，我会告诉你，有时候不写代码而解决问题，可能才是一个好方案。

先看一个场景：当一个产品经理给我交代一个要开发的功能特性时，我通常会问他这样一些问题：1）为什么要做这个特性，它会给用户带来怎样的价值？2）什么样的用户会用到这个特性，他们在什么场景下使用，他们又会怎样使用它？3）达成这个目的是否有其它手段？是不是一定要开发一个系统？4）这个特性上线之后，怎么衡量它的有效性？

如果产品经理能够回答好这些问题，说明他基本上已经把这个工作想得比较清楚了，这个时候，我才会放心地去了解后续的细节。我们用思考框架对照一下，为什么我会问这些问题。一般来说，一个新特性要开发时，现状我是知道的。所以，我更关心目标，这里「为什么要做这个特性？」就是在问目标，「给用户带来怎样的价值」是在确定这个目标的有效性。接下来，我会关注实现路径，用户会怎么用，是否有其他的替代手段，我需要了解产品经理的设计是经过思考的，还是「拍着脑袋」给出的。衡量有效性，则是要保证我的工作不会被浪费。

通过这个例子，给你展示了怎么用这个思考框架提出问题。但我估计你更想了解的是，我怎么会想到问这些问题。给出思考框架是为了让你明白为什么要提出问题，而具体问题要怎么问，就可以遵循下面这四项原则：以终为始；任务分解；沟通反馈；自动化。这是从思考框架延伸出来的。

这四个原则互相配合，形成了一个对事情的衡量标准。总体上可以保证我的工作是有效的，在明确目标和完成目标的过程中，都可以尽量减少偶然复杂度。怎么把这四个原则用在工作中呢？

回过头来看一下前面的场景，产品经理把要做的功能特性摆在我面前。站在以终为始的角度，我需要了解真正的目标是什么，所以，我会关心为什么要做这个特性。为了保证目标是有效的，我会关心它给用户带来的价值。有了任务分解的视角，我需要将一个大的目标进行拆解，如果我要达成这个目标，整体解决方案是远远不够的，我需要把任务分解成一个一个小的部分。所以，我会关心一个一个具体的使用场景。一方面，我会了解到更多的细节，另一方面，当时间紧迫的时候，我会和产品经理来谈谈究竟优先实现哪个场景。

为什么要学会沟通反馈？因为我需要明确，自己是否真正理解了产品经理提交的需求。所以，我要不断地问问题，确保自己的理解和产品经理交代的内容一致。另外，我也需要保证我的产品做出来确实能够达到目标。所以，我会关心它上线后的衡量手段。因为我知道，这个行业里有太多代码上线后，从来没有运行过。自动化的角度很有意思，我们做的方案通常是一个自动化方案，但我们需要了解这个方案没有自动化之前是怎么做的。如果不自动化，用户会怎么用。所以，我会关心是不是还有其它替换方案，比如，买一个现成的服务。因为很多需求的提出，只是因为我们有了一个开发团队而已。

1、以终为始，确定好真实目标。以终为始就是在工作的一开始就确定好自己的目标。我们需要看到的是真正的目标，而不是把别人交代给我们的工作当作目标。你可以看出这个原则是在帮助我们回答思考框架中，Where are we going?（我们要到哪儿去？）这个问题。

2、任务分解，找到实施路径。任务分解是将大目标拆分成一个一个可行的执行任务，工作分解得越细致，我们便越能更好地掌控工作，它是帮助我们回答思维框架中，How can we get there?（我们如何到达那里？）的问题。如果说前两个原则是要在动手之前做的分析，那后面两个原则就是在通往目标的道路上，为我们保驾护航，因为在实际工作中，我们少不了与人和机器打交道。

3、沟通反馈，解决与人打交道的问题。沟通反馈是为了疏通与其他人交互的渠道。一方面，我们保证信息能够传达出去，减少因为理解偏差造成的工作疏漏；另一方面，也要保证我们能够准确接收外部信息，以免因为自我感觉良好，阻碍了进步。

自动化，解决与机器打交道的问题。自动化就是将繁琐的工作通过自动化的方式交给机器执行，这是我们程序员本职工作的一部分，我们擅长的是为其他人打造自动化的服务，但自己的工作却应用得不够，这也是我们工作中最值得优化的部分。

四原则是起点（现状）、终点（目标）、路径思考框架的衍生品。

### 0102. 主题卡——编程练习的框架

基本框架是重构思维加测试思维加面向对象思维。要去看的书有：《重构》、《测试驱动开发》、《修改代码的艺术》、《代码整洁之道》、《架构整洁之道》（面向对象相关）。

### 0103. 主题卡——有效工作

有效工作，需要我们把力量聚焦到正确的地方，做本质复杂度（Essential Complexity）的事情，少做无意义的事情。我曾经在一个大公司做咨询，按照他们的统计，线上 60% 的代码从来没有运行过。我们都知道，一多半的代码增加的可不只是一多半的工作量，团队可能需要的是几倍甚至几十倍的心力去维护它。如何有效工作：1）拓展自己的上下文，看到真正的目标，更好地对准靶子，比如，多了解用户，才不至于做错了方向；站在公司的层面上，才知道哪个任务优先级更高；站在行业的角度，而不局限于只在公司内成为高手，等等。2）去掉不必要的内容，减少浪费，比如，花时间分析需求，不做非必要的功能；花时间做好领域设计，别围着特定技术打转；花时间做好自动化，把精力集中在编码上，等等。

要想有效工作，有两点非常重要。一方面，意识上要注意自己工作中无效的部分。这就像一个开关，拨过去就好了。所以，读这个专栏有人常有恍然大悟的感觉，也有人觉得很简单。很多时候，你只是不知道，就像我在专栏中提到，要问产品经理问题，这是很多人没想过的。每篇文章后面的那一句总结，就是这样的开关，拨过去就好。另一方面，要构建自己关于软件开发的知识体系，这是要花时间积累的。在这个专栏中，我给你讲了很多最佳实践，就是让你知道，在某些方面，有人已经做得很好了，花时间学习，比自己从头摸索好很多。这就像所有的数学公式一样，理论上你都可以自行推导，但肯定不如从教科书上学得快。

### 0201. 术语卡——本质复杂度和偶然复杂度

概念来自《人月神话》，已存入书籍「2019655人月神话」。

本质复杂度（Essential Complexity）和偶然复杂度（Accident Complexity）。本质复杂度是解决一个问题时，无论怎么做都必须要做的事，而偶然复杂度是因为选用的做事方法不当，而导致要多做的事。比如你要做一个网站，网站的内容是你无论如何都要写的，这是「本质复杂度」。而如果今天你还在用汇编写一个网站，效率是不可能高起来的，因为你选错了工具。这类选错方法或工具而引发的问题就是「偶然复杂度」。

### 0202. 术语卡——算法复杂度差异的本质

排序算法：插入排序、冒泡排序、归并排序、堆排序、快速排序等等。各个算法有其复杂度，比如，插入排序是 O (n^2），快速排序平均情况下是 O (nlogn）等等。你有没有想过一个问题，不同算法的复杂度本质差别到底是什么呢？我们就以插入排序和快速排序为例，为什么快速排序要比插入排序快呢？

答案：因为做比较的次数少。为什么同样的排序，比较次数会有差异呢？因为插入排序每次循环只关注当前的目标，循环之间没有关系，而快速排序在做不同划分时，上一次的结果对下一次有助力，因此它省下了不少的比较次数。

明白了这个道理，再来看所谓的算法优化，其实就是尽可能利用已知的信息，少做不必要的事。再来看一个常见的面试题，给你一堆数，找出前 100 个。很多人直觉就会想到排序，然后选出前 100 个。这种做法固然可行，但一定是做多了，因为这里需要的是找出前 100 个数，而不是要 100 个有序的数字，更不是要所有的数都有序。说到这里，你就知道了，只要把数据划分开就好，并不需要排序，如果划分点不是第 100 个元素，就向着 100 所在的方向继续划分就好。计算机是最擅长处理繁琐重复工作的，即便如此，我们依然要做算法优化，原因是当数据规模大到一定程度时，不同复杂度的算法差别就非常明显了。算法没用好，计算机硬件再好，也是徒劳的。

### 0203. 术语卡——微服务

### 0204. 术语卡——DDD

### 0301. 人名卡——人月神话的作者

#### 01. 基本信息

用一句话描述你对这个大牛的印象。

#### 02. 贡献及著作

### 0401. 金句卡——

最后根据他写的非常震撼的话语——产生一张金句卡。

## 模板

### 1. 逻辑脉络

用自己的话总结主题，梳理逻辑脉络，也就是在这个专栏的整个地图里，这一章节所在的节点。

### 2. 摘录及评论

## 0000. 发刊词

软件行业里有一本名著叫《人月神话》，其中提到两个非常重要的概念：本质复杂度（Essential Complexity）和偶然复杂度（Accident Complexity）。简单来说，本质复杂度就是解决一个问题时，无论怎么做都必须要做的事，而偶然复杂度是因为选用的做事方法不当，而导致要多做的事。比如你要做一个网站，网站的内容是你无论如何都要写的，这就是「本质复杂度」。而如果今天你还在用汇编写一个网站，效率是不可能高起来的，因为你选错了工具。这类选错方法或工具而引发的问题就是「偶然复杂度」。

作为一个在软件行业奋斗了近二十年的程序员，我深刻意识到一个遗憾的事实：大部分程序员忙碌解决的问题，都不是程序问题，而是由偶然复杂度导致的问题。换句话说，只要选择了正确的做事方法，减少偶然复杂度带来的工作量，软件开发是可以有条不紊进行的。如何减少偶然复杂度引发的问题，让软件开发工作有序、高效地进行，这正是我希望通过这个专栏帮你解决的问题。

许多人工作做事主要依靠直觉，在这个科学越发昌明的时代，我们清楚地看到，人类的直觉常常是错的，就像古人凭直觉认为大地是平的一样。软件开发也不例外，如果你不曾在做软件这件事上有过学习和思考，形成一套高效的工作方法，只是凭直觉行事，在真实世界中往往会举步维艰。

幸运的是，总会有不同的人在不同的方向上探索不同的做法，一旦通过真实世界的验证，就会沉淀出可供行业直接应用的最佳实践（Best Practice）。在软件行业中，这样能够提升工作效率的最佳实践已经有很多，但是，学习掌握这些最佳实践是有难度的，其根源就在于，很难找到这些实践彼此间的内在联系。直觉大多是错误的，最佳实践又多而琐碎，所以在这个专栏中，我会尝试给你提供一个思考框架，帮你在遇到问题时梳理自己真正要做的事情。围绕着这个框架，我还会给你一些原则。

这些原则，是我从软件行业的诸多软件开发最佳实践中总结出来的，也是我如今在工作中所坚持的。这些原则就是一条主线，将各种最佳实践贯穿起来。这些原则不多，总结起来就四个：1）以终为始；2）任务分解；3）沟通反馈；4）自动化。也许看到这四个原则的名字，你会不以为然，这些说法你在很多地方都看到过，但我想与你分享的内容可能与你想的并不完全一致。比如：你以为的「终」可能不是终，因为你只是站在自己的角度；你以为自己做了任务分解，在我看来，可能还不够，因为我希望你能够做到微操作；你以为的沟通反馈就是说话聊天，我想告诉你很多技术实践的存在也是为了沟通反馈；你以为自动化就是写代码，我会告诉你，有时候不写代码而解决问题，可能才是一个好方案。

2『又可以固化一个思维模型了，将四原则收录进个人模型里。』

在我看来，想要将精力聚焦在本质复杂度上，提高工作效率，摆脱直觉的束缚，只要掌握上面的四个原则就可以了。或许你此时会问，这些原则很难吧？其实并不难，在探讨这个专栏的内容时，我的编辑作为软件开发的局外人，经常发出感叹：「这事真的就这么简单吗？这不就是正常做事应该有的逻辑吗？」是的，就是这样简单，但大多数人没有这样做，因为这些原则在实际工作中很可能是反直觉的。只要打破思维误区，你的整个人都会变得不一样。

当我们详谈这些原则时，我会给你讲述一些最佳实践，让你看到这些原则是如何应用于不同的实践中的。希望我对这些实践的理解成为你的知识地图，让你拥有继续探索的方向。我做这个专栏的原则是「授人以鱼，不如授人以渔」。我希望你很好地理解这些原则，掌握高效工作的方法。至于最佳实践，你可以自行决定，是直接采纳还是曲线救国更为合适。

### 黑板墙

直觉在某种程度上也是很重要的吧，不是很多专家都是很依赖直觉的么。作者回复：这是一个好问题，这种说法混淆了直觉和洞见两件事。直觉是本能的，无需积累，而洞见是溯因推理（Abductive Reasoning），需要前期进行大量的积累之后，从中发现模式，方能形成洞见。打个比方，同样的思念，可以说，衣带渐宽终不悔，为伊消得人憔悴，也可以说，我想死你了。二者看上去差不多，但境界有差异。

购买了课程，学完了目前更新过的所有课程，除了测试这块，比较难推动，其他的基本都原来都践行，或者正在准备在落实。非常有用的课程，个人觉得，比看 JAVA 或者微服务的一个专栏，更容易学进去，也更有直接的收获，也更迫切需要。技术类课程到处都是，不花钱也可以找到，但是对于程序员的效率提升，整体能力的提升的课程较少，我之前也是一直觉得程序员就是写代码，但是新公司半年的加班告诉我，写代码成本太高，客户，产品经理一句话就可能让你多加几天班，但做出的功能却在业务上并未带来多少意义。我们不是执行指令的机器，也讨厌客户说的那句，你们只管写代码就好了，不要总是提什么拆分任务评估工时，跟她讲条件。按刘慈欣整理定律的方式来整理客户和开发的经验：1）甲方永远觉得付了钱，让乙方多干活也理所当然。2）开发时间是比较难评估的，一定要预留缓冲时间，即使多出来时间，也可以用来优化。3）技术是硬知识，独立思考和沟通，个人管理与项目管理是软知识，软知识是我所欠缺的，有更好的软知识可以事半功倍，可以处理各个上下文的问题。还有最直接的，把甲方拍大腿想的需求推掉，至少晚上更有时间去学习那些技术。作者回复：我希望专栏的读者在学过之后，遇到事情开始动脑想想为什么和怎么做，你的回复让我觉得我的初衷达成了。

对于一个明确的技术点，优秀的程序员仿佛能更快的找到解决方案，而且往往就是最佳实践，这是什么原因？从技术点角度讲，它并不需要掌握其他相关知识。作者回复：你把结果当成了原因，优秀的程序员能够快速解决问题，是因为它已经做了大量积累，有自己的知识体系，任何领域想做到一定的水准都需要刻意练习，而且是大量的刻意练习。刻意练习，是一个重要的概念，我本打算在这个专栏里讲一下，后来由于主题的关系，暂时拿掉了。

## 0001十倍程序员是如何思考的.md

大多数人工作低效是由于工作中偶然复杂度太多造成的，只要能够更多地将注意力放到本质复杂度上，减少偶然复杂度造成的消耗，我们「真实」的工作效率自然会得到大幅度提升。而想要减少偶然复杂度的消耗，就要了解一些高效的工作方式和行业的最佳实践，而这一切是可以用统一的框架进行思考的。运用这个思考框架，我们需要问自己一些问题：1）Where are we?（我们现在在哪？）2）Where are we going?（我们要到哪儿去？）3）How can we get there?（我们如何到达那里？）为了把这个框架应用在我们程序员的工作中，我给了你四个思考原则：1）以终为始，确定好真实目标；2）任务分解，找到实施路径；3）沟通反馈，解决与人打交道出现的问题；4）自动化，解决与机器打交道出现的问题。面对问题时，用思考框架问问自己，现状、目标和路径。

1、一个思考框架。我曾经组织过针对应届毕业生的培训，第一堂课我往往亲自操刀，其中有一个头脑风暴的环节「畅想未来」，我会让大家思考三个问题：1）我现在是个什么水平？2）我想达到一个什么水平？3）我将怎样到达那个目标？大家会围绕着这三个问题，从各种角度展开讨论。这是一个有趣的练习，你会发现大家「最擅长」的是回答第一个问题：我现在处于什么水平？和有经验的人相比，他们大多自认为比较「菜」。但对于后两个问题的讨论，却可以切实看出人和人之间处理问题的能力差异。有人通过之前的资料搜集，已经对自己的未来有了一个打算。比如想成为一个研发大牛，或者想做一个开源软件等，也就是说，对于第二个问题，他有明确的答案。而有的人则是一脸茫然，他很可能根本没有考虑过这个问题。而从题目本身来看，目标相对清晰的同学，才会进入到第三个问题，而茫然的同学，则完全无从下手。

那么我为什么会问这几个问题呢？我是想让大家跳出现有的思考模式，摆脱仅凭直觉「闷头做事」的习惯方式，把低着的头抬起来，看一眼未来，给自己找一个方向。否则，如果你对未来没有定位，是茫然的，尽管你也知道要努力，但劲儿该往哪里使呢？如果使劲的方向不对，那么你越使劲儿，可能会在错误的路上跑得越远。南辕北辙的道理大家都懂，但具体到自己的工作和发展上，真正能体会并实践的却是少数。其实，这三个问题来自一个思考框架。在给其他公司团队做咨询时，我也经常会运用到它，原来的问题是：1）Where are we?（我们现在在哪？）2）Where are we going?（我们要到哪儿去？）3）How can we get there?（我们如何到达那里？）

这三个问题实际上是帮我们确定：现状；目标；实现路径。如果一个人能够清晰地回答出这三个问题，通常意味着他对要做的事有着清晰的认识。这个框架虽然看似简单，但却非常有效，它已经成为我工具箱里一件非常称手的思考工具。在我的职业生涯里，与很多人讨论不同的事时，我都会用到这个思考框架的不同变体，而在这个专栏里，我也会用它来帮助回答「怎样高效工作、怎样做好软件」这件事。

2、四个思考原则。在实际的工作中，这个思考框架会帮助我更好地了解自己的工作。比如，当一个产品经理给我交代一个要开发的功能特性时，我通常会问他这样一些问题：1）为什么要做这个特性，它会给用户带来怎样的价值？2）什么样的用户会用到这个特性，他们在什么场景下使用，他们又会怎样使用它？3）达成这个目的是否有其它手段？是不是一定要开发一个系统？4）这个特性上线之后，怎么衡量它的有效性？

如果产品经理能够回答好这些问题，说明他基本上已经把这个工作想得比较清楚了，这个时候，我才会放心地去了解后续的细节。我们用思考框架对照一下，为什么我会问这些问题。一般来说，一个新特性要开发时，现状我是知道的。所以，我更关心目标，这里「为什么要做这个特性？」就是在问目标，「给用户带来怎样的价值」是在确定这个目标的有效性。接下来，我会关注实现路径，用户会怎么用，是否有其他的替代手段，我需要了解产品经理的设计是经过思考的，还是「拍着脑袋」给出的。衡量有效性，则是要保证我的工作不会被浪费。

通过这个例子，我给你展示了怎么用这个思考框架提出问题。但我估计你更想了解的是，我怎么会想到问这些问题。给出思考框架是为了让你明白为什么要提出问题，而具体问题要怎么问，就可以遵循下面这四项原则：以终为始；任务分解；沟通反馈；自动化。这是我从思考框架延伸出来的。在这个专栏里，我会围绕这四项原则和你详细讨论。

解释一下，1）以终为始就是在工作的一开始就确定好自己的目标。我们需要看到的是真正的目标，而不是把别人交代给我们的工作当作目标。你可以看出这个原则是在帮助我们回答思考框架中，Where are we going?（我们要到哪儿去？）这个问题。2）任务分解是将大目标拆分成一个一个可行的执行任务，工作分解得越细致，我们便越能更好地掌控工作，它是帮助我们回答思维框架中，How can we get there?（我们如何到达那里？）的问题。如果说前两个原则是要在动手之前做的分析，那后面两个原则就是在通往目标的道路上，为我们保驾护航，因为在实际工作中，我们少不了与人和机器打交道。3）沟通反馈是为了疏通与其他人交互的渠道。一方面，我们保证信息能够传达出去，减少因为理解偏差造成的工作疏漏；另一方面，也要保证我们能够准确接收外部信息，以免因为自我感觉良好，阻碍了进步。4）自动化就是将繁琐的工作通过自动化的方式交给机器执行，这是我们程序员本职工作的一部分，我们擅长的是为其他人打造自动化的服务，但自己的工作却应用得不够，这也是我们工作中最值得优化的部分。

这四个原则互相配合，形成了一个对事情的衡量标准。总体上可以保证我的工作是有效的，在明确目标和完成目标的过程中，都可以尽量减少偶然复杂度。怎么把这四个原则用在工作中呢？我们回过头来看一下前面的场景，产品经理把要做的功能特性摆在我面前。站在以终为始的角度，我需要了解真正的目标是什么，所以，我会关心为什么要做这个特性。为了保证目标是有效的，我会关心它给用户带来的价值。有了任务分解的视角，我需要将一个大的目标进行拆解，如果我要达成这个目标，整体解决方案是远远不够的，我需要把任务分解成一个一个小的部分。所以，我会关心一个一个具体的使用场景。一方面，我会了解到更多的细节，另一方面，当时间紧迫的时候，我会和产品经理来谈谈究竟优先实现哪个场景。

为什么要学会沟通反馈？因为我需要明确，自己是否真正理解了产品经理提交的需求。所以，我要不断地问问题，确保自己的理解和产品经理交代的内容一致。另外，我也需要保证我的产品做出来确实能够达到目标。所以，我会关心它上线后的衡量手段。因为我知道，这个行业里有太多代码上线后，从来没有运行过。自动化的角度很有意思，我们做的方案通常是一个自动化方案，但我们需要了解这个方案没有自动化之前是怎么做的。如果不自动化，用户会怎么用。所以，我会关心是不是还有其它替换方案，比如，买一个现成的服务。因为很多需求的提出，只是因为我们有了一个开发团队而已。

好，现在你已经对这四个原则在工作中的应用有了一个直观的认识。但你也会发现，我问的这些问题似乎已经「超纲」了，超过了一个普通程序员应该关注的范围。但这就是真实世界，它不像考试一样，有一个标准答案。我们不是一个人孤独地在工作，而是与其他人在协作，想要做到高效工作，我们就要「抬起头」来，跳出写代码这件事本身。所以，我在开篇词里说，程序员解决的问题，大多不是程序问题。可能你对这些原则的了解还没过瘾，没关系，这篇文章只是让大家清晰地了解思考框架和原则的背后逻辑。接下来，我会结合行业里的最佳实践，给你进一步讲解这些原则和具体应用。

### 黑板墙

现状：勉强的架构师、技术管理。目标：架构师、cto。途径：1）理论加强学习：togaf 学习理论。2）实践技能应用： netty、redis、mysql、niginx、微服务架构、分布式架构。3）做微信公众号，多思考多积累经验，形成自己的套路，同时形成影响力。

思考框架是道，原则是演化下的术，我们从 A → B，有无穷无尽的路径，最有效的唯有那条直线。本质上，各个维度、原则（不限于作者提到的四项原则）都是帮助我们更好地定位 A 在哪里，B 在哪里，那条直线在哪里。这个思考工具算是吸收了，四项原则也是有借鉴意义。

x-y 问题描述的就是错把手段当目的的没有以终为始的一个典型反例。解决问题第一步就是定义问题，知道自己要解决的问题的实质。爱因斯坦的名言说要解决问题的大部分时间应该拿来弄清问题本质。不过他指的解决问题应该只包含找到解决方案这部分，不包含具体实施。知道了问题的实质之后开始拆解问题，进行任务分解。通常，弄清问题本质和任务拆解是一体的，分不太开。关于任务分解，也就是找出解决方案，学问就大了。其中涉及各种思考框架，包括通用的如金字塔原理，各种领域套路，4c3p。这部分就需要学习工作中常常总结了。沟通反馈透露出控制论的思想。在行动中根据反馈不断调整自己的行动。自动化，在程序员这一职业中更加长见，程序员本身做的事情就是在帮助别人自动化。而自己的工作也不能忘了自动化。从软件的整个生命周期中，大量存在各种使用的工具。不过不能停留在学习这些工具的使用上，而是应该追问这些工具出现的原因，而自己的工作中有哪些工作是可以使用工具帮忙完成的。

老师的建议和指导都是非常有效，而且「感觉非常可行」，可是实际现实的情况，却有太多意外，我个人曾经在某银行的外包团队中，协同开发一个商户 —— 收银以及集成了各种第三方的团队的接口等等，这个大项目大概有 300 人以上，由此我的 leader 不在，我代表开会，足足开了 3-4 个小时 (约 30 个 leader)。杂乱无章，从我个人开发角度无法去高屋建瓴的把握全局应用场景，使用价值之类的。但是每个模块之间互相调用联系，系统升级需要协作。首先，这里沟通成本很高，最要命的是需求变动，无法预测，有的时候新增需求，技术 leader 直接告诉我在什么地方写一个 action，调用一个方法之类的。基本就是码农搬砖之类的，我想提的建议是：希望老师在有丰富理论知识，能给我们有一些实践中的例子，或者列举一些举一反三的例子，理论 + 实践，我觉得才是最佳法则 (没有说老师只是有实际，没有实践，莫怪）。作者回复：你的情况就是工作的上下文不足，这种情况你会很纠结，需要扩大自己的工作上下文，了解更多东西。这个话题后面会讲到。

一个职业发展思考框架：车日路模型。车，指的是你自己，你对自己的马力底盘是否了解？你有什么不足，哪些地方需要提高？你的动力来自于哪里？你要如何长期维持你的动力？路，指的是你到达目的地的要走的路径。你知道你要如何到达吗？你要如何做步骤分解？日，就是指你最终要达到的目标。你长期目标，比如五年计划是什么？短期目标，一两年内要达到什么地方？你最重要的目标是什么？车日路对应着就是自我、目标和路径。

自己看到自己的提问，现在可以用自己领悟到的答案回答自己的问题，扩大自己的上下文，有效的沟通反馈，敢于对于无效的需求说不，减少偶然复杂读，尽量少做无用功，以前总有种感觉是，给别人打工的感觉（叫做什么就得去做，感觉自己没什么反抗的或者反驳的余力，沟通反馈也是谨小慎微，说的多是是是，好好好之类的，然后就是埋头苦干）工作是别给别人打工是没错的，可是改不改做，怎么做作为一个开发人员还是可以以技术实现或者用户体验等等不同方式去考虑，也可以给出建设性意见，做到积极有效的反馈，做积极有效的需求，对个人和团队都是极为有利的。

## 0002结束语少做事才能更有效地工作.md

在这个专栏里，我讲过很多东西，几乎涉及到软件开发的方方面面，但有一个重要的方面，我却从来没有说过，那就是算法。因为我一直把它当做不言而喻的基本功，认为每个程序员都应该掌握。

1、算法的差异。排序算法是每个程序员都会学到的内容，大家对各种算法也是如数家珍：插入排序、冒泡排序、归并排序、堆排序、快速排序等等。我们也知道各个算法的复杂度，比如，插入排序是 O (n^2），快速排序平均情况下是 O (nlogn）等等。你有没有想过一个问题，不同算法的复杂度本质差别到底是什么呢？我们就以插入排序和快速排序为例，为什么快速排序要比插入排序快呢？我不打算做算法分析，直接公布答案：因为做比较的次数少。为什么同样的排序，比较次数会有差异呢？因为插入排序每次循环只关注当前的目标，循环之间没有关系，而快速排序在做不同划分时，上一次的结果对下一次有助力，因此它省下了不少的比较次数。

明白了这个道理，再来看所谓的算法优化，其实就是尽可能利用已知的信息，少做不必要的事。再来看一个常见的面试题，给你一堆数，找出前 100 个。很多人直觉就会想到排序，然后选出前 100 个。这种做法固然可行，但一定是做多了，因为这里需要的是找出前 100 个数，而不是要 100 个有序的数字，更不是要所有的数都有序。说到这里，你就知道了，只要把数据划分开就好，并不需要排序，如果划分点不是第 100 个元素，就向着 100 所在的方向继续划分就好。计算机是最擅长处理繁琐重复工作的，即便如此，我们依然要做算法优化，原因是当数据规模大到一定程度时，不同复杂度的算法差别就非常明显了。算法没用好，计算机硬件再好，也是徒劳的。有一则《计算机程序设计艺术》作者高德纳（Donald Knuth）的轶事，他年轻时参加算法大赛，用最差的系统击败了诸多对手，拿到算法执行效率的冠军，凭借的就是其强大的算法优化功力。对于计算机，算法尚且如此重要，我们面对工作时何尝不是如此呢！

2『已下载书籍「2020007计算机程序设计艺术1-3」。』

2、有效工作。《10x 程序员工作法》，也许有的同学最初看到这个标题就急急加入了，以为会从这个专栏中学习到一些「以一抵十」的编程技法，对不起，我彻底让你失望了。我非但没讲太多编程的技法，甚至还从各种角度劝你少写代码：无论是向产品经理提问题，还是让你在前面多考虑设计。难道不是做得越多才越高效吗？插入排序并不会因为干的活多，就比快速排序得到更高的评价，因为它们比的是谁排得快。工作效率高，不是因为代码写得多，而是有效工作做得多。如果 CPU 都被无效指令占据了，哪有时间执行有效指令呢？即使你很忙碌，但工作进展依然是收效甚微，因为无效工作占据了你太多的大脑，让你不能聚焦在正经事上，当然就是效率不高了。

其实，这个专栏的内容在我脑子里已经盘旋很多年了。不过，即便在专栏筹备期，我已经备了很多篇稿子之后，我依然没有找到一个准确的说法能够描绘内心的想法。我想过「程序员的职业素养」，但似乎这会让专栏朝着职场行动指南的方向努力；我想过「高效工作」，但实际上我也不打算讨论那些工作技巧。直到上线日期临近，我的编辑实在受不了我的拖延，坐下来与我交流了很久，我才终于找到了内心的那个词：有效。

我在这个专栏真正探讨的主题是，有效工作。有效工作，需要我们把力量聚焦到正确的地方，做本质复杂度（Essential Complexity）的事情，少做无意义的事情。我曾经在一个大公司做咨询，按照他们的统计，线上 60% 的代码从来没有运行过。我们都知道，一多半的代码增加的可不只是一多半的工作量，团队可能需要的是几倍甚至几十倍的心力去维护它。当然，有效工作最终没有成为这个专栏的名字，而用了更有个性的《10x 程序员工作法》。这个名字也不错，因为在我看来，很多程序员做的是负功，比如，写那 60% 代码的程序员。只要能做到有效工作，效率自然会高出业界平均水平很多。

怎么才能有效工作呢？我在专栏中已经给你讲了很多，小结一下就是：1）拓展自己的上下文，看到真正的目标，更好地对准靶子，比如，多了解用户，才不至于做错了方向；站在公司的层面上，才知道哪个任务优先级更高；站在行业的角度，而不局限于只在公司内成为高手，等等。2）去掉不必要的内容，减少浪费，比如，花时间分析需求，不做非必要的功能；花时间做好领域设计，别围着特定技术打转；花时间做好自动化，把精力集中在编码上，等等。

要想有效工作，有两点非常重要。一方面，意识上要注意自己工作中无效的部分。这就像一个开关，拨过去就好了。所以，读这个专栏有人常有恍然大悟的感觉，也有人觉得很简单。很多时候，你只是不知道，就像我在专栏中提到，要问产品经理问题，这是很多人没想过的。每篇文章后面的那一句总结，就是这样的开关，拨过去就好。另一方面，要构建自己关于软件开发的知识体系，这是要花时间积累的。在这个专栏中，我给你讲了很多最佳实践，就是让你知道，在某些方面，有人已经做得很好了，花时间学习，比自己从头摸索好很多。这就像所有的数学公式一样，理论上你都可以自行推导，但肯定不如从教科书上学得快。

3、藏经阁目录。虽然我讲了这么多内容，但实际上，因为篇幅的关系，这只是冰山一角。其实，我给你讲的这部分内容并不是具体的知识，而是告诉了你哪些东西要去学习，给了你一张学习地图，把各种知识贯串了起来。我曾与朋友打趣道，我的专栏实际上是藏经阁的目录，真正的经书还要等你自己去参悟。只不过，有一个人把这些经书之间的知识连接给你补齐了。这些连接恰恰是在学习相关内容时，让我苦思冥想许久的。大约一年前（2018 年 4 月），极客时间编辑找到我，问我是否有兴趣在极客时间开个专栏，作为「得到」重度用户的我，一直对知识服务很感兴趣。有这样的机会让我体验，我当然想试试，甚至最初给自己定下了写 100 篇的宏伟计划。

真正开始写，我才知道，在繁忙的日常工作之余，坚持写作还是一件很有挑战的事，今天看来，100 篇的目标显得那么无知无畏。不过，也正是因为压缩到一半左右的篇幅，在专栏后面的部分，我才极大地提高了知识密度，比如，微服务和 DDD，这两个可以分别写成一个系列内容的话题，我用一篇文章就将其精华和知识脉络提炼呈现了出来。因为我想尽我所能，帮助大家构建起一个软件开发的知识体系，让你在未来遇到问题时，知道可以在哪个方面进一步加强。希望这个专栏真的起到帮你理清思路，答疑解惑的作用。

还记得我在开篇词中的最后一段话吗？也许在这个专栏的最后，你发现自己并不认同我的原则，却能够用自己的原则来与我探讨，那么，恭喜你，因为那是最美妙的事情！不知道你是否形成了自己的原则呢？因为它代表着你已经形成了自己的知识体系。与我讲了些什么相比，你学到了什么才是一件更重要的事。希望在学习了这个专栏之后，你可以用自己的工作原则做更多本质复杂度的事情，减少无意义的时间消耗。

其实，这个专栏的最大收益人是我自己，感谢这次的专栏之旅，我终于强行治疗了我的拖延症，把自己对于有效工作的思考完整地整理了出来，那些在脑子里模糊的印象现在终于有了一个完整的体系。这个体系就是我在专栏里提到的工作原则，现在我可以更好地表达自己的想法了。不过，这个专栏于我而言也是有遗憾的。因为我想表达的内容很多，给大家打开更多大门的同时，也给很多同学留下了更多的疑问。有些同学期待在某个方面再深入细节地讲一下，比如，DDD，那可是值得再写一个专栏的主题。限于这个专栏的主题和篇幅关系，我没办法深入展开，只能对大家说声抱歉了。

### 黑板墙

一段历程结束也是另一段历程的开始。最近又完成了 typescript 协议生成，提高了客户端的开发效率，自动化算是又进了一步。结束语中您关于算法本质让我耳目一新，仔细一想确实如此，除了排序算法，字符串匹配中的 KMP 也是这样的。

当前云计算越来越成熟，云服务商提供了更好用的软件基础设施，可以预见这个行业对普通程序员的需求会越来越少，那么我们应该如何应对云计算带来的冲击呢？作者回复：云计算是简化了业务开发的过程，让程序员更多的把注意力放在业务上，这是好事情，未来的工作机会会增多。再者，回顾一下我在 40 那篇文章中提到的观点，先别焦虑，多考虑一下怎么让自己成长。

## 0003总复习重新来看书.md

制作了一个豆列（[10x 程序员工作法](https://www.douban.com/doulist/113366760/)），方便你去找到这些书。

1、编码实践。如果你想详细学习如何写好代码，我推荐你去读 Robert Martin 的《代码整洁之道》（Clean Code），这本书几乎覆盖了如何把代码写好的方方面面。《实现模式》是一本关于如何写好代码的书，更具体一点是，编写别人能够理解的代码。它的作者 Kent Beck 是许多软件开发实践的开创者。但 Kent Beck 的写作能力一般，他的很多作品被埋没了。只有细细品味，才能体会到 Kent Beck 深厚的功力。我提升自己编码水平的理解是从《程序设计实践》（The Practice of Programming）这本书开始的，这本书的作者是 Brian Kernighan 和 Rob Pike，这两个人都出身于大名鼎鼎的贝尔实验室，参与过 Unix 的开发。如果你想从日常开发中提升自己的效率，可以读一下《卓有成效的程序员》。假如你不曾思考过这个问题，这本书会让看到一些不同的工作方式，我也给这本书写过一篇书评。不过，这本书里的技巧太具体了，所以，有一些已经有些过时了。

2、设计。SOLID 原则是一种面向对象软件设计原则。早在 1995 年，Robert Martin 就提出了这些设计原则的雏形，然后在他的《敏捷软件开发：原则、实践与模式》这本书中，比较完整地阐述了这五个原则，后来，他有把这些原则进一步整理，成了今天的「SOLID」。有了设计原则做基础，这本书后面讲了设计模式，理解起来就容易多了。虽然书名是关于敏捷的，但这是一本讲设计的书。设计和架构有什么区别？2017 年，Robert Martin 出版了《架构整洁之道》（Clean Architecture），他在其中告诉我们，二者没有区别。所以，这也是一本关于设计的书，给出了 Robert Martin 对设计的最新理解。你可以把它看成《敏捷软件开发：原则、实践与模式》的修订版。

《设计模式》不推荐阅读，它是设计模式的开山之作，但它的起点是  Erich Gamma 的博士论文，其写作风格偏向学术，而且中文版翻译得也很一般。这里将它罗列出来只是因为其历史重要性。如果你想学习设计模式，现在有一些更容易入门的书，比如《Head First 设计模式》。Martin Fowler 的《企业应用架构模式》将软件开发当时常见的解决方案汇集成模式，今天看来很多模式已经习以为常，但当年出场可是技惊四座的。从这本书的名字你不难看出，它出版的年代是企业级开发盛行的年代。Martin Fowler 一直认为这本书没有写完，希望能够继续更新，但不知道何时能看到这本书的新版。《Unix 编程艺术》也是一本讲软件设计的书，只不过，它选择的切入点是 Unix 中的设计，从中你可以学到「只做一件事，把它做好」、「文本化」等编程理念，有助于你改善日常的工作。这样的书，也就只有 Eric Raymond 这样沉浸编程几十年的人才能写出来。

2『已下载书籍「2019032代码整洁之道 | 2019032Clean-Code」、「2020107Implementation-Pattern」、「2020108卓有成效的程序员 | 2020108The-productive-programmer」、「2020109The-Practice-of-Programming」、「2020111敏捷软件开发 | 2020111Agile-Software-Development」、「2020112Clean-Architecture」、「2019044Head-First设计模式」、「2020105企业应用架构模式」、「2019079Unix编程艺术」。』

3、工程实践。Kent Beck 有一本知名的软件工程之作《解析极限编程》（Extreme Programming Explained），它介绍了一种软件开发方法：极限编程。但更重要的是，今天很多主流的软件开发最佳实践都是从这里出来的。这本书可以理解成诸多最佳工程实践的总纲。Martin Fowler 在 1999 年写下软件行业的名著《重构：改善既有代码的设计》（Refactoring: Improving the Design of Existing Code），把重构这个小圈子实践带到了大众视野。2018 年底，Martin Fowler 时隔近 20 年后，又写出了《重构》第二版。把他对这些年行业发展的新理解融入到重构实践中。重构应该有个目标，这个目标就是「重构成模式」，而这也是一本专门的书：《重构与模式》（Refactoring to Patterns）。

2『已下载书籍「2020130解析极限编程 | 2020130Extreme-Programming-Explained」、「2019030重构2Ed | 2019030Refactoring2Ed」、「2020110重构与模式 | 2020110Refactoring-to-Patterns」』

《测试驱动开发》是 Kent Beck 为世人展示 TDD 做法的一本书。它好的地方需要自己体会，Kent Beck 并没有显式的讲出来，比如：任务分解。Jez Humble 和 Dave Farley 的《持续交付》（Continuous Delivery）让持续集成再进一步，将生产环境纳入了考量。乔梁，他是《持续交付》这本书的中文版译者，而且在这本书出版近十年后，他自己写了《持续交付 2.0》，把自己多年来关于持续交付的新理解整理了进去。说到遗留代码和测试，我推荐一本经典的书：Michael Feathers 的《修改代码的艺术》（Working Effectively with Legacy Code），从它的英文名中，你就不难发现，它就是一本关于遗留代码的书。如果你打算处理遗留代码，也建议你读读这本书。这本书我也写过书评，你可以了解一下我对它看法。

2『已下载书籍「2020114测试驱动开发 | 2020114Test-Driven-Development」、「2020131持续交付 | 2020131Continuous-Delivery」、「2019031修改代码的艺术 | 2019031Working-Effectively-with-Legacy-Code」。其中「持续交付」的中文版微信读书里有的。』

4、领域驱动设计。Eric Evans 2003 年写了《领域驱动设计》，向行业介绍一下 DDD 这套方法论，立即在行业中引起广泛的关注。但实话说，Eric 在知识传播上的能力着实一般，这本关于 DDD 的开山之作，其写作质量却难以恭维，想要通过它去学好 DDD，是非常困难的。所以，在国外的技术社区中，有很多人是通过各种交流讨论逐渐认识到 DDD 的价值所在，而在国内 ，DDD 几乎没怎么掀起波澜。

2013 年，在 Eric Evans 出版《领域驱动设计》十年之后，DDD 已经不再是当年吴下阿蒙，有了自己一套比较完整的体系。Vaughn Vernon 将十年的精华重新整理，写了一本《实现领域驱动设计》，普通技术人员终于有机会看明白 DDD 到底好在哪里了。所以，你会发现，最近几年，国内的技术社区开始出现了大量关于 DDD 的讨论。因为《实现领域驱动设计》实在太厚，Vaughn Vernon 又出手写了一本精华本《领域驱动设计精粹》，让人可以快速上手 DDD，这本书也是我向其他人推荐学习 DDD 的首选。

2『已下载书籍「2020134Domain-Driven-Design」、「2020135Implementing-Domain-Driven-Design」、「2020136Domain-Driven-Design-Distilled」，其中「领域驱动开发」的中文版微信读书里有，不过还是先读 Vaughn Vernon 的 2 本书，有多余的时间再看领域驱动开发。』

5、产品与需求。精益创业是 Eric Ries 最早总结出来的。他在很多地方分享他的理念，不断提炼，最终在 2011 年写成一本同名的书：《精益创业》。如果说精益创业是理论，《精益创业实战》这本书则给了你一个操作流程。Mike Cohn 是敏捷理念的一个重要传播者，我们在讲测试金字塔时，提到了他的著作《Scrum 敏捷软件开发》（Succeeding with Agile）。敏捷开发有两大流派：一派是工程实践，另一派是管理实践。如果你对 Scrum 这类管理实践感兴趣，可以读一下这本书。如果你对用户故事这个话题感兴趣，推荐阅读 Mike Cohn 的两本书《用户故事与敏捷方法》（User Stories Applied）和《敏捷软件开发实践—估算与计划》（Agile Estimating and Planning）。

2『已下载书籍「2020111敏捷软件开发 | 2020111Agile-Software-Development」、「2020137精益创业」、「2020138精益创业实战」、「2020139Scrum敏捷软件开发 | 2020139Succeeding-with-Agile」、「2020140Scrum敏捷软件开发 | 2020140User-Stories-Applied」、「2020141Agile-Estimating-and-Planning」。』

6、开发文化。软件行业里有一本名著叫《人月神话》，这算是软件开发领域第一本反思之作。今天，我们讨论的很多词汇都出自这本书，比如，没有银弹、焦油坑等等。虽然这本书出版于 1975 年，但其中提到的问题，依然困扰着今天的程序员。开源概念的提出者 Eric Raymond，他的《大教堂与集市》推开了开源大门。今天开源软件已经成为程序员日常工作的一部分，但如果没有 Eric Raymond 这些人的努力，我们还必须与复杂的企业级软件搏斗。了解一下开源的历程，可以帮助你更好地理解今天的幸福。程序员应该如何做，Robert Martin 也写了一本书《程序员的职业素养》（Clean Coder），其中对大多数程序员最重要的一点建议是，说「不」。

2『已下载书籍「2019655人月神话」、「2019746大教堂与集市」、「2019033程序员的职业素养 | 2019033The-Clean-Coder」。』

7、软件开发拾遗。高德纳的《计算机程序设计艺术》肯定是一套程序员都知道，但没几个人读完的书。算法的讲解经过几十年已经有了很好的发展，如果学算法，肯定有更好的选择。如果你想看图灵奖获得者如何从根上思考问题，不妨找来这套书来翻翻。《快速软件开发》（Rapid Development），不推荐阅读。在这本书中，作者首次提出了解决集成问题的优秀实践：Daily Build，每日构建。通过这个名字，我们便不难看出它的集成策略，即每天集成一次。它其中很多实践在当时是先进的，但今天看来有些落伍了。如果你只想从中收获一些理念性的东西，可以去读读。

《C 程序设计语言》、《Unix 编程环境》等出自贝尔实验室大师级程序员之手，他们的书都值得一读，其中的内容今天看来可能有些过时，但他们解决问题的方式和手法却值得慢慢品味。我在讲淘宝技术变迁时，提到了《淘宝技术这十年》，这本书算不上经典，但可以当做休闲读物。

8、技术之外。管理大师彼得·德鲁克有一本经典著作《卓有成效的管理者》，虽然标题上带着管理者几个字，但在我看来，这是一本告诉我们如何工作的书，每个人都可以读一下。尤瓦尔·赫拉利的《人类简史》或《未来简史》，是我第一次学到「大历史观」这个说法，历史不再是一个个单独的历史事件，而是一个有内在逻辑的发展脉络。《从一到无穷大》是一本著名科普著作，它向我们介绍了 20 世纪以来的科学进展。作者乔治·伽莫夫既是热宇宙大爆炸模型的提出者，也是生物学上最早提出「遗传密码」模型的人。虽然这本书出版自 1947 年，但以现在社会的整体科学素养，还是有必要读读这本书的。

史蒂芬·柯维（Stephen Richards Covey）的《高效能人士的七个习惯》，其中的理念我在专栏两个不同的地方提到过，一个是讲以终为始时，那段关于智力创造的论述，另一个是讲优先级时提到的艾森豪威尔矩阵。这本书值得每个人阅读，很多程序员欠缺的就是这些观念性的东西。很多程序员都是科幻小说迷，编程和科幻，这两个都是需要想象力的领域。刘慈欣的《三体》，不说它给 IT 行业带来的丰富的词汇表吧，作为科幻小说来说，它就是一流的，值得阅读。它会让你仰望星空，打开思维。如果你对科幻小说有兴趣，推荐阅读阿西莫夫的《银河帝国》系列，这是科幻小说界的扛鼎之作，你会看到，一部出版于 1942 年的书里就有大数据的身影。对于程序员来说，最好的工作状态就是进入心流，它会让你忘我工作。如果你对心流的概念感兴趣，可以去读米哈里·契克森米哈赖的著作《心流》，这位作者就是心流概念的提出者。

### 黑板墙

马大叔的《分析模式》，国内少有人提及，我认为是一本长期被低估的书。最大的价值是把 OO 抽象提到了新的高度。看完我发现：很多看似不同的事物，都有类似的关系。听起来是一句放之四海而皆准的「废话」，只有结合许多实实在在的例子以及思考，才有可能真正转变我们看待世界的方式。作者回复: 《分析模式》确实被低估了，可能是因为和大多数理解的技术有距离。

## 0004带着软件设计课回来了.md

我们都知道，《10x 程序员工作法》这个专栏，本质上是在讲如何有效工作，尽量地排除外部干扰，不让别人给我们添麻烦，把精力放在值得做的事情上。然而，当我们真正开始做值得做的事情后，我们做得又怎么样呢？

- 别人修改了他的程序，结果你的代码崩溃了，因为你们在底层共用了一个变量。

- 不同的项目组竞争公共的测试环境，测出来的常常是一些可以在单元测试里就解决的小问题。如果问他为什么不自己做好单元测试，他的回答常常是不好测。

- 为了提高一段代码的处理性能，我们使用了多线程处理。结果，更多的 Bug 随之而来。

- ……

是不是有一种熟悉的感觉扑面而来？在我的职业生涯里，我接触过的许多项目都会不停地出现类似的问题。事后究其原因，很大一部分都是软件设计没做好所造成的。换句话说，都是程序员自己给自己挖的坑。
如何避免给自己找麻烦，这就是我要在新专栏里讨论的内容。所以这次，我准备和你聊一下软件设计。

或许你会好奇，这些东西和软件设计有关系吗？软件设计不就是设计模式吗？我会在新专栏里告诉你，软件设计可比你想的内容多得多。它不仅可以教会我们如何组织代码，还会给我们提供一把尺子，用以衡量我们的设计。学会了软件设计，我们甚至可以把许多问题消灭在萌芽阶段，不会让它们为害人间。

如果说这个专栏是在告诉你要做正确的事，做有价值的需求，别把时间浪费在不该做的事情上。那软件设计专栏就是告诉你如何把事做对，如何建立有效的模型，划清模块之间的边界。所以，二者可谓一脉相承。
这个专栏是我工作之外的思考，新专栏则是我本职工作的深思。

### 黑板墙

通过郑大的引导，让我接触到了很多行业内的最佳实践，并且他们之间的关系是什么，怎么才能串成一条线。尤其是对于 Tdd ，以及持续重构，最后到自动化持续交付，软件设计方面的 DDD，微服务等从入门到有自己的思考。从曾今人云亦云的以为程序员是青春饭到把做一个有工匠精神的程序员作为自己的信仰，这是郑大带给我最重要的转变。只有眼界宽了，看到的东西多了，品味才能提升，才能有努力的目标。最近在研究如何让代码才能更有可测试性，期待通过大的分享中，再有新的启发和收获。

## 02. 任务分解

在这个模块中，我主要讲解的是「任务分解」这个知易行难的工作原则。普通人与高手之间的差异，很大程度上取决于任务分解的粒度大小。但真正理解并应用好「任务分解」的原则并不容易，希望你能勤于练习，将知识内化成为你的能力。我们学习到了一些最佳实践：

1、测试金字塔。1）行业中测试组合的最佳实践。2）多写单元测试是关键。

2、测试驱动开发。1）测试驱动开发的节奏是：红 —— 绿 —— 重构，重构是测试驱动开发区别于测试先行的关键。2）有人把测试驱动开发理解成测试驱动设计，它给行业带来的思维改变是，编写可测的代码。

3、艾森豪威尔矩阵（Eisenhower Matrix）。1）将事情按照重要和紧急进行划分。2）重要且紧急的事情要立即做。重要但不紧急的事情应该是我们重点投入精力的地方。紧急但不重要的事情，可以委托别人做。不重要不紧急的事情，尽量少做。

4、最小可行产品。1）「刚刚好」满足客户需求的产品。2）在实践中，要用最小的代价找到一条可行的路径。

另外，我还提到了一些可以直接在工作中应用的做法和评判标准：1）尽量不写 static 方法；2）主分支开发模型是一种更好的开发分支模型；3）好的用户故事应该符合 INVEST 原则；4）估算是一个加深对需求理解的过程，好的估算是以任务分解为基础的；5）好的测试应该符合 A-TRIP。

我也带你学习了一些重要的思想，帮你更好地改善自己的开发工作：1）分而治之，是人类解决问题的基本手段；2）软件变更成本，它会随着时间和开发阶段逐步增加；3）测试框架把自动化测试作为一种最佳实践引入到开发过程中，使得测试动作可以通过标准化的手段固定下来；4）极限编程之所以叫「极限」，它背后的理念就是把好的实践推向极限；5）大师级程序员的工作秘笈是任务分解，分解到可以进行的微操作；6）按照完整实现一个需求的顺序安排开发任务。

在「任务分解」的板块，我也将每篇内容浓缩为一句实战指南，现在一起回顾一下。1）动手做一个工作之前，请先对它进行任务分解。2）多写单元测试。3）我们应该编写可测的代码。4）将任务拆小，越小越好。5）按照完整实现一个需求的顺序去安排分解出来的任务。6）要想写好测试，就要写简单的测试。7）想要管理好需求，先把需求拆小。8）尽量做最重要的事。9）做好产品开发，最可行的方式是采用 MVP。

在这个部分的最后，针对大家在学习过程中的热门问题，我也进行了回答，希望你懂得：1）对不了解技术的任务，先要去了解技术，然后再做任务分解；2）通过一次技术 Spike ，学习新技术；3）丢弃掉在 Spike 过程中开发的原型代码；4）分清目标与现状，用目标作为方向，指导现状的改变；5）多个功能并行开发可以考虑使用 Feature Toggle；6）在遗留系统上做改造可以考虑使用 Branch by Abstraction。

在讲大师级程序员的工作秘笈时，西西弗与卡夫卡同学提到：最近在做战略拆解，都是一样的道理。战略飘在空中遥不可及，要落地就必须拆解。比如说达成目标有哪几个方面可以努力，各方面都需要做哪些事，这是路径。这些路径里哪些优先级最高，需要配置哪些组织资源。心里有数之后就是制订计划时间表。另外，西西弗与卡夫卡同学还为 Spike 给出了一个很生动的解释：「技术 Spike」可以翻译成「技术撩」，就是撩妹的那个撩。试探下，有戏就继续，撩不动就算或者放一段时间再说。

针对分解的粒度问题，大彬同学也分享了自己的心得：我会的任务分解，不仅可执行，粒度还很细。比如说，我要修复一个 rpc 接口的 bug。我会列出每个代码的修改点，要修改的测试，要增加的测试，合并到哪个分支，修改 rpc 文档，文档中有哪些点要修改。每一步都非常容易执行，看起来没多少必要，但在我当前的工作环境特别有用：1）事前思考，不会造成遗漏；2）任务实施过程中经常被打断，比如，测试有疑问和你讨论、主管找你谈事、紧急会议来了，这种「硬中断」完全打破了节奏，而任务列表，让我清楚知道当前做了多少，该从哪一步继续。

对于单元测试，树根同学提到：我的想法可以在复杂度高，重要核心的模块先开始写单元测试。特别是公用、底层的，因为这些靠功能测试很难覆盖。单元测试难以推行主要是没有碰到质量的痛点，通常都依靠测试工程师来保证质量。我们之前就遇到过质量崩塌，倒逼着我们去做，以保证质量。树根同学还分享了自己的任务分解实践心得：刚改了编程习惯，先在 notion 写出思路、需要用到的知识点，api 等，写出各个小任务，然后对应写出关键代码段。最后真正敲代码就花了 10 来分钟。重新开始看极客就看到这篇，实践过来读，很认同。我特别佩服国外的工程师写的代码，代码块很小，非常清晰易读。特别记得之前参加 infoq 会议，听 socketio 作者的分享，看他现场撸码，思路、代码结构都非常顺畅和清晰。

关于 TDD 的具体应用，萧同学提到了遇到的问题：不久前第一次接触 TDD 时为它的思想而惊叹，感觉它能极大的提升编码效率，编码后期的大量重构，还能保障代码质量。后面自己在写代码的时候也注意使用它的思想，但说实话，理解是一回事，用起来就不是那么回事了，很多的东西还不是太熟练，前期说实话比较耗时间，有些拖进度。由于也毕业不久，经验上有些欠缺，还不太熟练，有些测试还不知道怎么写。现在写多了一点，感受到的是代码质量上的提高，bug 比起以前少了，需求变更下改动，也不伤筋动骨了，但还是有许多感觉做的不够好的地方。看了这篇文章，补充了对 TDD 的认知，感受到如果和任务分解结合起来，TDD 会有更好的效果。

关于「任务分解」的执行问题，如明如月同学分享了感悟：对任务分解的体会非常深刻，刚入职的时候任务评估不准。现在想想主要是两个原因：1）需求梳理的不清晰，还没清楚地搞明白需求就动手写代码，导致返工和一些「意想不到」的情况。2）任务分解做的不好，没有将任务分解成非常清晰地可执行的单元，导致有些时候无从下手，而且任务时间评估不准确。

在讲到为什么很多人的测试不够好这个问题时，毅同学提到：1）从开发者的视角看，编码和测试是不分家的，是可以通过重构形成良性生态圈的，类似之前课程中的反馈模型和红绿重构模型；2）A-TRIP 是个很好的总结和行动指南，在今后工作中应一以贯之，把工作做到扎实有成效；3）对文中提到的数据库依赖的问题，我也说说自己的浅见。我觉得在测试代码中，尽量避免与数据库打交道，测试更关注领域与业务，往往爆雷更多的是 resource 和 service，模型的变化往往牵动着表结构的变化，与其两头兼顾不如多聚焦模型。我常用的做法是用例配合若干小文件（数据忠实于模型），保证库操作临门一脚前所有环节都是正确的，同时方便适应变化。一旦出现异常，也比较容易定位是否是数据库操作引发的问题。（此点基于，我在工作中发现，项目型程序员大多是先急于把表结构定义出来，好像不这么做，写代码就不踏实）

针对需求的管理问题，WL 同学提到的点也非常关键：程序员也应该更积极主动一些，最好能推动事情发展，当这件事情由你推动时，主动权就在你的手里了。

### 逻辑脉络

1、动手做一个工作之前，请先对它进行任务分解。


2）多写单元测试。3）我们应该编写可测的代码。4）将任务拆小，越小越好。5）按照完整实现一个需求的顺序去安排分解出来的任务。6）要想写好测试，就要写简单的测试。7）想要管理好需求，先把需求拆小。8）尽量做最重要的事。9）做好产品开发，最可行的方式是采用 MVP。

## 0210答疑如何分解一个你不了解的技术任务.md

在「任务分解」这个模块，我以测试为核心，讲解了任务分解这个原则，同时也给你介绍了一些最佳实践，帮助你更好地理解任务分解的重要性，以及应该怎样分解任务。同学们对任务分解这个原则大多是表示认同的，但就一些具体应用的场景，还是提出了自己的问题。在今天的答疑中，我选择了几个非常典型的问题来进行深入讨论。

问题 1：面对不了解的技术，我该如何分解任务？pyhhou 同学提到：很想听听老师的意见，就是在一个自己不熟悉的，充满未知的项目中该怎么更好地进行任务分解？shniu 同学提到：想请问一下老师，面对探索型的需求，调研型的需求如何做任务分解呢？

这是一个很好的问题。在这个模块讨论开发中的任务分解时，我说的都是确定了解的某项技术，比如，数据库、REST 服务等等，因为这是开发中最常见的场景，也是最基础的能力，连熟悉的技术都做不好分解，就别说不熟悉的技术了。那如果不了解这项技术呢？答案很简单，先把它变成你熟悉的技术。一旦变成了你熟悉的技术，你就可以应用在这个模块中学到的，面对确定性技术的分解方案。我知道，这个答案你并不满意。其实，你真正的问题是，怎么把它变成你熟悉的技术。

我的答案是，做一次技术 Spike。这里之所以用英文，是因为我没有找到一个特别合适的词来翻译。Spike 这个词的原意是轻轻地刺，有人把它翻译成调研，我觉得是有些重了。Spike 强调的重点在于快速地试，和调研的意思不太一样。既然是快速地试，就要在一定的时间内完成，比如，五人天，也就是一个人一周的时间，再多就不叫 Spike 了。一些简单的技术，用一天时间做 Spike 就差不多了。

这里强调的重点在于，要做一次技术 Spike。Spike 的作用就在于消除不确定性，让项目经理知道这里要用到一项全团队没有人懂的技术，需要花时间弄清楚。项目经理比你更担心不确定性，你清楚地把问题呈现在他面前，项目经理是可以理解的，他更害怕的是，做到一半你突然告诉他，项目进度要延期。把事情做在前面，尽早暴露问题，正是我们要在下一个模块要讨论的一个主题。好，那么接下来的问题变成了：怎么做技术 Spike 呢？

这里，我假设你已经通过各种渠道，无论是新闻网站，还是技术 blog，又或是上级的安排，对要用的技术有了一些感性的认识，至少你已经知道这项技术是干什么的了。接下来，我们要进入到技术 Spike 的任务分解。

首先，快速地完成教程上的例子。稍微像样点的技术都会有一个教程，跟着教程走一遍，最多也就是半天的时间。之所以要快速地完成教程上的例子，是为了让你有一个直观的认识，这时候，你对这项技术的认识就会超过新闻网站的报道。其次，我们要确定两件事：这项技术在项目中应用场景和我们的关注点。技术最终是要应用到项目中的，本着「以终为始」的原则，我们就应该奔着结果做，整个的 Spike 都应该围绕着最终的目标做。

很多程序员见到新技术都容易很兴奋，会把所有的文档通读一遍。如果是技术学习，这种做法无可厚非，但我们的目标是做 Spike，快速地试，没有那么多时间，必须一切围绕结果来。项目中的场景有无数，我们需要选择最重要的一个场景，而针对着这项最重要的场景，我们还要从这项技术无数功能中选取最需要的几个，而不是「满天撒网」。

再有是我们要找准关注点，比如，采用新的缓存中间件是为了提高性能，那关注点就是性能，采用新的消息队列是为了提升吞吐，那关注点就是吞吐。我们选用一项新技术总是有自己的一些假设，但这些假设真的成立吗？这是我们需要验证的。

无论场景，还是关注点，我们要在前面先想清楚，其目的就是为了防止发散。当时间有限时，我们只能做最重要的事，这也是我在专栏中不断强调的。确定好场景和关注点，接下来，我们要开发出一个验证我们想法的原型了。这个原型主要目的就是快速地验证我们对这项技术的理解是否能够满足我们的假设。开发一个只有主线能力的原型，对大部分程序员来说并不难，这里就不赘述了。当你把想法全部验证完毕，这项技术就已经由一项不熟悉的技术变成了熟悉的技术。我们前面的问题也就迎刃而解了。这时候，你就可以决定，对于这项技术，是采纳还是放弃了。

但是，我这里还有一点要提醒，当你确定要使用这项技术时，请丢弃掉你的原型代码。你或许会说，我辛辛苦苦写了几天的代码就这么丢了？是的，因为它是原型，你需要为你的项目重新设计。如果顺着原型接着做，你可能不会去设计，代码中会存在着大量对这项技术直接依赖的代码，这是值得警惕的，所有第三方技术都是值得隔离的。这是我们会在「自动化」模块讨论的内容。

问题 2：项目时间紧，该怎么办？在这个模块里，我花了大量的篇幅在讲测试，很多同学虽然认同测试的价值，却提出了开发中普遍存在的一些情况。玄源同学提到：很多时候，项目时间很紧，经常会提测后，再补测试，或者直接 code review，测试就不写了。

这是一个非常典型的问题，我在之前做咨询的时候，经常会遇到很多团队说，项目时间紧，所以，他们没有时间做测试。这里面有一个非常经典误区：混淆了目标与现状。目标是应该怎么做，现状是我们正在怎么做。我们都知道现状是什么样的，问题是，你对现状满意吗？如果每个人都对现状是满意的，就不会有人探索更好的做法。假设现在不忙了，你知道该怎么改进吗？

遗憾的是，很多人根本回答不了这个问题，因为忙是一种借口，一种不去思考改进的借口。我之所以要开这个专栏，就是为了与大家探讨行业中一些好的做法。回到这个具体问题上，我们在专栏开始就在讲以终为始，首先要有一个目标，专栏中介绍的各种实践都可以成为你设置目标的参考。有了这个目标再来考虑，如何结合我们工作的现状来谈改进。接下来，我们以测试为例，讨论一下具体的改进过程。用我们专栏最初讲过的思考框架看一下，假如我们的现状是团队之前没什么自动化测试，而我们的目标是业务代码 100% 测试覆盖。如果要达成这个目标，我们需要做一个任务分解。

这时你会发现，分解的过程主要需要解决两方面的问题，一个是与人的沟通，另一方面是自动化的过程。与人的沟通，就是要与团队达成共识。关于这点，你可以尝试将专栏里讲到的各种最佳实践以及其背后的逻辑，与团队进行沟通，也可以把专栏文章分享给他们。再来，我们考虑一下自动化的改进，因为我们的现状是没什么测试，所以，不能强求一步到位，只能逐步改进。下面我给出了一个具体的改进过程：1）把测试覆盖率检查加入到工程里，得到现有的测试覆盖率。2）将测试覆盖率加入持续集成，设定当前测试覆盖率为初始值。测试覆盖率不达标，不许提交代码。3）每周将测试覆盖率调高，比如，5% 或 10%，直到测试覆盖率达到 100%。

这样，我们就找到了一条由现状通往目标的路径，接下来，就是一步一步地具体实施了，由团队成员逐步为已有代码补充测试。

问题 3：多个功能同时开发，怎么办？妮可同学提到：公司经常存在有两个需求同时开发的情况。请问老师所在的团队如何解决单分支上线不同步的情况呢？

在主分支开发模型中，有一些常见的解决多功能并行开发的方法，其中，Feature Toggle 是最常用的一个，也就是通过开关，决定哪个功能是对外可用的。关于这一点，Y024 同学也补充了一些信息。1）[使用功能开关更好地实现持续部署 - InfoQ](https://www.infoq.cn/article/function-switch-realize-better-continuous-implementations)。2）[Feature Toggles (aka Feature Flags)](https://martinfowler.com/articles/feature-toggles.html)。

不过，如果用户故事划分得当，你可以很快完成一个完整的业务需求。实际上，Feature Toggle 只是一个非常临时的存在。但如果你在一个遗留系统上工作，一个功能要跨越很长的周期，Feature Toggle 才显得很有用。额外补充一个与主分支开发模型相关的常用技术，如果你想对遗留系统做改造，传统的做法是，拉出一个分支。

如果在一个分支上怎么做呢？可以考虑采用 Branch by Abstraction，简言之，再动手改造之前，先提取出来一个抽象，把原先的实现变成这个抽象的一个实现，然后，改造的过程就是提供这个抽象的一个新实现。这种做法对设计能力有一定要求，所以，对很多团队来说，这是一个挑战。

3『 [BranchByAbstraction](https://www.martinfowler.com/bliki/BranchByAbstraction.html) 』

「技术 Spike」可以翻译成「技术撩」，就是撩妹的那个撩。试探下，有戏就继续，撩不动就算或者放一段时间再说。作者回复：神来之笔！2019-02-13

最近我们团队也用到了不了解的技术做项目，一开始先用不到一周的时间去了解，写 demo 又花了一周多，写了一个简单一点的新项目，并且成功上线了。但是这个时候我只能说只是会用这个新技术，虽然使用起来很熟练，但是对他的底层原理还是不太了解。这个时候公司有一个老项目，功能比较复杂一些，因为这个老项目历史遗留问题比较多，崩溃率也比较高，这时候老大发话了，大家要不试着用新的技术重构一遍吧！因为新技术还不够成熟，各种功能缺失，或是尚未提供，一些常用的组件都要自己一个个去实现，因为项目涉及到的功能比较多，也不太可能一个一个的去验证，这个时候也只有在做的时候才会暴露问题，所以一再延期。一开始评估的时候也知道新技术对这些功能都提供了支持，但是不清楚能支持到哪一步，到具体去实现的时候才发现很多坑，目前已经陷入这个项目三四个月了，感觉离完成瑶瑶无期啊，不知道老师有什么好的建议没。作者回复：「怎么把新技术用在自己的项目中」，在这个问题中，很多人有一个严重的误区，他们眼中看到的更多的是「新技术」，而我思考这个的逻辑在于「自己的项目」。只有理解清楚了自己的问题，才好应用新技术去解决，盲目地采纳新技术，只会让自己不断地纠结，小程序库还好，要是引入一个大框架，无穷的问题就会吞噬你的时间。2019-02-20

spring-boot 项目有什么简单易用的测试覆盖率检查工具呢？作者回复：jacoco，我现在常用的工具。2019-02-27

对于不了解的技术任务，我会采用写伪代码的方式展开，先肢解成块，后续逐个突破。也就是先完成粗粒度的任务分解，看看哪些是现有的知识储备可以搞定的，把拦路虎限定在小范围内，战略上藐视它，树立解决问题的信心，然后是二次任务分解，着手预研和定型。作者回复：我不确定写伪代码的效率是否高，你如果很擅长，可以坚持。2019-02-14

对于要使用的新技术，以始为终的角度来看，个人的理解：1）了解要做的事： 新技术是否满足功能要求（目前和未来）。2）业内成功案例背书（大厂、成功案例）。3）分布式能力是否满足（性能、可伸缩、高可用...）。然后快速写个 demo、进而结合实际项目写出功能，这也是学习新技术最快的方式，带着目的去用，而不会太发散，导致没个重点。然后就是结合官方文档，了解原理，猜测底层实现、然后去源码中验证，已经进行性能压测等。作者回复：你说的是一个技术选型的过程。首先，要确定自己要做的问题，再来根据自己的问题确定合适的技术。2020-05-31

spike 可以理解为技术探针。作者回复：这是一个正常的翻译。2019-07-10

遇到紧急性的需求并且用到的技术自己不熟悉，首先要对这个技术有一个大致的了解，其最主要的功能是什么，再就是结合需求，看看如何利用这个技术解决这个需求。当需求做完后，并且市场对这个技术有很大的需求的话，可以对这项技术的细节加以学习研究。作者回复：只要不跑偏，效率都不低。2019-03-06

## 0201向埃隆马斯克学习任务分解.md

我们从外星人探索和马斯克的火星探索入手，介绍了任务分解在人类社会诸多方面的应用，引出了分而治之这个人类面对复杂问题的基本解决方案。接着，我给你讲了这一思想在软件开发领域中的一个常见应用，分而治之的算法。虽然我们很熟悉这一思想，但在日常工作中，我们却没有很好地应用它，这也使得大多数人的工作有很大改进空间。运用这一思想的难点在于，给出一个可执行的分解。

一方面，对复杂工作而言，给出一个分解是巨大的挑战；另一方面，面对日常工作，人们更容易忽略的是，分解的任务要可执行。每个人对可执行的理解不同，只要你清楚地知道接下来的工作该怎么做，任务分解就可以告一段落。大多数人对于可执行的粒度认识是不足的，低估了任务分解的程度，做到好的分解你需要达到「微操作」的程度。有了分解得很小的任务，我们就可以很容易完成一个开发循环，也就让计划调整成为了可能。软件行业在倡导拥抱变化，而任务分解是拥抱变化的前提。如果今天的内容你只记住一件事，那么请记住：动手做一个工作之前，请先对它进行任务分解。

这次我们从一个宏大的话题开始：银河系中存在多少与我们相近的文明。我想，即便这个专栏的读者主力是程序员这个平均智商极高的群体，在面对这样一个问题时，大多数人也不知道从何入手。我来做一个科普，给大家介绍一下德雷克公式，这是美国天文学家法兰克·德雷克（Frank Drake）于 1960 年代提出的一个公式，用来推测「可能与我们接触的银河系内外星球高等文明的数量」。下面，我要放出德雷克公式了，看不懂一点都不重要，反正我也不打算讲解其中的细节，我们一起来感受一下。

不知道你看了德雷克公式做何感想，但对于科学家们来说，德雷克公式最大的作用在于：它将一个原本毫无头绪的问题分解了，分成若干个可以尝试回答的问题。随着观测手段的进步，我们对宇宙的了解越来越多，公式中大多数数值，都可以得到一个可以估算的答案。有了这些因子，人们就可以估算出银河系内可以与我们通信的文明数量。虽然不同的估算结果会造成很大的差异，而且我们迄今为止也没能找到一个可以联系的外星文明，但这个公式给了我们一个方向，一个尝试解决问题的手段。

好吧，我并不打算将这个专栏变成一个科普专栏，之所以在这讲解德雷克公式，因为它体现了一个重要的思想：任务分解。通过任务分解，一个原本复杂的问题，甚至看起来没有头绪的问题，逐渐有了一个通向答案的方向。而「任务分解」就是我们专栏第二模块的主题。

### 1.1 马斯克的任务分解

如果大家对德雷克公式有些陌生，我们再来看一个 IT 人怎样用任务分解的思路解决问题。我们都知道埃隆·马斯克（Elon Musk），他既是电动汽车公司特斯拉（Tesla）的创始人，同时还创建了太空探索公司 SpaceX。SpaceX 有一个目标是，送 100 万人上火星。美国政府曾经算过一笔账，把一个人送上火星，以现有技术是可实现的，需要花多少钱呢？答案是 100 亿美金。如果照此计算，实现马斯克的目标，送 100 万人上火星就要 1 万万亿。这是什么概念呢？这笔钱相当于美国 500 年的 GDP，实在太贵了，贵到连美国政府都无法负担。

马斯克怎么解决这个问题呢？他的目标变了，他准备把人均费用降到 50 万美元，也就是一个想移民的人，把地球房子卖了能够凑出的钱。原来需要 100 亿美金，现在要降到 50 万美金，需要降低 2 万倍。当然，降低 2 万倍依然是一个听起来很遥远的目标。所以，我们关注的重点来了：马斯克的第二步是，把 2 万分解成 20×10×100。这是一道简单的数学题，也是马斯克三个重点的努力方向。

先看「20」：现在的火星飞船一次只能承载 5 个人，马斯克的打算是，把火箭造大一点，一次坐 100 人，这样，就等于把成本降低 20 倍。如果你关注新闻的话，会发现 SpaceX 确实在进行这方面的尝试，再来看「10」：马斯克认为自己是私营公司，效率高，成本可以降到十分之一。他们也正在向这个方向努力，SpaceX 的成本目前已经降到了同行的五分之一。最后的「100」是什么呢？就是回收可重复使用的火箭。如果这个目标能实现，发射火箭的成本就只是燃料成本了。这也就是我们频频看到的 SpaceX 试飞火箭新闻的原因。这么算下来，你是不是觉得，马斯克的目标不像最开始听到的那样不靠谱了呢？正是通过将宏大目标进行任务分解，马斯克才能将一个看似不着边际的目标向前推进。

### 1.2 软件开发的任务分解

好了，和大家分享这两个例子只是为了热热身，说明人类解决问题的方案是差不多的。当一个复杂问题摆在面前时，我们解决问题的一个主要思路是分而治之。一个大问题，我们都很难给出答案，但回答小问题却是我们擅长的。所以，当我们学会将问题分解，就相当于朝着问题的解决迈进了一大步。

我们最熟悉的分而治之的例子，应该是将这个理念用在算法上，比如归并排序。将待排序的元素分成大小基本相同的两个子集，然后，分别将两个子集排序，最后将两个排好序的子集合并到一起。一说到技术，大家就觉得踏实了许多，原来无论是外星人搜寻，还是大名鼎鼎的马斯克太空探索计划，解决问题时用到的思路都是大同小异啊！确实是这样。那么，用这种思路解决问题的难点是什么呢？给出一个可执行的分解。

在前面两个例子里面，最初听到要解决的问题时，估计你和我一样，是一脸懵的。但一旦知道了分解的结果，立即会有一种「柳暗花明又一村」的感觉。你会想，我要是想到了这个答案，我也能做一个 SpaceX 出来。但说到归并排序的时候，你的心里可能会有一丝不屑，这是一个学生级别的问题，甚至不值得你为此费脑子思考。因为归并排序你已经知道了答案，所以，你会下意识地低估它。

任务分解就是这样一个有趣的思想，一旦分解的结果出来，到了可执行的步骤，接下来的工作，即便不是一马平川，也是比原来顺畅很多，因为问题的规模小了。在日常工作中，我们会遇到很多问题，既不像前两个问题那样宏大，也不像归并排序那样小，但很多时候，我们却忘记了将任务分解这个理念运用其中，给工作带来很多麻烦。

举一个例子，有一个关于程序员的经典段子：这个工作已经做完了 80%，剩下的 20% 还要用和前面的一样时间。为什么我们的估算差别如此之大，很重要的一个原因就在于没有很好地分解任务，所以，我们并不知道要做的事情到底有多少。

前面我们在「为什么说做事之前要先进行推演？」文章中，讲到沙盘推演，这也是一个很好的例子，推演的过程就是一个任务分解的过程。上手就做，多半的结果都是丢三落四。你会发现，真正把工作完全做好，你落掉的工作也都要做，无论早晚。与很多实践相反，任务分解是一个知难行易的过程。知道怎么分解是困难的，一旦知道了，行动反而要相对来说容易一些。

在「任务分解」这个主题下，我还会给你介绍一些实践，让你知道，这些最佳实践的背后思想就是任务分解。如果你不了解这些实践，你也需要知道，在更多的场景下，先分解任务再去做事情是个好办法。也许你会说，任务分解并不难于理解，我在解决问题的过程中也是先做任务分解的，但「依然过不好这一生。」这就要提到我前面所说难点中，很多人可能忽略的部分：可执行。可执行对于每个人的含义是不同的，对于马斯克而言，他把 2 万分解成 20×10×100，剩下的事情对他来说就是可执行的，但如果你在 SpaceX 工作，你就必须回答每个部分究竟是怎样执行的。

同样，假设我们做一个 Web 页面，如果你是一个经验丰富的前端工程师，你甚至可能认为这个任务不需要分解，顶多就是再多一个获取网页资源的任务。而我如果是一个新手，我就得把任务分解成：根据内容编写 HTML；根据页面原型编写页面样式；根据交互效果编写页面逻辑等几个步骤。

不同的可执行定义差别在于，你是否能清楚地知道这个问题该如何解决。对于马斯克来说，他的解决方案可能是成立一个公司，找到这方面的专家帮助他实现。对你的日常工作来说，你要清楚具体每一步要做的事情，如果不能，说明任务还需要进一步分解。

比如，你要把一个信息存起来，假设你们用的是关系型数据库，对大多数人来说，这个任务分解就到了可执行的程度。但如果你的项目选用了一个新型的数据库，比如图数据库，你的任务分解里可能要包含学习这个数据库的模型，然后还要根据模型设计存储方案。

不过，在实际工作中，大多数人都高估了自己可执行粒度，低估任务分解的程度。换句话说，如果你没做过任务分解的练习，你分解出来的大部分任务，粒度都会偏大。只有能把任务拆分得非常小，你才能对自己的执行能力有一个更清楚地认识，真正的高手都是有很强的分解能力。这个差别就相当于，同样观察一个物品，你用的是眼睛，而高手用的是显微镜。在你看来，高手全是微操作。关于这个话题，后面我们再来细聊。一旦任务分解得很小，调整也会变得很容易。很多人都在说计划赶不上变化，而真正的原因就是计划的粒度太大，没法调整。

从当年的瀑布模型到今天的迭代模型，实际上，就是缩减一次交付的粒度。几周调整一次计划，也就不存在「计划赶不上变化」的情况了，因为我的计划也一直在变。如今软件行业都在提倡拥抱变化，而任务分解是我们拥抱变化的前提。

### 黑板墙

你在实际工作中，有哪些依靠任务分解的方式解决的问题呢？

我会的任务分解，不仅可执行，粒度还很细。比如说，我要修复一个 rpc 接口的 bug。我会列出每个代码的修改点，要修改的测试，要增加的测试，合并到哪个分支，修改 rpc 文档，文档中有哪些点要修改。每一步都非常容易执行，看起来每多少必要，但在我当前的工作环境特别有用：1）事前思考，不会造成遗漏，2）任务实施过程中经常被打断，比如，测试有疑问和你讨论，主管找你谈事，紧急会议来了，这种「硬中断」完全打破了节奏，而任务列表，让我知道清楚当前做了多少，该从哪一步继续。作者回复：很清楚的做法！2019-01-25

实际工作中来看，如果对一个任务，或者说是一项技术不是特别了解的话，确实很难做细致的任务分解，往往就是列一个粗糙的大概计划，然后去执行，在执行的过程中就发现很多计划都存在问题，一个计划里面还涵盖了之前没有考虑到的细节，导致任务项目充满了不确定性。很想听听老师的意见，就是在一个自己不熟悉的，充满未知的项目中该怎么更好地进行任务分解，还有这种分解的思想在平时是否可以通过一些练习和思考来加强，并应用到广泛的工作学习中去。作者回复：好问题，我就在答疑里谈谈这个问题吧！2019-01-23

任务分解和敏捷开发的用 user story 应该是相似的，首先我们会定义大的 feature，这个是大的产品经理关注的，然后我们基于 feature 分解成不同的 user story，最后每个 story，再分解成一个个具体的 task，我们程序员就主要解决 task。2019-01-24

如果清楚知道接下来怎么做，任务分解就告一段落。其实清楚就是知道是否可执行，如何执行，越是知道每步细节越能把控全局。但往往就是以为自己「清楚」，才导致任务评估不准。特别对自己没做过的领域，做沙盘推演，以结果导向推导任务推进过程，做好排坑。另外一点受益的，就是分解任务不单单是任务内容的分解。特别是文中提到的特斯拉通过建立公司引入专业人才，或者图数据库需要学习的知识。真正分解是如何达成任务目标，分解所需的步骤、资源、风险。我现在缺的是系统分解目标，清楚知道自己下一步要做什么，需要哪些资源。2019-01-23

最近在做战略拆解，都是一样的道理。战略飘在空中遥不可及，要落地就必须拆解。比如说达成目标有哪几个方面可以努力，各方面都需要做哪些事，这是路径。这些路径里哪些优先级最高，需要配置哪些组织资源。心里有数之后就是制订计划时间表。2019-01-23

网站积分清算都是系统定时任务，老是担心时间超时任务失败。后来把任务按照时间拍好顺序，保证每个任务都不超过一分钟，运行时间间隔大于 5 分钟。再也没有出现过运行失败。2019-01-23

老师说任务分解知难行义，我倒是觉得知易行难，这个概念很多人知道，但是在实际操作中怎么分解、分解到多少粒度是很难做到刚刚好的，我的经验是：1）按照业务模块、业务类型、业务流程进行划分。2）宁可足够细粒度，不能草草了事。2020-02-16

之前做过要把好几个小项目换框架，它们之间又有相互的调用，感觉要动一个就得动整体，无从下手，最后下定狠心做的时候，就是分解开，第一步先搭建一个空的能跑起来的项目，第二步将其中一个项目中的某个功能进行实现，比如登录，然后一步一步挪功能，等都挪完了，项目也就换完了，其中还有在具体功能的时候分解，比如登录的时候 ，第一步先导入包，第二步进行配置 ，第三步实现简单的数据通信，第四步修改参数获取项目需要的用户数据，感觉真正做起来的时候，反而没有想象中那么难。2019-04-18

任务分解是一个很好的策略，其实日常做事情也在做任务分解。比如在家里做饭，需要开始准备做什么菜、整理材料、蒸饭、炒菜。根据每个人的理解不同，会有不同的步骤，而且每次都不太一样。这里默认的就已经有任务分解在里面了。日常生活的自动化，或者称为习惯，大脑会在后台做任务分解反而降低了感知度。想要精细化的控制任务，就需要做可感知的任务分解。明确每一个步骤，做到可执行化。对于一个大的任务，或者未遇见的任务大脑的默认方式就不起作用了。这时会体现出懵懵的感觉。这种情况应该会有策略在之后的课程中讲解吗？作者回复：大任务分解的方式就是一点点分解，但对于不确定的任务，我准备在答疑中，专门讨论一次。2019-01-25

我看过一门公开课，里面谈到了一种编程风格：自顶向下。大概的思路是：先想清楚要做什么，再确定核心步骤，然后不断往下细分，直至完成。这种编程风格，算是把任务分解用在写代码上了？作者回复：本质解决问题的思路都是先分解再逐一击破，写代码一样。2020-04-21

我在开发一个 postgresql 有数据插入的时候，就同时写入链数据进行了简单的任务分解：1）学习 postegres；2）监察数据库变化；3）根据数据变化调用 api 写上链。在应用服务器迁移的时候进行任务分解，备份数据、更新公告、复制环境、移动数据、灰度测试、正式上线、关闭久服务器。作者回复：这个分解很好，但在执行过程中，还需要进一步分解。2020-02-20

让我想起一类面试题 ，譬如煎饼摊大妈的收入估算、估算北京一年出租出去的房子数量等等，将一个原本毫无头绪的问题分解，分成若干个可以尝试回答的问题。作者回复：嗯，是这个意思。2019-02-12

个人认为，要做到精确的任务分解任务，在实际工作中比较困难。如果不能对细节了如指掌，如果不能对全局高屋建瓴，要精确的分解是不可能的。我的指导思想是，在一项任务开始之前，做粗略的任务分解，然后随着任务的进行，边做边完善。说的通俗点就是边走边看。其实不管是做技术，还是给自己定发展目标，都是一样，一开始给自己定长期目标，然后具体到当下，我们就分解目标，边走边计划，边走边看！作者回复：分解到什么程度取决于自己的把控能力，不清楚的部分不分解是一种风险。2019-01-23

## 0202测试也是程序员的事吗.md

测试是软件开发重要的组成部分，测试应该是软件开发团队中所有人的事，而不仅仅是测试人员的事。因为软件变更成本会随着时间和开发阶段逐步增加，能在早期解决的问题，就不要将它延后至下一个阶段。在测试问题上，程序员有着天生的优势，会写代码，于是，程序员拥有了一个突出的强项，自动化测试。写测试应该是程序员工作完成的重要组成部分。随着人们对于测试理解的加深，各种各样的测试都出现了，也开始有了测试的分类：单元测试、集成测试、系统测试等等。越在底层测试，成本越低，执行越快；越在高层测试，成本越高，执行越慢。人的时间和精力是有限的，所以，人们开始思考不同的测试如何组合。在这个方面的最佳实践称之为测试金字塔，它强调的重点是，越底层的测试应该写得越多。只有按照测试金字塔的方式写测试，持续集成才能更好地发挥作用。如果今天的内容你只能记住一件事，那请记住：多写单元测试。

在「任务分解」这个模块，我准备从一个让我真正深刻理解了任务分解的主题开始，这个主题就是「测试」。这是一个让程序员又爱有恨的主题，爱测试，因为它能让项目的质量有保证；恨测试，因为测试不好写。而实际上，很多人之所以写不好测试，主要是因为他不懂任务分解。

在上一个模块，我们提到了一些最佳实践，但都是从「以终为始」这个角度进行讲解的。这次，我准备换个讲法，用五讲的篇幅，完整地讲一下「开发者测试」，让你和我一起，重新认识这个你可能忽视的主题。准备好了吗？我们先从让很多人疑惑的话题开始：程序员该写测试吗？

### 2.1 谁要做测试？

你是一个程序员，你当然知道为什么要测试，因为是我们开发的软件，我们得尽可能地保证它是对的，毕竟最基本的职业素养是要有的。但测试工作应该谁来做，这是一个很有趣的话题。很多人凭直觉想到的答案是，测试不就该是测试人员的事吗，这还用问？测试人员应该做测试，这是没错的，但是测试只是测试人员的事吗？

事实上，作为程序员，你多半已经做了很多测试工作。比如，在提交代码之前，你肯定会把代码跑一遍，保证提交的基本功能是正确的，这就是最基本的测试。但通常，你并不把它当成测试，所以，你的直觉里面，测试是测试人员的事。但我依然要强调，测试应该是程序员工作的一部分，为什么这么说呢？

我们不妨想想，测试人员能测的是什么？没错，他们只能站在系统外部做功能特性的测试。而一个软件是由它内部诸多模块组成的，测试人员只从外部保障正确性，所能达到的效果是有限的。打个比方，你做一台机器，每个零部件都不保证正确性，却要让最后的结果正确，这实在是一个可笑的要求，但这却真实地发生在软件开发的过程中。

在软件开发中有一个重要的概念：软件变更成本，它会随着时间和开发阶段逐步增加。也就是说我们要尽可能早地发现问题，修正问题，这样所消耗掉的成本才是最低的。上一个模块讲「以终为始」，就是在强调尽早发现问题。能从需求上解决的问题，就不要到开发阶段。同样，在开发阶段能解决的问题，就不要留到测试阶段。

3『 [Examining the Agile Cost of Change Curve](http://www.agilemodeling.com/essays/costOfChange.htm) 』

你可以想一下，是你在代码中发现错误改代码容易，还是测试了报了 bug，你再定位找问题方便。更理想的情况是，质量保证是贯穿在软件开发全过程中，从需求开始的每一个环节，都将「测试」纳入考量，每个角色交付自己的工作成果时，都多问一句，你怎么保证交付物的质量。需求人员要确定验收标准，开发人员则要交出自己的开发者测试。这是一个来自于精益原则的重要思想：内建质量（Build Quality In）。所以，对于每个程序员来说，只有在开发阶段把代码和测试都写好，才有资格说，自己交付的是高质量的代码。

### 2.2 自动化测试

不同于传统测试人员只通过手工的方式进行验证，程序员这个群体做测试有个天然的优势：会写代码，这个优势可以让我们把测试自动化。早期测试代码，最简单的方式是另外写一个程序入口，我初入职场的时候，也曾经这么做过，毕竟这是一种符合直觉的做法。不过，既然程序员有写测试的需求，如此反复出现的东西，就会有更好的自动化方案。于是开始测试框架出现了。

最早的测试框架起源是 Smalltalk。这是一门早期的面向对象程序设计语言，它有很多拥趸，很多今天流行的编程概念就来自于 Smalltalk，测试框架便是其中之一。真正让测试框架广泛流行起来，要归功于 Kent Beck 和 Erich Gamma。Kent Beck 是极限编程的创始人，在软件工程领域大名鼎鼎，而 Erich Gamma 则是著名的《设计模式》一书的作者，很多人熟悉的 Visual Studio Code 也有他的重大贡献。

有一次，二人一起从苏黎世飞往亚特兰大参加 OOPLSA（Object-Oriented Programming, Systems, Languages & Applications）大会，在航班上两个人结对编程写出了 JUnit。从这个名字你便不难看出，它的目标是打造一个单元测试框架。顺便说一下，如果你知道 Kent Beck 是个狂热的 Smalltalk 粉丝，写过 SUnit 测试框架，就不难理解这两个人为什么能在一次航班上就完成这样的力作。

JUnit 之后，测试框架的概念逐渐开始流行起来。如今的「程序世界」，测试框架已经成为行业标配，每个程序设计语言都有自己的测试框架，甚至不止一种，一些语言甚至把它放到了标准库里，行业里也用 XUnit 统称这些测试框架。这种测试框架最大的价值，是把自动化测试作为一种最佳实践引入到开发过程中，使得测试动作可以通过标准化的手段固定下来。

### 2.3 测试模型：蛋卷与金字塔

在前面的讨论里，我们把测试分为人工测试和自动化测试。即便我们只关注自动化测试，也可以按照不同的层次进行划分：将测试分成关注最小程序模块的单元测试、将多个模块组合在一起的集成测试，将整个系统组合在一起的系统测试。有人喜欢把验收测试也放到这个分类里。为了简化讨论，我们暂时忽略验收测试。

随之而来的一个问题是，我们应该写多少不同层次的测试呢？理论上固然是越多越好了，但实际上，做任何事都是有成本的，所以，人们必须有所取舍。根据不同测试的配比，也就有了不同的测试模型。有一种直觉的做法是，既然越高层的测试覆盖面越广，那就多写高层测试，比如系统测试。当然，有些情景高层的测试不容易覆盖到的，所以，还要有一些底层的测试，比如单元测试。在这种情况下，底层的测试只是作为高层测试的补充，而主力就是高层测试。这样就会形成下面这样一种测试模型：冰淇淋蛋卷。

1『冰淇淋模型从上而下依次为：手工回归测试、自动化端到端测试、集成测试、单元测试。』

听说过冰淇淋蛋卷测试模型的人并不多，它是一种费时费力的模型，要准备高层测试实在是太麻烦了。之所以要在这里提及它，是因为虽然这个概念很多人没听说过，但是有不少团队的测试实际采用的就是这样一种模型，这也是很多团队觉得测试很麻烦却不明就里的缘由。接下来，要说说另一种测试模型，也是行业里的最佳实践：测试金字塔。

1『金字塔测试模型自上而下依次为：UI、服务、单元。』

Mike Cohn 在自己的著作《Succeeding with Agile》提出了测试金字塔，但大多数人都是通过 Martin Fowler 的文章知道的这个概念。从图中我们不难看出，它几乎是冰淇淋蛋卷的反转，测试金字塔的重点就是越底层的测试应该写得越多。想要理解测试金字塔成为行业最佳实践的缘由，我们需要理解不同层次测试的差异。越是底层的测试，牵扯到相关内容越少，而高层测试则涉及面更广。

比如单元测试，它的关注点只有一个单元，而没有其它任何东西。所以，只要一个单元写好了，测试就是可以通过的；而集成测试则要把好几个单元组装到一起才能测试，测试通过的前提条件是，所有这些单元都写好了，这个周期就明显比单元测试要长；系统测试则要把整个系统的各个模块都连在一起，各种数据都准备好，才可能通过。

3『 [TestPyramid](https://martinfowler.com/bliki/TestPyramid.html)，[Scrum敏捷软件开发 (豆瓣)](https://book.douban.com/subject/5334585/)。顺便挖到了 Martin Fowler 大神的博客：[martinfowler.com](https://martinfowler.com/)。』

这个模块的主题是「任务分解」，我必须强调一点：小事反馈周期短，而大事反馈周期长。小事容易做好，而大事难度则大得多。所以，以这个标准来看，底层的测试才更容易写好。另外，因为涉及到的模块过多，任何一个模块做了调整，都有可能破坏高层测试，所以，高层测试通常是相对比较脆弱的。此外，在实际的工作中，有些高层测试会牵扯到外部系统，这样一来，复杂度又在不断地提升。

人们会本能地都会倾向于少做复杂的东西，所以，人们肯定不会倾向于多写高层测试，其结果必然是，高层测试的测试量不会太多，测试覆盖率无论如何都上不来。而且，一旦测试失败，因为牵扯的内容太多，定位起来也是非常麻烦的。而反过来，将底层测试定义为测试主体，因为牵扯的内容少，更容易写，才有可能让团队得到更多的测试，而且一旦出现问题，也会更容易发现。所以，虽然冰淇淋蛋卷更符合直觉，但测试金字塔才是行业的最佳实践。

### 2.4 当测试金字塔遇到持续集成

测试金字塔是一个重要实践的基础，它就是持续集成。当测试数量达到一定规模，测试运行的时间就会很长，我们可能无法在本地环境一次性运行所有测试。一般我们会选择在本地运行所有单元测试和集成测试，而把系统测试放在持续集成服务器上执行。这个时候，底层测试的数量就成了关键，按照测试金字塔模型，底层测试数量会很多，测试可以覆盖主要的场景；而按照冰淇淋蛋卷模型，底层测试的数量则有限。作为提交代码的防护网，测试数量多寡决定着得到反馈的早晚。所以，金字塔模型与持续集成天然就有着很好的配合。

需要特别注意的是，不是用单元测试框架写的测试就是单元测试。很多人用单元测试框架写的是集成测试或是系统测试。单元测试框架只是一个自动化测试的工具而已，并不是用来定义测试类型的。在实际工作中，区分不同测试有很多种做法，比如，将不同的测试放到不同的目录下，或是给不同类型的测试一个统一的命名规范。区分不同类型测试主要目的，主要是在不同的场景下，运行不同类型的测试。就像前面提到的做法是，在本地运行单元测试和集成测试，在持续集成服务器上运行系统测试。

### 黑板墙

团队认知，开发周期，软件和生命财产关系不大，是单元测试的拦路虎。作者回复：还有一点是，知识，很多人不愿意写测试的原因是不会写测试。2019-01-25

像前端项目主要以 UI 为主，版本迭代速度又很快的情况下怎么进行单元测试的编写。作者回复：首先，迭代速度快慢与是否写测试没关系，取决于工作是否完成是前面提到的 DoD。其次，前端之所以能够在今天成为一个独立的项目，在于它有大量的逻辑需要写，如今 JavaScript 相关的测试框架已经发展得很完整了，就按照正常的方式去写测试就好了。2019-01-25

老师我有几个疑问：1）单元测试是不是也要随着业务流程的变化而要持续维护？2）对于变动非常频繁的业务流程是不是可以不写单元测试？因为考虑到时间的问题。3）所有的大公司重要的项目（例如淘宝，京东等平台）是不是都有严格的单元测试编写或者执行规范？作者回复: 1 和 2，本质上是一个问题。其实，很多人担心写测试会影响写代码，但实际上，写测试，尤其是单元会帮助写代码，否则，你用的手工测试或系统测试的方式来保证系统的正确性。如果你不花练习写测试，你永远学不会写测试，写测试在你看来就是浪费时间。这背后其实还隐藏着另外一个问题，为什么会变化快？因为一方面，前期的工作做得少，这是我们前面讲的内容要解决的，另一方面，设计做的不好，变化都是大变化，设计不做好，那就到处是问题，这是我们后面要讲的内容。3，国内公司在工程上做得都不够好，如果想看好榜样，可以看看国外的公司，比如，Google，它要求 100% 测试覆盖率。2019-02-26

最近深有感触，单元测试写的越多，越能反思自己的代码，内建质量也能一步步建立起来，多写单元测试真是会产生蜕变的。作者回复：小病不治，会生大病的。2019-03-29

我的想法可以在复杂度高，重要核心的模块先开始写单元测试。特别是公用、底层的，因为这些靠功能测试很难覆盖。单元测试难以推行主要是没有碰到质量的痛点，通常都依靠测试工程师来保证质量。我们之前就在遇到过质量崩塌，倒逼着我们去做，以保证质量。作者回复：很多人不知道质量问题是一环套一环累积起来的。2019-02-02

团队开发人员的编程功力不够，即使想写单元测试也是奢望。那种前后台代码不分，用着先进的设计模式但写着落后方式实现的代码的，一旦开始了单元测试，估计大部分时间不是在实现上而是在频繁修改单元测试代码上了。作者回复：说得有道理，不过，在接下来的几篇，我们先把关于测试的理念梳理顺了，知道问题出在哪，以后才好进行改进。2019-01-25

现在单元测试有很多涉及到资源（比如 db）的测试，这种情况下往往有依赖 spring，导致了两个问题：1）spring 启动慢。2）dao 测试不能跨环境，导致竟然因为有 dao 用了 junit，不方便批量运行。junit 这两个问题怎么破？作者回复：首先，涉及到 Spring 启动，这是集成测试，不是单元测试。其次，Spring 提供了数据库的测试方案，测试之后，可以回滚，测试之间彼此不影响。用 spring 和 test 作为关键字可以搜到。再次，我个人推荐使用 Spring Data，自己少写数据库逻辑。2019-06-17

请教老师一个具体问题，mvc 结构的工程，c 层的单元测试要实际的去调用 m 层吗？需要和数据库里的数据做比对和验证吗？如果不用，c 层的单元测试应该验证或测试哪些内容呢？作者回复：在单元测试里，M 的接口是可以用 Mock 的，这才算是单元测试。涉及到数据库，就变成了集成测试。2019-03-21

单元测试不好写，基本可以断定业务代码和通用代码纠结在一起了，需要重构；多写基于方法级别的单元测试。作者回复：耦合是肯定的。2019-03-11

服务划分与编排做不好的、搞不清什么方法应该 private / 什么方法应该 public 的程序员，也会害怕写单元测试：不知道应该在哪切这一刀来看问题。作者回复：是的，良好的设计会让测试更好写。2019-03-01

测试没有银弹，主要看大家对测试这件事情的认知是否一致，现在都在推崇测试左移，尽可能玩发现问题，这就对程序员提出更高的要求。作者回复：优秀程序员总是少数的，会写测试就已经上了一级台阶，能在写代码之前思考测试，就会再上一级台阶。2019-01-27

作为一个程序员，怎么保证自己写出来的程序是好的，答案是写测试，只有自己通过了单元测试、集成测试、系统测试，那么提测的时候我们才会有底气，而不是时刻准备着测试出问题去改。但是，很不幸的是，团队内部成员没有写测试的意识，让他们写，以不会写、时间不够为借口，就是不写，不知道郑老师对这种情况有没有好的解决办法。作者回复：很多不喜欢写测试的真实原因是，不会写。2019-01-26

我之所以回来重读《10X 程序员工作法》，一方面是因为新专栏的更新，另一方面就是在写单元测试的时候，发现自己不会任务分解，所以写不出来。在我看来，程序员去写单元测试，而且尽可能的保持高的代码覆盖率（同时还有代码风格检查）都是不需要讨论的事情。从敏捷编程被介绍到国内，一直到现在，似乎也没有多少开发团队能够做到。不知道国外的情况怎么样？看了文中提供的关于软件变更成本的链接，那四张图片，应该可以用来说服开发团队和领导。但是，有自驱力，愿意提高自己编程技艺的程序员可能没有那么多。我对于测试驱动开发和单元测试都是认可的，但是一来是没有太多机会实践，二来就是真的不不会写。现在可能好一点，但是仍旧需要多练习。准备重读 Kent Beck 的《解析极限编程》和《测试驱动开发》。2020-06-04

目前好像大部分公司都不怎么要求写单元测试，即使有些公司要求自测最多也只是业务上的测试，就像前端和移动端很多时候都是 UI 还原度和适配上的问题，也只有视觉上的东西暴露的更直接一些，其他方面的问题一般都很难说清楚，一般公司业绩考核也更看重直观的东西，所以大部分人都不会去做一些底层的单元测试！作者回复：你说的是现状，我这里在讨论的是，应该是什么样。我反复提到，许多团队深陷泥潭不自知，就是现有的做事方式让他们陷了进去。2019-01-28

## 0203先写测试就是测试驱动开发吗.md

一些优秀的程序员不仅仅在写测试，还在探索写测试的实践。有人尝试着先写测试，于是，有了一种实践叫测试先行开发。还有人更进一步，一边写测试，一边调整代码，这叫做测试驱动开发，也就是 TDD。从步骤上看，关键差别就在，TDD 在测试通过之后，要回到代码上，消除代码的坏味道。测试驱动开发已经是行业中的优秀实践，学习测试驱动开发的第一步是，记住测试驱动开发的节奏：红 —— 绿 —— 重构。把测试放在前面，还带来了视角的转变，要编写可测的代码，为此，我们甚至需要调整设计，所以，有人也把 TDD 称为测试驱动设计。如果今天的内容你只能记住一件事，那请记住：我们应该编写可测的代码。

在上一讲中，我向你说明了为什么程序员应该写测试，今天我准备与你讨论一下程序员应该在什么阶段写测试。或许你会说，写测试不就是先写代码，然后写测试吗？没错，这是一个符合直觉的答案。但是，这个行业里确实有人探索了一些不同的做法。接下来，我们就将进入不那么直觉的部分。

既然自动化测试是程序员应该做的事，那是不是可以做得更极致一些，在写代码之前就把测试先写好呢？有人确实这么做了，于是，形成了一种先写测试，后写代码的实践，这个实践的名字是什么呢？它就是测试先行开发（Test First Development）。

我知道，当我问出这个问题的时候，一个名字已经在很多人的脑海里呼之欲出了，那就是测试驱动开发（Test Driven Development），也就是大名鼎鼎的 TDD，TDD 正是我们今天内容的重点。在很多人看来，TDD 就是先写测试后写代码。在此我必须澄清一下，这个理解是错的。先写测试，后写代码的实践指的是测试先行开发，而非测试驱动开发。下一个问题随之而来，测试驱动开发到底是什么呢？测试驱动开发和测试先行开发只差了一个词：驱动。只有理解了什么是驱动，才能理解了测试驱动开发。要理解驱动，先来看看这两种做法的差异。

### 3.1 测试驱动开发

学习 TDD 的第一步，是要记住 TDD 的节奏：「红 - 绿 - 重构」。

1『原文图里的内容：红，编写一个失败的测试；绿，编写代码使测试通过；重构，消除冗余。』

红，表示写了一个新的测试，测试还没有通过的状态；绿，表示写了功能代码，测试通过的状态；而重构，就是再完成基本功能之后，调整代码的过程。这里说到的「红和绿」，源自单元测试框架，测试不过的时候展示为红色，通过则是绿色。这在单元测试框架形成之初便已经约定俗成，各个不同语言的后代也将它继承了下来。

我们前面说过，让单元测试框架流行起来的是 JUnit，他的作者之一是 Kent Beck。同样，也是 Kent Beck 将 TDD 从一个小众圈子带到了大众视野。考虑到 Kent Beck 是单元测试框架和 TDD 共同的贡献者，你就不难理解为什么 TDD 的节奏叫「红 - 绿 - 重构」了。

测试先行开发和测试驱动开发在第一步和第二步是一样的，先写测试，然后写代码完成功能。二者的差别在于，测试驱动开发并没有就此打住，它还有一个更重要的环节：重构（refactoring）。也就是说，在功能完成而且测试跑通之后，我们还会再次回到代码上，处理一下代码上写得不好的地方，或是新增代码与旧有代码的重复。因为我们第二步「绿」的关注点，只在于让测试通过。

测试先行开发和测试驱动开发的差异就在重构上。很多人通过了测试就认为大功告成，其实，这是忽略了新增代码代码可能带来的「坏味道」（Code Smell）。如果你真的理解重构，你就知道，它就是一个消除代码坏味道的过程。一旦你有了测试，你就可以大胆地重构了，因为任何修改错误，测试会替你捕获到。

在测试驱动开发中，重构与测试是相辅相成的：没有测试，你只能是提心吊胆地重构；没有重构，代码的混乱程度是逐步增加的，测试也会变得越来越不好写。因为重构和测试的互相配合，它会驱动着你把代码写得越来越好。这是对「驱动」一词最粗浅的理解。

3『书籍「重构」里一个非常重要的观点：重构的前提是写好测试。』

### 3.2 测试驱动设计

接下来，我们再来进一步理解「驱动」：由测试驱动代码的编写。许多人抗拒测试有两个主要原因：第一，测试需要「额外」的工作量。这里我特意把额外加上引号，因为，你也许本能上认为，测试是额外的工作，但实际上，测试也应该是程序员工作的一部分，这在上一篇文章中我已经讲过。第二，很多人会觉得代码太多不好测。之所以这些人认为代码不好测，其中暗含了一个假设：代码已经写好了，然后，再写测试来测它。

如果我们把思路反过来，我有一个测试，怎么写代码能通过它。一旦你先思考测试，设计思路就完全变了：我的代码怎么写才是能测试的，也就是说，我们要编写具有可测试性的代码。用这个角度，测试是不是就变得简单了呢？这么说还是有些抽象，我们举个写代码中最常见的问题：static 方法。

很多人写代码的时候喜欢使用 static 方法，因为用着省事，随便在哪段代码里面，直接引用这个 static 方法就可以。可是，一旦当你写测试的时候，你就会发现一个问题，如果你的代码里直接调用一个 static 方法，这段代码几乎是没法测的。尤其是这个 static 方法里面有一些业务逻辑，根据不同业务场景返回各种值。为什么会这样？

我们想想，常见的测试手法应该是什么样的？如果我们在做的是单元测试，那测试的目标应该就是一个单元，在这个面向对象作为基础设施流行的时代，这个单元大多是一个类。测试一个类，尤其是一个业务类，一般会涉及到一些与之交互的类。比如，常见的 REST 服务三层架构中，资源层要访问服务层，而在服务层要访问数据层。编写服务层代码时，因为要依赖数据层。所以，测试服务层通常的做法是，做一个假的数据层对象，这样即便数据层对象还没有编写，依然能够把服务层写完测好。

在之前的「蛮荒时代」，我们通常会写一个假的类，模拟被依赖那个类，因为它是假的，我们会让它返回固定的值，使用这样的类创建出来的对象，我们一般称之为 Stub 对象。这种「造假」的方案之所以可行，一个关键点在于，这个假对象和原有对象应该有相同的接口，遵循同样的契约。从设计上讲，这叫符合 Liskov 替换法则。这不是我们今天讨论的重点，就不进一步展开了。

因为这种「造假」的方案实在很常见，所以，有人做了框架支持它，就是常用的 Mock 框架。使用 Mock 对象，我们可以模拟出被依赖对象的各种行为，返回不同的值，抛出异常等等。它之所以没有用原来 Stub 这个名字，是因为这样的 Mock 对象往往有一个更强大的能力：验证这个 Mock 对象在方法调用过程中的使用情况，比如调用了几次。

我们回到 static 的讨论上，你会发现 Mock 对象的做法面对 static 时行不通了。因为它跳出了对象体系，static 方法是没法继承的，也就是说，没法用一系列面向对象的手法处理它。你没有办法使用 Mock 对象，也就不好设置对应的方法返回值。要想让这个方法返回相应的值，你必须打开这个 static 方法，了解它的实现细节，精心地按照里面的路径，小心翼翼地设置对应的参数，才有可能让它给出一个你预期的结果。更糟糕的是，因为这个方法是别人维护的，有一天他心血来潮修改了其中的实现，你小心翼翼设置的参数就崩溃了。而要重新进行设置的话，你只能把代码重读一遍。如此一来，你的工作就退回到原始的状态。更重要的是，它并不是你应该关注的重点，这也不会增加你的 KPI。显然，你跑偏了。

讨论到这里你已经知道了 static 方法对测试而言，并不友好。所以，如果你要想让你的代码更可测，一个好的解决方案是尽量不写 static 方法。这就是「从测试看待代码，而引起的代码设计转变」的一个典型例子。

关于 static 方法，我再补充几点。static 方法从本质上说，是一种全局方法，static 变量就是一种全局变量。我们都知道，全局方法也好，全局变量也罢，都是我们要在程序中努力消除的。一旦放任 static 的使用，就会出现和全局变量类似的效果，你的程序崩溃了，因为别人在另外的地方修改了代码，代码变得脆弱无比。

static 是一个方便但邪恶的东西。所以，要限制它的使用。除非你的 static 方法是不涉及任何状态而且行为简单，比如，判断字符串是否为空。否则，不要写 static 方法。你看出来了，这样的 static 方法更适合做库函数。所以，我们日常写应用时，能不用尽量不用。前面关于 static 方法是否可以 Mock 的讨论有些绝对，市面上确实有某些框架是可以 Mock static 方法的，但我不建议使用这种特性，因为它不是一种普遍适用的解决方案，只是某些特定语言特定框架才有。更重要的是，正如前面所说，它会在设计上将你引到一条不归路上。

如果你在自己的代码遇到第三方的 static 方法怎么办，很简单，将第三方代码包装一下，让你的业务代码面对的都是你自己的封装就好了。以我对大多数人编程习惯的认知，上面这个说法是违反许多人编程直觉的，但如果你从代码是否可测的角度分析，你就会得到这样的结论。先测试后写代码的方式，会让你看待代码的角度完全改变，甚至要调整你的设计，才能够更好地去测试。所以，很多懂 TDD 的人会把 TDD 解释为测试驱动设计（Test Driven Design）。

还有一个典型的场景，从测试考虑会改变的设计，那就是依赖注入（Dependency Injection）。不过，因为 Spring 这类 DI 容器的流行，现在的代码大多都写成了符合依赖注入风格的代码。原始的做法是直接 new 一个对象，这是符合直觉的做法。但是，你也可以根据上面的思路，自己推演一下，从 new 一个对象到依赖注入的转变。有了编写可测试代码的思路，即便你不做 TDD，依然对你改善软件设计有着至关重要的作用。所以，写代码之前，请先想想怎么测。

即便我做了调整，是不是所有的代码就都能测试了呢？不尽然。从我个人的经验上看，不能测试的代码往往是与第三方相关的代码，比如访问数据库的代码，或是访问第三方服务之类的。但不能测试的代码已经非常有限了。我们将它们隔离在一个小角落就好了。

至此，我们已经从理念上讲了怎样做好 TDD。有的人可能已经跃跃欲试了，但更多的人会用自己所谓的「经验」告诉你，TDD 并不是那么好做的。怎么做好 TDD 呢？下一讲，我会给你继续讲解，而且，我们「任务分解大戏」这个时候才开始真正拉开大幕！

### 黑板墙

你对测试驱动开发的理解是怎样的呢？

最近在一个新项目中尝试使用了 TDD 有测试保驾护航是真的爽。事情是这样的，今天经过讨论要把一个模型替换掉，刚听到这个消息的时候我是崩溃的，心想这要是出 bug 怎么办，到转念一想我测试覆盖率 88% 应该还好，动手改完跑起测试，果然不过，但是只是几个小问题，再次运行测试，绿灯！我的天，此时内心别提多么舒爽，这要是没有测试我今晚应该不用睡了，谢谢老师。最近也开始先分解任务再小步提交，这么做下来有一种很踏实的感觉，同事 review 代码也舒服很多。2019-04-17

测试驱动不但可以写出精炼的代码，还能养成良好的编程习惯和设计思维，相辅相成。团队达到这种状态还真是不易，架子搭好了有人觉得没发挥空间，要是放开了代码又会五花八门难以测试。莫名有种担心，会不会为了测试而测试在代码里混搭着 workaround 呢？作者回复：测试应该是什么样子，后面即将呈现，敬请期待！2019-01-30

之前在其他领域的里也有介绍负反馈相关单位内容，各个领域之间还是有很多互通之处。软件或者其他系统一直处于熵增的状态，需要持续的保养和维护。不得不感慨大道至简。

印象最深的几次 TDD。1）是个 CS 应用，从服务端拉取数据后，根据不同状态，客户端执行不同逻辑。采用的方法是，将服务端的响应值记录，然后在测试代码里回放，不依赖服务端。修 bug 时，每个 bug 就是一个测试，测试代码里直接回放记录的服务端响应。好处是，回归非常快，而且不依赖服务端。2）上家公司要做 HA 软件开发，情况很复杂，手工做测试代价很高。正好赶上 docker 兴起，于是就写了很多「暴力」代码（比如直接 kill 服务、删除服务等）测试各种场景，只留少数必须用物理机测试的场景交给人工。作者回复：第一个像验收测试，第二个像暴力测试。2019-01-28

以前理解的测试驱动开发，我写完测试、代码完成就结束了。看完文章，增加对重构理解。有了测试的依托，改动代码的结果也能从测试结果中看出。目前对于 TDD 还是处于理解状态，不知道如何真正的在项目工程中使用。因为项目工程往往还有很多其他调用，如 rpc，数据库服务，第三方服务，不知道在这个过程如何处理。期待老师的之后文章讲解。作者回复：在综合运用模块答疑这个问题。2019-01-31

请问为什么「一旦放任 static 的使用，就会出现和全局变量类似的效果，你的程序崩溃了，因为别人在另外的地方修改了代码，代码变得脆弱无比。」？ 一般来说，别人修改代码，应该不改变输入和输出，所以不会受到影响。而如果改变了输入和输出，就算是实例方法也会 break 吧？作者回复：如果代码可以保证是纯函数，当然不会有问题，但 static 的出现常常会破坏函数的纯粹性。你修改这个 static 的值，还不知道它在哪用到了，就可能带来很多问题。2020-05-10

对于开发者自测，有什么比较好的书籍推荐么？现在对于不同层次的测试感觉还是没有一个章法，有点乱，怎样可以提高自测的效率？作者回复：可以看看 Kent Beck 的《测试驱动开发》，还有一本《测试驱动的面向对象软件开发》（Growing Object-Oriented Software, Guided by Tests）也可以看看。2020-03-25

测试驱动开发的精髓是第三步重构。最近也是做一个业务测试。发现最初的修改只是通过代码中加特殊的判断去规避了这个问题。在影响性测试中发现，正常的处理逻辑完全满足了这种业务场景。只是我们在当前场景中少置为了一个标记。导致下游不识别。在正常业务流程中增加这个标示完全解决问题。这就是重构的精髓。作者回复：这好像是缺少了集成测试吧！2019-12-21

PowerMock 框架是可以支持 mock static 类和方法的。作者回复：但我不建议使用，因为它会把设计引导向一个错误的方向。如果是应对遗留代码，勉强可用。2019-06-03

TDD，和任务分解可以说是相辅相成。在写测试的时候，一个一个的 case 其实在对任务的分解，考虑每个 case 所要达到的目标，输入、输出，以及 case 与 case 之间的衔接。写测试的时候，我们是站在一个 consumer 的角度来的，考虑的是这个 case 的输入和输出。首先，这对于设计能力有一定的要求，其次，按照这种方式写出来的代码可用性更高。因为我们的起点是 consumer 而不是 provider。2019-03-10

老师如果有机会的话，谈一谈对不同层面测试的理解吧。我们现在的后端代码库大概有三种层面的测试：1）单元测试 - 对某个类的测试。2）系统测试 - 测试 service 之间的 interaction。3）我们还有一个 container test，测试方法是 mock 所有的 external dependency 数据库也好，其他的服务也好，这样能保证负责的业务逻辑从头到尾的结果。老师你对测试的理解是怎么样的？什么应该被测试，大概投入多少比例。作者回复：其实，测试金字塔已经说了测试比例，越是底层的测试应该越多，只有尽可能多的单元测试才能有接近 100% 的覆盖率。2019-01-29

不久前第一次接触 TDD 时为它的思想而惊叹，感觉它能极大的提升编码效率，编码后期的大量重构，还能保障代码质量。后面自己在写代码的时候也注意使用它的思想，但说实话，理解是一回事，用起来就不是那么回事了，很多的东西还不是太熟练，前期说实话比较耗时间，有些拖进度。由于也毕业不久，经验上有些欠缺，还不太熟练，有些测试还不知道怎么写。现在写多了一点，感受到的是代码质量上的提高，bug 比起以前少了，需求变更下也改动也不伤筋动骨了，但还是有许多感觉做的不够好的。看了这篇文章，给了一个补充 TDD 的认知，感受到如果和任务分解结合起来会有更好的效果。2019-01-28

## 0204大师级程序员的工作秘笈.md

TDD 在很多人眼中是不实用的，一来他们并不理解测试「驱动」开发的含义，但更重要的是，他们很少会做任务分解。而任务分解是做好 TDD 的关键点。只有把任务分解到可以测试的地步，才能够有针对性地写测试。同样听到任务分解这个说法，不同的人理解依然是不一样的。我把任务分解的结果定义成微操作，它远比大多数人理解得小。我们能将任务分解到多小，就决定了我们原子操作的粒度是多大。软件开发中的许多问题正是由于粒度太大造成的，比如，分支策略。如果今天的内容你只能记住一件事，那请记住：将任务拆小，越小越好。

前面我和大家分享了 TDD 的来龙去脉，那些尚未将 TDD 烂熟于胸的同学会分为两个派别。一派是摩拳擦掌，准备动手实践一番；另一派是早就自我修炼过，但实践之路不通。所以，市面上经常会听到有人说，TDD 不实用。但是 TDD 真的不实用吗？和任何一门技能一样，TDD 也是需要练习的。更重要的是，你需要打通 TDD 的「任督二脉」，而这关键正是我们这个模块的主题：任务分解。

### 4.1 TDD 从何而来？

要学最原汁原味的 TDD ，莫过于从源头学起。从前 TDD 只在小圈子里流行，真正让它在行业里广为人知的是 Kent Beck 那本知名的软件工程之作《解析极限编程》（Extreme Programming Explained）。这是一本重要的作品，它介绍了一种软件开发方法：极限编程。当年他写作之时，许多人都在努力探寻瀑布开发方法之外的软件工程方法，除了极限编程，还有特征驱动开发、水晶开发方法等等，正是这些开发方法的探索，才有了后面敏捷方法的诞生。

极限编程对于行业最大的贡献在于，它引入了大量的实践，比如，前面提到过的持续集成、这里提到的 TDD，还有诸如结对编程、现场客户等等。极限编程之所以叫「极限」，它背后的理念就是把好的实践推向极限。1）前面提到持续集成时，我们已经介绍过这个理念，如果集成是好的，我们就尽早集成，推向极限每一次修改都集成，这就是持续集成。2）如果开发者测试是好的，我们就尽早测试，推向极限就是先写测试，再根据测试调整代码，这就是测试驱动开发。3）如果代码评审是好的，我们就多做评审，推向极限就是随时随地地代码评审，这就是结对编程。4）如果客户交流是好的，我们就和客户多交流，推向极限就是客户与开发团队时时刻刻在一起，这就是现场客户。这种极限思维是一种很好的思考问题方式，推荐你也在工作中尝试使用一下。

虽然 TDD 只是《解析极限编程》介绍的诸多实践的一种，它却是与开发人员关系最为密切的一个实践。随着 TDD 逐渐流行开来，人们对如何做 TDD 也越来越感兴趣，于是，Kent Beck 又专门为 TDD 写了一本书，叫《测试驱动开发》。

### 4.2 大师级程序员的秘笈

《测试驱动开发》这本书很有意思。如果你只是为了了解 TDD，这本书可能很无聊。Kent Beck 在第一部分只是在写一个功能，写完一段又写一段。这本书我看过两遍，第一遍觉得平淡无奇，这种代码我也能写。第二遍看懂他的思路时，我几乎是震惊的感觉，因为它完全是在展示 Kent Beck 的工作方式。这也是我把 TDD 放到这个部分来讲的重要原因，Kent Beck 在做的就是任务分解。任务分解，也是这本书的真正价值所在。

当时，我已经工作了很多年，自以为自己在写代码上已经很专业了。看懂 Kent Beck 的思路，我才知道，与他相比，我还不够专业。Kent Beck 是怎么做的呢？每当遇到一件要做的事，Kent Beck 总会先把它分解成几个小任务，记在一个清单上，然后，才是动手写测试、写代码、重构这样一个小循环。等一个循环完成了，他会划掉已经做完的任务，开始下一个。一旦在解决问题的过程中遇到任何新的问题，他会把这个要解决的问题记录在清单上，保证问题不会丢失，然后，继续回到自己正在处理的任务上。当他把一个个任务完成的时候，问题就解决完了。

你或许会纳闷，这有什么特别的吗？你不妨回答这样一个问题，你多长时间能够提交一次代码？如果你的答案超过半天，对不起，你的做法步子一定是太大了。你之所以不能小步提交，一定是牵扯了太多相关的部分。Kent Beck 的做法清晰而有节奏，每个任务完成之后，代码都是可以提交的。看上去很简单，但这是大多数程序员做不到的。只有把任务分解到很小，才有可能做到小步提交。你能把任务分解到很小，其实是证明你已经想清楚了。而大多数程序员之所以开发效率低，很多时候是没想清楚就动手了。

我在 ThoughtWorks 工作时，每个人都会有个 Sponsor，类似于工厂里师傅带徒弟的关系。我当时的 Sponsor 是 ThoughtWorks 现任的 CEO 郭晓，他也是写代码出身的。有一次，他给我讲了他和  Wiki 的发明者 Ward Cunningham 一起结对编程的场景。Ward 每天拿到一个需求，他并不急于写代码，而是和郭晓一起做任务分解，分解到每个任务都很清晰了，才开始动手做。接下来就简单了，一个任务一个任务完成就好了。

当时，郭晓虽然觉得工作节奏很紧张，但思路则是非常清晰的。有时，他也很奇怪，因为在开始工作之前，他会觉得那个问题非常难以解决。结果一路分解下来，每一步都是清晰的，也没遇到什么困难就完成了。之所以这里要和你讲 Ward Cunningham 的故事，因为他就是当年和 Kent Beck 在同一个小圈子里一起探讨进步的人，所以，在解决问题的思路上，二人如出一辙。

为什么任务分解对于 TDD 如此重要呢？因为只有当任务拆解得足够小了，你才能知道怎么写测试。很多人看了一些 TDD 的练习觉得很简单，但自己动起手来却不知道如何下手。中间就是缺了任务分解的环节。任务分解是个好习惯，但想要掌握好它，大量的练习是必须的。我自己也着实花不少时间进行练习，每接到一个任务，我都会先做任务分解，想着怎么把它拆成一步一步可以完成的小任务，之后再动手解决。

### 4.3 微操作

随着我在任务分解上练习的增多，我越发理解任务分解的关键在于：小。小到什么程度呢？有时甚至可以小到你可能认为这件事不值得成为一件独立的事。比如升级一个依赖的版本，做一次变量改名。这样做的好处是什么呢？它保证了我可以随时停下来。

我曾在一本书里读到过关于著名高尔夫球手「老虎」伍兹的故事。高尔夫球手在打球的时候，可能会受到一些外界干扰。一般情况下还好，如果他已经开始挥杆，这时候受到了干扰，一般选手肯定是继续把杆挥下去，但通常的结果是打得不理想。而伍兹遇到这种情况，他会停下来，重新做挥杆的动作，保证了每一杆动作的标准。伍兹能停下来，固然是经过了大量的练习，但还有一个关键在于，对于别人而言，挥杆击球是一个动作，必须一气呵成。而对伍兹来说，这个动作是由若干小动作组成的，他只不过是刚好完成了某个小动作，而没有做下一个小动作而已。

换句话说，大家同样都是完成一个原子操作，只不过，伍兹的原子操作比其他人的原子操作小得多。同样，我们写程序的时候，都不喜欢被打扰，因为一旦被打扰，接续上状态需要很长一段时间，毕竟，我们可不像操作系统那么容易进行上下文切换。但如果任务足够小，完成一个任务，我们选择可以进入到下一个任务，也可以停下来。这样，即便被打扰，我们也可以很快收尾一个任务，不致于被影响太多。

其实，这种极其微小的原子操作在其他一些领域也有着自己的应用。有一种实践叫微习惯，以常见的健身为例，很多人难以坚持，主要是人们一想到健身，就会想到汗如雨下的健身场景，想想就放弃了。但如果你一次只做一个俯卧撑呢？对大多数人来说，这就不是很难的一件事，那就先做一个。做完了一个如果你还想做，就接着做，不想做就不做了。一个俯卧撑？你会说这也叫健身，一个俯卧撑确实是一个很小的动作，重要的是，一个俯卧撑是你可以坚持完成的，如果每天做 10 个，恐怕这都是大多数人做不到的。我们知道，养成一个习惯，最难的是坚持。如果你有了一个微习惯，坚持就不难了。

我曾经在 github 上连续提交代码 1000 天，这是什么概念？差不多三年的时间里，每天我都能够坚持写代码，提交代码，这还不算工作上写的代码。对于大多数人来说，这是不可思议的。但我坚持做到了，不是因为我有多了不起，而是我养成了自己的微习惯。

这个连续提交的基础，就是我自己在练习任务分解时，不断地尝试把一件事拆细，这样，我每天都至少能保证完成一小步。当然，如果有时间了，我也会多写一点。正是通过这样的方法，我坚持了 1000 天，也熟练掌握了任务分解的技巧。一个经过分解后的任务，需要关注的内容是有限的，我们就可以针对着这个任务，把方方面面的细节想得更加清晰。很多人写代码之所以漏洞百出，一个重要的原因就是因为任务粒度太大。

我们作为一个普通人，能考虑问题的规模是有限的，也就很难方方面面都考虑仔细。

### 4.4 微操作与分支模型

经过这种练习之后，任务分解也就成了我的本能，不再局限于写程序上。我遇到任何需要解决的问题，脑子里的第一反应一定是，它可以怎么一步一步地完成，确定好分解之后，解决问题就是一步一步做了。如果不能很好地分解，那说明我还没想清楚，还需要更多信息，或者需要找到更好的解决方案。一旦你懂得了把任务分解的重要性，甚至通过训练能达到微操作的水准，你就很容易理解一些因为步子太大带来的问题。举一个在开发中常见的问题，代码开发的分支策略。

关于分支策略，行业里有很多不同的做法。有的团队是大家都在一个分支上写代码，有的是每个人拉出一个分支，写完了代码再合并回去。你有没有想过为什么会出现这种差异呢？行业中的最佳实践是，基于主分支的模型。大家都在同一个分支上进行开发，毕竟拉分支是一个麻烦事，虽然 git 的出现极大地降低了拉分支的成本。但为什么还有人要拉出一个分支进行开发呢？多半的原因是他写的代码太多了，改动量太大，很难很快地合到开发的主分支上来。

那下一个问题就来了，为什么他会写那么多代码，没错，答案就是步子太大了。如果你懂得任务分解，每一个分解出来的任务要改动的代码都不会太多，影响都在一个可控的范围内，代码都可以很快地合并到开发的主分支上，也就没有必要拉分支了。在我的实际工作中，我带的团队基本上都会采用基于主分支的策略。只有在做一些实验的时候，才会拉出一个开发分支来，但它并不是常态。

### 黑板墙

Feature toggle（功能开关）分享两篇文章：1）[Feature Toggles (aka Feature Flags)](https://martinfowler.com/articles/feature-toggles.html)。2）[使用功能开关更好地实现持续部署 - InfoQ](https://www.infoq.cn/article/function-switch-realize-better-continuous-implementations)。2019-02-03

关于基于主分支的策略上线流程是怎么样的，假如两个人同时在开发两个功能，并不断的进行小的粒度提交，那其中一个人完成功能要上线的话，另一个人的功能才完成一部分，待主干中已经有他那没完成的任务的代码了，是要一块发布吗？作者回复：这种问题的常见解决方案是 Feature Toggle。2019-01-30

开发多年，潜移默化的，我习惯了在稳定的根基上构建代码，重构，改善代码既有设计是本神书，推荐大家看看，里面套路包满满，例如代码意图与实现分离这句话，我在第一次看到时感受到了震撼，突然觉得自己之前写代码好 sb。然后随阅读量上升，当我看到这段文字时：An algorithm can be regarded as consisting of a logic component, which specifies the knowledge to be used in solving problems, and a control component, which determines the problem-solving strategies by means of which that knowledge is used. The logic component determines the meaning of the algorithm whereas the control component only affects its efficiency. The efficiency of an algorithm can often be improved by improving the control component without changing the logic of the algorithm. We argue that computer programs would be more often correct and more easily improved and modified if their logic and control aspects were identified and separated in the program text.

以及 google 整理术后，更明白为啥要那样处理了。不扯太远，话说回来，tdd 的精髓我认为就是任务细分和重构。而且很多时候重构就是为了更好的去理解和实现任务细分。形成更好的正向循环。并且每一步是建立在成功的根基上。然而此事还可以继续再横向迁移一下。一个计划能稳定可保障的执行，靠的就是合适粒度的分解。（放心，我们平时都分的过粗了，分的不适合我们的大脑高效工作了）我自己是马拉松爱好者，更深知步子迈大了对跑全马来说意味者什么，更别提大铁，巨人，utmb（utmb 是我此生的梦想）了。2019-11-07

任务分解也是我目前最想做好的，也是最无从下手的，概念都懂，做起来吃力，即使做一份分解清单出来，也不知道是不是好的。因为现在也在带团队做项目，所以对做任务分解的重要性深有体会，现在尝试让所有人在思维认知上有变化，一步步去实操微操作级别的任务分解，学好这些软技能才能快速成长为大牛级的人物。而所有问题中最大最迫切的问题是如何能快速合理的做任务分解，得到任务清单，希望老师能多拿些实际需求来讲解下如何分解出合理的任务清单，是否可以在后面的章节中留些任务分解的作业，实践后老师给一些指正。作者回复：稍安勿躁，下一讲，我就带着大家做一次任务分解，先体会一下分解可以做到什么程度。2019-01-30

老师请教个问题，传统的项目型公司，一个客户一个项目但是都是基于同一个产品的，那么是否适合用一个分支的模式，还是不同项目不同分支呢？作者回复：这其实是一个产品设计的问题，能不能把公共部分变成产品配置，这是很挑战产品设计的，否则，就是用代码解决问题，费时费力。2020-02-08

昨天刚改了编程习惯，先在 notion 写出思路、需要用到的知识点，api 等，写出各个小任务，然后对应写出关键代码段。最后真正敲代码就花了 10 来分钟。重新开始看极客就看到这篇，实践过来读，很认同。我特别佩服国外的工程师写的代码，代码块很小，非常清晰易读。特别记得之前参加 infoq 会议，听 socketio 作者的分享，看他现场撸码，思路、代码结构都非常顺畅和清晰。2019-02-14

对任务分解的体会非常深刻，刚入职的时候任务评估不准。现在想想主要是两个原因：1）需求梳理的不清晰，还没清楚地搞明白需求就动手写代码，导致返工、导致一些「意想不到」的情况。2）任务分解做的不好，没有将任务分解成非常清晰地可执行的单元，导致有些时候无从下手，而且任务时间评估不准确。2019-01-31

刚刚做完 2018 年项目的复盘，其中很重要的一个教训就是拆解不细致。依赖供应商的系统，而他们习惯于完成全部接口开发后才对接交付，结果其他依赖于此的系统迟迟不能交付，这段时间业务方增加很多工作量不说，等完成上线才发现移动端体验距离我们习惯差很远，再加上其他问题，导致供应商项目暂停。幸好之前有预见，提前做了二手准备，才不至于项目整体失败。没有做细致的推演，没有做细致的拆分和迭代交付，道理容易懂，但教训仍然要自己品尝才会深刻。作者回复：你已经能理解任务分解的价值，缺少的就是分解得小，拆小才能对任务有更深的理解。2019-01-30

最近在连续读老师关于任务拆解和测试部分的文章，快排是一直我自己以为很懂，但直接写代码又写不出来的。昨晚决定采用先拆解，再逐步测试，最后完成任务的方法去实现。1）编写快排的测试用例；2）把快排拆解出一个 helper function ： partition，分区方法；3）通过对 partition 的理解，编写测试用例；4）编写 partition 的代码，尝试通过测试；虽然过程还是因为一些临界值麻烦来一阵，但还是写下来了。在写 partition 中，交换两个下标数值的操作也可以拆分成函数，测试之，编写之；5）编写快排的递归主函数，完成 1 步骤的测试用例。2020-06-04

老师，我了解了下 feature toggle。觉得这种方式相对多分支开发有很多弊端。1）未上线的代码有全局影响的变动，比如引入 maven 依赖，导致 maven 冲突。这就肯定影响到要上线的代码了。toggle 解决不了。而多分枝不会有这种影响。2）toggle 的判断。实际开发中会有很多零碎的改动。会导致引入很多判断的地方。请老师解疑。作者回复：引入依赖是不是问题呢？对于服务端，可能不是问题，对于客户端，可能是，但通常解决方案会有很多，比如，有压缩的方案，对于 Java，有 Proguard，有构建脚本中，根据 Feature Toggle 选择依赖的方案。代码会出现零碎的改动，如果设计做得不好，确实会这样，但是，这正好是一个改进设计的机会，让你发现自己的代码产生变动的维度，把相同的改进收到一起。再有一点，无论是 Feature Toggle 或者多分支，必须理解成是短时间存在的，这是问题的关键所在，它们俩任何的长期存在都会引发各种问题。2020-04-21

看到任务分解以及它带来的好处，我就在想一个重要的问题：一定要主动去做任务分解，而不是等待别人把任务分解好了再给你。一个很好的例子就是对日外包的项目，很多人诟病对日外包项目要求严格，文档要细化到傻瓜一眼就能看懂的地步。但我想说，这其实也是任务分解的要求，粒度尽可能细，虽然不一定事无巨细的用文档来跟踪，但是这个思维过程还是很有用的。作者回复：主动和被动差别非常大。2020-03-19

Feature Toggle 并不算一个好的解决方案。我们使用的是频繁的分支合并。每次 master 分支有提交会自动向其他分支合并，这样有冲突就可以第一时间发现了。作者回复：这取决于你怎么定义「频繁」，如果真的能够每天都提交，分支也可以接受，但如果真能每天都提交，你还会开分支吗？2019-05-09

主干分支用着委实不错。但有几个点，一个是在已用线上产品的时候，我们通常会有一条 release 分支。这样当有线上 bug 出现的时候，我们能在 release 分支上快速修复 + 上线。另外一个是，在规律性的迭代上线时，难免会遇到有 story 没有完成 (开发或者测试)，此时，就得使用 feature toggle 或者 revert 代码了。最后是当在做一个很明显上线前不可能完成的大 feature 的时候，一般我们会启另一条分支来开发。此时会定时从主分支 merge 代码，因为有些改动可能会影响已用的业务。2019-03-10

公司经常存在有两个需求，其中一个需求因公司需要，如发布会，延迟更新的情况，这种实际情况似乎无法用任务分解完成。请问老师所在的团队如何解决单分支上线不同步的情况呢？作者回复：两个功能的问题应该用 Feature Toggle 解决。2019-02-03

## 0205一起练习手把手带你分解任务.md


