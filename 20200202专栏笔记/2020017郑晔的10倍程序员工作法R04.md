# 2020017郑晔的10倍程序员工作法R04

## 记忆时间

## 04. 自动化

## 0400自动化主题的重点内容回顾汇总.md

程序员的三大美德：懒惰、急躁和傲慢（Laziness, Impatience and hubris）。小心 NIH 综合症（Not Invented Here Syndrome）。写好构建脚本，做好项目自动化。参照 Java 知识体系，学习运维知识。软件设计最基础的原则是「高内聚、低耦合」。分层架构是一种设计上的分解。不同业务量的系统本质上不是一个系统。采用简单技术解决问题，直到问题变复杂。

1、一些重点内容汇总：1）持续交付。将生产部署纳入了开发的考量。持续交付的基础设施通常包含持续集成环境、测试环境、预生产环境和生产环境。构建流水线保证到了下游的交付物一定是通过上游验证的。随着 Docker 的诞生，交付由发布包变成了 Docker 镜像。2）DevOps。将开发和运维结合到一起。环境配置工具上的进步，让基础设施即代码成了行业共识。3）验收测试。验收测试要站在业务的角度编写。BDD 是一种编写验收测试的方式。Given…When…Then… 的描述给了一个描述业务的统一方式。写好验收测试，需要构建测试模型。

4）SOLID 原则。设计模式背后的道理。单一职责原则（Single responsibility principle，SRP）。开放封闭原则（Open–closed principle，OCP）。Liskov 替换原则（Liskov substitution principle，LSP）。接口隔离原则（Interface segregation principle，ISP）。依赖倒置原则（Dependency inversion principle，DIP）。用好单一职责原则，前提条件是看待问题颗粒度要小。5）DDD。它将思考的起点拉到了业务上。DDD 分为战略设计和战术设计。6）微服务。做好微服务的前提是划分好限界上下文。微服务的第一步，不要划分微服务。

2、一些额外收获：1）持续集成的延伸。a）持续集成完成系统集成。b）持续交付完成可部署上线。c）「持续验证」完成产品想法验证。2）AB 测试，用一个软件的多个版本验证想法。3）Selenium 用以完成浏览器的自动化。4）熟练使用快捷键。

3、一些留言精选汇总：

在讲到「懒惰」应该是所有程序员的骄傲时，jxin 同学提到：有价值的事并不局限性于事情本身。做自动化很重要，写代码很重要。但根据现有情况判断是否需要自动化，是否需要写代码也很重要。有的放矢，任务分解。权衡跟设计是件很艺术的事情，令人着迷。

另外，关于持续交付，Jxin 同学也提出了自己的理解：分而治之是解决复杂问题的一大利器。持续交互就像重构中小步快走（每次微调后运行测试代码验证），都能保证大工程的稳步前进。同时由于单元小了，所以也灵活了，持续交互可以结合最小产品的理念，以小成本做 test，收集数据后，即时调整产品发展方向。

关于软件设计，毅同学分享了自己的感悟：我们常说任务到手不要着急去做，要从设计入手，把时间多花在前面。工作中发现大家都是思考了才动手的，那为什么越往后偏差越大呢？共性原因有二：一是全局观不够，用咱们课里的话说就是上下文局限和反馈延迟（看到问题不提，直到代码写到那绕不过去了再沟通）；二是没有领域的概念和有意识地去实践（纸上谈兵），尤其是做流程型任务，都喜欢先把表结构定义出来，再去生成实体，所以从领域层面来看这些实体就很不合适了。结果必然是用面向对象的工具写出了面向过程的代码，既然是面向过程那 OO 设计原则就鲜有用武之地了。这两点也是我个人理解要做好软件设计的两个必要条件。

讲到分层架构时，desmond 同学提到：学了 REST 和 DDD，感觉两者有相通的地方：两者都以数据（一个是资源，另外一个是领域对象）为中心，并制定一套标准的数据操作（一个是 HTTP Verb，另外一个我项目主要用 JPA 这一套）；而核心是业务建模。

对于微服务的理解，风翱同学提到：公司说我们的开发方式是敏捷开发，实际上只是使用了一些敏捷开发的方法，只有遵守敏捷开发的价值观和原则，才能算是敏捷开发。微服务也是一样，不是说拆分成多个服务去部署，就叫做微服务。也不是采用市面上常用的微服务框架，就是微服务了。

对于一个好的项目自动化应该是什么样子这个问题，西西弗与卡夫卡同学提到：设想过这样的情景（还没实现，打算实践一把）：我们新招一名比较熟练的程序员，从 TA 入职拿到机器，到开发示意代码，再提交 SCM，然后 CI/CD，再发布到线上交付给用户，整个过程可以在入职当天的午饭之前完成。这不光要求构建和集成自动化，甚至要求从入职开始的各个环节都能提前准备好，包括机器、开发环境、线上环境等，甚至连示范的需求都要能及时传递给 TA。理想情况下，程序员只需要开发好程序，保证质量，提交到 SCM 即可，其他事情都应该交给机器。要知道程序员都很贵，越早给用户交付价值越好。

对于自动化验收测试，shniu 同学分享了他的学习感悟：自动化验收测试确实是很好的东西，比如在回归测试，省去了很多的重复工作。但我理解 BDD 的初衷是驱动产品、业务、开发、测试等去深入讨论沟通需求，在还没有真的写代码的时候去实例化 story，并一起定义验收用例，让每个人对需求的理解都很透彻，当然特别注意的是要从统一的业务角度去描述，可见，真的做好 BDD 是需要不断的尝试和总结的。

对于「5 万块做淘宝」这个话题，enjoylearning 同学提到：做一个淘宝那样的，客户指的是业务类似，但用户量多少，需要多少并发数，搜索性能等如何都是需要跟客户沟通后才能决定技术选型的。现实中我们的有些系统已经满足了业务需求，就没有必要为了追求技术复杂度而去拆分了，只有面向问题技术选型才会有成效。

关于运维知识，hua168 同学对文章内容进行了补充：现在运维流行 DevOps，高级一点就是 AI，其中一篇文章《DevOps 详解》不错，链接如下：[DevOps 详解 - InfoQ](https://www.infoq.cn/article/detail-analysis-of-devops)；《DevOps 知识体系与标准化的构建》也不错，下载地址：[DevOps 知识体系与标准化的构建 - 下载频道 - 云栖社区](https://yq.aliyun.com/download/778)；运维知识体系：[运维知识体系v3.1【赵班长】](https://www.unixhot.com/page/ops)；Web 缓存知识体系：[缓存知识体系v3.0【赵班长】](https://www.unixhot.com/page/cache)。

## 0410答疑解惑持续集成持续交付然后呢.md

「自动化」模块落下了帷幕，这是四个工作原则中最为「技术化」的一个，也应该是程序员们最熟悉的主题。我从软件外部的自动化 —— 工作流程讲起，让你能够把注意力专注于写好代码；讲到了软件内部的自动化 —— 软件设计，选择恰当的做法，不贪图一时痛快，为后续的工作挖下深坑。既然是一个大家都熟悉的话题，同学们自然也有很多经验分享，也有很多人看到了与自己不同的做法，提出了各种各样的问题。在今天的答疑中，我选出了几个很有意思的问题，让大家可以在已有内容上再进一步延伸。

问题 1：持续交付是否可以再做扩展？毅同学提到：为达到有效交付的目标，用户能够尽早参与，我觉得也是比较重要的一环。从生产环境获得结果，是否可再做扩展，将用户也作为一个独立节点？西西弗与卡夫卡同学提到：持续交付可以是持续交付最大价值，那范围就不仅限于软件，还可以进一步延伸到运营，比如说结合 ABTest，自动选择最有效的运营策略，为用户交付最大价值。

两位同学能提出这样的想法，说明真的是已经理解了持续集成和持续交付，所以，才能在这个基础上继续延伸，思考进一步的扩展。我在专栏中一直在强调，别把自己局限在程序员这个单一的角色中，应该了解软件开发的全生命周期。在前面的内容中，我讲了不少做产品的方法，比如，MVP、用户测试等等。如果只把自己定位在一个写代码的角色上，了解这些内容确实意义不大，但你想把自己放在一个更大的上下文中，这些内容就是必须要了解的。

回到两位同学的问题上，如果说我们一开始把持续集成定义成编写代码这件事的完成，那持续交付就把这个「完成」向前再推进了一步，只有上线的代码才算完成。但放在整个软件的生命周期来说，上线并不是终点。把系统送上线，不是最终目的。那最终目的是什么呢？回到思考的起点，我们为什么要做一个软件？因为我们要解决一个问题。那我们是不是真正的解决了问题呢？其实，我们还不知道。

在《06 | 精益创业：产品经理不靠谱，你该怎么办？》这篇文章中，我给你讲了做产品的源头。如果是采用精益创业的模式工作，我们构建产品的目的是为了验证一个想法，而怎么才算是验证了我们的想法呢？需要搜集各种数据作为证据。所以，我曾经有过这样的想法，精益创业实际上是一种持续验证，验证想法的有效性，获得经过验证的认知（Validated Learning）。

现在有一些获取验证数据的方式，比如，西西弗与卡夫卡同学提到的 AB 测试。AB 测试是一种针对两个（或多个）变体的随机试验，常常用在 Web 或 App 的界面制作过程中，分别制作两个（或多个）版本，让两组（或多组）成分相同的用户随机访问不同版本，收集数据，用以评估哪个版本更好。每次测试时，最好只有一个变量。因为如果有多个变量，你无法确认到底是哪个变量在起作用。

AB 测试的概念在其他领域由来已久。2000 年，Google 的工程师率先把它应用在了软件产品的测试中，时至今日，它已经成为很多产品团队常用的做事方式。AB 测试的前提是用户数据搜集。我在《09 | 你的工作可以用数字衡量吗？》这篇文章给你介绍了在开发过程中，用数字帮助我们改善工作。在产品领域实际上更需要用数字说话，说到这里，我「插播」一个例子。

很多产品经理喜欢讲理念、讲做法，偏偏不喜欢讲数字。用数字和产品经理沟通其实是更有说服力的。我就曾经遇到过这样的事情，在一个交易平台产品中，一个产品经理创造性地想出一种新的订单类型，声称是为了方便用户，提高资金利用率。如果程序员接受这个想法，就意味着要对系统做很大的调整。

我问了他几个问题：第一，你有没有统计过系统中现有的订单类型的使用情况？第二，你有没有了解过其他平台是否支持这种订单类型呢？产品经理一下子被我问住了。我对第一个问题的答案是，除了最基础的订单类型之外，其他的订单类型用得都很少，之前做的很多号称优化的订单类型，实际上没有几个人在用。第二个问题我的答案是，只有极少数平台支持类似的概念。换句话说，虽然我们想得很美，但教育用户的成本会非常高，为了这个可能存在的优点，对系统做大改造，实在是一件投资大回报小的事，不值得！

再回到我们的问题上，一旦决定了要做某个产品功能，首先应该回答的是如何搜集用户数据。对于前端产品，今天已经有了大量的服务，只要在代码里嵌入一段代码，收集数据就是小事一桩。前端产品还好，因为用户行为是比较一致的，买服务就好了，能生成标准的用户行为数据。对于后端的数据，虽然也有各种服务，但基本上提供的能力都是数据的采集和展示，一些所谓的标准能力只是 CPU、内存、JVM 之类基础设施的使用情况。对于应用来说，具体什么样的数据需要搜集，还需要团队自己进行设计。

说了这些，我其实想说的是，持续验证虽然是一个好的想法，但目前为止，还不如持续集成和持续交付这些已经有比较完整体系做支撑。想做到「持续」，就要做到自动化，想做到自动化，就要有标准化支撑，目前这个方面还是「八仙过海各显神通」的状态，没法上升到行业最佳实践的程度。其实道理上也很简单，从一无所有，到持续集成、再到持续交付，最后到持续验证，每过一关，就会有大多数团队掉队。所以，真正能达到持续交付的团队都少之又少，更别提要持续验证了。

问题 2：Selenium 和 Cucumber 的区别是什么？没有昵称同学提到：Selenium 跟 Cucumber 有区别吗？

这是一个经常有人搞混的问题。为了让不熟悉的人理解，我先讲一点背景。Selenium 是一个开源项目，它的定位是浏览器自动化，主要用于 Web 应用的测试。它最早是 Jason Huggins 在 2004 年开发出来的，用以解决 Web 前端测试难的问题。之所以取了 Selenium 这个名字，主要是用来讽刺其竞争对手 Mercury 公司开发的产品。我们知道，Mercury 是水银，而 Selenium 是硒，硒可以用来解水银的毒。又一个程序员的冷幽默！

Cucumber 的兴起伴随着 Ruby on Rails 的蓬勃发展，我们在之前的内容中提到过，Ruby on Rails 是一个改变了行业认知的 Web 开发框架。所以，Cucumber 最初主要就是用在给 Web 应用写测试上，而 Selenium 刚好是用来操作浏览器的，二者一拍即合。于是，你会在很多文章中看到，Cucumber 和 Selenium 几乎是同时出现的，这也是很多人对于二者有点傻傻分不清楚的缘由。

讲完了这些背景，结合我们之前讲的内容，你就不难理解了。Cucumber 提供的是一层业务描述框架，而它需要有自己对应的步骤实现，以便能够对被测系统进行操控；而 Selenium 就是在 Web 应用测试方面实现步骤定义的一个非常好的工具。

问题 3：IntelliJ IDEA 怎么学？hua168 同学提到：IDEA 怎么学呢？是用到什么功能再学？还是先看个大概，用到时再仔细看？

一个工具怎么学？我的经验就是去用。我没有专门学过 IntelliJ IDEA，只是不断地在使用它。遇到问题就去找相应的解决方案。如果说在 IDEA 上下过功夫，应该是在快捷键上。我最早写代码时的风格应该是鼠标与键盘齐飞，实话说，起初也没觉得怎么样。加入 ThoughtWorks 之后，看到很多人把快捷键运用得出神入化，那不是在写一行代码，而是在写一片代码。我当时有一种特别震惊的感觉。

我自以为在写代码上做得已经相当好了，然而，有人却在你很擅长的一件事上完全碾压了你，那一瞬间，我感觉自己这些年都白学了。这种感觉后来在看到别人能够小步重构时又一次产生了。看到差距之后，我唯一能做的，就是自己下来偷偷练习。幸好，无论是快捷键也好，重构也罢，都是可以单独练习的。花上一段时间就可以提高到一定的水平。后来，别人看我写代码时也会有类似的感觉，我会安慰他们说，不要紧，花点时间练习就好。

其实，也有一些辅助的方法可以帮助我们练习，比如，我们会给新员工发放 IntelliJ IDEA 的快捷键卡片，写代码休息之余，可以拿来看一下；再比如，IntelliJ IDEA 有一个插件叫 Key Promoter X，如果你用鼠标操作，它会给你提示，帮你记住快捷键。有一段时间，我已经练习到「看别人写代码，脑子里能够完全映射出他在按哪个键」的程度。写代码是个手艺活，要想打磨手艺，需要看到高手是怎么工作的，才不致于固步自封。如果你身边没有这样的人，不如到网上搜一些视频，看看高手在写代码时是怎么做的，这样才能找到差距，不断提高。

### 黑板墙

学习使用一个工具时，除了多练习之外，个人还有一个经验是，先明白这个工具涉及到的一些概念，比如 idea 的 module，gradle 的 source set 等，这样看帮助文档的时候，不至于不知所云，同时也方便从全局认识这个工具，只有这样，每一个功能才不是离散的，减少脑子里的混乱感。作者回复：很好的补充。2019-04-19

现在我准备在项目组实践持续集成，jenkins 环境搭建好了，我们的项目是 java+maven。但是自动化测试这个环节我不是很清楚怎么落地，我大概网上查了一下。我的理解是这样的：1）使用测试框架先写单元测试用例，例如 Junit。2）搭建 jenkins 环境，并安装 junit 相关插件。3）使用 jenkins 拉取代码，然后通过 junit 插件运行单元测试。4）最后打包部署。我这个理解对吗？作者回复：按照我在专栏中的介绍，单元测试应该在本地运行，在构建脚本里面配置好。你可以把持续集成和持续交付的几篇好好再读一遍，体会一下。2020-03-25

老师能分享一个你们发给新员工的 IDEA 快捷键卡片么？借鉴一下。作者回复：正方形的小卡片，正面是操作名称，比如提取方法，背面是快捷键，比如 option+command+M。2019-04-09

## 0411加餐你真的了解重构吗.md

重构是一个让人误解太多的概念，大家经常认为调整代码就是在做重构。重构，本质上就是一堆微操作。重构这个实践的核心，就是将调整代码的动作分解成一个一个的小动作，如果不能理解这一点，你就很难理解重构本身的价值。不过，对于我们专栏的读者而言，因为大家已经学过了「任务分解」模块，理解起这个概念，难度应该降低了很多。既然重构的核心也是分解，它就需要大量的锤炼。就像之前提到任务分解原则一样，我在重构上也下了很大的功夫做了专门的练习，才能让自己一小步一小步地去做。但一个有追求的软件工匠不就应该这样锤炼自己的基本功吗？如果今天的内容你只记住一件事，那请记住：锤炼你的重构技能。

Martin Fowler 《重构》第二版的中文版正式发布。在专栏里，我只是在谈 TDD 的时候提到了重构，并没有把它作为一个专门的话题来讲，于是，我决定给我的专栏读者加餐，专门谈谈重构，毕竟重构是几乎每个程序员都会用到的词汇。但你真的了解重构吗？

2『已下载书籍「2019030重构1-2Ed | 2019030Refactoring1-2Ed」』

1、每个程序员都要做的事。作为程序员，我们都希望自己的代码是完美的。但没有代码是完美的，因为只要你的代码还有生命力，一定会有新的需求进来，而新的需求常常是你在编写这段代码之初始料未及的。很多人直觉的选择是，顺着既有的代码结构继续写下去，这里添一个 if，那里加一个标记位，长此以往，代码便随时间腐坏了。如果用一个物理学术语描述这种现象，那就是「熵增」，这也就是大名鼎鼎的热力学第二定律。如果没有外部干预，系统会朝着越来越混乱的方向发展。对抗熵增的一个办法就是引入负熵，让系统变得更加有序。而在代码中引入负熵的过程就是「重构」。

调整代码这件事是程序员都会有的习惯，但把这件事做到比较系统，上升为「重构」这个值得推广的实践是从一个小圈子开始的，这个小圈子的核心就是我们在专栏里前面提到过的两位大师级程序员：Ward Cunningham 和 Kent Beck。而真正让这个概念走出小圈子，来到大众面前的，则是 Martin Fowler 在 1999 年写下那本软件行业的名著《重构：改善既有代码的设计》（Refactoring: Improving the Design of Existing Code）。Martin Fowler 的本事就在于他极强的阐述能力，很多名词经过他的定义就会成为行业的流行语（Buzzword），重构就是其中之一。重构这个说法可比「调整代码」听上去高级多了。时至今日，很多人都会把重构这个词挂在嘴边：「这个系统太乱了，需要重构一下。」但遗憾的是，很多程序员对重构的理解是错的。

2、重构是一种微操作。你理解的重构是什么呢？就以前面那句话为例：这个系统太乱了，需要重构一下。如果我们接着问，你打算怎么重构呢？一些人就会告诉你，他们打算另立门户，重新实现这套系统。对不起，你打算做的事叫重写（rewrite），而不是重构（refactoring）。

《重构》是一本畅销书，但以我的了解，很少有人真正读完它，因为 Martin Fowler 是按照两本书（Duplex Book）来写的，这是他常用写书的风格，前半部分是内容讲解，后半部分是手册。让这本书真正声名鹊起的就是前半部分，这部分写出了重构这件事的意义，而后半部分的重构手册很少有人会看完。很多人以为看了前半部分就懂了重构，所以，在他们看来，重构就是调整代码。调整代码的方法我有很多啊，重写也是其中之一。

如果真的花时间去看这本书的后半部分，你多半会觉得很无聊，因为每个重构手法都是非常细微的，比如，变量改名，提取方法等等。尤其是在今天，这些手法已经成了 IDE 中的菜单。估计这也是很多人就此把书放下，觉得重构不过如此的原因。所以，行业里流传着各种关于重构的误解，多半是没有理解这些重构手法的含义。

重构，本质上就是一个「微操作」的实践。如果你不能理解「微操作」的含义，自然是无法理解重构的真正含义，也就不能理解为什么说「大开大合」的重写并不在重构的范畴之内。我在《大师级程序员的工作秘笈》这篇文章中曾经给你介绍过「微操作」，每一步都很小，小到甚至在很多人眼里它都是微不足道的。重构，也属于微操作的行列，与我们介绍的任务分解结合起来，你就能很好地理解那些重构手法的含义了：你需要把做的代码调整分解成若干可以单独进行的「重构」小动作，然后，一步一步完成它。比如，服务类中有一个通用的方法，它并不适合在这个有业务含义的类里面，所以，我们打算把它挪到一个通用的类里面。你会怎么做呢？

大刀阔斧的做法一定是创建一个新的通用类，然后把这个方法复制过去，修复各种编译错误。而重构的手法就会把它做一个分解：1）添加一个新的通用类，用以放置这个方法；2）在业务类中，添加一个字段，其类型是新添加的通用类；3）搬移实例方法，将这个方法移动到新的类里面。

得益于现在的 IDE 能力的增强，最后一步，按下快捷键，它就可以帮我们完成搬移和修改各处调用的工作。在这个分解出来的步骤里，每一步都可以很快完成，而且，每做完一步都是可以停下来的，这才是微操作真正的含义。这是大刀阔斧做法做不到的，你修改编译错误的时候，你不知道自己需要修改多少地方，什么时候是一个头。当然，这是一个很简单的例子，大刀阔斧的改过去也无伤大雅。但事实上，很多稍有规模的修改，如果不能以重构的方式进行，常常很快就不知道自己改到哪了，这也是很多所谓「重写」项目面临的最大风险，一旦开始，不能停止。你现在理解了，重构不仅仅是一堆重构手法，更重要的是，你需要有的是「把调整代码的动作分解成一个个重构小动作」的能力。

3、重构地图。下面我准备给你提供一张关于重构的知识地图，帮你了解它与周边诸多知识之间的关系，辅助你更好地理解重构。学习重构，先要知道重构的定义。关于这点，Martin Fowler 给出了两个定义，一个名词和一个动词。1）重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。2）重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

之所以要了解重构的定义，因为重构的知识地图就是围绕着这个定义展开的。首先，我们要对软件的内部结构进行调整，第一个要回答的问题是，我们为什么要调整。Martin Fowler 对于这个问题的回答是：代码的坏味道。代码的坏味道，在我看来，是这本书给行业最重要的启发。很多人常常是无法嗅到代码坏味道的，因此，他们会任由代码腐坏，那种随便添加 if 或标记的做法就是嗅不出坏味道的表现。

我经常给人推荐《重构》这本书，但我也常常会补上一句，如果你实在没有时间，就去看它的第三章《代码的坏味道》。顺便说一下，对比两版的《重构》，你会发现它们在坏味道的定义上有所差异，在新版的《重构》中，可变数据（Mutable Data）、循环语句（Loops）都定义成了坏味道，如果你不曾关注近些年的编程发展趋势，这样的定义着实会让人为之震惊。但只要了解了函数式编程的趋势，就不难理解它们的由来了。换句话说，函数式编程已然成为时代的主流。如果你还不了解，赶紧去了解。

我们接着回到重构的定义上，重构是要不改变软件的可观察行为。我们怎么知道是不是改变了可观察行为，最常见的方式就是测试。关于测试，我在「任务分解」模块已经讲了很多，你现在已经可以更好地理解重构、TDD 这些概念是怎样相互配合一起的了吧！再来，重构是要提高可理解性，那重构到什么程度算是一个头呢？当年重构讨论最火热的时候，有人给出了一个答案：重构成模式（Refactoring to Patterns）。当然，这也是一本书的名字，有兴趣的话，可以找来读一读。

我个人有个猜想，如果这个讨论可以延续到 2008 年，等到 Robert Martin 的《Clean Code》出版，也许有人会提「重构成 Clean Code」也未可知。所以，无论是设计模式，亦或是 Clean Code，都是推荐你去学习的。至此，我把重构的周边知识整理了一番，让你在学习重构时，可以做到不仅仅是只见树木，也可看见森林。当然，重构的具体知识，还是去看 Martin Fowler  的书吧！

2『已下载书籍「2019032代码整洁之道 | 2019032Clean-Code」和「2020110重构与模式 | 2020110Refactoring-to-Patterns」』

### 黑板墙

函数式编程有什么推荐书籍吗？作者回复：有几本可以了解一下，《计算机程序的解释与构造》（Structure and Interpretation of Computer Programs，SICP），还有《Haskell 趣学指南》（Learn You a Haskell for Great Good!），《函数式编程思维》（Functional Thinking）。

重构不仅是愿景（名词），也不仅是行为（动词），还应该成为程序员必备的习惯和工作方式。但要成为习惯，甚至是深入骨髓的那种，是需要有积极意识和大量联系的。有程序员会说，先把功能实现了，后面我再去重构，但后来的情况往往是不重构，或是债务过多重构代价太大，原因也大多是之前课程中提到的诸如任务分解不到位，微操作缺失，缺乏合理有效的单元测试等等，所以程序员的自我修养也是要体系化的，所谓功到自然成。与诸君共勉之！

### 逻辑脉络

1、请谨慎地将工作自动化。

7、构建好你的领域模型。服务端三层架构的来龙去脉；分层架构实际是一种设计上的分解，将不同的内容放在不同的地方，降低软件开发和维护的成本。分层，更关键的是，提供抽象。这种分层抽象在计算机领域无处不在，无论是编程语言，还是网络协议，都体现着分层抽象的价值。有了分层抽象，人们才能更好地在抽象的基础上构建更复杂的东西；应该把精力重点放在构建自己的领域模型上，因为它才是工作最核心、不易变的东西。

10、锤炼你的重构技能。重构，本质上就是一堆微操作。重构这个实践的核心，就是将调整代码的动作分解成一个一个的小动作，如果不能理解这一点，你就很难理解重构本身的价值。既然重构的核心也是分解，它就需要大量的锤炼。就像之前提到任务分解原则一样，我在重构上也下了很大的功夫做了专门的练习，才能让自己一小步一小步地去做。

将你的工作过程自动化。

——《30 | 一个好的项目自动化应该是什么样子的？》

有体系地学习运维知识。

——《31 | 程序员怎么学习运维知识？》

将部署纳入开发的考量。

——《32 | 持续交付：有持续集成就够了吗？》

将验收测试自动化。

——《33 | 如何做好验收测试？》

把函数写短。

——《34 | 你的代码是怎么变混乱的？》

用简单技术解决问题，直到问题变复杂。

——《36 | 为什么总有人觉得 5 万块钱可以做一个淘宝？》

学习领域驱动设计。

——《37 | 先做好 DDD 再谈微服务吧，那只是一种部署形式》

## 0407总是在说MVC分层架构但你真的理解分层吗.md

构建好你的领域模型。从最常见的服务端三层架构入手，给你讲了它们的来龙去脉。分层架构实际是一种设计上的分解，将不同的内容放在不同的地方，降低软件开发和维护的成本。分层，更关键的是，提供抽象。这种分层抽象在计算机领域无处不在，无论是编程语言，还是网络协议，都体现着分层抽象的价值。有了分层抽象，人们才能更好地在抽象的基础上构建更复杂的东西。在日常工作中，我们应该把精力重点放在构建自己的领域模型上，因为它才是工作最核心、不易变的东西。

作为程序员，你一定听说过分层，比如，最常见的 Java 服务端应用的三层结构，在《15 | 一起练习：手把手带你分解任务》中，我曾提到过：1）数据访问层，按照传统的说法，叫 DAO（Data Access Object，数据访问对象），按照领域驱动开发的术语，称之为 Repository；2）服务层，提供应用服务；3）资源层，提供对外访问的资源，采用传统做法就是 Controller。这几乎成为了写 Java 服务的标准模式。但不知道你有没有想过，为什么要分层呢？

### 7.1 设计上的分解

其实，分层并不是一个特别符合直觉的做法，符合直觉的做法应该是直接写在一起。在编程框架还不是特别流行的时候，人们就是直接把页面和逻辑混在一起写的。如果你有机会看看写得不算理想的 PHP 程序，这种现象还是大概率会出现的。即便像 Java 这个如此重视架构的社区，分层也是很久之后才出现的，早期的 JSP 和 PHP 并没有什么本质区别。

那为什么要分层呢？原因很简单，当代码复杂到一定程度，人们维护代码的难度就急剧上升。一旦出现任何问题，在所有一切都混在一起的代码中定位问题，本质上就是一个「大海捞针」的活。前面讲任务分解的时候，我不断在强调的观点就是，人们擅长解决的是小问题，大问题怎么办？拆小了就好。分层架构，实际上，就是一种在设计上的分解。

回到前面所说的三层架构，这是行业中最早普及的一种架构模式，最开始是 MVC，也就是 Model、View 和 Controller。MVC 的概念起源于 GUI （Graphical User Interface，图形用户界面）编程，人们希望将图形界面上展示的部分（View）与 UI 的数据模型（Model）分开，它们之间的联动由 Controller 负责。这个概念在 GUI 编程中是没有问题的，但也仅限于在与 UI 有交互的部分。很多人误以为这也适合服务端程序，他们就把模型部分误解成了数据库里的模型，甚至把它理解成数据库访问。于是，你会看到有人在 Controller 里访问数据库。

不知道你是不是了解 Ruby on Rails，这是当年改变了行业认知的一个 Web 开发框架，带来很多颠覆性的做法。它采用的就是这样一种编程模型。当年写 Rails 程序的时候我发现，当业务复杂到了一定规模，代码就开始难以维护了。我想了好久，终于发现，在 Rails 的常规做法中少了服务层（Service）的设计。这个问题在 Java 领域，爆发得要比 Rails 里早，因为 Ruby 语言的优越性，Rails 实现的数据访问非常优雅。正是因为 Rails 的数据访问实在太容易了，很多服务实际上写到 Model 层里。在代码规模不大时，代码看上去是不复杂的，甚至还有些优雅。

1『 laravel 的基本框架就是参考 Ruby on Rails 的，那么 laravel 应该也没有服务层。』

而那时的 Java 可是要一行一行地写数据访问，所以，代码不太可能放在 Model 层，而放在 Controller 里也会让代码变复杂，于是，为业务逻辑而生的 Service 层就呼之欲出了。至此，常见的 Java 服务端开发的基础就全部成型了，只不过，由于后来 REST 服务的兴起，资源层替代了 Controller 层。到这里，我给你讲了常见的 Java 服务三层架构的来龙去脉。但实际上，在软件开发中，分层几乎是无处不在的，因为好的分层往往需要有好的抽象。

### 7.2 无处不在的分层

作为程序员，我们几乎每天都在与分层打交道。比如说，程序员都对网络编程模型很熟悉，无论是 ISO 的七层还是 TCP/IP 的五层。但不知道你有没有发现，虽然学习的时候，你要学习网络有那么多层，但在使用的时候，大多数情况下，你只要了解最上面的那层，比如，HTTP。

很多人对底层的协议的理解几乎就停留在「学过」的水平上，因为在大多数情况下，除非你要写协议栈，不然你很难用得到。即便偶尔用到，90% 的问题靠搜索引擎就解决了，你也很少有动力去系统学习。之所以你可以这么放心大胆地「忽略」底层协议，一个关键点就在于，网络模型的分层架构实现得太好了，好到你作为上层的使用者几乎可以忽略底层。而这正是分层真正的价值：构建一个良好的抽象。这种构建良好的抽象在软件开发中随处可见，比如，你作为一个程序员，每天写着在 CPU 上运行的代码，但你读过指令集吗？你之所以可以不去了解，是因为已经有编译器做好了分层，让你可以只用它们构建出的「抽象」—— 编程语言去思考问题。比如，每天写着 Java 程序的程序员，你知道 Java 程序是如何管理内存的吗？这可是令很多 C/C++ 程序员寝食难安的问题，而你之所以不用关心这些，正是托了 Java 这种「抽象」的福。对了，你甚至可能没有注意到编程语言也是一种抽象。

### 7.3 有抽象有发展

只有构建起抽象，人们才能在此基础上做出更复杂的东西。如果今天的游戏依然是面向显示屏的像素编程，那么，精彩的游戏视觉效果就只能由极少数真正的高手来开发。我们今天的大部分游戏应该依然停留在《超级玛丽》的水准。同样，近些年前端领域风起云涌，但你是否想过，为什么 Web 的概念早就出现了，但前端作为一个专门的职位，真正的蓬勃发展却是最近十年的事？2009 年，Ryan Dahl 发布了 Node.js，人们才真正认识到，原来 JavaScript 不仅仅可以用于浏览器，还能做服务器开发。于是，JavaScript 社区大发展，各种在其他社区已经很流行的工具终于在 JavaScript 世界中发展了起来。正是有了这些工具的支持，人们才能用 JavaScript 构建更复杂的工程，前端领域才能得到了极大的发展。如今，JavaScript 已经发展成唯一一门全平台语言，当然，发展最好的依然是在它的大本营：前端领域。前端程序员才有了今天幸福的烦恼：各种前端框架层出不穷。在这里，Node.js 的出现让 JavaScript 成为了一个更好的抽象。

### 7.4 构建你的抽象

理解了分层实际上是在构建抽象，你或许会关心，我该怎么把它运用在自己的工作中。构建抽象，最核心的一步是构建出你的核心模型。什么是核心模型呢？就是表达你业务的那部分代码，换句话说，别的东西都可以变，但这部分不能变。这么说可能还是有点抽象，我们回到前面的三层架构。

在前面介绍三层架构的演变时，提到了一个变迁：REST 服务的兴起，让 Controller 逐渐退出了历史舞台，资源层取而代之。换句话说，访问服务的方式可能会变。放到计算机编程的发展中，这种趋势就更明显了，从命令行到网络，从 CS（Client-Server） 到 BS（Browser-Server），从浏览器到移动端。所以，怎么访问不应该是你关注的核心。同样，关系型数据库也不是你关注的核心，它只是今天的主流而已。从前用文件，今天还有各种 NoSQL。

如此说来，三层架构中的两层重要性都不是那么高，那重要的是什么？答案便呼之欲出了，没错，就是剩下的部分，我们习惯上称之为服务层，但这个名字其实不能很好地反映它的作用，更恰当的说法应该可以叫领域模型（Domain Model）。它便是我们的核心模型，也是我们在做软件设计时，真正应该着力的地方。为什么叫「服务层」不是一个好的说法呢？这里会遗漏领域模型中一个重要的组成部分：领域对象。

很多人理解领域对象有一个严重的误区，认为领域对象属于数据层。数据存储只是领域对象的一种用途，它更重要的用途还是用在各种领域服务中。由此还能引出另一个常见的设计错误，领域对象中只包含数据访问，也就是常说的 getter 和 setter，而没有任何逻辑。如果只用于数据存储，只有数据访问就够了，但如果是领域对象，就应该有业务逻辑。比如，给一个用户修改密码，用户这个对象上应该有一个 changePassword 方法，而不是每次去 setPassword。严格地说，领域对象和存储对象应该是两个类，只不过它俩实在太像了，很多人经常使用一个类，这还是个小问题。但很多人却把这种内部方案用到了外部，比如，第三方集成。

为数不少的团队都在自己的业务代码中直接使用了第三方代码中的对象，第三方的任何修改都会让你的代码跟着改，你的团队就只能疲于奔命。解决这个问题最好的办法就是把它们分开，你的领域层只依赖于你的领域对象，第三方发过来的内容先做一次转换，转换成你的领域对象。这种做法称为防腐层。当我们把领域模型看成了整个设计的核心，看待其他层的视角也会随之转变，它们只不过是适配到不同地方的一种方式而已，而这种理念的推广，就是一些人在说的六边形架构。

怎么设计好领域模型是一个庞大的主题，推荐你去了解一下领域驱动设计（Domain Driven Design，DDD），这个话题我们后面还会再次提到。讨论其实还可以继续延伸下去，已经构建好的领域模型怎么更好地提供给其他部分使用呢？一个好的做法是封装成领域特定语言（Domain Specific Language，DSL）。当然，这也是一个庞大的话题，就不继续展开了。

### 黑板墙

分层或模型，实质是因为人的认知能力有限不得已而为之的。学习计算机，我们都知道晶体管，即便早就忘了它的原理。实际上晶体管涉及非常深奥的物理学知识，这是绝大多数人一辈子都不需要了解的物理学。抛开复杂艰深的物理学，晶体管的本质却很简单，它就是一个包含通和不通两个状态的开关，这就是它构建的模型。在开关的模型基础之上，信息论的创立者香农用一篇硕士论文构建了逻辑门这层。他证明了可以用最简单的开关，实现所有逻辑运算。逻辑运算层次之上，就是我们所知道的 CPU 模型。再往上，就是我们所熟悉的信息世界。

best practices 其实在不同时期有不同的理解，有时候甚至变化很大，我自己也有迷惑的时候。我是做 ror 出身的，rails 就是标准的 MVC，再加上一个 helper 目录；初入行时候接触的项目，controller 都很臃肿，后来，提倡的是 thin controller, fat model, 于是大家又把逻辑搬到 model 里面；于是 model 又变得非常臃肿，里面包括了很多业务逻辑，耦合太高，写起测试来非常痛苦；另外，原本 helper 只应该放关于 view 的 method，却很快变成了垃圾桶，很多不是 view 相关的方法都扔在了 helper 目录下，甚至很多 controller 要 include 其他 controller 对应的 helper，只是因为那里定义了一个可以用到的方法。再后来，有了 presenter 的概念，helper 目录基本就不用了；每个 controller 都有对应都 presenter，再有，就是建立了 service 的目录，把业务逻辑从 model 里面抽离处理；这样的结构稍微清洁了一点，测试也好写了很多。但是在我看来，我们项目 presenter/services 这种分层没有什么标准，有些同事还是把这种分层当作万能垃圾桶，什么都建一个，甚至业务 / 运算都扔在 presenter 里面；services 的分层也是一个问题，很多只是根据 model 的来分，而不是业务； 最近有看了一下 elixir 对应的 phoenix ，它引入了 context 的概念，更偏重于业务划分，我感觉这是一个比 rails 更合理的分层。

老师提到的直接把第三方类库的字段直接使用，导致 bug 层出不穷，这个真的是深受其害，线上程序莫名 bug，原来是第三方修改或者擅自把字段等出现问题，改来改去，最后还是用类似老师提出那种转化本地对象再使用，最后做了类似一个防腐层那种解决问题。实际才出的坑总结到这么个东西，就是类似老师提出的模型概念。作者回复：道理很简单，痛过才知道。

请问老师，在 jdk 的集合框架中常常会在实现类内部维护一个内部类，比如 HashMap 内部有个 Node 内部类，这算领域对象么？作者回复：在通常的讨论中，这是不算的。

学了 REST 和 DDD，感觉两者有相通的地方：两者都以数据（一个是资源，另外一个是领域对象）为中心，并制定一套标准的数据操作（一个是 HTTP Verb，另外一个我项目主要用 JPA 这一套）；而核心是业务建模。

2『这个有些感触，因为学习做 api 时有接触过 REST 模型，REST 和 DDD 的类比做一张计算机卡片。』

我将界面逻辑层（界面数据显示）、业务逻辑层（具体业务逻辑功能实现）分出来后，但像支持这些业务的一些服务，比如通讯服务，数据缓存服务，这些算是工具，还是说也可以分为一些单独的层，还有像界面显示的数据我需要给界面单独提供一些界面显示的数据结构，还是直接使用逻辑层里面的数据结构，还是说这些数据结构单独拆分出来也可以作为一层。作者回复：看六边形架构的图，通信服务属于六边形架构的适配器。

对项目中变化代码和稳定代码的拆分。按特性归类成变化层和稳定层，中间用门面或适配器对接。针对变化层提炼出抽象层用装饰者模式或抽象工厂实现多态。作者回复：学习 DDD，建立模型概念，你就不纠结于这里的设计模式了。

分层是为了更好的抽象，区分出程序中的不变点与与易变点，集中精力优化抽象不变点，以便更好的复用不变点逻辑。尽可能的快速添加和修改易变逻辑响应业务变更需求。个人认为：分层设计有点像代码设计模式里的模板设计模式。但分层设计更像是代码组织的模板，功能和交互层面的分组的模板。分层设计不但做到代码的分层也促进了分工合作，从而达到快速，简单，高效开发的目的。

文章有些地方看不懂，不太懂领域对象什么的。作者回复：核心模型，就是当你的软件去掉它，就不是这个软件了。比如，如果没有商品和订单，电商就玩不转了，但如果它不支持高并发，其实没什么影响。

很多技术都是吧，都是为了把一些通用的基础的功能抽象出来，Robot 框架也是，提供了很多实现基础功能的类库，通过这些基础的关键字可以组成新的关键字，再由关键字组成更复杂的关键字，我们只用关心怎么实现功能，而这些关键字怎么调用，编译，log 和结果怎么一层层展示，这些都由框架实现了。

分层架构设计的目的：1）提炼抽象，构建好领域模型。2）降低软件开发和维护成本。3）扩展性更好。

跟过一段时间微软的 silverlight，一开始听说是 wpf 的子集，后来又有人辟谣说除了使用 xaml 等形似之处外差别很大的。自己也看过两者的源码，就抽象能力和程度看还是正宗 wpf 强大，虽然不是业务框架，但从开发工具角度来看，它的基于自身定位及领域的体系设计还是值得称道的。曾经有一段时间里 java 和.net 相互 diss 的厉害，现在看来在道的层面是可以和谐共处的，只是术上各有各的呈现罢了。

微服务中的数据访问层，有可能跟访问数据库一点关系都没有，而只是一层调用 http 请求去访问其他微服务的封装，但它的原理其实跟传统的分层结构应该是一致的。

产品，开发，测试，运维，运营等岗位也属于分层，不同技术栈的人，组成完备技术体系。

## 0401懒惰应该是所有程序员的骄傲.md

Perl 语言的发明人 Larry Wall 曾经说过，优秀程序员应该有三大美德：懒惰、急躁和傲慢（Laziness, Impatience and hubris）。想要成为一个优秀的程序员，就要让机器为自己很好地工作，而这需要对自动化有着很好地理解。我们学习自动化，先要知道哪些东西不要自动化，尽最大的努力不做浪费时间的事。一方面，我们要从需求上规避那些没必要做的事；另一方面，我们也从自身防止 NIH 综合症（Not Invented Here Syndrome），争取做一个懒惰的程序员。对于要自动化的事，我们需要反思一下，在为别人打造自动化工具的同时，我们自己的工作过程有没有很好地自动化。而如果我们想拥有打造良好的自动化工具，我们需要对软件设计有着充分地理解。如果今天的内容你只能记住一件事，那请记住：请谨慎地将工作自动化。

经过前面几个模块的学习，我们的专栏终于进入到程序员看上去最熟悉的一个主题：自动化。每每提及自动化，我就会想起 Perl 语言的发明人 Larry Wall 一个经典叙述：优秀程序员应该有三大美德：懒惰、急躁和傲慢（Laziness, Impatience and hubris）。

有人甚至为此专门打造了一个三大美德的网站，阐释这个初看起来匪夷所思的说法。1）懒惰，是一种品质，它会使你花很大力气去规避过度的精力消耗，敦促你写出节省体力的程序，别人也能很好地利用，你还会为此写出完善的文档，以免别人来问问题。2）急躁，是计算机偷懒时，你会感到的一种愤怒。它会促使你写出超越预期的程序，而不只是响应需求。3）傲慢，极度自信，写出（或维护）别人挑不出毛病的程序。

不知道你是否感受到，程序员独有的幽默和透露出的那种骄傲：我做的东西就应该是最好的。之所以要从 Larry Wall 的这段话开启「自动化」这个模块，因为只要一说到自动化，我就会情不自禁地联想到「偷懒」这个词。是的，我们程序员的工作，本质上就是打造各种自动化的工具，让人们从各种繁复的工作中解脱出来，让人有机会「偷懒」。不过，我也知道，从机器那里偷来的「懒」很快就被更多的工作填满了。但 Larry Wall 的这段话却可以鼓励我们不断地打造出更好的工具。

作为程序员，你当然知道「自动化」这件事的价值，在日常工作中，也实实在在地践行着打造自动化工具的任务，但很多人对自动化的理解可能有些单薄。今天，我就从一个你可能会忽略的主题开始讨论：不要自动化。

### 1.1 不要自动化

我先给你讲一个让我印象深刻的「不自动化」的例子。之前在 ThoughtWorks 工作时，我们有一项工作是，帮助其他公司启动一些新产品。有一次，我的两个同事被一个公司请去启动一个视频网站的项目。那时候还不像如今的市场，已经由几大视频网站瓜分完毕，当时不少公司看到了视频网站的苗头，觉得自己有机会。这个来请我们的公司也不例外，觉得自己也能分一杯羹。

两个星期之后，我的两个同事回来了。我们饶有兴趣地去问项目的进展，因为项目启动之后，通常会有后续的开发合作，但结果令我们很意外，这个项目停止了。「出了什么状况吗？」我们问。「是我们建议用户停掉这个项目的。」他们回答到。

我们「恨恨地」问他们为什么丢掉了一个这么重要的机会。这两个同事的回答也很直白，他们结合着客户的想法算了一笔账：这个项目需要大量的资金投入，投入规模之大，是超出客户想象的，按照现有的规划投入，这个项目肯定会亏本。要么重新规划，要么取消这个项目。客户认真研究了一番，最终决定取消项目。

这件事大约发生在 10 年前，今天我们都看到各大视频网站在烧钱上的投入，以那个公司的实力，想要参加这场比拼，确实还差太多。这件事之所以给我留下深刻印象，因为它是我职业生涯中见到的第一个通过「主动取消项目」获取项目成功的案例。

或许你不能理解我这里所说的「项目成功」。在我看来，做有价值的事是重要的，这里面的有价值，不仅仅是「做」了什么，通过「不做」节省时间和成本也是有价值的。我的两个同事阻止了客户的浪费，所以，我将这个项目视为成功。

对于开发来说，也遵循同样的道理。程序员这个群体技术能力实在太强，做一个技术方案简直是太符合直觉的做法，我们就是忠实地把一个个需求做出来，把「全世界」都自动化了。但事实上，这个世界太多的浪费就是做了不该做的东西。在我们的专栏里，我反复地说，我们要多问问题，目的就是为了不做那些不该做的事。

### 1.2 小心 NIH 综合症

你可以从需求的角度判断哪些工作是可以不做的，但我们也要防止程序员自己「加戏」，我再给你讲一个技术人员普遍存在的问题：NIH 综合症（Not Invented Here Syndrome）。

NIH 是什么意思？就是有人特别看不上别人做的东西，非要自己做出一套来，原因只是因为那个东西不是我做的，可能存在各种问题。这种现象在开源之前尤为流行，很多公司都要做自己的中间件，做自己的数据库封装。虽然很多公司因此有了自己特色的框架，但是因为水平有限，做出来的东西通常极为难用，很多人一边骂，一边还要继续在上面开发。

开源运动兴起之后，我以为这种现象会好一些，但事实证明，我想多了。比如，这种乱象在前端领域也出现了，各种各样的框架，让很多前端程序员哭诉，实在学不动了。再比如，我曾经面试过一个接触 Go 比较早的程序员，他就是恨不得把所有框架都自己写。因为他学 Go 的时候，确实框架比较少，但问题是，如今的 Go 已经不是他学习时的那个 Go 了，现在各种框架已经很丰富了，不需要什么都自己做。当时我问他，如果有一天你离开了，公司怎么办呢？实际上，他从来没考虑过这个问题。

说了这么多，无非就是想说明一件事，写代码之前，先问问自己真的要做吗？能不做就不做，直到你有了足够的理由去做。对应到 Larry Wall 的说法，你要懒惰，花大力气去规避精力消耗。

### 1.3 做好自动化

说完了不要自动化的部分，再来说说要自动化的部分。我还是先从你可能会忽略的问题入手，你的日常工作是给别人打造自动化，但你自己的工作够自动化吗？还是问一个更具体的问题吧！如果你写的代码要上线，会经过怎样的过程？

我先给你看一个极其糟糕的例子。刚开始工作不久，我有一次出差到客户现场。临近下班时，我发现了程序的一个 Bug。在那个年代，我们的程序是按照官方推荐做法编写的 EJB（Enterprise JavaBean），今天很多年轻的程序员可能不了解了，它只有部署到应用服务器才能运行。

我的解决方案就是加上一些打印语句，然后部署到应用服务器上，看输出的结果，再加上另外一些语句，再部署，如此往复。那时我们完全是手工打包上传，每次至少要十几分钟。最终，定位到了问题，只修改了一行代码。但几个小时的时间就这样被无谓的消耗了。

那之后，我花了很长时间研究怎么做自动化的增量部署，最终让这个过程简化了下来。但这件事对我的影响很大，这是我第一次认识到一个部署过程可能对开发造成的影响，也让我对自动化在开发过程内的应用有了属于自己的认识。相比于我刚开始工作那会。现在在工具层面做类似的事已经容易很多了，在后面的内容中，我会结合着具体的场景介绍一下现在的最佳实践。

### 1.4 你要懂得软件设计

最后，我们再来说说我们的本职工作，给别人打造自动化工具中需要的能力：软件设计。

软件设计，是很多人既熟悉又陌生的一个词，说熟悉，很多人都知道，做软件要设计，还能顺嘴说出几个设计模式的名字；说陌生，是因为在我的职业生涯中，遇到真正懂软件设计的程序员少之又少。大多数人都是混淆了设计和实现。

举个例子。有一次，我要在两个系统之间做一个连接器，让上游系统向下游系统发消息，或许你一听就知道了，这里需要的是一个消息队列。但实际上，我们需要的能力要比消息队列更丰富一些，比如，要将重复的消息去除。一个同事给我推荐了 Kafka 当作这个连接器的基础，我欣然地接受了。不过，在后续设计的讨论中，我们就经常出现话语体系的分歧。我说，这个连接器要有怎样的能力，他会说 Kafka 能够如何如何。究其根因，我在讨论的是设计，而他说的是实现，所以，我们两个很难把问题讨论到一起。

为什么我会如此看重设计呢？在软件开发中，其它的东西都是易变的，唯有设计的可变性是你可以控制的。同样以前面的讨论为例，尽管 Kafka 在当下比较火热，但是我不敢保证 Kafka 在未来不会被我换掉。因为就在几年前，消息队列还是传统中间件的强项，现在也渐渐被人淡忘了。

我不想让我的设计随着某一个技术选型而不断摇摆。如果工作许多年，知识体系只能靠各种新框架新工具支撑，我们做程序员就只剩下疲于奔命了。不懂软件设计，只专注各种工具，其结果一定是被新技术遗弃，这也是很多人经常抱怨 IT 行业变化快的重要原因。

回到 Larry Wall 的说法上，你要想写出一个别人挑不出毛病的程序，你先要懂得软件设计。幸运的是，软件设计这些年的变化真不大，掌握了软件设计再来看很多框架和工具，学习起来就会容易很多。在这个模块的后半部分，我会与你探讨软件设计的话题，降低自己给自己挖坑的概率。

### 黑板墙

你现在是怎样理解自动化的呢？

从老师这学到一个很喜欢的思想。有价值的事并不局限性于事情本身。做自动化很重要，写代码很重要。但根据根据现有情况判断是否需要自动化，是否需要写代码也很重要。有的放矢，任务分解。权衡跟设计是件很艺术的事情，令人着迷。作者回复：以现在大家的努力程度，少做点事是需要锻炼的技能。2019-03-18

最近确实感觉追随快速迭代技术追得自己挺迷茫的，也一直在思考到我究竟缺了什么。之前偶然看了软件工程相关的，才意识到算法、分析、设计等基础重要性，看到郑老师这一篇，让我更加坚信了这一点！作者回复：追变的东西，永远追不完，追不变的东西，就那么点东西。2019-03-20

面试的时候，常常听到应聘者提起换工作的原因之一是手头任务重复性高，都是增删查改，代码粘帖复制。我就会问，你有没有想过把工作变得不那么重复，不要粘帖复制代码。有不少人就没什么话说了。其实还是有很多可做的。比如自动生成增删查改的管理功能和页面，集成好缓存、搜索等服务。懒惰真的是程序员的优秀品质，只是有些人理解成思想上的懒惰了。作者回复：动手的人多，动脑的人少。2019-03-18

做值得做的事确实很重要，否则你忙活半天项目失败了，可能你也能赚一部分钱，或者技术得到了提升，但对客户却是损失，明知不可为还要去干就是不职业了。另外就是变中求不变，注重软件设计很重要，就像有些公司面试只考算法，根本不关注你用什么框架和语言，因为技术很多都是想通的，所有的 Orm 框架不能说完全相同，但设计思想总是想通的吧。可是国内有些单位在筛选人简历时就是看你用过的框架和语言，我招的是 java, 你简历中项目用的 c#, 所以不合适直接过滤掉。其实一个合格的程序员又怎么会被语言和框架固化住呢，只不过是不同的场景选择最适合的就是最好的。2019-03-27

郑老师提到的那个问题，其实还有另外种解决方案：远程调试。当然这也无法避免部署的活，但是可以大幅减少部署的次数。有次出现了开发环境无法复现，只有测试环境才能复现的问题，就是通过远程调试解决的，当初使用的中间件是 WebSphere（估计很多童鞋都不知道了）。作者回复：远程调试，是一种重量级的工具，能不用就不用。2019-03-18

## 0402一个好的项目自动化应该是什么样子的.md

今天我们通过一个具体的例子展示了一个最基本的项目自动化，包括了：1）生成 IDE 工程；2）编译；3）打包；4）运行测试；5）代码风格检查；6）测试覆盖率；7）数据库迁移；8）运行应用。但这就是自动化的全部了吗？显然不是，我这里给出的只是一个最基本的示例。实际上，几乎每个重复的工作或是繁琐的工作，都应该自动化。我们不应该把时间和精力浪费在那些机器可以很好地替我们完成的工作上。今天的基础设施已经让我们的自动化工作变得比以往容易了很多，比如，可执行 JAR 包就比从前部署到应用服务器上简化太多了。Gradle 也让订制构建脚本的难度降低了很多。这里提到的项目自动化也是持续集成的基础，在持续集成服务上执行的命令，就应该是我们在构建脚本中写好的，比如：./gradlew build。

2011 年，我在 InfoQ 上发表了一篇《软件开发地基》，讨论的就是一个项目的构建脚本应该是什么样子。虽然其中用到的工具今天已经不再流行，但一些基础内容今天看来，依然是有效的。如果有兴趣，你也可以看一下。如果今天的内容你只能记住一件事，那请记住：将你的工作过程自动化。

2『[软件开发地基 - InfoQ](https://www.infoq.cn/article/zy-software-development-foundation)，去把他博客里的文章都消化一下。』

进入自动化这个模块，我准备从程序员的日常工作开始。介绍「迭代 0」时，我提到构建脚本是项目准备的一个重要组成部分，但在那一讲中，我并没有具体说构建脚本长成什么样。今天，我们以一个典型的 Java REST 服务为例，介绍一下最基本的构建脚本应该做到什么样子。这里我采用的 Java 技术中最为常见的 Spring Boot 作为基础框架，而构建工具，我选择了 Gradle（[Gradle Build Tool](https://gradle.org/)）。

估计很多 Java 程序员心中的第一个问题就是，为什么用 Gradle，而不是 Maven？Maven 明明是 Java 社区最经典的构建工具。答案是因为 Maven 不够灵活。你可以回想一下，你有多少次用 Maven 实现过特定需求？估计大部分人的答案都是没有。随着持续集成、持续交付的兴起，构建脚本的订制能力会变得越来越重要，Maven 则表现得力有不逮。其实，早在 2012 年，ThoughtWorks 技术雷达就将 Maven 放到了 暂缓（HOLD）里面，也就是说，能不用就不用。

为了配合这次的讲解，我写了一个 Demo，放在了 Github 上。它的功能非常简单：1）通过向 /users POST 一个请求，实现用户注册；2）访问 /users，查看已注册的用户。如果方便的话，你最好把这个项目 clone 下来，以便参考。这里我主要是讲解自动化要做成什么样子，如果你想了解具体是怎么实现的，可以参考 Demo 里的代码。

### 2.1 基础准备

先把这个项目从 Github 上 clone 下来。

```
git clone  https://github.com/dreamhead/geektime-zero.git
```

然后，进入到项目所在的目录中。

```
cd geektime-zero
```

当你准备就绪，我们就开始进一步了解这个项目。一般我们了解一个项目，都会用用一个 IDE 打开这个项目，这里我推荐使用 IntelliJ  IDEA，这是目前行业中最好的 Java IDE。自从它的社区版免费之后，它就成为了我向他人推荐的首选。

我知道，开发工具是除了程序设计语言之外，另外一个容易引起「宗教战争」的话题，如果你喜欢其他的 IDE，那就用你最喜欢的 IDE 打开好了，只不过，需要调整一下构建脚本中的配置。怎么打开这个项目呢？我们先用 Gradle 命令生成一个 IDEA 工程。

```
./gradlew idea
```

这个命令会生成一个.ipr 文件，这就是 IDEA 的工程文件，用 IDEA 打开即可。这里有两点需要说明一下。1）这里用的 gradlew，它是 Gradle 命令的一个封装，它会自动下载一个构建这个项目所需的 Gradle，重点是通过这个命令锁定了 Gradle 的版本，避免因为构建脚本的差异，造成「你成功我失败」的情况。2）IDE 工程是生成的。很多人直觉的做法是用 IDE 直接打开。有一些团队的项目里有好多个构建文件，究竟用哪个打开，不去问人是根本不知道的，这对项目的新人是非常不友好的。

生成的做法与前面 Gradle 封装是类似的，它可以避免因为本地安装不同版本 IDE 造成各种问题。另外，因为 IDE 的工程是生成的，如果项目里一旦增加了新的程序库依赖，你只需重新执行一次上面的命令就好了，现在的 IDE 都有很好的自动加载能力，当它检测到工程文件的变化，就会重新加载。好，现在你可以用 IDE 打开，我们就可以进一步了解这个项目了。

### 2.2 初见项目

我们先来了解一点 Gradle 的配置文件，它也是我们做项目自动化的重点。1）build.gradle，它是 Gradle 的配置文件。因为 Gradle 是由 Groovy 编写而成，build.gradle 本质上就是一个 Groovy 的脚本，其中的配置就是 Groovy 代码，这也是 Gradle 能够灵活订制的基础。2）settings.gradle，这也是一个 Gradle 配置文件，用以支持多模块。如果说一个项目的每个模块都可以有一个 build.gradle，那整个项目只有一个 settings.gradle。

在 Gradle 里，许多能力都是以插件的形式提供的，比如，前面生成 IDEA 工程就是配置文件中的一句话。

```
apply plugin: 'idea'
```

所以，如果你是其他 IDE 的死忠粉，你可以把这句话，换成你喜欢的 IDE。（注：这个项目采用 Lombok 简化代码，为了能让代码在你的 IntelliJ IDEA 编译运行，你可以安装 Lombok 插件，然后，在「Build, Execution, Deployment」->「Compiler」->「Annotation Processors」中，选中 Enable annotation processing。）

好，有了基础知识之后，我们来了解一下代码组织。首先是分模块。除非你的代码库规模非常小，否则，分模块几乎是一种必然。一种恰当的划分方式是根据业务划分代码。比如，把用户相关的内容放到一个模块里，把交易订单信息放到一个模块里，把物流信息放到另一个模块里。如果你未来打算做微服务，那每一个模块就可以成为一个独立的服务。

在我们的项目里，我示例性地划分了两个模块：1）zero-identity，是用户信息的模块；2）zero-bootstrap，是多个模块打包成一个可部署应用的模块。这两个模块的信息都配置在 settings.gradle 中。

```
include 'zero-bootstrap'
include 'zero-identity'
```

再来是目录结构。具体要怎么样组织代码，在 Java 世界里已经是一件约定俗成的事情了。src/main/java 下放着你的源代码，src/main/resources 下放配置文件，src/test/java 放测试代码。这是约定优于配置（Convention over Configuration）思想的体现。如果你用的工具没有约定，你只能自己定好，让其他人遵守。

### 2.3 检查

在自动化过程中，一个最基本的工作是检查。检查的工作在我们的项目中通过一个 check 任务来执行。

```
./gradlew check
```

这个检查会检查什么呢？这取决于配置。在这个项目里，我们应用了 Java 插件，它就可以编译 Java 文件，检查代码是否可以正常编译，运行测试，检查代码是否功能正常等等。但我要求更多。讲「迭代 0」时，我说过，最基本的代码风格检查要放在构建脚本中，这里我用了 CheckStyle 来做这件事。缺省情况下，你只要应用 Checkstyle 插件即可。

```
apply plugin: 'checkstyle'
```

在这个项目里，我做了一些订制，比如，指定某些文件可以不做检查。

```
style.excludePackages = [
]

style.excludeClasses = [
]
```

测试覆盖率也应该加入到构建脚本中，这里我用了 JaCoCo。同样，缺省情况下，只要应用 JaCoCo 插件即可。

```
apply plugin: 'jacoco'
```

我依然是做了一些订制，比如，生成结果的 HTML 报表，还有可以忽略某些文件不做检查。

```
coverage.excludePackages = [
]

coverage.excludeClasses = [
]
```


这里最特别的地方是，我将测试覆盖率固定在 1.0，也就是 100% 的测试覆盖。这是我做新项目的缺省配置，也是我对团队的要求。如果一个新项目，能把这几个检查都通过，腐坏的速度应该就不会那么快了。当然，你也可以根据自己的需要，添加更多的检查。

### 2.4 数据库迁移

讲「迭代 0」时，我还提到了数据库迁移，也就是怎样修改数据库。在示例项目中，我选择的数据库迁移工具是 Flyway（[Flyway by Redgate • Database Migrations Made Easy.](https://flywaydb.org/)）。

```
plugins {
    id "org.flywaydb.flyway" version "5.2.4"
}
```

下面先要做一些基本的配置，保证可以连接到数据库。（注：如果你想直接使用这里的配置，可以在本机的 MySQL 数据库上，创建一个 zero 的用户，密码是 geektime，然后，再创建一个 zero_test 的数据库。）

```
flyway {
    url = 'jdbc:mysql://localhost:3306/zero_test?useUnicode=true&characterEncoding=utf-8&useSSL=false'
    user = 'zero'
    password = 'geektime'
    locations = ["filesystem:$rootDir/gradle/config/migration"]
}
```

那修改数据库会怎么做呢？先添加一个数据库迁移文件，比如，在示例项目中，我创建一个迁移文件（gradle/config/migration/V2019.02.15.07.43\_\_Create\_user\_table.sql），在其中创建了一个 User 表。

```
CREATE TABLE zero_users(
    id bigint(20) not null AUTO_INCREMENT,
    name varchar(100) not null unique,
    password varchar(100) not null,
    primary key(id)
);
```

这里的迁移文件版本，我选择了以时间戳的方式进行命名，还有一种方式是以版本号的方式，比如 V1、V2。时间戳命名方式的好处是，不同的人可以同时开发，命名冲突的几率很小，而采用版本号命名的方式，命名冲突的概率会大一些。添加好数据库迁移文件之后，只要执行下面这个命令就好：

```
./gradlew flywayMigrate
```

这样，对数据库的修改就在数据库里了，你可以打开数据库查看一下。

### 2.5 构建应用

做好了最基本的检查，数据库也准备就绪，接下来，我们就应该构建我们的应用了。首先是生成构建产物，它只要一个命令。

```
./gradlew build
```

这个命令会在 zero-bootstrap/build/libs 下生成一个可执行 JAR 包，它就是我们最终的构建产物。此外，build 任务会依赖于 check 任务，也就是说，构建之前，会先对代码进行检查。从前 Java 程序只是打出一个可部署的包，然后，部署到应用服务器上。感谢现在基础设施的进步，我们可以省去部署的环节，这个包本身就是一个可执行的。我们可以通过命令执行将 JAR 执行起来。

```
java -jar zero-bootstrap/build/libs/zero-bootstrap-*-boot.jar
```

在开发过程中，并不需要每次都将 JAR 包打出来，我们还可以直接通过 Gradle 命令将应用运行起来。

```
./gradlew bootRun
```

不过，我估计你更常用的方式是，在 IDE 中找到 Bootstrap 这个入口类，然后，直接运行它。既然程序已经运行起来，我们不妨测试一下。我们通过一些工具，比如 Postman 或者 Curl，把下面的内容 POST 到 http://localhost:8080/users

```
{
  "username": "foo",
  "password": "bar"
}
```

然后，通过浏览器访问 http://localhost:8080/users，我们就可以看见我们刚刚注册的这个用户了。

### 黑板墙

在日常开发工作中，你还把哪些过程自动化了呢？

设想过这样的情景（还没实现，打算实践一把）：我们新招一名比较熟练的程序员，从 TA 入职拿到机器，到开发示意代码，再提交 SCM，然后 CI/CD，再发布到线上交付给用户，整个过程可以在入职当天的午饭之前完成。这不光要求构建和集成自动化，甚至要求从入职开始的各个环节都能提前准备好，包括机器、开发环境、线上环境等，甚至连示范的需求都要能及时传递给 TA。理想情况下，程序员只需要开发好程序，保证质量，提交到 SCM 即可，其他事情都应该交给机器。要知道程序员都很贵，越早给用户交付价值越好。作者回复：是这个意思，后面继续谈如何往线上送。2019-03-20

对于 Gradle 的特性了解还是比较少…… 感觉学习中会有这样的一个现象：对与技术是干什么用的其实是知道的，但是对于细节的把握总是容易遗忘，之前就拿实战 Gradle 这本书基本上通读了一遍，但是遗忘的确实有点快！我感觉这应该是大多数程序员的通病吧，老师能否给出一些建议？抑或是这种学习方式本身就是低效或者是错误的。作者回复：我的学习方式是，我先要知道构建脚本要做哪些事情，就像这篇文章中写到的这些内容，然后看怎么样用对应工具如何完成，这样看起手册来就有针对性了。2019-05-03

我一般会在需要专有的构建工具之上再定义一个 Makrfile 封装，通用的 test build deploy 操作，统一各语言构建工具差异，比如 maven gradle npm。作者回复：我也做过类似的事情，用 shell 脚本去封装。2019-03-20

郑老师是否可以分享一下自己在模块划分上面的经验呢？作者回复: 《敏捷软件开发：原则、实践与模式》、《架构整洁之道》中都有关于模块划分的内容。2019-03-20

有时候感觉流程比技术更重要。之前有一个经历，就是本来想写个自动化的脚本把在做的事情自动化，但是我的一个同事直接改变了流程，让整个流程更加简化了的。原来脚本所要做的事压根都不存在了。确实像老师所说的，写程序是最高的成本，在着手写程序之前，一切都要考虑清楚。2019-06-12

老师，有个细节问题想咨询一下，现在用 Spring boot 做一个新项目，由于是前期阶段，短时间内要上线，选择了 Spring boot，用业务划分模块的方式来进行开发，就像您文中提到划分模块，现在有个疑问的地方是模块之间会产生一些调用，比如用户的金币数据在用户模块里，游戏模块需要用到某个用户的金币数据，有比较好的做法吗？如果是让游戏模块依赖用户模块，然后注入用户的 service，感觉跟之前没什么区别。作者回复：不要直接依赖于服务，要用接口的方式进行隔离，哪怕是接口和原来服务一模一样，也要隔离。必须明确的一点，这两个业务模块之间是服务相互调用的关系，不是程序库的关系。2019-04-23

老师，我有个疑问。公司最近有个技术老大说不准用 lombok 这个小工具，一定要我们手写 set get？lombok 真的那么差吗？作者回复：我不清楚具体的情况。我凭一般认知回答一下，有一种可能是，你老大觉得 getter/setter 就不应该写，需要做更好的领域建模；另一种情况是，对于这种生成代码的机制有担心。lombok 本身不是问题，很多人乱用才是问题。2019-03-23

老师，以后用 idea 导向建立 Spring Boot，我是不是把默认的 maven 改为 gradle？自动化：gitlab CI/CD+jenkins 的 gradle+docker，其中 docker 是把脚本放在 jenkins，根据 tag，如果是稳定版本就用 makeFile 生成 docker 镜像，这样可以吧？作者回复：我的建议是用构建脚本生成 IDE 工程。2019-03-20

自动化在持续交付中得到了非常充分的体现，把频繁的打包、单测、集成测试、部分验收测试、镜像构建和发布、CI 环境更新、服务可用性验证等过程全部流水线化，极大的提升了构建发布效率，当然自动化的意义不仅于此；同时，把一切自动化是思维的转变，高效工作的有利工具。作者回复：没错，我们下面就会谈到持续交付。2019-03-20

idea 没有直接集成 gradle 吧？我看 maven 就直接有，好不容易学完 maven，就淘汰了。有 gradle 方面的书吗？idea 方面的呢？看官方教程？idea 是不是用到什么功能再学？还是先看过大概，用到再仔细看？还是最好都看一遍？目前 idea 只会一些基础的…...作者回复：理解错了，IDEA 提供了很好的 Gradle 支持。我的建议是生成 IDE 工程，maven 同样适用。我学 Gradle 和 IDEA 这种工具都是看官方文档。IDEA 的学习，别的不说，先熟练适用快捷键。2019-03-20

我想问下 PHP 有类似构建脚本的工具吗？还没开始学习 JAVA。作者回复：我并不擅长 PHP，你不妨用 PHP build tool 为关键词搜索一下。2019-03-20

运维现在也有很多工具支持了。都是显示了配置化。作者回复：显示是一个 view，需要先把 model 做好。2019-03-24

## 0403程序员怎么学习运维知识.md

我们今天的关注点在于，将开发过程产生的构建产物部署起来。部署过程要依赖于运维知识，每个程序员都应该学习运维知识，保证我们对软件的运行有更清楚地认识，而且部署工作是非常适合自动化的。但是，对运维工具的学习是非常困难的，因为我们遇到的很多工具是非常零散的，缺乏体系。这里，我给你介绍了一个运维的知识体系，这个体系借鉴自 Java 的知识体系，包括了编程语言、核心库、第三方库、开发框架、单机部署和集群部署等诸多方面。我把今天提到的各种技术整理成一个表格列在下面，你可以参考它更好地理解运维知识。如果今天的内容你只能记住一件事，那请记住：有体系地学习运维知识。

| 类别 | JAVA | 运维 |
|:-------------|:-------------|:-----|
| 语言 | JAVA 语言 | Shell |
| 核心库 |  JDK   | Unix/Linux 核心命令 |
| 第三方库 | 第三方程序库，比如：Google Guava、SLF4J | 第三方命令，如 rsync、curl 等 |
| 开发框架 | 开发框架，比如 Spring | 配置管理工具，如 Chef、Puppet、Ansible 等 |
| 单机部署 | 应用服务器，比如 Tomcat、Jetty | 部署环境，如虚拟机、Docker 等 |
| 集群部署 | 企业级应用服务器，比如 IBM Websphere、Oracle Weblogic、Server、JBoss EnterPrise、Application Platform | 云服务，如 Amazon AWS、Openstack、阿里云等；Docker 集群，比如 Kubernates、Docker Swarm 等 |

在上一讲中，我们讲到了开发过程的自动化，我们的关注点在于如何构建出一个有效的部署包，这个包最终是要上线部署的，那接下来，我们就来关心一下部署的相关工作。

### 3.1 零散的运维知识

在一些稍具规模的公司，为部署工作设置了一个专有职位，称之为运维。当然，这个岗位的职责远不止部署这一件事，还要维护线上系统的稳定。不过，如果你的团队规模不大，或是项目处于初始阶段，这些工作往往也要由程序员自行完成。对于一个程序员来说，了解自己的程序怎么部署上线，是非常重要的。我们既要了解一个软件的逻辑，也要知道它的物理部署。只有这样，出了问题才知道怎么修复。更重要的是，我们在设计时，才能尽量规避部署带来的问题。而部署，恰恰也是最适合发挥自动化本领的地方。

好，即便下定决心准备学习运维相关知识，你准备怎么学呢？我先来问你个问题，提到运维，你会想到什么？如果你是一个刚刚步入这个行业的程序员，你或许会想到 Docker（[Empowering App Development for Developers | Docker](https://www.docker.com/)），想到 Kubernetes（[Production-Grade Container Orchestration - Kubernetes](https://kubernetes.io/)）；如果再早一点入行，你或许还会想到 Chef（[Chef: Enabling the Coded Enterprise through Infrastructure, Security and Application Automation](https://www.chef.io/)）、Puppet（[Powerful infrastructure automation and delivery | Puppet | Puppet.com](https://puppet.com/)）、Ansible；更早一些入行的话，你会想到 Shell 脚本。没错，这些东西都是与运维相关的。那我就这么一个一个地都学一遍吗？

就我个人的学习经验而言，如果所有的知识都是零散的，没有一个体系将它们贯穿起来，你原有的知识无法帮助你学习新知识，这种学习方式效率极低，过程也极其痛苦。如果是有结构的知识，所谓的学习新知识不过是在学习增量，真正要理解的新东西并不多，学习效率自然会大幅度提高。所以，想学好运维知识，首先你要建立起一个有效的知识体系。

你可能会问，这些运维知识看上去就是一个一个独立的工具啊？我曾经也为此困惑了许久，虽然我对各个工具已经有了不少的了解，但依然缺乏一个有效的知识体系，将它们贯穿起来，直到我上了一堂课。感谢 Odd-e 的柴锋，有一次，他给我上了一堂 DevOps 课，他对运维知识的讲解让我茅塞顿开，从此，我的运维知识有了体系。准确地说，他的这堂课就是讲给程序员的运维课。今天，我就把这个体系按照我的理解，重新整理一遍分享给你，也算是完成一次知识输出。

3『[DevOps 技术栈 | 三分热度：柴锋](https://chaifeng.com/devops-tech-stack/)』

### 3.2 Java 知识体系

正如我前面所说，学习一个新东西，最好的办法是学习增量，如果能够找到它与已有知识体系的联系，我们就可以把已有知识的理解方式借鉴过去。作为程序员，我们其实已经有了一个完善的知识体系，这就是我们对于程序设计的理解，而理解运维的知识体系，刚好可以借鉴这个体系。怎么理解这句话呢？

以最常见的 Java 开发为例，如果要成为一个合格的 Java 程序员，我应该知道些什么呢？

首先肯定是 Java 语言，我需要了解 Java 语言的各种语法特性。不过，只了解语法是写不出什么像样程序的，我们还需要掌握核心库。对于 Java 来说，就是 JDK 中的各种类，比如，最常见的 String、List、Map 等等。理论上来说，掌握了基本的语法和核心库，你就可以开发任何程序了。但在实践中，为了避免重新发明「轮子」，减少不必要的工作量，我们还会用到大量的第三方类库，比如，Google Guava、SLF4J 等等。

除了功能实现，还有一些结构性的代码也会反复出现。比如说，在常见的 REST 服务中，我们要将数据库表和对象映射到一起，要将结果转换成 JSON，要将系统各个组件组装到一起。为了减少结构上的代码重复，于是，开发框架出现了，在 Java 中最常见的开发框架就是 Spring。至此，你就可以完成基本的代码编写，但这还不够。在 Java 中，你不会从底层完成所有事情，比如，虽然你写 REST 服务，但你很少会接触到最底层的 HTTP 实现，因为这些工作由运行时环境承担了。我们要做的只是把打好的包部署到这些运行时环境上，在 Java 的世界里，这是 Tomcat、Jetty 之类的容器承担的职责。

如果你刚刚加入这一行，上来就用 Spring Boot 之类的框架写代码，你可能并没有碰到这样的部署过程，因为这些框架已经把容器封装其中，简化了部署过程。Tomcat、Jetty 往往还只是在一台机器上部署，在现实的场景中，一台机器通常是不够用的，我们可能需要的是一个集群。

你可能会想到用 Nginx 来做一个负载均衡，但如果用原生的 Java 解决方案，这时候就轮到企业级的应用服务器登场了，比如：IBM WebSphere、Oracle WebLogic Server、JBoss Enterprise Application Platform 等等。至此，一套完整的 Java 应用解决方案已经部署起来了。但我们知道了这些，和我们运维知识有什么关系呢？我们可以用同样的体系去理解运维知识。

### 3.3 运维知识体系

首先，要理解运维体系的语言。运维的语言是什么呢？是 Shell，人们最熟悉的应该是 Bash。我们通过操作系统与计算机打交道，但我们无法直接只用操作系统内核，Shell 为我们提供了一个接口，让我们可以访问操作系统内核提供的服务。

你可能会以为我这里用的是比喻，将 Shell 比喻成语言，但还真不是，Shell 本身就是一门编程语言。绝大多数人都知道 Shell 可以编程，但几乎没有人把 Shell 当成一门编程语言来学习，基本上都是在需要的时候，搜一下，然后照猫画虎地将代码复制上去。这样造成的结果就是，一旦写一个脚本，就要花费大量的时间与语法做斗争，只是为了它能够运行起来。

有了语言，再来就是核心库了。运维的核心库是什么？就是 Shell 提供的各种 Unix/Linux 的核心命令，比如：ls、cd、ps、grep、kill、cut、sort、uniq 等等，它们几乎与操作系统绑定在一起，随着操作系统一起发布。

了解了核心的部分，还需要了解一些第三方库，运维知识的第三方库就是那些不属于操作系统核心命令的命令，比如：rsync、curl 等等。Java 有框架可用，运维也有框架吗？你可以想一下，Java 的框架提供的是一些通用的能力，在运维工作中，也是有一些通用能力的，比如：在安装某个包之前，要检查一下这个包是否已经安装了；在启动一个服务前，要检查这个服务是否启动了，等等。所以，能够帮我们把这些工作做好的工具，就是我们的运维框架。到这里，你应该已经明白了，我在说的运维框架其实就是像 Chef、Puppet、Ansible 之类的配置管理工具。它们做的事就是把那些繁琐的工作按照我们的定义帮我们做好。

有了对软件环境的基本配置，接下来，就要找一个运行时的环境将软件跑起来了。这时候，我们要了解像虚拟机、Docker 之类的技术，它们帮我们解决的问题就是在单机上的部署。一般来说，了解了这些内容，我们就可以构建出一个开发环境或测试环境。除非用户非常少，我们可以在生产环境考虑单机部署，否则，我们迄今为止讨论的各种技术还都是在开发环节的。

如果我们需要一个集群或是高可用环境，我们还需要进一步了解其他技术，这时候，就轮到一些更复杂的技术登场了，比如，云技术，Amazon AWS、OpenStack，包括国内的阿里云。如果你采用的是 Docker 这样的基础技术，就需要 Kubernetes、Docker Swarm 之类的技术。至此，一个相对完整的运维知识体系已经建立起来了，现在你有了一张知识地图，走在运维大陆上，应该不会轻易地迷失了。希望你可以拿着它，继续不断地开疆拓土。

### 黑板墙

现在运维流行 DevOps，高级一点就是 AI，其中一篇文章《DevOps 详解》不错，链接如下：[DevOps详解 - InfoQ](https://www.infoq.cn/article/detail-analysis-of-devops)。《DevOps 知识体系与标准化的构建》也不错。运维知识体系：[运维知识体系v3.1【赵班长】](https://www.unixhot.com/page/ops)。Web 缓存知识体系：[缓存知识体系v3.0【赵班长】](https://www.unixhot.com/page/cache)。

运维技能：1）懂网络，一般要求 CCNA（最好 CCNP）或同等水平。2）懂系统，懂得主流的 linux 系统操作（Centos、ubuntu、debian 等），操作命令、维护、性能优化、故障排查。3）简单安全，一些简单的安全知识。4）半个 DBA，一般中小公司前期没有 DBA，需要运维做，最起码会 SQL 语句、主从、群集：redis、mysql、MongoDB 等。5）会运维开发，一般用于开发运维工具、运维系统（如 CMDB、ELK 日志系统等）；运维主要语言是 shell、python/Go；python web 框架：Django、tonado 等；Go web 框架：Beego、Gin、Iris 等；有的还会用 PHP 及框架（TP、YII、Laravel 做 web 前端）。中小公司运维一般都没有专职的前端，需要运维兼职所以要学前端知识。6）懂点开发，一般都懂一点本公司开发的语言，如公司用 PHP 需要学习、如公司用 java web 也需要学习一下，目标：a）更好的维护网站，排错。b）运维自动化、DevOps，因 DevOps 是基于敏捷开发，极限编程的思想，所以得懂一点软件工程。7）主职：各种环境的搭建：LAMP、LNMP、负载均衡（nginx、haproxy、VLS 等）、web 群集、数据库群集、主流的 docker [必会]；排错 [必会]；批量安装系统安装：Cobbler [少]；部署工具：Ansible/SaltStack [重要]；主流的部署方案：如云、docker、k8s 等 [必会]；监控系统：zabbix、Open-Falcon [至少掌握其中一种]；自动化：gitlab CI/CD、jenkins 结合 ansible/salt、docker [必会]；运维流程的制定；减少背锅的次数：运维是出名的「背锅侠」，制定明确的责任可以减少背锅。等等。8）会点构架，一般中小公司没有构架师，所以当业务增大出现瓶颈，运维得给出解决方案和开发讨论如何扩展。总结：在中小公司运维工作就是一件很杂的工作，什么都要求会一点。2019-03-22

1『运维知识体系，这个图谱好 NB。』

还有性能分析和调优，比如 Java 有 JVM 内存模型和运行参数调优，运维有单 CPU 多 CPU 的硬件模型和操作系统参数优化。作者回复：这个类比很不错！2019-03-22

可视化监控衍生出的网络协议、网络与安全设备、软硬件性能指标等相关方面的知识与工具也是运维工作需要关注的。2019-03-25

如何系统学习呢？就是按照上面的表格类比，类比思维？作者回复：一层一层地了解，至少要了解基本的用法。还有一种极致的方式，联系柴锋老师去上他的课。2019-03-22

我有一个困惑：「我开发完成之后，现在提测。提测需要发送测试邮件，然后把代码上传到 svn。再由编译人员拉下代码，编译部署。」但是在这过程中发生了几个问题：1）部署涉及三个服务器环境，但是其中有两个环境的服务（包括数据库）挂掉了，而且我们实现并不知晓。2）编译人员并不知道，他所负责环境下的项目服务器的用户名和密码还有数据库的用户名和密码。3）项目经理坦言这几个环境不归他管理，但是对应的服务必须由他开启。然后我们并没有服务开启的文档，只能从百度上一点一点的尝试。那现在的问题是，这一些都需要我去串联。作者回复：你工作在二三十年前，辛苦了。如果过程不做改变，你一个人很难改变。所以，可以建议调整流程。2019-10-14

我看完这篇文章的收获，可能和老师写这篇文章的初衷有所不同，老师写这篇文章的初衷是写给那些想学习运维知识的程序员，通过 Java 的框架来类比于运维的框架。而对于我来说，我本身是运维，目前正在学习 Java 语言，所以反而能让我从运维的视角，更好的理解和学习 Java 语言这门工具。2019-06-13

## 0404持续交付有持续集成就够了吗.md

