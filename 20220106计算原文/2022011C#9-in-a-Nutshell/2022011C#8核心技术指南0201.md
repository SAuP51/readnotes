## 0201. C# 语言基础

本章将介绍 C# 语言的一些基础知识。

本章和接下来的两章中的所有程序和代码片段都可以作为交互式示例在 LINQPad 中运行。阅读本书时使用这些示例可以加快你的学习进度。在 LINQPad 中编辑、执行这些示例可以立即看到结果，无须在 Visual Studio 中建立项目和解决方案。

若要在 LINQPad 中下载这些示例，请单击 Samples 选项卡，然后单击「Download more samples」。

2.1　第一个 C# 程序

以下程序计算 12

乘以 30

，并将结果 360

打印到屏幕上。双斜线「//

」表示其后的内容是注释：

using System;           // Importing namespace

class Test            // Class declaration{ static void Main()       //  Method declaratio

n

{  int x = 12 * 30;       //   Statement 1  Console.WriteLine (x);    //   Statement 2 }                //  End of method}                 // End of class

该程序的核心是以下两个语句：

int x = 12 * 30;

Console.WriteLin

e (x);

在 C# 中，语句按顺序执行，每条语句都以分号（或者代码块，详见本章后续内容）结尾。第一条语句计算表达式 12*30

的值，并把结果存储到一个局部变量 x

中，该变量是一个整数类型。第二条语句调用 Console

类的 WriteLine

方法，将变量 x

的值输出到屏幕上的文本窗口中。

方法完成由一系列语句（称为语句块）指定的行为。语句块由一对大括号及其中的零条或者多条语句组成。以下示例定义了一个名为 Main

的方法：

static void Main()

{  ... }

编写高层函数来调用低层函数可令程序得到简化。下面来重构该程序，使用一个可重用的方法来计算某个整数乘以 12

：

using System;

class Test{ static void



Main() {  Console.W

r

iteLine (Fe

et

ToInches (30));

// 3

60  Console.W

r

iteLine (Fe

et

ToInches (100));

// 1

200 } static int

F

eetToInches

(

int feet) {  int inche

s

= feet * 1

2;

return in

c

hes; }}

方法可以通过参数来接收调用者输入的数据，并通过指定的返回类型向调用者返回输出数据。上述代码中定义了一个 FeetToInches

方法，该方法有一个用于输入英尺的参数和一个用于输出英寸的返回类型：

static int

FeetToInches (int feet

) {...}

示例中的字面量 30

和 100

是传递给 FeetToInches

方法的实际参数。而 Main

方法后的括号是空的，因为没有任何参数。其返回类型是 void

，说明它不向调用者返回任何值：

static void

Main()

C# 将 Main

方法作为程序执行的默认入口点。Main

方法也可以返回整数值（而非 void

），从而将其返回给程序的执行环境（非 0

返回值往往代表一个错误）。Main

方法还可以接受一个字符串数组作为参数（数组中包含了传递给可执行程序的任何实际参数）。例如：

static int Main (string[] args) {...}

数组（例如 string []

）是固定数量的某种特定类型元素的集合。数组由元素类型和它后面的方括号指定。相关内容将在 2.7 节介绍。

Main

方法可以在异步编程中声明为 async

并返回 Task

或 Task<int>

对象，详情请参见第 14 章。

方法是 C# 中诸多种类的函数之一。另一种函数是我们用来执行乘法运算的「*

」运算符。其他的函数种类还包括构造器、属性、事件、索引器和终结器。

本例将两个方法组合到一个类中。类由函数成员和数据成员组成，并形成面向对象的构件块。Console

类将处理命令行输入 / 输出（I/O）功能的成员（例如 WriteLine

方法）聚集在一起。Test

类则由 Main

方法和 FeetToInches

两个方法组成。类也是一种类型，将在 2.3 节中介绍。

程序的最外层将类型组织到了命名空间中。为了使 System

命名空间在应用程序中生效，并能够使用 Console

类，需要使用 using

指令。应将所有的类定义在 TestPrograms

命名空间中，例如：

using System;

namespace Tes

t

Programs{ class Test



{...} class Test2



{...}}

.NET Core 库由若干嵌套的命名空间组织而成。例如，以下命名空间中包含处理文本的类型：

using System.Text;

使用 using

指令仅仅是为了方便，也可以使用命名空间加类型名称（例如 System.Text.StringBuilder

）这种完整限定名称来引用类型。

编译

C# 编译器将一系列.cs 扩展名的源代码文件编译成程序集（assembly）。程序集是.NET 中的最小打包和部署单元。程序集可以是一个应用程序或者是一个库。普通的控制台程序或 Windows 应用程序包含一个 Main

方法（即入口点），而库则没有。库可以被应用程序或其他的库调用（或引用）。.NET Core 就是由一系列程序集（及其运行时环境）组成的。

和.NET Framework 不同，.NET Core 程序集并没有.exe 后缀。.NET Core 应用程序构建后生成的.exe 文件只是一个和平台相关的、负责启动应用程序的.dll 程序集的原生加载器。

.NET Core 还支持创建自包含部署。它包含加载器、程序集以及.NET Core 框架本身，而这些内容均包含在一个.exe 文件中。

dotnet

工具（Windows 下则为 dotnet.exe）是一个用于管理.NET 源代码和二进制文件的命令行工具。该工具像集成开发环境（例如 Visual Studio 和 Visual Studio Code）那样，既可用于构建程序，也可用于启动程序。

dotnet

工具可通过安装.NET Core SDK 或安装 Visual Studio 获得。其默认安装位置在 Windows 操作系统上位于 % ProgramFiles%\dotnet

，在 Ubuntu Linux 上位于 /usr/bin/dotnet

。

dotnet

工具在编译应用程序时需要一个工程文件及一个或者多个 C# 代码文件。以下命令将创建一个控制台应用程序的基本结构：

dotnet new Console -n MyFirstProgram

上述命令将创建名为 MyFirstProgram

的子目录，并在其中创建名为 MyFirstProgram.csproj

的工程文件以及包含 Main

方法的 Program.cs

代码文件。其中 Main

方法将在控制台输出「Hello，World」。

在 MyFirstProgram

目录执行以下命令将构建并运行上述应用程序：

dotnet run MyFirstProgram

如果仅仅希望构建应用程序，但不运行，则可以执行以下代码：

dotnet build MyFirstProgram.csproj

构建生成的程序集将保存在 bin\debug

子目录下。

我们将在第 18 章详细介绍程序集。

2.2　语法

C# 的语法基于 C 和 C++ 语法。本节将使用下面的程序介绍 C# 的语法元素：

using System;

class Test{ static void



Main() {  int x = 1

2

* 30;  Console.W

r

iteLine (x)

; }}

2.2.1　标识符和关键字

标识符是程序员为类、方法、变量等选择的名字。下面按顺序列出了上述示例中的标识符：

System  Test  Main  x  Console  WriteLine

标识符必须是一个完整的词，它由以字母和下划线开头的 Unicode 字符构成。C# 标识符是区分大小写的。通常约定参数、局部变量以及私有字段应该以小写字母开头（例如 myVariable

），而其他类型的标识符则应该以大写字母开头（例如 MyMethod

）。

关键字是对编译器有特殊意义的名字。以下是示例中用到的关键字：

using  class  static  void  int

大部分关键字是保留的，这意味着它们不能用作标识符。以下列出了 C# 中的所有关键字：

避免冲突

如果希望用保留的关键字作为标识符，需在关键字前面加上 @

前缀。例如：

class class {...}   // Illegal

class @class {...}   // Legal

@

并不是标识符的一部分，所以 @myVariable

和 myVariable

是一样的。

@

前缀在调用使用其他拥有不同关键字的.NET 语言编写的库时非常有用。

上下文关键字

一些关键字是上下文相关的，它们有时不用添加 @

前缀就可以用作标识符。它们是：

使用上下文关键字作为标识符时，应避免与上下文中的关键字混淆。

2.2.2　字面量、标点与运算符

字面量在语法上是指嵌入程序中的原始数据片段。上述示例中用到的字面量有 12

和 30

。

标点有助于划分程序结构。以下是示例中用到的标点：

{  }  ;

大括号可将多条语句组合成一个语句块。

分号用于结束一条语句（但语句块并不需要使用分号）。这意味着语句也可以放在多行中：

Console.WriteLine

(1 + 2 + 3 + 4

+ 5 + 6 + 7 + 8 + 9 + 10);

运算符用于改变和结合表达式。大多数 C# 运算符都以符号表示，例如乘法运算符 *

。我们将在本章后续内容中详细介绍运算符。上述示例中出现的运算符有：

. ()  *  =

点号（.

）表示某个对象的成员（或者数字字面量的小数点）。括号在声明或调用方法时使用；空括号在方法没有参数时使用（本章后续还会介绍括号的其他用途）。等号用于赋值操作（双等号 == 用于相等比较，请参见本章后续内容）。

2.2.3　注释

C# 提供了两种不同形式的源代码文档：单行注释和多行注释。单行注释由双斜线开始，到本行结束为止。例如：

int x = 3;  // Comment about assigning 3 to x

多行注释由 /*

开始，到 */

结束。例如：

int x = 3;  /* This is a comment that

spans two lines */

注释也可以嵌入 XML 文档标签中，我们将在 4.19 节中介绍。

2.3　类型基础

类型是值的蓝图。以下示例使用了两个 int

类型的字面量 12

和 30

，并声明了一个 int

类型的变量 x

：

static void Main()

{ int x = 12 * 30;

Console.WriteLin

e

(x);}

变量表示一个存储位置，其中的值可能会不断变化。与之对应，常量总是表示同一个值（后面会详细介绍）：

const int y = 360;

C# 中的所有值都是某一种类型的实例。值或者变量所包含的可能取值均由其类型决定。

2.3.1　预定义类型示例

预定义类型是指那些由编译器特别支持的类型。int

就是一种预定义类型，它代表一系列能够存储在 32 位内存中的整数，其范围为 - 231

～231

-1，并且它是该范围内数字字面量的默认类型。我们能够对 int

类型的实例执行算术运算等功能：

int x = 12 * 30;

C# 中的另一个预定义类型是 string

。string

类型表示字符序列，例如「.NET」或者「http://oreilly.com

」。我们可以通过以下方式调用函数来操作字符串：

string message = "Hello world";

string upperMessage = message.T

oUpper();Console.WriteLine (upperMessage

);        // HELLO WORLDint x = 2015;message = message + x.ToString(

);Console.WriteLine (message);

// Hello world2015

预定义类型 bool

只有两种值：true

和 false

。bool

类型通常与 if

语句一起控制条件分支执行流程。例如：

bool simpleVar = false;

if (simpleVar) Console.WriteLine ("T

his will not pr

int");int x = 5000;bool lessThanAMile = x

< 5280;if (lessThanAMile) Console.WriteLine ("T

his will print"

);

在 C# 中，预定义类型（也称为内置类型）拥有相应的 C# 关键字。在.NET Core 的 System

命名空间下也包含很多不是预定义类型的重要类型（例如 DateTime

）。

2.3.2　自定义类型示例

我们能使用简单函数来构造复杂函数，同样也可以使用基元类型来构建复杂类型。以下示例定义了一个名为 UnitConverter

的自定义类型。这个类将作为单位转换的蓝图：

using System;

public class

U

nitConverter{ int ratio;







// Field public Unit

C

onverter (int unitRatio) {r

at

io = unitRatio; } // Constructor public int

C

onvert  (int unit)  {ret

ur

n unit * ratio; } // Method}class Test{ static void



Main() {  UnitConve

r

ter feetToInchesConverter =

n

ew UnitConverter (12);  UnitConve

r

ter milesToFeetConverter =

n

ew UnitConverter (5280);  Console.W

r

iteLine (feetToInchesConver

te

r.Convert(30));  // 360  Console.W

r

iteLine (feetToInchesConver

te

r.Convert(100));  // 1200  Console.W

r

iteLine (feetToInchesConver

te

r.Convert(



milesToFeetConve

rt

er.Convert(1)));  // 63360 }}

类型的成员

类型包含数据成员和函数成员。UnitConverter

的数据成员是 ratio

字段，函数成员是 Convert

方法和 UnitConverter

的构造器。

预定义类型和自定义类型

C# 的优点之一是其中的预定义类型和自定义类型非常相近。预定义 int

类型是整数的蓝图。它保存 32 位的数据，提供像 ToString

这种函数成员来使用这些数据。类似地，我们自定义的 UnitConverter

类型也是单位转换的蓝图。它保存比率数据，并提供函数成员来使用这些数据。

构造器和实例化

将类型实例化即可创建数据。预定义类型可以简单地通过字面量进行实例化，例如 12

或 "Hello World"

。而自定义类型则需要使用 new

运算符来创建实例。以下语句创建并声明了一个 UnitConverter

类型的实例：

UnitConverter feetToInchesConverter = new UnitConverter (12);

使用 new

运算符后会立刻实例化一个对象，调用对象的构造器进行初始化。构造器的定义类似于方法，不同的是方法名和返回类型简化为所属的类型名称：

public class UnitConverter{ ... public UnitConverter (int unitRatio) { ratio = unitRatio; }

...}

实例与静态成员

由类型的实例操作的数据成员和函数成员称为实例成员。UnitConverter

的 Convert

方法和 int

的 ToString

方法就是实例成员的例子。在默认情况下，成员就是指实例成员。

那些不是由类型的实例操作，而是由类型本身操作的数据成员和函数成员必须标记为 static

。Test.Main

和 Console.WriteLine

就是静态方法。事实上，Console

类是一个静态类，它的所有成员都是静态的。Console

类型无法实例化，因此控制台将在整个应用程序内共享使用。

我们来对比实例成员和静态成员。在下面的代码中，实例字段 Name

属于特定的 Panda

实例，而 Population

则属于所有 Panda

实例：

public class Panda

{ public string Na

me

;       // Instance field public static in

t

Population;  // Static field public Panda (st

ri

ng n)     // Constructor {  Name = n;



// Assign the instance field  Population = P

op

ulation + 1; // Increment the static Population fie

ld }}

下面的代码创建了两个 Panda

实例，先打印它们的名字，再打印总数：

using System;

class Test{ static void



Main() {  Panda p1

=

new Panda

("

Pan Dee");  Panda p2

=

new Panda

("

Pan Dah");  Console.W

r

iteLine (p1

.N

ame);   // Pan Dee

Console.W

r

iteLine (p2

.N

ame);   // Pan Dah

Console.W

r

iteLine (Pa

nd

a.Population);  // 2

}}

如果试图求 p1.Population

或者 Panda.Name

的值，则会生成一个编译时错误。

public

关键字

public

关键字将成员公开给其他类。在上述示例中，如果 Panda

类中的 Name

字段没有标记为公有（public

）的，那么它就是私有的，且 Test

类就不能访问它。将成员标记为 public

就是类型的通信手段：「这就是我想让其他类型看到的，而其他的都是我私有的实现细节。」在面向对象的术语中，类的公有成员封装了私有成员。

2.3.3　转换

C# 可以转换兼容类型的实例。转换始终会根据一个已经存在的值创建一个新的值。转换可以是隐式的也可以是显式的：隐式转换自动发生而显式转换需要强制转换。在下面的示例中，我们把一个 int

隐式地转换为 long

类型（其存储位数是 int

的两倍），并将一个 int

显式地转换为一个 short

类型（其存储位数是 int

的一半）：

int x = 12345;    // int is a 32-bit integer

long y = x;     // Implicit conversion to

64-bit integershort z = (short)x; // Explicit conversion to

16-bit integer

隐式转换只有在以下条件都满足时才能进行：

编译器能确保转换总能成功。

没有信息在转换过程中丢失。

相对地，只要满足下列条件之一就需要显式转换：

编译器不能保证转换总是成功。

信息在转换过程中有可能丢失。

如果编译器可以确定某个转换一定会失败，那么这两种转换都无法执行。包含泛型的转换在特定情况下也会失败，请参见 3.9.11 节。

以上的数值转换是 C# 中内置的。C# 还支持引用转换、装箱转换（见第 3 章）与自定义转换（见 4.16 节）。对于自定义转换，编译器并没有强制要求上述规则，因此没有良好设计的类型有可能在转换时出现意想不到的效果。

2.3.4　值类型与引用类型

所有的 C# 类型可以分为以下几类：

值类型

引用类型

泛型参数

指针类型

本节将介绍值类型和引用类型。泛型参数将在 3.9 节介绍，指针类型将在 4.17 节中介绍。

值类型

包含大多数的内置类型（具体包括所有数值类型、char

类型和 bool

类型）以及自定义的 struct

类型和 enum

类型。

引用类型

包含所有的类、数组、委托和接口类型（这其中包括了预定义的 string

类型）。

值类型和引用类型最根本的不同在于它们在内存中的处理方式。

值类型

值类型

的变量或常量的内容仅仅是一个值。例如，内置的值类型 int

的内容是 32 位的数据。

可以通过 struct

关键字定义自定义值类型（参见图 2-1）：

public struct Point { public int X; public int Y; }

或采用更简短的形式：

public struct Point { public int X, Y; }

图 2-1：内存中的值类型实例

值类型实例的赋值总是会进行实例复制。例如：

static void Main()

{ Point p1 = new P

oi

nt(); p1.X = 7; Point p2 = p1;



// Assignment cau

ses copy Console.WriteLin

e

(p1.X); // 7 Console.WriteLin

e

(p2.X); // 7 p1.X = 9;



// Change p1.X Console.WriteLin

e

(p1.X); // 9 Console.WriteLin

e

(p2.X); // 7}

图 2-2 中展示了 p1

和 p2

拥有不同的存储空间。

图 2-2：赋值操作复制了值类型的实例

引用类型

引用类型比值类型复杂，它由两部分组成：对象

和对象引用

。引用类型变量或常量中的内容是一个含值对象的引用。以下示例重写了前面例子中的 Point

类型，令其成为一个类而非 struct

（参见图 2-3）：

public class Point { public int X, Y; }

图 2-3：内存中的引用类型实例

给引用类型变量赋值只会复制引用，而不会复制对象实例。这允许不同的变量指向同一个对象，而值类型通常不会出现这种情况。如果 Point

是一个类，那么若重复之前的示例，则对 p1

的操作就会影响 p2

：

static void Main()

{ Point p1 = new P

oi

nt(); p1.X = 7; Point p2 = p1;



// Copies p1 refe

rence Console.WriteLin

e

(p1.X); // 7 Console.WriteLin

e

(p2.X); // 7 p1.X = 9;



// Change p1.X Console.WriteLin

e

(p1.X); // 9 Console.WriteLin

e

(p2.X); // 9}

图 2-4 展示了 p1

和 p2

是指向同一对象的两个不同引用。

图 2-4：赋值操作复制了引用

null

引用可以用字面量 null

来赋值，表示它并不指向任何对象：

class Point {...}

...Point p = null;Console.WriteLine

(p

=

= null);  // Tr

ue// The following

line



generates a runt

ime error// (a NullReferen

ceEx

c

eption is thrown

):Console.WriteLine

(p.

X

);

C# 8 引入了一个新的特性来避免意外发生 NullReferenceException

错误。更多详细信息请参见 4.8 节。

相对地，值类型通常不能为 null

：

struct Point {...}

...Point p = null; /

/ Co

mpile-time errorint x = null;  /

/ Co

mpile-time error

C# 中也有一种可令值类型为 null

的结构，称为可空（nullable）值类型（请参见 4.7 节）

存储开销

值类型实例占用的内存大小就是存储其字段所需的内存。例如，Point

需要占用 8 字节的内存：

struct Point

{ int x; //

4

bytes int y; //

4

bytes}

从技术上说，CLR 用整数倍字段的大小（最大到 8 字节）来分配内存地址。因此，下面定义的对象实际上会占用 16 字节的内存（第一个字段的 7 个字节被「浪费了」）：

struct A { byte b; long l; }

这种行为可以通过指定 StructLayout

属性来重写（请参见 25.6 节）。

引用类型要求为引用和对象单独分配存储空间。对象除占用和字段一样的字节数外，还需要额外的管理空间开销。管理开销的精确值本质上属于.NET 运行时实现的细节，但最少也需要 8 个字节来存储该对象的类型的键以及一些临时信息（如线程锁的状态及是否可以被垃圾回收器固定等）。根据.NET 运行时是工作在 32 位还是 64 位平台上，每一个对象的引用都需要额外的 4 或 8 个字节的存储空间。

2.3.5　预定义类型分类

C# 中的预定义类型有：

值类型

数值

有符号整数（sbyte

、short

、int

、long

）

无符号整数（byte

、ushort

、uint

、ulong

）

实数（float

、double

、decimal

）

逻辑值（bool

）

字符（char

）

引用类型

字符串（string

）

对象（object

）

C# 的预定义类型又称为.NET Core 类型，位于 System

命名空间。因而以下两个语句仅在拼写上有所不同：

int i = 5;

System.Int

32 i = 5;

在 CLR 中，除了 decimal

之外的一系列预定义值类型

属于基元类型

。之所以称为基元类型，是因为它们在编译过的代码中有直接的指令支持，而这种指令通常翻译为底层处理器直接支持的指令。例如：

// Underlying hexadecimal representation

int i = 7;     // 0x7bool b = true;   // 0x1char c = 'A';   // 0x41

float f = 0.5f;  // uses

IEEE floating-point encod

ing

System.IntPtr

和 System.UIntPtr

类型也是基元类型（参见第 25 章）。

2.4　数值类型

表 2-1 中列出了 C# 中所有的预定义数值类型。

表 2-1：C# 中的预定义数值类型

在整数类型中，int

和 long

是最基本的类型，C# 和运行时都对其有良好的支持。其他的整数类型通常用于实现互操作性或存储空间使用效率要求更高的情况。

在实数类型中，float

和 double

称为浮点类型，并通常用于科学和图形计算。decimal

类型通常用于金融计算这种十进制下的高精度算术运算。

2.4.1　数值字面量

整数类型字面量

可以使用十进制或者十六进制表示，十六进制使用 0x

作为前缀。例如：

int x = 127;

long y = 0x7

F;

从 C# 7 开始，可以在数值字面量的任意位置加入下划线以方便阅读：

int million = 1_000_000;

C# 7 及后续版本还可以用 0b

前缀使用二进制表示数值：

var b = 0b1010_1011_1100_1101_1110_1111;

实数字面量

可以用小数或指数表示，例如：

double d = 1.5;

double million

= 1E06;

数值字面量类型推断

默认情况下，编译器将数值字面量推断

为 double

类型或是整数类型：

如果字面量包含小数点或者指数符号（E

），那么它是 double

。

否则，字面量的类型就是下列能匹配这个字面量的第一个类型：int

、uint

、long

和 ulong

。

例如：

Console.WriteLine (    1.0.GetType()); // Double (double

)Console.WriteLine (    1E06.GetType()); // Double (double

)Console.WriteLine (     1.GetType()); // Int32  (int

)Console.WriteLine ( 0xF0000000.GetType()); // UInt32 (uint

)Console.WriteLine (0x100000000.GetType()); // Int64  (long

)

数值后缀

数值后缀

显式地定义了字面量的类型。后缀可以是小写或大写字母：

一般 U

和 L

后缀很少使用，因为 uint

、long

和 ulong

总是可以推断出来或者从 int

类型隐式地转换过来：

long i = 5;   // Implicit lossless conversion from int literal to long

从技术上讲，后缀 D

是多余的，因为所有带小数点的字面量都会推断为 double

类型，可以直接在数值字面量后加上小数点：

double x = 4.0;

后缀 F

和 M

最有用，并应该在指定 float

或 decimal

字面量时使用。如果没有后缀 F

，下面的语句将不能编译，因为 4.5

会被认定为 double

，而 double

是无法隐式地转换为 float

的：

float f = 4.5F;

同样的规则也适用于 decimal

字面量：

decimal d = -1.23M;   // Will not compile without the M suffix.

我们将在下一节详细介绍数值转换的语义。

2.4.2　数值转换

整数类型到整数类型的转换

整数类型转换在目标类型能够表示源类型的所有可能值时是隐式转换

，否则需要显式转换

。例如：

int x = 12345;    // int is a 32-bit integer

long y = x;     // Implicit conversion to

64-bit integral typeshort z = (short)x; // Explicit conversion to

16-bit integral type

浮点类型到浮点类型的转换

double

能表示所有可能的 float

值，因此 float

能隐式地转换为 double

。反之，则必须是显式转换。

浮点类型和整数类型的转换

所有整数类型都可以隐式地转换为浮点数类型：

int i = 1;

float f =

i;

反之，则必须是显式转换：

int i2 = (int)f;

将浮点数转换为整数时，小数点后的数值将被截去而不会舍入。静态类 System.Convert

提供了在不同值类型之间转换的舍入方法（见第 6 章）。

将大的整数类型隐式地转换为浮点类型会保留数值部分

，但是有时会丢失精度

。这是因为浮点类型虽然拥有比整数类型更大的数值，但是有时其精度却比整数类型要小。以下代码用一个更大的数重复上述示例展示了这种精度丢失的情况：

int i1 = 100000001;

float f = i1;

// Magnitude preserved, precision lostint i2 = (int)f;

// 100000000

decimal

类型转换

所有的整数类型都能隐式地转换为 decimal

类型，因为 decimal

可以表示所有可能的 C# 整数类型值。其他所有的数值类型转换为 decimal

或从 decimal

类型进行转换都必须是显式的转换，因为这些转换要么数值可能超越边界，要么可能发生精度损失。

2.4.3　算术运算符

算术运算符（+

、-

、*

、/

、%

）可应用于除 8 位和 16 位整数类型之外的所有数值类型：

+  Addition

-  Subtract

ion*  Multipli

cation/  Division

%  Remainde

r after division

2.4.4　自增和自减运算符

自增和自减运算符（++

、--

）分别给数值类型加 1 或者减 1。具体要将其放在变量之前还是之后，则取决于需要得到变量在自增 / 自减之前

的值还是之后

的值。例如：

int x = 0, y = 0;

Console.WriteLine

(x++);  // Outputs 0; x is now 1Console.WriteLine

(++y);  // Outputs 1; y is now 1

2.4.5　特殊整数类型运算

整数类型指 int

、uint

、long

、ulong

、short

、ushort

、byte

和 sbyte

。

整数除法

整数类型的除法运算总是会截断余数（向 0 舍入）。用一个值为 0 的变量作除数将产生运行时错误（DivideByZeroException

）：

int a = 2 / 3;   // 0

int b = 0;int c = 5 / b;   // t

h

rows Divide

ByZeroException

用字面量

或常量

0 作除数将产生编译时错误。

整数溢出

在运行时执行整数类型的算术运算可能会造成溢出。默认情况下，溢出会默默地发生而不会抛出任何异常，且其溢出行为是「周而复始」的，就像是运算发生在更大的整数类型上，而将超出部分的进位丢弃后继续运算一样。例如，减小最小的整数值将产生最大的整数值：

int a = int.MinValue;

a--;Console.WriteLine (a

== in

t.MaxValue); // True

整数运算溢出检查运算符

checked

运算符的作用是：在运行时当整数类型表达式或语句超过相应类型的算术限制时不再默默地溢出，而是抛出 OverflowException

。checked

运算符可在有 ++

、--

、+

、-

（一元运算符和二元运算符）、*

、/

和整数类型间显式转换运算符的表达式中起作用。溢出检查会带来微小的性能损失。

checked

运算符对 double

和 float

类型没有作用（它们会溢出为特殊的「无限」值，这会在后面介绍），对 decimal

类型也没有作用（这种类型总是会进行溢出检查）。

checked

运算符既可以包裹表达式，也能够包裹语句块，例如：

int a = 1000000;int b = 1000000;int c = checked

(a * b);   // Checks just the expression.checked

// Checks all expressions{

// in statement block.  ...  c = a * b;  ...}

在编译时打开 checked

开关（在 Visual Studio 中，可以在「Advanced Build Settings」中设置）将使程序在默认情况下对所有表达式都进行算术溢出检查。如果你只想禁用指定表达式或语句的溢出检查，可以用 unchecked

运算符来实现。例如，下面的代码即使在编译时打开了 checked

开关也不会抛出异常：

int x = int.MaxValue;int y = unchecked

(x + 1);unchecked

{ int z = x + 1; }

常量表达式的溢出检查

无论是否打开了 checked

工程选项，编译时的表达式计算总会检查溢出，除非应用了 unchecked

运算符。

int x = int.MaxValue + 1;        // Compile-time error

int y = unchecked (int.MaxValue + 1);  // No errors

位运算符

C# 支持以下的位运算符：

2.4.6　8 位和 16 位整数类型

8 位和 16 位整数类型指 byte

、sbyte

、short

、ushort

。这些类型自己并不具备算术运算符，所以 C# 隐式地将它们转换为所需的更大一些的类型。当试图把运算结果赋给一个小的整数类型时会产生编译时错误：

short x = 1, y = 1;

short z = x + y;

// Compile-time error

在以上示例中，x

和 y

会隐式地转换成 int

以便进行加法运算。因此运算结果也是 int

，它不能隐式地转换回 short

（因为这可能会造成数据丢失）。必须使用显式转换才能令其通过编译：

short z = (short) (x + y);  // OK

2.4.7　特殊的 float

和 double

值

不同于整数类型，浮点类型包含某些特定运算需要特殊对待的值。这些特殊的值是 NaN（Not a Number，非数字）、+∞、-∞和 - 0。float

和 double

类型包含表示 NaN、+∞、-∞值的常量，其他的常量还有 MaxValue

、MinValue

以及 Epsilon

。例如：

Console.WriteLine (double.NegativeInfinity);  // -Infinity

double

和 float

类型的特殊值的常量表如下：

非零值除以零的结果是无穷大：

Console.WriteLine ( 1.0 / 0.0);         // Infinity

Console.WriteLine (−1.0 / 0.0);         // -Infinity

Console.WriteLine ( 1.0 / −0.0);         // -Infinity

Console.WriteLine (−1.0 / −0.0);         // Infinity

零除以零或无穷大减去无穷大的结果是 NaN：

Console.WriteLine ( 0.0 / 0.0);         // NaN

Console.WriteLine ((1.0 / 0.0) − (1.0 / 0.0));  // NaN

使用相等比较运算符（==

）时，一个 NaN

值永远也不等于其他的值，甚至不等于其他的 NaN

值：

Console.WriteLine (0.0 / 0.0 == double.NaN);  // False

必须使用 float.IsNaN

或 double.IsNaN

方法来判断一个值是否为 NaN：

Console.WriteLine (double.IsNaN (0.0 / 0.0));  // True

但使用 object.Equals

方法时，两个 NaN

值却是相等的：

Console.WriteLine (object.Equals (0.0 / 0.0, double.NaN));  // True

NaN

在表示特殊值时很有用。在 Windows Presentation Foundation（WPF）中，double.NaN

表示值为「自动」（Automatic）。另一种表示方法是使用可空值类型（见第 4 章）；还可以使用一个包含数值类型和一个额外字段的自定义结构体（见第 3 章）。

float

和 double

遵循 IEEE 754 格式类型规范，几乎所有的处理器都原生支持此规范。如需此类型行为的详细信息，可参考 IEEE 官方网站（http://www.ieee.org/

）。

2.4.8　double

和 decimal

的对比

double

类型常用于科学计算（例如计算空间坐标）。decimal

类型常用于金融计算以及计算那些「人为」的而非真实世界度量的结果。以下是这两种类型的不同之处：

2.4.9　实数的舍入误差

float

和 double

都是基于 2 来表示数值的。因此只有基于 2 表示的数值才能够精确表示。事实上，这意味着大多数有小数部分的字面量（它们都基于 10）将无法精确表示。例如：

float tenth = 0.1f;            // Not quite 0.1

float one  = 1f;Console.WriteLine (one - tenth * 10f);  // -1.490116E-08

这就是为什么 float

和 double

不适合金融运算。相反，decimal

基于 10，它能够精确表示基于 10 的数值（也包括它的因数，基于 2 和基于 5 的数值）。因为实数的字面量都是基于 10 的，所以 decimal

能够精确表示像 0.1 这样的数。然而，double

和 decimal

都不能精确表示那些基于 10 的循环小数：

decimal m = 1M / 6M;        // 0.1666666666666666666666666667M

double d = 1.0 / 6.0;       // 0.16666666666666666

这将会导致积累性的舍入误差：

decimal notQuiteWholeM = m+m+m+m+m+m; // 1.0000000000000000000000000002M

double notQuiteWholeD = d+d+d+d+d+d; // 0.99999999999999989

这也将影响相等和比较操作：

Console.WriteLine (notQuiteWholeM == 1M);  // False

Console.WriteLine (notQuiteWholeD < 1.0);  // True

2.5　布尔类型和运算符

C# 中的 bool

（System.Boolean

的别名）类型是能赋值为 true

和 false

字面量的逻辑值。

尽管布尔类型的值仅需要 1 位的存储空间，但是运行时却使用了 1 字节内存空间。这是因为字节是运行时和处理器能够有效使用的最小单位。为避免在使用数组时的空间浪费，.NET 在 System.Collections

命令空间下提供了 BitArray

类，其中的每一个布尔值仅占用一位。

2.5.1　布尔类型转换

bool

类型不能转换为数值类型，反之亦然。

2.5.2　相等和比较运算符

==

和！=

用于判断任意类型的相等与不等，并总是返回一个 bool

值。值类型通常有很简单的相等定义：

int x = 1;

int y = 2;

int z = 1;

Console.Wr

iteLine (x

== y);

// FalseConsole.Wr

iteLine (x

== z);

// True

对于引用类型，默认情况下相等是基于引用的，而不是基于底层对象的实际值（更多内容请参见第 6 章）：

public class Dude

{ public string N

am

e; public Dude (st

ri

ng n) { Name = n; }}...Dude d1 = new Dud

e

("John");Dude d2 = new Dud

e

("John");Console.WriteLine

(

d1 == d2);    // Fa

lseDude d3 = d1;Console.WriteLine

(

d1 == d3);    // Tr

ue

相等和比较运算符 ==

、!=

、<

、>

、>=

和 <=

可用于所有的数值类型，但是用于实数时要特别注意（请参见 2.4.9 节）。比较运算符也可以用于枚举（enum

）类型的成员，它比较的是表示枚举成员的整数值，将在 3.7 节中介绍。

相等和比较运算符将在 4.16 节、6.11 节和 6.12 节中详细介绍。

2.5.3　条件运算符

&&

和 ||

运算符用于判断「与」和「或」条件。它们常常与代表「非」的！

运算符一起使用。在下面的例子中，UseUmbrella

方法在下雨或阳光充足（伞可以保护我们不会经受日晒雨淋），以及无风（因为伞在有风的时候不起作用）的时候返回 true

：

static bool UseUmbrella (bool rainy, bool sunny, bool windy)

{ return !windy && (rainy || sunny);}

&&

和 ||

运算符会在可能的情况下执行短路计算。在上面的例子中，如果刮风，(rainy || sunny)

将不会计算。短路计算在某些表达式中是非常必要的，它可以允许像下面这样的表达式运行而不会抛出 NullReferenceException

：

if (sb != null && sb.Length > 0) ...

&

和 |

运算符也可用于判断「与」和「或」条件：

return !windy & (rainy | sunny);

不同之处是 &

和 |

运算符不支持短路计算，因此它们很少用于替代条件运算符。

与在 C 和 C++ 中不同，C# 中的 &

和 |

运算符在用于布尔表达式时执行布尔比较（非短路计算），仅在用于数值运算时才执行位运算。

（三元）条件运算符

三元条件运算符（由于它是唯一一个使用三个操作数的运算符，因此也称为三元运算符）使用 q ? a : b

的形式。它在 q

为真时计算 a

，否则计算 b

。例如：

static int Max (int a, int b)

{ return (a > b) ? a : b;}

条件运算符在 LINQ 语句中尤其有用（见第 8 章）。

2.6　字符串和字符

C# 的 char

（System.Char

的别名）类型表示一个 Unicode 字符并占用两个字节（UTF-16）。char

字面量应位于两个单引号之间：

char c = 'A';    // Simple character

转义序列指那些不能用字面量表示或解释的字符。转义序列由反斜线后跟一个表示特殊含义的字符组成，例如：

char newLine = '\n';

char backSlash = '\\

';

表 2-2 中列出了转义序列字符。

表 2-2：转义序列字符

\u

（或 \x

）转义字符通过 4 位十六进制代码来指定任意 Unicode 字符：

char copyrightSymbol = '\u00A9';

char omegaSymbol   = '\u03A9';

char newLine     = '\u000A';

2.6.1　char 转换

从 char

类型到数值类型的隐式转换只在这个数值类型可以容纳无符号 short

类型时有效。其他的数值类型则需要显式转换。

2.6.2　字符串类型

C# 中的字符串类型（System.String

类型的别名，将在第 6 章详细介绍）表示不可变（创建之后即无法更改）的 Unicode 字符序列。字符串字面量应位于两个双引号（"

）之间：

string a = "Heat";

string

类型是引用类型而不是值类型，但是它的相等运算符却遵守值类型的语义。

string a = "test";

string b = "test";

Console.Write (a =

= b); // True

对 char

字面量有效的转义字符在字符串中同样有效：

string a = "Here's a tab:\t

";

这意味着当需要一个反斜线时，需要写两次才可以：

string a1 = "\\\\server\\fileshare\\helloworld.cs";

为避免这种情况，C# 引入了原意字符串字面量。原意字符串字面量要加 @

前缀，它不支持转义字符。下面的原意字符串和之前的字符串是一样的。

string a2 = @

"\\server\fileshare\helloworld.cs";

原意字符串可以贯穿多行：

string escaped = "First Line\r\nSecond Line";

string verbatim = @"First LineSecond Line";// True if your text editor uses CR-LF line se

parators:Console.WriteLine (escaped == verbatim);

原意字符串中需要用两个双引号来表示一个双引号字符：

string xml = @"<customer id=""123""></customer>";

字符串连接

+

运算符可连接两个字符串：

string s = "a" + "b";

如果操作数之一是非字符串值，则会调用其 ToString

方法：

string s = "a" + 5; // a5

重复使用 +

运算符来构建字符串效率较低。更高效的解决方案是使用 System.Text.StringBuilder

类型（将在第 6 章介绍）。

字符串插值

以 $

字符为前缀的字符串称为插值字符串。插值字符串可以在大括号内包含表达式：

int x = 4;Console.Write ($

"A square has {x}

sides"); // Prints: A square has 4 sides

大括号内可以是任意类型的有效 C# 表达式。C# 会调用其 ToString

方法或等价方法将表达式转换为字符串。若要更改表达式的格式，可以使用冒号和一个格式字符串（将在 6.1.2 节中对其详细介绍）：

string s = $"255 in hex is {byte.MaxValue:X2

}"; // X2 = 2-digit hexadecimal

// Evaluates to "255 in hex is F

F"

插值字符串只能在单行内声明，除非使用原意字符串运算符。

int x = 2;// Note that $ must appear before @ prior to C# 8:string s = $@

"this spans {

x} lines";

若要在插值字符串中表示大括号字符，只需书写两个大括号字符即可。

字符串比较

string

类型不支持使用「<

」和「>」

进行比较。必须使用字符串的 CompareTo

方法进行比较，这部分内容将在第 6 章介绍。

2.7　数组

数组是固定数量的特定类型的变量（称为元素）集合。为了实现高效访问，数组中的元素总是存储在连续的内存块中。

C# 中的数组用元素类型后加方括号的方式表示：

char[] vowels = new char[5];  // Declare an array of 5 characters

方括号也可用于通过索引检索数组，即通过位置访问特定的元素：

vowels[0] = 'a';

vowels[1] = 'e';

vowels[2] = 'i';

vowels[3] = 'o';

vowels[4] = 'u';

Console.WriteLin

e (vowels[1]);

// e

因为数组索引从 0 开始，所以上面的语句打印「e」。可以使用 for

循环语句来遍历数组中的每一个元素。下面的例子中的 for

循环将把整数变量 i

从 0

到 4

进行循环：

for (int i = 0; i < vowels.Length; i++)

Console.Write (vowels[i]);

// aeiou

数组的 Length

属性返回数组中的元素数目。一旦数组创建完毕，它的长度将不能更改。System.Collection

命名空间和子命名空间提供了可变长度数组和字典等高级数据结构。

数组初始化表达式可以让你一次性声明并填充数组：

char[] vowels = new char[] {'a','e','i','o','u'};

或者简写为：

char[] vowels = {'a','e','i','o','u'};

所有的数组都继承自 System.Array

类，它为所有的数组提供通用服务。这些成员包括与数组类型无关的获取和设定数组元素的方法，将在 7.3 节介绍。

2.7.1　默认数组元素初始化

创建数组时其元素总会用默认值初始化。类型的默认值是按位取 0 的内存表示的值。例如，若定义一个整数数组，由于 int

是值类型，因此该操作会在连续的内存块中分配 1 000 个整数。每一个元素的默认值都是 0：

int[] a = new int[1000];

Console.Write (a[123]);

// 0

值类型和引用类型的区别

数组元素的类型是值类型还是引用类型对其性能有重要的影响。若元素类型是值类型，每个元素的值将作为数组的一部分进行分配，例如：

public struct

Point { public int X, Y; }

...Point[] a = new Point[1000]

;int x = a[500].X;





// 0

若 Point

是类，创建数组则仅仅分配 1 000 个空引用：

public class

Point { public int X, Y; }

...Point[] a = new Point[1000]

;int x = a[500].X;





// Runtime error, NullRefe

renceException

为避免这个错误，必须在实例化数组之后显式实例化 1 000 个 Point

实例：

Point[] a = new Point[1000];

for (int i = 0; i < a.Length

; i++) // Iterate i from 0 to 999  a[i] = new Point();

// Set array element i with new point

不论元素是何种类型，数组本身总是引用类型对象。例如，下面的语句是合法的：

int[] a = null;

2.7.2　索引和范围（C# 8）

C# 8 引入了索引和范围的概念以简化对数组元素或部分数组的操作。

索引和范围可以和 CLR 类型 Span<T>

与 ReadOnlySpan<T>

配合使用（请参见 5.4.16 节）。

自定义类型也可以通过定义类型为 Index

或 Range

的索引器来使用索引和范围（请参见 3.1.9 节）。

索引

索引使用 ^

运算符从数组的末尾来引用数组元素。^1

代表最后一个元素而 ^2

代表倒数第二个元素，依此类推（^0

等于数组的长度，因此 vowels [^0]

将会产生错误）。

char[] vowels = new char[] {'a','e','i','o','u'};char lastElement = vowels [^1

];  // 'u'char secondToLast = vowels [^2

];  // 'o'

C# 的 Index

类型实现了索引的功能，因此也可以使用如下方式来引用数组元素：

Index

first = 0

;Index

last = ^1

;char firstElement = vowels [first

];  // 'a'char lastElement = vowels [last

];   // 'u'

范围

范围使用..

运算符得到数组的一个「切片」：

char[] firstTwo = vowels [..2];  // 'a', 'e'

char[] lastThree = vowels [2..];  // 'i', 'o'

, 'u'char[] middleOne = vowels [2..3];  // 'i'

注意，范围中的第二个数字是开区间的。因此..2

表示返回 vowels [2]

之前的元素。

在范围中也可以使用 ^

符号。例如，以下语句返回数组中的最后两个字符：

char[] lastTwo = vowels [^2..];   // 'o', 'u'

C# 的 Range

类型实现了范围的功能，因此可以用如下方式来操作范围：

Range firstTwoRange = 0..2;

char[] firstTwo = vowels [f

irstTwoRange];  // 'a', 'e'

2.7.3　多维数组

多维数组分为两种类型：矩形数组和锯齿形数组。矩形数组代表 n

维的内存块，而锯齿形数组则是数组的数组。

矩形数组

矩形数组声明时使用逗号分隔每个维度。下面的语句声明了一个矩形二维数组，它的维度是 3×3：

int[,] matrix = new int[3,3];

数组的 GetLength

方法返回给定维度的长度（从 0 开始）：

for (int i = 0; i < matrix.GetLength(0); i++)

for (int j = 0; j < matrix.GetLength(1); j+

+)  matrix[i,j] = i * 3 + j;

矩形数组可以显式地以具体值来初始化。以下示例创建了一个和上例一样的数组：

int[,] matrix = new int[,]

{ {0,1,2}, {3,4,5}, {6,7,8}};

锯齿形数组

锯齿形数组在声明时用一对方括号表示一个维度。以下例子声明了一个最外层维度是 3 的二维锯齿形数组：

int[][] matrix = new int[3][];

有趣的是，这里是 new int [3][]

而非 new int [][3]

。Eric Lippert 有一篇精彩的文章（http://albahari.com/jagged

）详细解释了这个问题。

不同于矩形数组，锯齿形数组内层维度在声明时并未指定，每个内层数组都可以是任意长度。每一个内层数组都隐式初始化为 null

而不是一个空数组，因此都需要手动创建：

for (int i = 0; i < matrix.Length; i++)

{ matrix[i] = new int[3];



// Create inner array for (int j = 0; j < matrix[i].Length;

j

++)  matrix[i][j] = i * 3 + j;}

锯齿形数组也可以用具体值进行初始化。以下例子创建了一个和前面例子类似的数组，并在最后额外追加了一个元素：

int[][] matrix = new int[][]

{ new int[] {0,1,2}, new int[] {3,4,5}, new int[] {6,7,8,9}};

2.7.4　简化数组初始化表达式

有两种方式可以简化数组初始化表达式。第一种是省略 new

运算符和类型限制条件：

char[] vowels = {'a','e','i','o','u'};

int[,] rectangularMatrix ={ {0,1,2}, {3,4,5}, {6,7,8}};int[][] jaggedMatrix ={ new int[] {0,1,2}, new int[] {3,4,5}, new int[] {6,7,8,9}};

第二种是使用 var

关键字，使编译器隐式确定局部变量类型：

var i = 3;      // i is implicitly of type int

var s = "sausage";  // s is implicitly of type str

ing// Therefore:var rectMatrix = new int[,]  // rectMatrix is imp

licitly of type int[,]{ {0,1,2}, {3,4,5}, {6,7,8}};var jaggedMat = new int[][]  // jaggedMat is impl

icitly of type int[][]{ new int[] {0,1,2}, new int[] {3,4,5}, new int[] {6,7,8,9}};

数组类型可以进一步应用隐式类型转换规则：可以直接在 new

关键字之后忽略类型限定符，而由编译器推断数组类型：

var vowels = new[] {'a','e','i','o','u'};  // Compiler infers char[]

为了使上述机制工作，数组中的所有元素必须能够隐式转换为一种类型（至少有一个元素是目标类型，而且最终只有一种最佳类型），例如：

var x = new[] {1,10000000000};  // all convertible to long

2.7.5　边界检查

运行时会为所有数组的索引操作进行边界检查。如果用了无效的索引，就会抛出 IndexOutOfRangeException

。

int[] arr = new int[3];

arr[3] = 1;

// IndexOutOfRangeException thrown

数组边界检查对类型安全和调试简化都是非常必要的。

通常，边界检查的性能开销很小，且即时（Just-In-Time，JIT）编译器也会对其进行优化。例如，在进入循环之前预先确保所有的索引操作的安全性，从而避免每次循环中都进行检查。另外 C# 还提供了 unsafe

代码来显式绕过边界检查（参见 4.17 节）。

2.8　变量和参数

变量表示存储着可变值的存储位置。变量可以是局部变量、参数（value

、ref、out

或 in

），字段（实例或静态）以及数组元素。

2.8.1　栈和堆

栈和堆是存储变量的地方。它们分别具有不同的生命周期语义。

栈

栈是存储局部变量和参数的内存块。从逻辑上讲，栈会在函数进入和退出时增加或减少。考虑下面的方法（为了避免干扰，这里省略了输入参数检查）：

static int Factorial (int x)

{ if (x == 0) return 1; return x * Factorial (x-1)

;}

这个方法是递归的，即它调用其自身。每一次进入这个方法的时候，就在栈上分配一个新的 int

，而每一次离开这个方法，就会释放一个 int

。

堆

堆是保存对象（例如引用类型的实例）的内存块。新创建的对象会分配在堆上并返回其引用。程序执行过程中，堆就被新创建的对象不断填充。运行时的垃圾回收器会定期从堆上释放对象，因此应用程序才不会内存不足。只要对象没有被「存活」的对象引用，它就可以被释放。

以下例子中，首先创建了一个 StringBuilder

对象并将其引用赋值给 ref1

变量，之后在其中写入内容。StringBuilder

对象在后续没有使用的情况下可立即被垃圾回收器释放。

之后，创建另一个 StringBuilder

对象赋值给 ref2

，再将引用复制给 ref3

。虽然 ref2

之后便不再使用，但是由于 ref3

保持着同一个 StringBuilder

对象的引用，因此在 ref3

使用完毕之前它不会被垃圾回收器回收。

using System;

using System.

Text;class Test{ static void

Main() {  StringBui

lder ref1 = new Str

i

ngBuilder (

"o

bject1");  Console.W

riteLine (ref1);  // The St

ringBuilder referen

c

ed by ref1

is

now eligible for GC.

StringBui

lder ref2 = new Str

i

ngBuilder (

"o

bject2");  StringBui

lder ref3 = ref2;  // The St

ringBuilder referen

c

ed by ref2

is

NOT yet eligible for

GC.

Console.W

riteLine (ref3);







// object2 }}

值类型的实例（和对象的引用）就存储在变量声明的地方。如果声明为类的字段或数组的元素，则该实例会存储在堆上。

C# 中无法像 C++ 那样显式删除对象。未引用的对象最终将被垃圾回收器回收。

静态字段也会存储在堆上。与分配在堆上的对象（可以被垃圾回收）不同，这些变量一直存活直至应用程序域结束。

2.8.2　明确赋值

C# 强制执行明确赋值策略。在实践中，这意味着在 unsafe

上下文之外无法访问未初始化的内存。明确赋值有三种含义：

局部变量在读取之前必须赋值。

调用方法时必须提供函数的实际参数（除非标记为可选参数，参见 2.8.4 节）。

运行时将自动初始化其他变量（例如字段和数组元素）。

例如，以下示例将产生编译时错误：

static void Main()

{ int x; Console.WriteLin

e

(x);

// Compile-time error}

字段和数组元素会自动初始化为其类型的默认值。以下代码输出 0

，因为数组元素会隐式赋为默认值：

static void Main()

{ int[] ints = new

i

nt[2]; Console.WriteLin

e

(ints[0]);  // 0}

以下代码输出 0

，因为字段会隐式赋值为默认值：

class Test

{ static i

nt

x; static v

oi

d Main() { Conso

le.WriteLine (x); }  // 0}

2.8.3　默认值

所有类型的实例都有默认值。预定义类型的默认值是按位取 0 的内存表示的值：

default

关键字可用于获取任意类型的默认值：

Console.WriteLine (default (decimal)

);  // 0

从 C# 7.1 开始，在可以进行类型推定的情况下无须指定类型信息：

decimal d = default

;

自定义值类型（例如 struct

）的默认值等同于每一个字段都取其默认值。

2.8.4　参数

方法可以有一连串的参数。在调用方法时必须为这些参数提供实际值。在下面的例子中，Foo

方法仅有一个类型为 int

的参数 p

：

static void Foo (int p)

{ p = p + 1;



// Increment p by 1 Console.WriteLine (p)

;

// Write p to screen}static void Main(){ Foo (8);



// Call Foo with an argument of 8}

使用 ref

、in

和 out

修饰符可以控制参数的传递方式：

按值传递参数

默认情况下，C# 中的参数默认按值传递，这是最常用的方式。这意味着在将参数值传递给方法时将创建一份参数值的副本：

class Test

{ static v

oi

d Foo (int p) {  p = p

+

1;        // Incre

ment

p by 1  Consol

e.

WriteLine (p);  // Write

p t

o screen } static v

oi

d Main() {  int x

=

8;  Foo (x

);

// Make

a co

py of x  Consol

e.

WriteLine (x);  // x wil

l st

ill be 8 }}

为 p

赋一个新的值并不会改变 x

的内容，因为 p

和 x

分别存储在不同的内存位置。

按值传递引用类型参数复制的是引用而非对象本身。下例中，Foo

方法中的 String-Builder

对象和 Main

方法中实例化的是同一个对象，但是它们的引用是不同的。换句话说，变量 sb

和 fooSB

是引用同一个 StringBuilder

对象的不同变量：

class Test

{ static v

oi

d Foo (StringBuilder fooSB) {  fooSB.

Ap

pend ("test");  fooSB

=

null; } static v

oi

d Main() {  String

Bu

ilder sb = new StringBuilder();  Foo (s

b)

;  Consol

e.

WriteLine (sb.ToString());  // test }}

由于 fooSB

是引用的一份副本，因此将它赋值为 null

并不会把 sb

也赋值为 null

（然而，如果在声明和调用 fooSB

时使用 ref

修饰符，则 sb

会变成 null

）。

ref 修饰符

在 C# 中，若按引用传递参数则应使用 ref

参数修饰符。在下面的例子中，p

和 x

指向同一块内存位置：

class Test{ static void Foo (ref

int p) {  p = p + 1;        // Increment p by 1  Console.WriteLine (p);  // Write p to screen } static void Main() {  int x = 8;  Foo (ref

x);      // Ask Foo to deal directly with x

Console.WriteLine (x);  // x is now 9 }}

现在给 p

赋新值将改变 x

的值。注意，ref

修饰符在声明和调用时都是必需的，这样就清楚地表明了程序将如何执行。

ref

修饰符对于实现「交换」方法是必要的（3.9 节将介绍如何编写适用于所有类型的「交换」方法）：

class Test

{ static v

oi

d Swap (ref string a, ref string b) {  string

t

emp = a;  a = b;

b = te

mp

; } static v

oi

d Main() {  string

x

= "Penn";  string

y

= "Teller";  Swap (

re

f x, ref y);  Consol

e.

WriteLine (x);  // Teller  Consol

e.

WriteLine (y);  // Penn }}

无论参数是引用类型还是值类型，都可以按引用传递或按值传递。

out 修饰符

out

参数和 ref

参数类似，但在以下几点上不同：

无须在传入函数之前进行赋值。

必须在函数结束之前赋值。

out

修饰符通常用于获得方法的多个返回值，例如：

class Test

{ static v

oi

d Split (string name, out string firstNames,



out string lastName) {   int i

=

name.LastIndexOf (' ');   first

Na

mes = name.Substring (0, i);   lastN

am

e  = name.Substring (i + 1); } static v

oi

d Main() {  string

a

, b;  Split

("

Stevie Ray Vaughan", out a, out b);  Consol

e.

WriteLine (a);           // Stevie Ray  Consol

e.

WriteLine (b);           // Vaughan }}

与 ref

参数一样，out

参数按引用传递。

out 变量及丢弃变量

从 C# 7 开始，允许在调用含有 out

参数的方法时直接声明变量。因此可以将前面例子中的 Main

方法简化为：

static void Main() {  Split ("Stevie Ray Vaughan", out string a, out string b

);



Console.WriteLine (a);           // Stevie Ray

Console.WriteLine (b);           // Vaughan

}

当调用含有多个 out

参数的方法时，若并不关注所有参数的值，那么可以使用下划线来「丢弃」那些不感兴趣的参数：

Split ("Stevie Ray Vaughan", out string a, out _

);  // Discard the 2nd param

Console.WriteLine (a);

此时，编译器会将下划线认定为一个特殊的符号，称为丢弃符号。一次调用可以包括多个丢弃符号。假设 SomeBigMethod

定义了 7 个 out

参数，除第 4 个之外其他的全部被丢弃：

SomeBigMethod (out _, out _, out _, out int x, out _, out _, out _);

出于向后兼容性的考虑，如果在作用域内已经有一个名为 [_] 的变量，这个语言特性就失效了。

string _

;

S

plit ("Stevie Ray Vaughan", out string a, out _);C

onsole.WriteLine (_);   // Vaughan

按引用传递的含义

按引用传递参数是为现存变量的存储位置起一个别名而不是创建一个新的存储位置。下面的例子中，变量 x

和 y

代表相同的实例：

class Test

{ static i

nt

x; static v

oi

d Main() { Foo (

out x); } static v

oi

d Foo (out int y

) {  Consol

e.

WriteLine (x);

// x is 0  y = 1;





// Mutate y  Consol

e.

WriteLine (x);

// x is 1 }}

in 修饰符

in

参数和 ref

参数相似，但前者的参数值无法在方法内更改（如果更改则会产生一个编译时错误）。这个修饰符非常适用于向方法传递大型值类型对象，因为此时编译器不仅可以避免在参数传递时对参数进行拷贝操作而造成开销，还可以保护参数的原始值不被修改。

in

修饰符是重载的一个重要部分：

void Foo (  SomeBigStruct a) { ... }void Foo (in

SomeBigStruct a) { ... }

若希望调用第二个重载方法，则调用者必须使用 in

修饰符。

SomeBigStruct x = ...;Foo (x);   // Calls the first overloadFoo (in

x);  // Calls the second overload

当调用不会造成歧义时：

void Bar (in SomeBigStruct a) { ... }

则 in

修饰符是可选的：

Bar (x);   // OK (calls the 'in' overload)

Bar (in x); // OK (calls the 'in' overload)

需要说明的是为了使上述示例有实际意义，我们将 SomeBigStruct

定义为 struct

类型（请参见 3.4 节）。

params 修饰符

params

参数修饰符只能修饰方法的最后一个参数，它能够使方法接受任意数量的指定类型参数。参数类型必须声明为数组，例如：

class Test{ static int Sum (params int[] ints

)



{

i

nt sum = 0;

f

or (int i = 0; i

< ints.Length; i++)



sum += ints[i];

// Increase sum by i

nts[i]

r

eturn sum;

}

sta

tic void Main()

{

i

nt total = Sum (1

, 2, 3, 4);

C

onsole.WriteLine

(total);       // 10

}}

也可以将普通的数组提供给 params

参数，因此 Main

方法的第一行从语义上等价于：

int total = Sum (new int[] { 1, 2, 3, 4 } );

可选参数

方法、构造器和索引器（见第 3 章）中都可以声明可选参数。只要在参数声明中提供默认值，这个参数就是可选参数：

void Foo (int x = 23

) { Console.WriteLine (x); }

可选参数在调用方法时可以省略：

Foo();   // 23

默认参数 23

实际上传递给了可选参数 x

，编译器在调用端将值 23

传递到编译好的代码中。上例中调用 Foo

的代码语义上等价于：

Foo (23);

这是由于编译器总是用默认值代替可选参数而造成的。

若 public 方法对其他程序集可见，则在添加可选参数时双方均需重新编译，就像参数是必须提供的一样。

可选参数的默认值必须由常量表达式或者无参数的值类型构造器指定，可选参数不能标记为 ref

或者 out

。

必填参数必须在可选参数方法声明和调用之前出现（params

参数例外，它总是最后出现）。下面的例子将 1 显式传递给参数 x

，而将默认值 0 传递给参数 y

：

void Foo (int x = 0, int y = 0) { Console.WriteLine (x + ", " + y); }

void Test(){ Foo(1);  // 1, 0}

相反，如需传递默认值给 x

而传递显式值给 y

，则必须联合使用命名参数与可选参数。

命名参数

除了用位置确定参数外，还可以用名称来确定参数：

void Foo (int x, int y) { Console.WriteLine (x + ", " + y); }void Test(){ Foo (x:1, y:2

); // 1, 2

}

命名参数能够以任意顺序出现。下面两种调用 Foo

的方式在语义上是一样的：

Foo (x:1, y:2);

Foo (y:2, x:1);

上述写法的不同之处是参数表达式将按调用端参数出现的顺序计算。通常，这种不同只出现在非独立的拥有副作用的表达式中。例如下面的代码将输出 0,1：

int a = 0;

Foo (y: ++

a, x: --a); // ++a is evaluated first

当然，在实践中应当避免这种代码。

命名参数和可选参数可以混合使用：

Foo (1, y:2);

然而这里有一个限制：除非参数均出现在正确的位置，否则按位置传递的参数必须出现在命名参数之前。因此可以按照如下方式调用 Foo

方法：

Foo (x:1, 2);     // OK. Arguments in the declared positions

但无法进行如下的调用：

Foo (y:2, 1);     // Compile-time error. y isn't in the first position

命名参数在和可选参数混合使用时特别有效。例如，考虑下面的方法：

void Bar (int a = 0, int b = 0, int c = 0, int d = 0) { ... }

我们可以用以下方式在调用它的时候仅提供 d

的值：

Bar (d:3);

这个特性在调用 COM API 时非常有用，将在第 25 章中详细讨论。

2.8.5　引用局部变量

C# 7 添加了一个令人费解的特性：即定义一个用于引用数组中某一个元素或对象中某一个字段的局部变量：

int[] numbers = { 0, 1, 2, 3, 4 };ref

int numRef = ref

numbers [2];

在这个例子中，numRef

是 numbers [2]

的引用。当更改 numRef

的值时，也相应更改了数组中的元素值：

numRef *= 10;

Console.Write

Line (numRef);    // 20Console.Write

Line (numbers [2]);  // 20

引用局部变量的目标只能是数组的元素、对象字段或者局部变量；而不能是属性（见第 3 章）。引用局部变量适用于在特定的场景下进行小范围优化，并通常和引用返回值合并使用。

2.8.6　引用返回值

第 24 章将讨论 Span<T>

和 ReadOnlySpan<T>

类型。这两种类型使用引用返回值特性实现了非常高效的索引器。除此场景之外，引用返回值鲜有使用。可以将其理解为一个微观性能改进。

从方法中返回的引用局部变量，称为引用返回值（ref return）：

static string x = "Old Value";static ref

string GetX() => ref

x;  // This method returns a refstatic void Main(){ ref

string xRef = ref

GetX();    // Assign result to a ref local

xRef = "New Value"; Console.WriteLine (x);       // New V

alue}

如果在调用端忽略 ref

修饰符，则该调用将会返回一个普通的值：

string localX = GetX(); // Legal: localX is an ordinary non-ref variable.

定义属性或者索引器时也可以使用引用返回值：

static ref

string Prop => ref

x;

注意，这些属性即使不定义 set

访问器也是隐式可写的：

Prop = "New Value";

为了避免修改，可使用 ref readonly

：

static ref readonly

string Prop => ref x;

ref readonly

修饰符在保持了返回引用所带来的性能提升之余还阻止了修改操作。当然，由于 x

是字符串类型（引用类型），因此这种更改在本例中的影响微乎其微。不论字符串有多长，唯一改进的地方是避免了一次 32 位或者 64 位引用的复制。如果使用自定义值类型（请参见 3.4 节），则在将结构体标记为 readonly

的情况下（否则编译器将执行一次防御性质的拷贝）才会切实地改善性能。

试图在返回类型为引用返回值的属性或者索引器中定义 set

访问器是非法的。

2.8.7　var

：隐式类型局部变量

我们通常会一次性完成变量的声明和初始化。如果编译器能够从初始化表达式中推断出变量的类型，就能够使用 var

关键字（C# 3.0 引入）来代替类型声明，例如：

var x = "hello";

var y = new Syst

em.Text.StringBuilder();var z = (float)M

ath.PI;

它们完全等价于：

string x = "hello";

System.Text.StringB

uilder y = new System.Text.StringBuilder();float z = (float)Ma

th.PI;

因为是完全等价的，所以隐式类型变量仍是静态类型的。例如，下面的代码将产生编译时错误：

var x = 5;

x = "hello

";  // Compile-time error; x is of type int

注意，当无法直接从变量声明语句中看出变量类型的时候，var

关键字将降低代码的可读性。例如：

Random r = new Random();

var x = r.Next();

变量 x

的类型是什么呢？

4.10 节将介绍必须使用 var

的场景。

2.9　表达式和运算符

表达式本质上是值。最简单的表达式是常量和变量。表达式能够用运算符进行转换和组合。运算符用一个或多个输入操作数来输出一个新的表达式。

以下是一个常量表达式的例子：

12

可以使用 *

运算符来组合两个操作数（字面量表达式 12

和 30

）：

12 * 30

由于操作数本身可以是表达式，所以可以创造出更复杂的表达式。例如，(12 * 30)

是下面表达式中的操作数。

1 + (12 * 30)

C# 中的运算符分为一元运算符、二元运算符和三元运算符，这取决于它们使用的操作数数量（1、2 或 3）。二元运算符总是使用中缀表示法，即运算符在两个操作数之间。

2.9.1　基础表达式

基础表达式由 C# 语言内置的基础运算符表达式组成，例如：

Math.Log (1)

该表达式由两个基础表达式构成，第一个表达式执行成员查找（用.

运算符），而第二个表达式执行方法调用（用 ()

运算符）。

2.9.2　空表达式

空表达式是没有值的表达式，例如：

Console.WriteLine (1)

因为空表达式没有值，所以不能作为操作数来创建更复杂的表达式：

1 + Console.WriteLine (1)   // Compile-time error

2.9.3　赋值表达式

赋值表达式用 =

运算符将另一个表达式的值赋值给变量，例如：

x = x * 5

赋值表达式不是一个空表达式，它的值即是被赋予的值。因此赋值表达式可以和其他表达式组合。下面的例子中，表达式将 2

赋给 x

并将 10

赋给 y

：

y = 5 * (x = 2)

这种类型的表达式也可以用于初始化多个值：

复合赋值运算符是由其他运算符组合而成的简化运算符（这条规则的例外是第 4 章中介绍的事件，它的 +=

和 -=

运算符会特殊对待并映射至事件的 add

和 remove

访问器上。）：

x *= 2  // equivalent to x = x * 2

x <<= 1  // equivalent to x = x <<

1

2.9.4　运算符优先级和结合性

当表达式包含多个运算符时，运算符的优先级和结合性决定了计算的顺序。优先级高的运算符先于优先级低的运算符执行。如果运算符的优先级相同，那么运算符的结合性决定计算的顺序。

优先级

对于以下表达式：

1 + 2 * 3

由于 *

的优先级高于 +

，因此它将按下面的方式计算：

1 + (2 * 3)

左结合运算符

二元运算符（除了赋值运算符、Lambda 运算符、null

合并运算符）是左结合运算符。换句话说，它们是从左往右计算的。例如，下面的表达式：

8 / 4 / 2

由于左结合性将按如下方式计算：

( 8 / 4 ) / 2  // 1

插入括号可以改变实际的计算顺序：

8 / ( 4 / 2 )  // 4

右结合运算符

赋值运算符、Lambda 运算符、null

合并运算符和条件运算符是右结合的。换句话说，它们是从右往左计算的。右结合性允许多重赋值，例如：

x = y = 3;

首先将 3

赋值给 y

，之后再将表达式的结果 (3)

赋值给 x

。

2.9.5　运算符表

表 2-3 按照优先级列出了 C# 的运算符。同一类别的运算符优先级相同。4.16 节将介绍用户可重载的运算符。

表 2-3：C# 的运算符（按照优先级顺序分类）

表 2-3：C# 的运算符（按照优先级顺序分类）（续）

表 2-3：C# 的运算符（按照优先级顺序分类）（续）

2.10　null 运算符

C# 提供了三个简化 null 处理的运算符：null 合并运算符、null 合并赋值运算符和 null 条件运算符。

2.10.1　null 合并运算符

null 合并运算符写作？

。它的意思是「如果左侧操作数不是 null，则结果为操作数，否则结果为另一个值。」例如：

string s1 = null;

string s2 = s1 ??

"nothing";  // s2 evaluates to "nothing"

如果左侧的表达式不是 null，则右侧的表达式将不会进行计算。null 合并运算符同样适用于可空值类型（请参见 4.7 节）。

2.10.2　null 合并赋值运算符（C# 8）

null 合并赋值运算符写作？=

。它的含义是「如果左侧操作数为 null，则将右侧的操作数赋值给左侧的操作数。」例如：

string s1 = null;

s1 ??= "something

";Console.WriteLine

(s1); // something

s1 ??= "everythin

g";Console.WriteLine

(s1); // something

该运算符可以将如下的模式：

if (myVariable == null) myVariable = someDefault;

简化为

myVariable ??= someDefault;

2.10.3　null 条件运算符

?.

运算符称为 null 条件运算符或者 Elvis 运算符（从 Elvis 表情符号而来）。该运算符可以像标准的「.

」运算符那样访问成员或调用方法。当运算符的左侧为 null 的时候，该表达式的运算结果也是 null，而不会抛出 NullReferenceException

异常。

System.Text.StringBuilder sb = null;string s = sb?.

ToString(); // No error; s instead evaluates to null

上述代码的最后一行等价于：

string s = (sb == null ? null : sb.ToString());

当遇到 null 时，Elvis 运算符将直接略过表达式的其余部分。在下例中，即使 ToString ()

和 ToUpper ()

方法使用的是标准的「.

」运算符，s

的值仍然为 null。

System.Text.StringBuilder sb = null;string s = sb?.

ToString().ToUpper();  // s evaluates to null without error

仅当直接的左侧运算数有可能为 null 的时候才有必要重复使用 Elvis 运算符。因此下述表达式在 x

和 y

都为 null 时依然是健壮的：

x?.y?.z

它等价于（唯一的不同在于 x.y

仅执行了一次）：

x == null ? null

: (x.y

== null ? null : x.y.z)

需要指出，最终的表达式必须能够处理 null，因此以下的范例是非法的：

System.Text.StringBuilder sb = null;int

length = sb?.ToString().Length;  // Illegal : int cannot be null

我们可以使用可空值类型（请参见 4.7 节）来修正这个问题。如果你已经对可空值类型有所了解，请参见如下范例代码：

int?

length = sb?.ToString().Length;  // OK: int? can be null

也可以使用 null 条件运算符调用返回值为 void

的方法：

someObject?.

SomeVoidMethod();

如果 someObject

为 null，则表达式将「不执行指令」而不会抛出 NullReferenceException

异常。

null 条件运算符可以和第 3 章介绍的常用类型成员（包括方法、字段、属性和索引器）一起使用。而且它也可以和 null 合并运算符配合使用。

System.Text.StringBuilder sb = null;string s = sb?.ToString() ??

"nothing";  // s evaluates to "nothing"

2.11　语句

函数是由语句构成的，语句按照出现的字面顺序执行。语句块则是在大括号（{}

）中的一系列语句。

2.11.1　声明语句

声明语句可以声明新的变量，并可以用表达式初始化变量。声明语句以分号结束。可以用逗号分隔的列表声明多个同类型的变量：

string someWord = "rosebud";

int someNumber = 42;bool rich = true, famous = f

alse;

常量的声明和变量声明类似，但是它的值无法在声明之后改变，并且变量初始化必须和声明同时进行（请参见 3.1.2 节）：

const double c = 2.99792458E08;

c += 10;

// Compile-time error

局部变量

局部变量和局部常量的作用范围在当前的语句块中。在当前语句块或者嵌套的语句块中声明另一个同名的局部变量是不行的：

static void Main()

{ int x; {  int y;  int x;



// Erro

r -

x already d

efined } {  int y;



// OK -

y n

ot in scope

} Console.Write (y

);

// Erro

r -

y is out of

scope}

变量的作用范围是它所在的整个代码块（前向和后向都包含）。由于在变量或常量声明之前引用它是不合法的，因此将示例中的 x

初始化移到方法的末尾会得到相同的错误，这个奇怪的规则和 C++ 是不同的。

2.11.2　表达式语句

表达式语句既是表达式也是合法的语句。表达式语句必须改变状态或者执行某些可能改变状态的调用。状态改变本质上指改变一个变量的值。可能的表达式语句有：

赋值表达式（包括自增和自减表达式）

方法调用表达式（有返回值的和没有返回值的）

对象实例化表达式

例如：

// Declare variables with declaration statements:

string s;int x, y;System.Text.StringBuilder sb;// Expression statementsx = 1 + 2;         // Assignment expressi

onx++;            // Increment expressio

ny = Math.Max (x, 5);    // Assignment expressi

onConsole.WriteLine (y);   // Method call express

ionsb = new StringBuilder(); // Assignment expressi

onnew StringBuilder();    // Object instantiatio

n expressi

on

当调用有返回值的构造器或方法时，并不一定要使用它的返回值。因此，除非构造器或方法改变了某些状态，否则以下这些语句完全没有用处：

new StringBuilder();   // Legal, but useless

new string ('c', 3);   // Legal, but useless

x.Equals (y);      // Legal, but useless

2.11.3　选择语句

C# 使用以下几种机制来有条件地控制程序的执行流：

选择语句（if

、switch

）

条件语句（?:

）

循环语句（while

、do-while

、for

和 foreach

）

本节介绍两种最简单的结构：if

语句和 switch

语句。

if 语句

if

语句在 bool

表达式为真时执行其中的语句。例如：

if (5 < 2 * 3)

Console.Writ

eLine ("true");    // true

if

中的语句可以是代码块：

if (5 < 2 * 3)

{ Console.Writ

eL

ine ("true"); Console.Writ

eL

ine ("Let's move on!");}

else 子句

if

语句之后可以紧跟 else

子句：

if (2 + 2 == 5)

Console.Write

Line ("Does not compute");else Console.Write

Line ("False");    // False

在 else

子句中，可以嵌套另一个 if

语句：

if (2 + 2 == 5) Console.WriteLine ("Does not compute");else if (2 + 2 == 4)

Console.WriteLine ("Computes");  // Computes

用大括号改变执行流

else

子句总是与它之前的语句块中紧邻的未配对的 if

语句结合：

if (true)

if (fal

se)  Conso

le.WriteLine(

); else  Conso

le.WriteLine

("executes");

上述代码在语义上等价于：

if (true)

{ if (fal

se

)  Conso

le

.WriteLine();

else  Conso

le

.WriteLine ("

executes");}

可以通过改变大括号的位置来改变执行流：

if (true)

{ if (fal

se

)  Conso

le

.WriteLine();

}else Console

.W

riteLine ("do

es not execute");

大括号可以明确表明结构，这能提高嵌套 if

语句的可读性（虽然编译器并不需要）。需要特别指出的是下面的模式：

static void TellMeWhatICanDo (int age){ if (age >= 35)  Console.WriteLine ("You can be president!"); else if

(age >= 21)  Console.WriteLine ("You can drink!"); else if

(age >= 18)

Console.

WriteLine ("You can vote!"); else  Console.

WriteLine ("You can wait!");}

这里，我们参照其他语言的 elseif 结构（以及 C# 本身的 #elif

预处理指令）来安排 if

和 else

语句。Visual Studio 自动识别这个模式并保持代码缩进。从语义上讲，紧跟着每一个 if

语句的 else

语句在功能上都是嵌套在 else

子句之中的。

switch 语句

switch

语句可以根据变量可能的取值来转移程序的执行。switch

语句有比嵌套 if

语句更加简洁的代码，因为 switch

语句只要求表达式计算一次：

static void ShowCard (int cardNumber)

{ switch (cardNumber) {  case 13:   Console.WriteLine ("King");   break;  case 12:   Console.WriteLine ("Queen");   break;  case 11:   Console.WriteLine ("Jack");   break;  case -1:

//

Joker is -1   goto case 12;

//

In this game joker co

unts

as queen  default:

//

Executes for any othe

r ca

rdNumber   Console.WriteLine (cardNumber);

break; }}

这个例子演示了最一般的情形，即针对常量的 switch

。当指定常量时，只能指定内置的整数类型、bool

、char

、enum

类型以及 string

类型。

每一个 case

子句结束时必须使用某种跳转指令显式指定下一个执行点（除非代码本身就是一个无限循环）。这些跳转指令有：

break

（跳转到 switch

语句的最后）

goto case x

（跳转到另外一个 case

子句）

goto default

（跳转到 default

子句）

其他的跳转语句，例如 return

、throw

、continue

或者 goto label

当多个值要执行相同的代码时，可以按照顺序列出共同的 case

条件：

switch (cardNumber){ case 13:

case 12:

case 11:

Console.WriteLine ("Face card");  break; default:  Console.WriteLine ("Plain card");

break;}

switch

语句的这种特性可以写出比多个 if-else

更加简洁的代码。

按类型 switch

按照类型进行 switch

是带有模式的 switch

语句的一种特殊的使用情况。C# 7 和 C# 8 引入了一系列普遍适用的模式，有关模式的完整讨论请参见 4.12 节。

C# 7 开始支持按类型 switch

：

static void Main(){ TellMeTheType (12); TellMeTheType ("hello"); TellMeTheType (true);}static void TellMeTheType (object x)  // object allows any type.{ switch (x) {  case int i

:   Console.WriteLine ("It's an int!");   Console.WriteLine ($"The square of {i} is {i * i}");   break;  case string s

:



Console.WriteLine ("It's a string");

Console.WriteLine ($"The length of {s}

is {s.Length}");

break;

default:

Console.WriteLine ("I don't know what

x is");

break;

}}

（object

类型允许其变量为任何类型，这部分内容将在 3.2 节和 3.3 节详细讨论。）

每一个 case

子句都指定了一种需要匹配的类型和一个变量（模式变量），如果类型匹配成功就对变量赋值。和常量不同，子句对可用的类型并没有进行任何限制。

when

关键字可用于对 case

进行预测，例如：

switch (x){ case bool b when b == true

:   // Fires only when b is true

Console.WriteLine ("True!");  break; case bool b:  Console.WriteLine ("False!");  break;}

case

子句的顺序会影响类型的选择（这和选择常量的情况有些不同）。如果交换 case

的顺序，则上述示例可以得到完全不同的结果（事实上，上述程序甚至无法编译，因为编译器发现第二个 case

子句是永远不会执行的）。但 default

子句是一个例外，不论它出现在什么地方都会在最后才执行。

如果希望按照类型进行 switch

，但对其值却并不关心，这种情况下可以使用变量「丢弃」（_

）：

case DateTime _

:



Console.WriteLine ("It's a DateTime");

堆叠多个 case

子句也是没有问题的。下面的例子中，Console.WriteLine

会在任何浮点类型的值大于 1 000 时执行：

switch (x){ case float f when f > 1000:

case double d when d > 1000:

case decimal m when m > 1000:

Console.WriteLine ("We can refer to x

here but not f

or d

or m

");



break;}

上述例子中，编译器仅允许在 when

子句中使用模式变量 f

、d

和 m

。当调用 Console.WriteLine

时，它并不清楚到底三个模式变量中的哪一个会被赋值，因而编译器会将它们放在作用域之外。

除此以外，还可以混合使用常量选择和模式选择，甚至可以选择 null

值：

case null

:



Console.WriteLine ("Nothing here");

break;

switch 表达式（C# 8）

C# 8 支持在表达式中使用 switch

。以下示例展示了其使用方法，其中假定变量 cardNumber

是 int

类型：

string cardName = cardNumber switch

{ 13 =>

"King", 12 =>

"Queen", 11 =>

"Jack", _ =>

"Pip card"  // equivalent to 'default'

};

注意，switch

是在变量名称后出现的，且其中的 case

子句相应地变为了以逗号结尾的表达式而不再是语句。switch

表达式相比 switch

语句更加紧凑，且可以用于 LINQ 查询（请参见第 8 章）。

如果在 switch

表达式中忽略默认表达式（_

）同时其他条件匹配失败，则会抛出一个异常。

switch

表达式也支持多变量的选择（元组模式）：

int cardNumber = 12;string suit = "spades";string cardName = (cardNumber, suit)

switch{ (13, "spades")

=> "King of spades", (13, "clubs")

=> "King of clubs",

...};

switch

表达式和各种模式（详情请参见 4.12 节）组合可以获得更多的选择效果。

2.11.4　迭代语句

C# 中可以使用 while

、do-while

、for

和 foreach

语句重复执行一系列语句。

while 和 do-while 循环

while

循环在其 bool

表达式为 true

的情况下重复执行循环体中的代码。这个表达式在循环体执行之前进行检测。例如：

int i = 0;

while (i <

3){ Console.

WriteLine (i);

i++;}OUTPUT:012

do-while

循环在功能上不同于 while

循环的地方是它在语句块执行之后才检查表达式的值（保证语句块至少执行过一次）。以下将上述例子用 do-while

循环进行了重写：

int i = 0;

do{ Console.

Wri

te

Line (i); i++;}while (i <

3)

;

for 循环

for

循环类似一个有特殊子句（用于初始化和迭代循环变量）的 while

循环。for

循环有以下三个子句：

for (initialization-clause; condition-clause; iteration-clause

) statement-or-statement-block

每一个子句的作用如下：

初始化子句：

在循环之前执行，初始化一个或多个迭代变量。

条件子句：

它是一个 bool

表达式，当其为 true

时，将执行循环体。

迭代子句：

在每次语句块迭代之后执行，通常用于更新迭代变量。

例如，下面的例子将打印 0 到 2 的数字：

for (int i = 0; i < 3; i++)

Console.WriteLine (i);

下面的代码将打印前 10 个斐波那契数（每一个数都是前面两个数的和）：

for (int i = 0, prevFib = 1, curFib = 1; i < 10; i++)

{ Console.WriteLine (prevFib); int newFib = prevFib + curFib; prevFib = curFib; curFib = newFib;}

for

语句的这三个部分都可以省略，因而可以通过下面的代码来实现无限循环（也可以用 while (true)

来代替）：

for (;;)

Consol

e.WriteLine ("interrupt me");

foreach 循环

foreach

语句遍历可枚举对象的每一个元素。大多数 C# 和.NET Core 中表示集合或元素列表的类型都是可枚举的。例如，数组和字符串都是可枚举的。以下示例从头到尾枚举了字符串中的每一个字符：

foreach (char c in "beer")  // c is the iteration variable

Console.WriteLine (c);OUTPUT:beer

第 4.6 节将详细介绍可枚举对象。

2.11.5　跳转语句

C# 的跳转语句有 break

、continue

、goto

、return

和 throw

。

跳转语句仍然遵守 try

语句的可靠性规则（参见 4.5 节）。这意味着：

到 try

语句块之外的跳转总是在达到目标之前执行 try

语句的 finally

语句块。

跳转语句不能从 finally

语句块内跳到块外（除非使用 throw

）。

break 语句

break

语句用于结束迭代或 switch

语句的执行：

int x = 0;while (true){ if (x++ > 5)  break

;   // break from the loop

}// execution continues here a

ft

er break...

continue 语句

continue

语句放弃循环体中其后的语句，继续下一轮迭代。例如，以下的循环跳过了偶数：

for (int i = 0; i < 10; i++)

{ if ((i % 2) == 0)    //

I

f i is even,  continue;       //

c

ontinue with next iteration Console.Write (i + " ");}OUTPUT: 1 3 5 7 9

goto 语句

goto

语句将执行点转移到语句块中的指定标签处。格式如下：

goto statement-label

;

或用于 switch

语句内：

goto case case-constant

;  // (Only works with constants, not patterns)

标签语句仅仅是代码块中的占位符，位于语句之前，用冒号后缀表示。下面的代码模拟 for

循环来遍历从 1 到 5 的数字：

int i = 1;startLoop

:if (i <= 5){ Console.Write (i + " "); i++; goto startLoop

;

}

O

UT

P

UT: 1 2 3 4 5

goto case

case-constant

会将执行点转移到 switch

语句块中的另一个条件上（参见本章 2.11.3 节）。

return 语句

return

语句用于退出方法。如果这个方法有返回值，则必须返回方法指定返回类型的表达式。

static decimal AsPercentage (decimal d)

{ decimal p = d * 100m; return p;       // Return to th

e

calling method with valu

e}

return

语句能够出现在方法的任意位置（除 finally

块中），且可以出现超过一次。

throw 语句

throw

语句抛出异常来表示有错误发生（参见 4.5 节）：

if (w == null)

throw new Ar

gumentNullException (...);

2.11.6　其他语句

using

语句用一种优雅的语法在 finally

块中调用实现了 IDisposable

接口对象的 Dispose

方法（请参见 4.5 节和 12.1 节）。

C# 重载了 using

关键字，使它在不同上下文中有不同的含义。特别注意 using

指令和 using

语句是不同的。

lock

语句是调用 Mintor

类的 Enter

和 Exit

方法的简化写法（请参见第 14 章和第 23 章）。

2.12　命名空间

命名空间是一系列类型名称的领域。通常情况下，类型组织在分层的命名空间里，既避免了命名冲突又更容易查找。例如，处理公钥加密的 RSA

类型就定义在如下的命名空间下：

System.Security.Cryptography

命名空间组成了类型名的基本部分。下面代码调用了 RSA

类型的 Create

方法：

System.Security.Cryptography.RSA rsa =

System.Security.Cryptography.RSA.Cre

ate();

命名空间是独立于程序集的。程序集是像.exe

或者.dll

一样的部署单元（参见第 18 章）。命名空间并不影响成员的可见性（public

、internal

、private

等）。

namespace

关键字为其中的类型定义了命名空间。例如：

namespace Outer.Middle.Inner

{ class Class1 {} class Class2 {}}

命名空间中的「.

」表明了嵌套命名空间的层次结构。下面的代码在语义上和上一个例子是等价的：

namespace Outer

{ namespace Mid

dl

e {  namespace I

nn

er  {   class Cla

ss

1 {}   class Cla

ss

2 {}  } }}

类型可以用完全限定名称（也就是包含从外到内的所有命名空间的名称）来指定。例如，上述例子中，可以使用 Outer.Middle.Inner.Class1

来指代 Class1

。

如果类型没有在任何命名空间中定义，则它存在于全局命名空间。全局命名空间也包含了顶层命名空间，就像前面例子中的 Outer

命名空间。

2.12.1　using

指令

using

指令用于导入命名空间。这是避免使用完全限定名称来指代某种类型的快捷方法。以下例子导入了前一个例子的 Outer.Middle.Inner

命名空间：

using Outer.Middle.Inner;class Test{ static void Main() {  Class1 c;  // Don't need fully qualified name

}}

在不同命名空间中定义相同类型名称是合法的（通常也是可取的）。不过，这种做法通常出现在开发者不会同时导入两个命名空间时使用。TextBox

类就是一个典型的例子，这个名称在 System.Windows.Controls

（WPF）和 System.Windows.Forms.Controls

（Windows Forms）命名空间中都有定义。

2.12.2　using static

指令

我们不仅可以导入命名空间，还可以使用 using static

指令导入特定的类型。这样就可以使用类型静态成员而无须指定类型的名称了。下面的例子中，在不指定类型的情况下调用了 Console

类的静态方法 WriteLine

：

using static System.Console;

class Test{ static void Main() { WriteLine

("Hello"); }

}

using static

指令将导入类型的全部可访问静态成员，包括字段、属性以及嵌套类型（参见第 3 章）。同时，该指令也支持导入枚举类型的成员。因此，如果导入了以下的枚举类型：

using static System.Windows.Visibility;

就可以直接使用 Hidden

而非 Visibility.Hidden

：

var textBox = new TextBox { Visibility = Hidden

};  // XAML-style

C# 编译器还没有聪明到可以基于上下文来推断出正确的类型，因此在导入多个静态类型导致歧义时会发生编译错误。

2.12.3　命名空间中的规则

名称范围

外层命名空间中声明的名称能够直接在内层命名空间中使用。以下示例中的 Class1

在 Inner

中不需要限定名称：

namespace Outer{ class Class1 {} namespace Inner {  class Class2 : Class1

{}

}}

使用命名空间分层结构中不同分支中的类型需要使用部分限定名称。在下面的例子中，SalesReport

类继承 Common.ReportBase

：

namespace MyTradingCompany{ namespace Common {  class ReportBase {} } namespace ManagementReporting {  class SalesReport : Common.ReportBase

{}

}}

名称隐藏

如果相同类型名称同时出现在内层和外层命名空间中，则内层名称优先。如果要使用外层命名空间中的类型，必须使用它的完全限定名称：

namespace Outer

{ class Foo { }

namespace Inn

er

{  class Foo {

}

class Test  {   Foo f1;



// = Outer.

I

nner.Foo   Outer.Foo

f

2;  // = Outer.

F

oo  } }}

所有的类型名在编译时都会转换为完全限定名称。中间语言（IL）代码不包含非限定名称和部分限定名称。

重复的命名空间

只要命名空间内的类型名称不冲突就可以重复声明同一个命名空间：

namespace Outer.Middle.Inner

{ class Class1 {}}namespace Outer.Middle.Inner

{ class Class2 {}}

上述例子也可以分为两个不同的源文件，并将每一个类都编译到不同的程序集中。

源文件 1：

namespace Outer.Middle.Inner

{ class Class1 {}}

源文件 2：

namespace Outer.Middle.Inner

{ class Class2 {}}

嵌套的 using

指令

可以在命名空间中嵌套 using

指令，这样可以控制 using

指令在命名空间声明中的作用范围。在以下例子中，Class1

在一个命名空间中可见，但是在另一个命名空间中不可见：

namespace N1

{ class Clas

s1

{}}namespace N2

{ using N1; class Clas

s2

: Class1 {}}namespace N2

{ class Clas

s3

: Class1 {}  //

Co

m

pile-time err

or

}

2.12.4　类型和命名空间别名

导入命名空间可能导致类型名称的冲突，因此可以只导入需要的特定类型而不是整个命名空间，并给它们创建别名。例如：

using PropertyInfo2 = System.Reflection.PropertyInfo;

class Program { PropertyInfo2 p; }

下面的代码为整个命名空间创建了别名：

using R = System.Reflection;

class Program { R.PropertyIn

fo p; }

2.12.5　高级命名空间特性

外部别名

使用外部别名就可以引用两个完全限定名称相同的类型（例如，命名空间和类型名称都相同）。这种特殊情况只在两种类型来自不同的程序集时才会出现。请考虑下面的例子：

程序库 1，编译为 Widgets1.dll

：

namespace Widgets

{ public class Wi

dg

et {}}

程序库 2，编译为 Widgets2.dll

：

namespace Widgets

{ public class Wi

dg

et {}}

当应用程序同时引用 Widgets1.dll

和 Widgets2.dll

时：

using Widgets;

class Test{ static void

M

ain() {  Widget w =



new Widget(

);

}}

以上程序是无法编译的，因为 Widget

类型是有二义性的。外部别名则可以消除应用程序中的二义性。首先需要更改应用程序的.csproj

工程文件，为每一个引用赋予唯一的别名：

<ItemGroup> <Reference Include="Widgets1">  <Aliases>W1</Aliases>

</Reference> <Reference Include="Widgets2">  <Aliases>W2</Aliases>

</Reference></ItemGroup>

接下来就可以使用 extern alias

指令使用这些别名了：

extern alias W1;

extern alias W2;

c

lass Test{



static voi

d

Main()

{

W1.Widge

ts

.Widget w1 = new W1.W

idge

ts.Widget();

W2.Widge

ts

.Widget w2 = new W2.W

idge

ts.Widget();

}}

命名空间别名限定符

之前提到，内层命名空间中的名称「隐藏」外层命名空间中的名称。但是，有时即使使用类型的完全限定名也无法解决冲突。请考虑下面的例子：

namespace N

{ class A {  static

vo

id Main()

=> n

ew A.B();   // Instantiate class B  public

cl

ass B {}



// Nested type }}namespace A

{ class B {

}}

Main

方法可以实例化嵌套类 B

或命名空间 A

中的类 B

。编译器总是给当前命名空间中的标识符以更高的优先级；在这种情况下，将会实例化嵌套类 B

。

要解决这样的冲突，可以使用如下的方式限定命名空间中的名称：

全局命名空间，即所有命名空间的根命名空间（由上下文关键字 global

指定）

一系列的外部别名

「::

」用于限定命名空间别名。下面的例子使用了全局命名空间（这通常出现在自动生成的代码中，以避免名称冲突）：

namespace N

{ class A {  static

vo

id Main()  {   Syste

m.

Console.Wr

iteL

ine (new A.B());   Syste

m.

Console.Wr

iteL

ine (new global::A.B())

;  }  public

cl

ass B {} }}namespace A

{ class B {

}}

以下例子使用了别名限定符（「外部别名」一节中例子的修改版本）：

extern alias W1;

extern alias W2;

class Test{ static void Ma

in() {  W1::Widgets.

Widget w1 = new W

1

::Widgets.W

id

get();  W2::Widgets.

Widget w2 = new W

2

::Widgets.W

id

get(); }}

