Vim’s quickfix list is a core feature that allows us to integrate external tools into our workflow. At its simplest, it maintains a sequence of annotated addresses comprising the filename, line number, column number (optional), and a message. Traditionally, these addresses would be a list of error messages generated by a compiler, but they could just as well be warnings from a syntax checker, linter, or any other tool that emits such output.

We’ll start off by looking at an example workflow: running make in an external shell and navigating to error messages by hand. Then we’ll introduce the :make command, seeing how it can streamline our workflow by parsing error messages from the compiler and making them navigable in the form of the quickfix list.

Tip 106, provides a tour of the most useful commands for navigating the results of running :make. Then in Tip 107, we’ll learn that the quickfix feature has its own form of the undo command.

In Tip 108, we’ll walk through the steps required to configure Vim so that calling :make puts the contents of a JavaScript file through JSLint, generating a navigable quickfix list from the output.

Tip 105 Compile Code Without Leaving Vim

	 	 	 	 Calling an external compiler from Vim saves us from having to leave our editor—and if the compiler reports any errors, Vim provides the means for us to jump between them quickly.

Preparation

We’ll use a small C program to demonstrate. The source files are distributed with this book (for more details, refer to ​Downloading the Examples​). In the shell, change to the code/quickfix/wakeup directory:

​=> ​$ cd code/quickfix/wakeup​

You’ll need gcc to build this program, but don’t feel that you need to install a compiler just to follow this tip. The workflow here demonstrates the task for which the quickfix list was originally conceived (and from which it takes its name). As we’ll soon see, this feature has many other uses.

Compile the Project in the Shell

	 	 The wakeup program provided consists of three files: Makefile, wakeup.c, and wakeup.h. From the shell, we could compile it by running make:

​=> ​$ make​

​<= gcc -c -o wakeup.o wakeup.c

​ wakeup.c:68: error: conflicting types for ‘generatePacket’

​ wakeup.h:3: error: previous declaration of ‘generatePacket’ was here

​ make: *** [wakeup.o] Error 1

The compiler helpfully reports a couple of errors. It’s all very well having this information printed in the terminal, but now we need to navigate to each of the errors so that we can fix them in Vim.

Compile the Project from Inside Vim

Instead of running make in the shell, let’s try building the project from inside Vim. Make sure that you’re in the code/quickfix/wakeup directory and that it includes a Makefile file, and then launch Vim like this:

​<= $ pwd; ls

​ ~/code/quickfix/wakeup

​ Makefile wakeup.c wakeup.h

​=> ​$ vim -u NONE -N wakeup.c​

	 From inside Vim, we can now run the :make command:

​=> ​:make​

​<= gcc -c -o wakeup.o wakeup.c

​ wakeup.c:68: error: conflicting types for ‘generatePacket’

​ wakeup.h:3: error: previous declaration of ‘generatePacket’ was here

​ make: *** [wakeup.o] Error 1

​

​ Press ENTER or type command to continue

We get the same result as when we ran make in the shell—except that Vim does something smart with the output. Instead of just echoing the output from make, Vim parses each line, extracting the filename, line number, and error message. For each warning, Vim creates a record in the quickfix list. We can navigate backward and forward through these records, and Vim jumps to the exact line corresponding to the error message. As Vim’s documentation on quickfix says (quickfixⓘ), it allows us to「speed up the edit-compile-edit cycle.」

Vim jumps to the first record in the quickfix list when we run :make. In our case, we should find ourselves in the file wakeup.c at the top of this function:

​ ​void​ generatePacket(​uint8_t​ *mac, ​uint8_t​ *packet)

​ {

​ ​int​ i, j, k;

​ k = 6;

​ ​for​ (i = 0; i <= 15; i++)

​ {

​ ​for​ (j = 0; j <= 5; j++, k++)

​ {

​ packet[k] = mac[j];

​ }

​ }

​ }

The error message reports「conflicting types for ‘generatePacket’.」We can skip to the next location in the quickfix list by running the command :cnext. In this case, we jump to the file wakeup.h and find ourselves on this line:

​ ​void​ generatePacket(​char​ *, ​char​ *);

That explains why the compiler was complaining: the signature for this function in the header file doesn’t match the one used in the implementation. Let’s change the line in the header file to use the uint8_t type. Make it so:

​ ​void​ generatePacket(​uint8_t​ *, ​uint8_t​ *);

Save the changes to the file, and then we’ll call :make again:

​=> ​:write​

​=> ​:make​

​<= gcc -c -o wakeup.o wakeup.c

​ gcc -o wakeup wakeup.o

This time the program compiles successfully. Our quickfix list is updated to use the output from the latest invocation of make. No errors are reported, so our cursor stays put.

Don't Lose the Place

When we run the :make command, Vim automatically jumps to the first error (unless there are none). If we prefer that our cursor remain where it is, we can instead run this:

​=> ​:make!​

The trailing ! character tells Vim to update the quickfix list without jumping to the first item. Now suppose that we run :make and immediately realize that we should have used the bang version. How can we get back to where we were before we ran :make? Simple: use the <C-o> command to jump back to the previous position in the jump list. See Tip 56, for more details.

Tip 106 Browse the Quickfix List

	 	 	 The quickfix list holds a collection of locations from one or more files. Each record could be an error raised by the compiler when running :make, or it could be a search match from running :grep. No matter how the list was forged, we must be able to navigate these records. In this tip, we’ll review the ways of browsing the quickfix list.

An exhaustive list of commands for navigating the quickfix list can be found by looking up quickfixⓘ. Table 17, ​Commands for Working with the Quickfix List​ shows some of the most useful.

* * *

Table 17. Commands for Working with the Quickfix List

CommandAction

:cnext

		 		Jump to next item

:cprev

		 		Jump to previous item

:cfirst

		 		Jump to first item

:clast

		 		Jump to last item

:cnfile

		 		Jump to first item in next file

:cpfile

		 		Jump to last item in previous file

:cc N

		 		Jump to nth item

:copen

		 		Open the quickfix window

:cclose

		 		Close the quickfix window

:cdo {cmd}

		 Execute {cmd} on each line listed in the quickfix list

:cfdo {cmd}

		 Execute {cmd} once for each file listed in the quickfix list

* * *

They all begin with :c. The location list (see ​Meet the Location List​) has equivalents for all of these commands, each beginning with :l, such as :lnext, :lprev, and so on. The :ll N command, which jumps to the nth item in the location list, makes a natural diversion from this pattern.

Meet the Location List

	 	 	 	 For every command that populates the quickfix list, there’s a variant that places the results in a location list instead. While :make, :grep, and :vimgrep use the quickfix list, :lmake, :lgrep, and :lvimgrep use the location list. So what’s the difference? At any given moment, there can be only one quickfix list, but we can create as many location lists as we want.

Suppose that we’ve followed the steps in Tip 108, so that running :make in a JavaScript file passes the contents of the file through JSLint. Now let’s say that we’ve got two different JavaScript files open in split windows. We run :lmake to compile the contents of the active window, which saves any error messages to the location list. Then we switch to the other window and run :lmake again. Rather than overwriting the existing location list, Vim creates a new one. Now we have two location lists, each containing errors for a different JavaScript file.

Any commands that interact with a location list (:lnext, :lprev, and so on) will act on the list that is bound to the currently active window. Compare this with the quickfix list, which is available globally throughout Vim: no matter which tab page or window is active, when you run :copen, the quickfix window will show the same list.

Basic Quickfix Motions

We can iterate forward and backward through the items in the quickfix list with the :cnext and :cprevious commands. If we want to skip to the start or end of the list, we can do so with the :cfirst and :clast commands. We’ll use these four commands a lot, so it’s a good idea to map them to something easier to reach. See the discussion of the unimpaired plugin for a suggestion.

Quickfix Fast Forward/Rewind

Both :cnext and :cprev can be prepended with a count. So instead of stepping through every item in the quickfix list one by one, we could skip through them five at a time by running this:

​=> ​:5cnext​

Suppose that we’re browsing through the quickfix list and we come upon a file with dozens of matches, none of which are of much interest to us. In this scenario, rather than stepping through the results one at a time (or even ten at a time), it would be handy if we could just skip all of the results in that file by jumping to the first record in the next file. That’s what the :cnfile command does. As you’d expect, the :cpfile does the same in reverse, jumping to the last quickfix record in the previous file.

Use the Quickfix Window

	 	 We can open a window containing the contents of the quickfix list by running :copen. In some ways, this window behaves like a regular Vim buffer. We can scroll up and down with the k and j keys, and we can even use Vim’s search feature on the contents of the quickfix list.

The quickfix window has special behavior of its own. If we position our cursor on it and press the <CR> key, then that file will be opened with our cursor positioned on the line containing the match. The file usually opens in the window directly above the quickfix window, but if the file is already open in a window in the current tab page, then that buffer will be reused.

Note that each line in the quickfix window corresponds to a record in the quickfix list. If we run :cnext, then the cursor position will move down one line in the quickfix window, even when that window is not active. Conversely, if we use the quickfix window to jump to an item in the quickfix list, then the next time we run :cnext we’ll go to the item after the one we selected in the quickfix window. Selecting an item from the quickfix window is much like running the :cc [nr] command but with an intuitive visual interface.

We can close the quickfix window as usual by running :q when the window is active. But we can also close it by running :cclose when any other window is active.

Tip 107 Recall Results from a Previous Quickfix List

	 	 When we update the quickfix list, Vim doesn’t overwrite the previous contents. It saves the results of older quickfix lists, allowing us to refer back to them.

		 		 		We can recall an older version of the quickfix list (Vim holds onto the last ten lists) by running the :colder command (sadly, there is no :warmer command). To revert from an old quickfix list back to a newer one, we run :cnewer. Note that both :colder and :cnewer commands can accept a count, which causes the respective command to be run the specified number of times.

If we open the quickfix window after running :colder or :cnewer, its status line will indicate the command that was run to generate that particular list.

You can think of the :colder and :cnewer commands as being like undo and redo for the quickfix list. That means it’s cheap for us to try out commands that repopulate the quickfix list because we can always run :colder to revert to the previous list. Also, instead of repeating a :make or :grep command, we could pull up the results from the last time it was executed (unless we’ve changed any files). This can be a real time saver, especially if the command takes a long time to run.

Tip 108 Customize the External Compiler

	 	 	 	 Vim’s :make command isn’t limited to calling the external make program; it can execute any compilers available on your machine. (Note that Vim’s definition of「compiler」is looser than what you may be used to; see ​‘:compiler’ and ‘:make’ Are Not Just for Compiled Languages​.) In this tip, we’ll set up the :make command so that it passes a JavaScript file through JSLint and then uses the output to populate the quickfix list.

	 	 	 First, we’ll configure Vim so that running :make calls nodelint,[26] a command-line interface to JSLint.[27] It depends on Node.js and can be installed using NPM simply by running this:[28]

​=> ​$ npm install nodelint -g​

As a test case, we’ll use this JavaScript implementation of FizzBuzz:

quickfix/fizzbuzz.js

​ ​var​ i;

​ ​for​ (i=1; i <= 100; i++) {

​ ​if​(i % 15 == 0) {

​ console.log(​'Fizzbuzz'​);

​ } ​else​ ​if​(i % 5 == 0) {

​ console.log(​'Buzz'​);

​ } ​else​ ​if​(i % 3 == 0) {

​ console.log(​'Fizz'​);

​ } ​else​ {

​ console.log(i);

​ }

​ };

Configure ‘:make’ to Invoke Nodelint

	 	 The ‘makeprg’ setting allows us to specify the program that will be called when we run :make (see 'makeprg'ⓘ). We can instruct Vim to run nodelint as follows:

​=> ​:setlocal makeprg=NODE_DISABLE_COLORS=1\ nodelint\ %​

The % symbol is expanded to the path for the current file. So if we were editing a file called ~/quickfix/fizzbuzz.js, then running :make inside Vim would be equivalent to running this in the shell:

​=> ​$ export NODE_DISABLE_COLORS=1​

​=> ​$ nodelint ~/quickfix/fizzbuzz.js​

​<= ~/quickfix/fizzbuzz.js, line 2, character 22: Unexpected '++'.

​ for (i=1; i <= 100; i++) {

​ ~/quickfix/fizzbuzz.js, line 3, character 15: Expected '===' ...

​ if(i % 15 == 0) {

​ ~/quickfix/fizzbuzz.js, line 5, character 21: Expected '===' ...

​ } else if(i % 5 == 0) {

​ ~/quickfix/fizzbuzz.js, line 7, character 21: Expected '===' ...

​ } else if(i % 3 == 0) {

​ ~/quickfix/fizzbuzz.js, line 12, character 2: Unexpected ';'.

​ };

​ 5 errors

By default, nodelint highlights errors in red using ANSI color codes. Setting NODE_DISABLE_COLORS=1 mutes the colors, which makes it easier to parse the error messages.

Next, we have to make Vim parse the output from nodelint so that it can build a quickfix list from the results. We can approach this problem in two ways: we could configure nodelint so that its output resembled the error messages generated by make, which Vim already understands, or we could teach Vim how to parse the default output from nodelint. We’ll use the latter technique.

Populate the Quickfix List Using Nodelint’s Output

	 	 	 The ‘errorformat’ setting allows us to teach Vim how to parse the output generated by running :make (see 'errorformat'ⓘ). We can inspect the default value by running the following:

​=> ​:setglobal errorformat?​

​<= errorformat=%*[^"]"%f"%*\D%l: %m,"%f"%*\D%l: %m, ...[abridged]...

If you’re familiar with scanf (in C), then you’ll recognize the concept. Each of the characters preceded by a percent sign has a special meaning: %f stands for the filename, %l for the line number, and %m for the error message. For the complete list, look up errorformatⓘ.

To parse the output from nodelint, we could set the error format as follows:

​=> ​:setlocal efm=%A%f\,\ line\ %l\,\ character\ %c:%m,%Z%.%#,%-G%.%#​

Now when we run :make, Vim will use this error format to parse the output from nodelint. For each warning it will extract the filename, line number, and column number to generate an address, which becomes a record in the quickfix list. That means we can jump between warnings using all of the commands discussed in Tip 106.

Set Up ‘makeprg’ and ‘errorformat’ with a Single Command

This ‘errorformat’ string is not something we would want to commit to memory. Instead, we can save it to a file and then activate it with the :compiler command, which is a convenient shortcut for setting both ‘makeprg’ and ‘errorformat’ options (see :compilerⓘ):

​=> ​:compiler nodelint​

	 The :compiler command activates a compiler plugin, which sets the ‘makeprg’ and ‘errorformat’ options to run and parse nodelint. It’s roughly equivalent to sourcing these lines of configuration:

quickfix/ftplugin.javascript.vim

​ ​setlocal​ makeprg=NODE_DISABLE_COLORS=1\ nodelint\ %

​

​ ​let​ &​l​:efm=​'%A'​

​ ​let​ &​l​:efm.=​'%f\, '​

​ ​let​ &​l​:efm.=​'line %l\, '​

​ ​let​ &​l​:efm.=​'character %c:'​

​ ​let​ &​l​:efm.=​'%m'​ . ​','​

​ ​let​ &​l​:efm.=​'%Z%.%#'​ . ​','​

​ ​let​ &​l​:efm.=​'%-G%.%#'​

The internals of a compiler plugin are more elaborate, but this is a fair approximation of what goes on. You can familiarize yourself with the compiler plugins that are distributed with Vim by running this command:

​=> ​:args $VIMRUNTIME/compiler/*.vim​

Note that Vim doesn’t ship with a nodelint compiler plugin, but we can easily install one.[29] If we wanted to always use nodelint as the compiler for JavaScript files, we could either use an autocommand or a file-type plugin to make it so. To find out how, see ​Apply Customizations to Certain Types of Files​.

‘:compiler’ and ‘:make’ Are Not Just for Compiled Languages

	 	 	 	 The words make and compile have particular meanings in the context of a compiled programming language. But in Vim, the corresponding :make and :compile commands have more flexible definitions, making them just as applicable for interpreted languages and markup formats.

	 	 For example, when working on a LaTeX document, we can configure Vim so that the :make command compiles our .tex file into a PDF. Or if we’re working with an interpreted language such as JavaScript, we can have :make run our source code through JSLint or some other (less opinionated) syntax checker. Alternatively, we could set up :make so that it runs the test suite.

In Vim’s terminology, a compiler is any external program that does something with our document and produces a list of errors or warnings. The :make command simply invokes the external compiler and then parses the output to construct a navigable quickfix list from them.

Footnotes

[26]

https://github.com/tav/nodelint

[27]

http://jslint.com/

[28]

http://nodejs.org/ and http://npmjs.org/, respectively.

[29]

https://github.com/bigfish/vim-nodelint

Copyright © 2016, The Pragmatic Bookshelf.

Chapter 18

Search Project-Wide

with grep, vimgrep, and Others

