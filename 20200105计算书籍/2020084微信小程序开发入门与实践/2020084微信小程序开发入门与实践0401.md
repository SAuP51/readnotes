# 04 文章列表页面

在编写完「welcome」欢迎页面后，我们将编写文章列表部分。文章列表部分展示了一个 banner 轮播图与一组文章。在编写此部分功能时，我们会介绍使用 swiper 组件构建 banner！轮播图以及 Swiper 组件的其他属性；详细介绍 image 组件的 4 种缩放模式与 9 种裁剪模式，全面理清官方文档中没有详细说明的一些知识点。

除此之外，小程序最重要的数据绑定将出现在本章中。数据绑定是小程序中最重要的概念，它是和传统的 Web 网页编程相比最大的不同。在小程序中，几乎所有和数据相关的操作都只能使用数据绑定来完成。本章我们还会重温在传统网页中经常使用到的「事件」，一起来看看小程序中的事件和传统网页中的事件有什么异同。

## 4.1 文章列表页面元素分析及准备工作

上ー章我们一起完成了 Orange Can 的第一个页面：welcome 欢迎页。虽然简单，但它基本描述了小程序的开发模式。本章我们来构建第二页面：文章页面。该页面的设计图可参考本书彩页部分图片。

文章页面主体部分由两部分构成，上半部分是一个轮播图，下半部分是文章列表。

轮播图目前来说已经成为各大电商网站首页的标配元素，如图 4-1 所示。

轮播图每隔几秒钟图片会自动更换一张。在小程序中，我们不需要自己编写代码来实现这样的轮播图效果，小程序已经提供了一个现成的组件 —— Swiper。

下半部分是多篇文章构成的文章列表。每篇文章包含文章标题、文章头图、文章概要、评论数和阅读数。我们依然只需要使用在上一章中介绍的 3 个组件：view、image 和 text，即可实现这个文章列表。

先来创建文章列表页面的相关文件。

在 pages 目录下新建一个名为 post 的目录，然后依次在 post 目录下新建阅读页面所需要的 4 个文件。

建议使用 3.2 小节中介绍的快捷创建页面目录及文件的方法，一个个地创建 4 个页面文件实在太麻烦。如果你是一个个地手动新建页面文件，那么请注意添加 3.2 小节中我们讲到的页面默认必备代码，否则小程序会报错。创建后的项目目录如图 4-2 所示。

现在有个问题，我们要编写阅读页面，但我们的启动页面已经设置成了 welcome 欢迎页面。在不编写「开启小程序之旅」这个 button 跳转页面功能之前，我们没办法看到文章页面。实现 button 跳转页面的功能，需要用到小程序事件和 Javascript 代码，我们先尽可能地熟悉小程序页面骨架的编写，稍微复杂一些的事件和 Javascript 代码留在后面的章节讲解。

先做一个调整。在之前章节里我们提到过，小程序启动后显示的首页，由 app.json 文件里 pages 数组的第一个元素決定。我们暂时先将首页调整成 post 页面。

在 app.json 的 pages 数组里加入 post 页面路径，注意它必须是 pages 数组的第一个元素，位于 welcome 页面之前。代码清单如下：

更改完成后，现在保存或者重新编译项目，启动页面将不再是 welcome 页面，而变成了 post 页面。

在小程序的 images 目录下新建一个子目录 post，并将阅读页面所需要的图片素材拷贝到该目录下。读者可以自行选择自己喜欢的图片素材，或者访问前言中（项目资源文件及源代码及如何阅读本书）中所提供的地址来获取素材。图片的像素大小要大于或者等于 750（宽）和 600（高），过小的图片会出现「留白」的情况。图 4-3 显示了本书所使用图片素材的目录情况，本书后续将不再一一展示图片目录，请读者朋友自行将图片路径填写正确。

完成以上准备工作后，就可以开始编写文章页面了。

## 4.2 Swiper 组件

本小节，我们来学习小程序提供的滑动视图容器 —— swiper 组件，在 post.wxml 中加入以下代码：

```
<view >
<swiper >
<swiper-item >
<image src="/images/post/post-1@text.jpg" />
</swiper-item>
<swiper-item >
<image src="/images/post/post-2@text.jpg" />
</swiper-item>
<swiper-item >
<image src="/images/post/post-3@text.jpg" />
</swiper-item>
</swiper>
</view>
```

最外层的 \<view>\</view> 将作为整个页面的容器，在 view 的内部，我们加入了ー个 swiper 组件，swiper 组件主要由多个 swiper-item 组成，可以定义任意多个 swiper-item。同时，需要注意的是，swiper 组件的直接子元素只可以是 swiper-item，如果放置其他组件，则会被自动删除。但 swiper-item 下是可以放置其他组件或者元素的。swiper-item 元素仅仅只是一个容器，如果要显示内容，需要在 swiper-item 容器下再添加元素内容。如代码清单 4-2 所显示的一样，我们在每个 swiper-item 内都加入了一个 image 组件，用来显示 UI 效果图中的轮播图片，图片路径请根据自己顼目的实际情况做出相应的修改。

添加完代码后，保存一下项目看看结果，如图 4-4。

swiper 组件的第一个 swiper-item 元素图片已经显示出来了。在动手设置 swiper 组件的样式前首先在 post.wxss 文件内，将 swiper 组件的宽度和高度设置好。

添加完代码后，保存预览，发现图片的显示尺寸依然不正确。宽度没有呈现 100%，高度也不是期望的 600 rpx。还需要对 image 组件设置同样的样式，在 post.wxss 中添加 image 组件的样式，添加完成后的页面代码如代码清单 4-4。

此时再次预览小程序，发现样式已经符合预期的效果了，如图 4-5 所示。

```
swiper{
  width: 100%;
  height: 600rpx;
}

swiper image{
  width: 100%;
  height: 600rpx;
}
```

这里需要同时设置 swiper 组件和 image 组件的高宽，才能达到预期的效果。如果只设置 image 组件的高度同样是不可以的，读者可以把 swiper 组件的样式注释掉，看看只对 image 设置样式的结果。

要实现轮播效果，还要为 swiper 组件添加一些属性，分别是：indicator-dots、autoplay、interval，如代码清单 4-5 所示。

```
<view >
<swiper indicator-dots="{{true}}" autoplay="{{true}}" interval="5000">
<swiper-item >
<image src="/images/post/post-1@text.jpg" />
</swiper-item>
<swiper-item >
<image src="/images/post/post-2@text.jpg" />
</swiper-item>
<swiper-item >
<image src="/images/post/post-3@text.jpg" />
</swiper-item>
</swiper>
</view>
```

保存后预览一下效果。图片开始了轮播，每隔 5 秒钟更换一张。同时 swiper 组件上出现了 3 个小圆点，用来指示当前图片。

简单介绍一下这 3 个属性。

1、indicator-dots，Boolean 类型。用来指示是否显示面板指示点（上文提到的 3 个小圆点就是面板指示点，默认为 false。

2、autoplay，Boolean 类型。用来决定是否自动播放，默认为 false。

3、interval，Number 类型。用来设置 swiper-item 的切换时间间隔，默认为 5000 毫秒。

除了自动切换图片，swiper 组件还可以通过拖动图片来进行切换，也可以通过点击面板指示点来切换。官方在 0.11.12210 版本中为 swiper 组件新增了一个 circular 属性，这个属性可以使轮播图循环滚动。如果 circular 为 false，那么当 swiper 组件滚动到第三张图片后就无法继续滚动了；但如果增加一个 circular 为 true 的属性，则当 Swiper 组件滚动到第三张图片后，会继续向第一张图片滚动，从而形成循环滚动。swiper 组件的属性使用方式都比较简单，更多属性请参考官方 API 文档。

## 4.3 Boolean 值的陷阱

这里介绍一个文档里没有提到的属性：vertical。这个属性将指明 swiper 组件面板指示点的排布方向是水平还是垂直，将 vertical="true"，加入到 swiper 的属性中。保存后，我们发现 swiper 组件的面板指示点由原来的水平排布更改为垂直排布，出现在组件的右侧。

那如果把 vertica 属性改为 False！呢？形如，vertical-="false"。此时，面板指示点如何排列？它依然和 vertical="true" 时的排列方向一样，呈垂直排布。为什么会出现这样的情况？我们可以把 vertical 的属性值更改为任何字符串，再看看效果。形如 vertical="aaa"、vertical-="bb" 等属性值都会让指示面板呈垂直分布。而 vertical=" " 则呈水平分布。

我们应该可以从上面的属性举例中找出原因了。即使我们将 vertical 的值设置为 false，但这里的 false 并不是 Boolean 类型，而是一个字符串。只要不是空字符串，那么在 Javascript 里都会认为这是一个 true。所以，设置效果是一样的，vertical 属性被认为设置成了 true。

如果想让面板指示点水平排列，有以下几种方式：1）不加入 vertical 属性。2）vertical=" "。3）vertical="{{false}}"。

以上几种写法，小程序都会认为你将 vertical 属性设置成了 false。第三种写法，是我们后面要学习到的核心知识：数据绑定。这种写法，让 "{{false}}" 里的 false 被认为是一个 Boolean 类型的变量，而不是一个字符串，从而实现 false 即是假，true 即是真的效果。

当然，swiper 的 vertical 属性如果设置错误，一眼就能看出问题来。但如果是其他无法直接在 UI 上表现的属性出现了真假错误，就不是那么容易排查了，可能会浪费掉我们大量的时间。所有组件的 Boolean 类型属性都有这样的 Boolean 陷阱，比如，本例中的 indicator-dots 和 autoplay 也存在这个问题。

## 4.4 构建文章列表的骨架和样式

完成了 swiper 轮播图后，我们继续来构建设计图中的下半部分一文章列表。设计图见本书彩页部分。

正如前文所讲，构建文章列表依然只需要我们熟悉 3 个组件：view、text 和 image。将代码清单 4-6 的代码添加在 swiper 组件代码后面。

保存后，效果如图 4-6 所示。

由于还没有加入 CSS 代码，所以整个页面的布局乱七八糟，但文章列表所有的元素都已经呈现在了页面中。将代码清单 4-7 的代码加入到 post.wxss 文件中。

保存预览一下，效果将如图 4-7 所示。

还有些小小的问题：「Jan 28 2017」和「108、92」这几个文本的字体大小与颜色都不太好看。我们可以将一些默认的字体样式放在 app.wxss 全局样式表里。保存后，日期和数量都呈现出 app. Wxss 里设置的样式。

## 4.5 image 组件的 4 种缩放模式与 9 种裁剪模式

4 种缩放模式和 9 种裁剪模式如果从理论上完全精确理解，还是有稍许的难度的。但这里笔者建议各位开发者，没有必要完全从理论上搞清楚这些模式。当遇到具体问题时，尝试多去更换几个属性，找到最适合自己需求的属性即可。

来看看上个小节中雪糕图片的显示问题，很明显整个图片被压缩变形了。这并不是我们想要的结果。

post-image 这个元素的高宽分别被设置成 340 rpx 和 100% (iphone 6 下就是 750 rpx），而雪糕图片素材原始高宽分别为 600 px 和 750 px。

在现实的项目中，我们经常要面对原始图片的尺寸和设计图里的尺寸不一样的情況（尤其是原始图片高宽是未知和不固定的情况，比如动态从网络获取图片）。在这种情况下，我们必须要有所舍弃，或放弃等比例，或裁剪掉图片的一部分。接受不完美，也是编程中很重要的心态，如何选择，需要看业务上的需求。具体到文章列表图片，我们需要的是保持宽高比，接受部分裁剪（现实项目中，绝大多数情况下，图片保持比例、允许裁切是最普遍的需求）。

小程序的 image 组件提供了 4 种缩放模式和 9 种裁剪模式，来支持我们的选择。

4 种缩放模式：1）scaleToFill 不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素。2）aspectFit 保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。3）aspectFill 保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。4）widthFis 宽度不变，高度自动变化，保持原图宽高比不变（0.11.122100 版本新增）。

9 种裁剪模式：1）top 不缩放图片，只显示图片的顶部区域。2）bottom 不缩放图片，只显示图片的底部区域。3）center 不缩放图片，只显示图片的中间区域。4）left 不缩放图片，只显示图片的左边区域。5）right 不缩放图片，只显示图片的右边区域。6）top left 不缩放图片，只显示图片的左上边区域。7）top right 不缩放图片，只显示图片的右上边区域。8）bottom left 不缩放图片，只显示图片的左下边区域。9）bottom right 不缩放图片，只显示图片的右下边区域。

每种模式的字面意思都很好理解。要更改图片的裁剪或缩放模式，只需要给 image 组件加上ー个 mode 属性值。我们来看一下这 13 种不同属性值的实际效果。

### 4.5.1 scaleToFill

保存预览一下，文章图片好像并没有发生任何变化。这是因为 scale ofill 模式是缩放的默认模式，如果缺省了 mode，则小程序也会以 scaletofilll 的模式来缩放图片。scaletof 模式将改变图片的高宽比，强行让图片更改为样式指定的尺寸，使图片变形（如果原始图片的宽高比例和要缩放的目标宽高比例相同，则不会变形，只是整体上放大或者缩小了）。

### 4.5.2 aspectFit

再来看看 mode= aspectFit 的情况，如图 4-8 所示。同样不是我们要的效果。官方文档的解释：aspectFit 模式保持纵横比缩放图片，使图片的长边能完全显示出来。这个解释从字面上来看，并不是很容易理解，我们可以这样理解这种模式，假想有一个容器，这个容器的高宽等同于 image 将要被缩放的目标尺寸。比如在当前的事例中，这个容器的高宽就是样式 post-image，所设置的高 320 rpx，宽 100%（iphone6 下为 750 rpx）。aspectfite 的特点就是保持图片不变形，且容器要「刚好」将这个图片装进去。注意是「刚好」。如果原始图片比容器大，就要被等比例缩小；而原始图片如果比容器小，则要被等比例放大。一直放大或者缩小到图片的某一条边刚好和容器的一条边重合，而另一条边不能超出容器，也不能小于容器太多。

再回头看看图 4-8，宽刚好和容器相贴合，而高则刚好能被容器装进去，既没有超出容器，也没有比容器矮太多。同时整个图片保持了原始图片的宽高比，没有変形。所以官方文档的解释，没有把这种模式的特点完全描述出来。事例里用到的图片是大于容器的，所以图片会被缩小；开发者们可以尝试着用一张小于容器的图片替换这张雪糕图，试试 aspectFit 的效果如图 4-9 和图 4-10 所示。

### 4.5.3 aspectFill

再看看 mode= aspectfille 的效果，如图 4-11 所示。

aspectFill 同样保持图片的高宽比不会变形。但它有个特点，它会让图片完全填满整个容器，类似于 scaletofill 这种模式。不同的是 scaletofill 会改变图片的高宽比，而 aspectfill 不会。用我们上面提到的「容器」的观点来理解 aspectFill，既然 aspectFill 定要填满整个容器，那么首先要让这张图片的整体尺寸是大于这个容器的，不能留下任何的空白。对于原始尺寸小于容器的，就等比例放大图片（任意一边小于容器都需要放大，否则就会留下空白），让图片的某一边刚好接触容器的一边，同时另外一边又不会小于容器（可以超出，因为这边会被截取）。

如果原始尺寸大于容器，则需要等比例缩小，缩小的要求同样是一边刚好接触容器，另外一边要等于或者超出容器。这样就保证了图片可以完全填满整个容器，但某一边要发生截取。那么问是题来了，如何截取？在超出容器的这一边上，是保留图片的上部、中部还是下部？答案是：中部。注意观察图中的雪糕和原始图片，发现正中间部分被保留了下来。开发者可以自行多換几张素材图看看截取的效果。

### 4.5.4 widthFix

widthFix 属性是小程序 0.11.122100 版本中新增的属性。这个属性的最大特点是，图片将不会按照设定的尺寸呈现，比如设置 image 宽度为 750 rpx，高度为 340 rpx，如果设置 mode= widthFix，则图片最终不会按照 750 rpx 和 340 rpx 呈现，除非原始图片恰好是这个尺寸。这个属性让宽缩放至指定尺寸，再动态计算高度，如图 4-12 所示。虽然宽度按照我们设定的尺寸呈现，但高度突破了 340 rpx。

## 4.5 9 种裁剪模式

9 种裁剪模式非常容易理解，我们举例看看其中的几种。同样建议开发者参考上ー小节中，我们想象的一个容器，这个容器用来裁剪图片的不同部位。将 post-image 的 mode 属性设置为 top，效果如图 4-13 所示。top 模式只保留图片的上部，裁剪掉了剩余部分。注意，这种模式不会缩放图片。我们可以仔细地再观察一下图中的图片，不仅仅是裁剪掉了图片的下部，上部水平方向也发生了裁剪。因为图片不会缩放，我们所设置的容器不能够在水平方向上完全把图片装进去，所以水平方向也发生了裁剪。这点是大家要注意的。

不同于 4 种缩放模式，裁剪模式是不会缩放图片的。用一张小图片来替换上面的大图，比如用 avatar 头像图片，替换后的效果如图 4-14 所示。明显可以看到，由于图片的原始尺寸小于容器的尺寸，裁剪模式也不会使图片发生缩放，所以结果就是不会裁剪图片。接着我们再将 mode 设置为 bottom right，效果如图 4-15 所示，图片只被保留了右下角部分，其余部分全部被裁剪掉了。其他几种裁剪类型从字面意思上都非常好理解，就不在这里 一一 列举了，开发者可以自行替换 mode 的属性值，看看裁剪效果。

## 4.6 完成静态文章列表

先把上节更改的 post-image 的 mode 属性恢复成我们需要的 mode=aspectFill，现在，文章列表还只有 1 篇文章。1 篇文章如何叫做文章列表？为了多几篇文章，我们将代码清单 4-6 的代码再复制几份，依次加入到 post.wxml 文件中。这里再复制两份，形成一个有 3 篇文章的文章列表。

如果 CSS 代码编写足够健壮，无须更改 CSS 代码，重复复制 post.wxm 中的文章代码即可迅速新增文章，且样式不会错乱。保存后，模拟器将呈现出 3 篇一模一样的文章来。效果如图 4-16 所。

开发者可任意复制若干数量的文章，让页面看起来更像是一个文章列表。为了避免重复的数据，我们修改其中的两个文章数据，更改后的 post.wxml 文件如下。

保存后可以看到，3 篇不同的文章已出现在了页面中。开发者可自行调整代码中的文字、图片，无须和示例代码保持一致。

```
<view >
  <swiper indicator-dots="{{true}}" autoplay="{{true}}" interval="5000" catch:tap="onSwiperTap">
    <swiper-item >
      <image src="/images/post/post-1@text.jpg" />
    </swiper-item>
    <swiper-item >
      <image src="/images/post/post-2@text.jpg" />
    </swiper-item>
    <swiper-item >
      <image src="/images/post/post-3@text.jpg" />
    </swiper-item>
  </swiper>

  <view class="post-container">
    <view class="post-author-date">
      <image src="/images/avatar/avatar-5.png" mode="aspectFill"/>
      <text>Jan 28 2020</text>
    </view>
    <text class="post-title">小时候的冰棍与雪糕</text>
    <image class="post-image" src="/images/post/post-4.jpg"/>
    <text class="post-content">冰棍与雪糕绝对不是一个东西，3 到 5 毛起的雪糕犹如现在的哈根达斯，而 5 分 1 毛的冰棍就像现在的老冰棒，时过境迁啊......
    </text>

    <view class="post-like">
      <image src="/images/icon/wx_app_collect.png"/>
      <text>108</text>
      <image src="/images/icon/wx_app_view.png"/>
      <text>92</text>
      <image src="/images/icon/wx_app_message.png"/>
      <text>7</text>
    </view>
  </view>

  <view class="post-container">
    <view class="post-author-date">
      <image src="/images/avatar/avatar-5.png" mode="aspectFill"/>
      <text>Jan 28 2020</text>
    </view>
    <text class="post-title">小时候的冰棍与雪糕</text>
    <image class="post-image" src="/images/post/post-4.jpg"/>
    <text class="post-content">冰棍与雪糕绝对不是一个东西，3 到 5 毛起的雪糕犹如现在的哈根达斯，而 5 分 1 毛的冰棍就像现在的老冰棒，时过境迁啊......
    </text>

    <view class="post-like">
      <image src="/images/icon/wx_app_collect.png"/>
      <text>108</text>
      <image src="/images/icon/wx_app_view.png"/>
      <text>92</text>
      <image src="/images/icon/wx_app_message.png"/>
      <text>7</text>
    </view>
  </view>

  <view class="post-container">
    <view class="post-author-date">
      <image src="/images/avatar/avatar-5.png" mode="aspectFill"/>
      <text>Jan 28 2020</text>
    </view>
    <text class="post-title">小时候的冰棍与雪糕</text>
    <image class="post-image" src="/images/post/post-4.jpg"/>
    <text class="post-content">冰棍与雪糕绝对不是一个东西，3 到 5 毛起的雪糕犹如现在的哈根达斯，而 5 分 1 毛的冰棍就像现在的老冰棒，时过境迁啊......
    </text>

    <view class="post-like">
      <image src="/images/icon/wx_app_collect.png"/>
      <text>108</text>
      <image src="/images/icon/wx_app_view.png"/>
      <text>92</text>
      <image src="/images/icon/wx_app_message.png"/>
      <text>7</text>
    </view>
  </view>
</view>
```

## 4.7 js 文件的代码结构与 Page 页面的生命周期

到目前为止，我们还没有在页面的 js 文件中写过一行代码，是时候来学习一下小程序逻辑层代码的编写了。如果开发者是使用 3.2 小节中介绍的快速新建页面文件的方法来创建的 post 页面，那么由开发工具生成的 post.js。文件内默认将包含代码清单 4-11 所示的代码。

```
// pages/post/post.js
Page({

  /**
   * 页面的初始数据
   */
  data: {

  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {

  },

  /**
   * 生命周期函数--监听页面初次渲染完成
   */
  onReady: function () {

  },

  /**
   * 生命周期函数--监听页面显示
   */
  onShow: function () {

  },

  /**
   * 生命周期函数--监听页面隐藏
   */
  onHide: function () {

  },

  /**
   * 生命周期函数--监听页面卸载
   */
  onUnload: function () {

  },

  /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh: function () {

  },

  /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom: function () {

  },

  /**
   * 用户点击右上角分享
   */
  onShareAppMessage: function () {

  }
})
```

页面 js 文件默认代码包含了我们可能使用到的代码结构，整个页面执行了ー个 Page (..) 方法，参数是一个 Object 对象，用来指定页面的初始数据（data）、生命周期函数（on 开头的函数）、事件处理函数等。本节主要介绍页面的生命周期，关于 data 变量和其他的事件处理函数，后续章节再做详细介绍。

什么是页面的生命周期？如同人的成长需要分为出生、童年、青年、中年、老年一样，一个页面从创建到卸载，同样会经历以下 5 个周期：1）加载。2）显示。3）渲染。4）隐藏。5）卸载。MINA 框架分别提供了 5 个生命周期函数来监听这 5 个特定的生命周期，以方便开发者可以在这些特定的时刻执行一些自己的代码逻辑，它们分别是：1）onLoad 监听页面加载，一个页面只会调用一次。2）onShow 监听页面显示，每次打开页面都会调用。3）onReady 监听页面初次渲染完成，一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。4）onHide 监听页面隐藏。5）onUnload 监听页面卸载。

我们可以做一个小测试，来了解生命周期函数的触发时机。向 post.js 的 5 个生命周期函数中添加以下代码：

保存代码，并将开发工具切換到「调试」→「Console」面板，编译看看 Console 的输出，如图 4-17 所示。

可以看到，一个页面要正常显示，必须经历以上 3 个生命周期：加载、显示、渲染。注意这 3 个生命周期函数的执行顺序，首先是 onLoad，其次是 onShow，最后才是 onReady。

这里要特别提醒各位开发者，onShow 的执行时刻是在 onReady 之前的，但官方文档在编写时，将 onReady 放置在 onShow 之前（截止 0.11.122100 版本）。虽然只是顺序不同，但极容易让开发者误以为 onReady 是在 onShow 之前的，但这是不正确的。

那么 onHide 和 onUnload 呢？这两个函数的触发需要执行一些 API 的操作，比如当页面执行 navigateTo 方法或者使用小程序 tab 栏切换页面时会执行 onHide 函数；而当页面执行 redirectTo 或 navigateBack 的时候会执行 onUnload 函数。除了以上 5 个生命周期函数外，还有以下 3 个小程序特定事件的处理函数：1）onPullDownRefresh 监听用户下拉动作的事件处理函数。2）onReachBottom 页面上拉触底事件的处理函数。3）onShareAppMessage 用户点击右上角分享。开发者还可以添加任意的函数或数据到这个 Page 方法的 Object 参数中，在页面的函数中用 this 即可访问这些自定义函数或者数据。

关于 onHide 和 onUnload 以及 3 个特定事件的处理函数，我们将在后面介绍到导航、tab 栏、刷新、分享等项目需求时，再具体演示和讲解。放在具体的示例里演示，效果远比用文字理论描述要好。

官方文档中，还给出了ー个较为全面的 Page 实例生命周期图解，如图 4-18 所示。

图 4-18 页面生命周期图解

我们大概可以看到整个图分为左右两侧，左侧是视图层，右侧是服务逻辑层。整个页面的生命周期都是围绕着这两个层来进行的。他们之间不是孤立的，而是有很多的事件与通知交互的。目前，我们所学的知识还不足以完全解释页面的整个生命周期。我们所讲的 5 个生命周期函数就在图 4-18 右侧多次出现，如果仔细观察，会发现以下几个特点：

1）onload、onshow 和 onready 确实是按照前面所讲到执行顺序依次执行。

2）onload 与 onready 在整个页面的生命周期中只会执行 1 次，除非这个页面被执行了 onunload 载掉了（卸载掉后这个页面的生命周期就结束了）。

3）onhide 与 onshow 在一次生命周期内可能会执行多次。

除了 First Render 第一次渲染，页面还有可能会 Rerender 再次渲染多次。数据更新会造成页面的重新渲染。开发者还要注意，小程序仅在第一次 First Render 完成后，提供了监听函数 onready，对于以后的 Rerender 并没有提供相应的监听函数。所以，onReady 仅用来监听「第一渲染」完成。

现在无法看明白这张图是很正常的事情，开发者不需要太过于担心。正如官方文档中所说：「此图你不需要立马完全弄明白，不过以后它会有帮助」。笔者的建议是，当遇到问题或者业务需要时，再回过头来研究这张完整的生命周期图更有意义。

事实上，如果开发者只想单纯的开发业务项目，只需要理解 5 个生命周期函数发生的时机与意义即可。通过大量的编码，可以让经验来弥补一些知识上的缺陷，这就是所谓的熟能生巧。但如果开发者想去做一些与小程序编译相关的框架时，深入了解这张图就很有必要了。当然，无论你想做什么，能够完全看懂和理解这张图，自然是再好不过了。我们会在后面的项目实践中，不断验证这些生命周期的特性，开发者只需要记得到时侯回过头来看看即可。

## 4.8 数据绑定

在真实的项目中，业务数据通常都放置在自己的服务器中，然后通过 HTTP 请求来访问服务器提供的 RESTFU API，从而实现数据获取。

现在我们的 post 面里的内容，全是一些被直接编码在 wxml 里的数据，这样的代码写法我们通常称为「硬编码」。这当然是一种非常不好的编码方法。

我们现在尝试将编码在 post.wxml 文件里的数据移植到 post.js 中，在 post.js 中加入一个临时变量 postData 用来模拟文章数据，并将上ー小节中测试生命周期的代码移除。编写完成后的代码如下：

那么如何将 data 中的这些数据「填充」到页面中，并显示这些数据呢？

如果是开发传统的网页，肯定会使用以下思路：首先获取到 HTML 文档的 DOM，然后对 DOM 标签进行赋值，从而实现数据的显示。但在小程序中，是没有 DOM 结构的，所以这个思路行不通。在许多流行的 MVC 或者 MVVM 框架中，比如 AngularJs、Vue.js 中，都有数据绑定的概念。小程序也借鉴了这些流行框架的思想，采用数据绑定的机制来做数据的初始化和更新。

只不过小程序做得更加决绝。AngularJs 中，虽然官方不推荐使用 DOM，但至少还有一个内置的 jQLite 用来支持获取 DOM（虽然有很多的限制），开发者也可以自行集成 jQuery。但小程序的腳本逻辑是运行在 JSCore 中，JSCore 是一个没有 DOM 的环境，它完全抛弃了 DOM 结构，我们只能使用数据绑定来做数据的相关操作。

不同于 AngularJs 的双向数据绑定，小程序仅实现了单向数据绑定，即只支持从逻辑层传递到渲染层的数据绑定，反之则不可以。

小程序使用 Page 方法参数里的 data 变量作为数据绑定的桥梁。如代码清单 4-13 所示，data 里已经被我们放置了一些数据，这些直接写在 data 里的数据，被称为数据绑定的初始化数据。

注意，数据绑定有以下两种：一种是初始化数据的数据绑定，通常将这些数据直接写在 Page 方法参数的 data 对象下面；另外一种是使用 setData 方法来做数据绑定，这种方式也可以理解为数据更新。这样的数据更新将引起页面的 Rerender（重新渲染），参考图 4-18 中的 Rerender。

### 4.8.1 初始化数据绑定

先来看看初始化数据绑定的写法。

代码清单 4-13 中，我们已经为 Page 方法的 data 对象填充了一些属性数据。现在，只需要对 post.wxml 文件做一些改动，即可让 wxml 能够「接收」这些初始化数据。

```
  data: {
    date: "Jan 28 2020",
    title: "小时候的冰棍与雪糕",
    postimg: "/images/post/post-4.jpg",
    avatar: "/images/avatar/avatar-5.png",
    content:"冰棍与雪糕绝对不是一个东西，3 到 5 毛起的雪糕犹如现在的哈根达斯，而 5 分 1 毛的冰棍就像现在的老冰棒，时过境迁啊.....",
    readingnum: 92,
    collectionnum:108,
    commentnum: 7
  }
```

小程序使用 Mustache 语法双大括号 {{}} 在 wxml 组件里进行数据的绑定。我们试着用数据绑定的方式来显示《小时候的冰棍儿与雪糕》这篇文章，更改这篇文章的 wxml 代码，如代码清单 4-14 所示。注意，post.wxml 文件里总共有 3 篇文章，但我们只更改了第一篇文章的相关代码，其他两篇文章依然使用硬编码的方式来填充数据。

```
  <view class="post-container">
    <view class="post-author-date">
      <image src="{{avatar}}" mode="aspectFill"/>
      <text>{{date}}</text>
    </view>
    <text class="post-title">{{title}}</text>
    <image class="post-image" src="{{postimg}}"/>
    <text class="post-content">{{content}}</text>

    <view class="post-like">
      <image src="/images/icon/wx_app_collect.png"/>
      <text>{{collectionnum}}</text>
      <image src="/images/icon/wx_app_view.png"/>
      <text>{{readingnum}}</text>
      <image src="/images/icon/wx_app_message.png"/>
      <text>{{commentnum}}</text>
    </view>
  </view>
```

保存后可以看到，页面并没有变化，第一篇文章的数据正常地显示了出来，这说明数据绑定成功了。

可以看到双大括号中写入了一些变量名。细心的开发者应该发现 {{}} 里的变量名称同 js 文件里 data 对象的属性名称是相同的。可见，数据绑定非常简单，只要将 data 对象的属性名填入到双大括号中即可。MINA 框架会自动在运行时用 data 数据替换这些 {{}}。比如 {{date}｝，在运行后将被替换为「Jan 28 2017」，而 {{readingNum} 将被替换为「92」。

我们用图 4-18 页面生命周期图解这张图，解释一下初始化数据绑定的过程。

当页面执行了 onshow 函数后，逻辑层会收到一个通知（Notify）；随后逻辑层会将 data 对象以 json 的形式发送到 View 视图层（Send Initial Data），视图层接收初始化数据后，开始渲染并示初始化数据（First Render），最终将数据呈现在开发者的眼前。

这里需要注意，如果数据绑定是作用在组件的属性中，比如 \<image src="{{avatar}}"/>，则定要在 {{}} 外边加上双引号，否则小程序会报错。如果是内容型的数据绑定，则不需要加双引号，比如 \<text>{{date}}\</text。

数据绑定的 Mustache 语法还有一些其他用法，我们依然会放在下面的实例项目中来讲解

### 4.8.2 在哪里可以查看数据绑定对象

开发工具为我们提供了一个面板专门用来查看和调试数据绑定变量，这个面板就是在第 2 章中介绍的 Appdatal 面板

我们来看一下 Orange Can 项目此时的 Appdata 情况。打开『调试】-→【Appdata】，可以看到以下的数据情况，如图 4-19 所示

请开发者注意，Appdatal 面板对于调试和理解数据绑定有非常重要的作用，建议当开发者遇到数

据绑定相关问题时，一定要首先打开这个面板来査看具体的数据绑定情况。

Appdata 下的数据以页面为组织単位。因为现在只在 post 页面里做了数据绑定，所以 Appdata 下边只出现了 pages/post/Post 这一个页面的数据。如果同时有多个页面进行了数据绑定，那么这里将出现多个页面的数据绑定情况。

如图 4-19 所示，可以看到在 bages/post/post 下显示了 post 页面的数据绑定变量情况，它的属性

和 oost, js》文件中所设置的 data 对象属性是一模一样的。

可以在这里更改某一项数据的值。更改是实时进行的，改变任何一个值，开发工具都能实时地将变化更新到模拟器川里显示。开发者可以自行尝试，更改一下 title、date 或者 content 等的属性值，并注意观察模拟器的川变化。

这里还有一个小技巧，让页面的数据以 json 的形式呈现：点击图 4-19 中的【Tree】这个选项，

将打开如图 4-20 所示的面板。点击【Code】后，数据将 json 的形式呈现，如图 4-21 所示。

Json 格式的数据，非常利于我们快速复制这些数据。

### 4.8.3 绑定复杂对象

4.8.1 小节中的 Page 参数下的 data 对象只是一个最简単的 js 对象，它的属性值都只是简单的文本与数字。在实际项目中，可能出现较为复杂的对象，将 data 对象更改为如下代码

止此时，data 对象已不再是简单的对象，它的属性还包含有对象和数组。运行代码后，我们发现，小程序并不会报错，但 U 上的数据无法正确显示。原因是被绑定的 data 对象数据结构改变后，相应的也需要在页面的 wxml 里做出和 data 数据结构等同的调整。调整之后的代码如下（注意，我们同样只更改第一篇文章的相关代码）

现在，date 数据的绑定语法由 {date} 变成了 {object. Date｝；而 collection 数据的绑定语法由 { collectionnum} 变成了 {ollectionnum. Array}。这些相应的调整都是根据 data 数据结构的变化做出的，开发者请仔细对比。

重新运行项目，文章数据又可以正常显示了。

### 4.8.4 数据绑定更新

还可以使用 setdata 函数来做数据绑定，这种方法可以理解为「数据更新」。setdata 方法位于 Page 对象的原型链上：Page. Prototype. Setdata。大多数情况下，我们使用 this. Setdatar 的方式来调用这个方法。

setdata 的参数接受一个对象，以 key 和 value 的形式将 this. Data 中的 key 对应的值设置成 value。

上面这句话要注意两点

setdata 会改变 this. Data 変量里相同 key 的值。

setdata 执行后会通知逻辑层执行 Rerender，并立刻重新渲染视图，参考图 4-18。

说起来好像很难理解，但使用起来非常简单，来看看具体代码

在 post 页面中新增一个 onload 函数，并在其中执行 setdata，更改后的代码如下

运行后我们发现，第一篇文章的标题由 data 里所设置的 title:「小时候的冰棍儿与雪糕「，被更改成了「一根雪糕的经济学原理」，但其他的数据并没有改变。原因在于我们使用 this. Setdata 只更新了 titlei 这一个数据，并未改变其他诸如 date、avatar、content 等数据。

止此外，当执行了代码清单 4-17 后，此时 this. Data. Itle 的值将是一根雪糕的经济学原理」，而不再是「小时候的冰棍儿与雪糕」，因为 this. Setdata 的执行也会改变 this. Data 里的值。

这就是 setdatal 的基本用法。此外，setdata 参数中的 key 是非常灵活的，来看看 key 可能出现的形式。修改代码清单 4-17 中的 onload 方法如下

Key 可以使用字符串来表示，代码如下：

更改 collection Num 数组子元素的值，代码如下：

更改 object 下的 date 的数值。

用 this. Setdataa 所绑定或者更新的数据，并不要求在 this. Data 中已预先定义。看看下面的例子

将 post. Js）文件中的代码改为代码清单 4-21 所示。

上述代码中，去掉了 this. Data 中的初始化数据，转而直接使用 this. Setdata 进行数据更新，从而实现数据绑定，这种方法也是可行的。

旦这时项目并不能正常运行，U 上第一篇文章変成了一篇空白，且没有任何错误提示。原因在于，数据绑定的数据结构变了，Wxml 里的 {} 也需要做相应的改变。

借助我们之前讲到的【Appdata）面板来看一下现在的数据绑定情况，如图 4-22 所示。

很明显，这个数据结构和之前的是不一样的。所有的属性都被 postdata 对象包裹了起来，因为我们在 this. Setdatal 的时候指定的 key 是 postdata, value 是文章的数据。所以，Wxm 里的 {} 需要如下这么改：

只需要在每个 {份里加入 postdatal 即可。比如 { title) } 应当改为 { postdata. Title】。

请各位开发者注意，关于数据绑定的错误，小程序目前不会给出任何的错误提醒。如果你发现整个页面是空白的又没有错误消息，多半是数据绑定出了问题。这个时候 Appdatal 面板是最好的调试工具

## 4.9 列表渲染 x: for

到目前为止，我们只将第一篇《小时候的冰棍儿与雪糕》改为了数据绑定的形式，现在来尝试把所有的文章都改为数据绑定的形式。

首先将其他两篇文章的数据提取到 oost. Js 文件中，同第一篇文章的数据组成一个数组。

注意，代码中 this. Setdata 的 key 更改为了 postlist, value？被更換成了一个包含 3 个元素的数组，每个元素代表一篇文章的数据。

现在，我们已经有 3 篇文章的数据了。我们当然可以像改写第一篇文章一样，依次改写其他两篇文章的 {} 绑定。但这样好吗？

这里来考虑一个问题，如果我有 100 篇文章，怎么办？难道也像这样手动地去填写 100 篇文章的 t} 吗？

如果可以在 Wxml 里做 for 循环该有多好？

小程序确实提供了一个 wxm 组件的 for 循环，称为列表渲染。我们一起来看看，如何使

用列表渲染来改写文章列表，先给出改写后的代码。

重点关注《block> </block》这对括号内的代码。《block》标签没有实质意义，它并不是组件，所以我们称作「标签」，它仅仅是一个包装，不会在页面内被渲染，可以理解为常见编程语言里的括号，在 block 标签中被包裏的元素将被重复渲染。

在 block 标签上，放置了ー个 wx: for 的特殊属性，它的值为 { postlist。Wx: for 将绑定一个数组，在本示例中，这个数组就是 postlist，它对应 post. JS 文件中 setdata 的数组数据。

Wx: for-item 指定数组当前元素的变量名，我们将当前元素的变量名指定为 item。

Wx: for- index 指定当前元素在数组中序号的变量名，我们命名为 idx。当然，在本示例中，只是定义了这个 wx: for- index，并没有真正地使用它。

有了 item 这个数组子元素后，就可以按照上一小节中改写第一篇文章时所使用的} 语法来填写数据绑定了。在所有的鉛} 填写数据绑定变量。保存运行后，发现三篇文章都可以正常显示，但代码的总量却大大減少了。

Wx: for 并不是一定要作用在 block 标签上，如果把代码清单 4-24 中的 block / 标签換成 View，一样可以正常运行。但并不推荐使用 View 等组件来做列表渲染。因为同 HTML 一样，我们希望标签或者组件元素是语义明确的。View 组件通常被用来当作容器或者是区域分隔，它有它的使命，不应该被滥用。

开发者可以尝试将 Wx: for-item="item「属性给去掉，文章列表依然可以正常显示。不定义 item,

那么} 内的 item 是哪里来的？事实上，不定义数组子元素的变量名，小程序默认子元素的变量名就是 item。如果你不喜欢 item 这个变量名，可以将它替换为其他你喜欢的变量名，比如 Wx: for-item=" element「。如果更改了子元素的变量名，记得将 {} 中对应的 item 都更换为被指定的变量名，比如 element。

## 4.10 配置单个页面导航栏背景色

注意观察 pot 文章页面，它顶部的导航栏并不是默认的黑色，而是呈现出和 welcome 欢迎页面相同的橘红色。

原因在于我们在 app. Json！中配置了全局导航栏的颜色为 #3 d4 d。在项目设计图里，全局导航栏

的配色应该是 #4 A6141, 所以，我们现在将全局导航栏的颜色配置为 #4 A6141。在 app. Json 中更改全局导航栏配色，代码如下

更改后发现，welcome I 页面 J 顶部的导航栏颜色也被更換成了新的颜色。所以，我们需要单独配置 welcome 页面的导航栏颜色，让它不受全局配置的影响。

全局配置是在 app. J son 中设置，那么对单个页面的配置应该在页面的 json 文件中配置。在

welcome json 中添加如下代码

保存后发现 Welcome 页面的导航栏颜色已经被更改成了橘红色。

那么页面的 json 文件配置和 app, son 文件的配置有什么不同？

页面的 json 文件只能够配置和 window 相关的属性。window 属性的配置项请参考 3.9 小节。但 app. J sonl 除了可以配置 window 外还可以配置 pages、tabbar？等选顼。

页面的 ison 配置不要像 app. Json 那样，加上 window 这个对象，直接编写 window 下面的配置项即可。请仔细对比代码清单 4-25 和代码清单 4-26 的区别。

修改完成后，以后再新建任何页面，页面的导航栏背景色都将被配置为 #4 A6141 这个颜色。当然，可以将颜色修改为任何你喜欢的颜色

## 4.11 人欢迎页面跳转到文章页面

我们现在一共编写了两个页面：welcome》欢迎页面与 post 文章页面。来尝试将两个页面连接起

来，通过点击 welcome 页面的「开启小程序之旅」跳转到 post 文章页面。

首先将 welcome 页面重新调整为启动页面，代码如下

调整启动页面的方法很简单，将启动页面的路径放在 pages 数组下的第一个元素即可。

## 4.11 事件

要从 welcome 页面跳转到 post 页面，需要使用事件来响应点击「开启小程序之旅」这个动作什么是事件？

严肃一些的定义是：事件是视图层（wwm）到逻辑层（js）的通信方式。简单一些理解，事件可以让我们在 js 里处理一些用户在界面上的一些操作并对这些操作做出反馈。比如点击 Welcome 页面「开启小程序之旅」按钮后，需要在 js 里调用 MINA 框架的 AP，使页面从 welcome 跳转到 post。

要实现这样的机制，需要做两件事情

在组件上注册事件。注册事件将告诉小程序，我们要监听哪个组件的什么事件。在本例中，需要监听「开启小程序之旅」这个组件的 tap 事件。

在 js 中编写事件处理函数响应事件。也就是说，监听到事件后，需要编写自己的业务。在本例中，我们将调用 MNA 框架的导航 AP，让 welcome 页面跳转到 post 页面。

更改 welcome. Wwml 页面的代码，如代码清单 4-28 所示。

和之前的代码相比并没有太大的改动，仅仅是在 Clas="Journey- container「的这个 view 组件上添加了ー个 catchtap=" on T apjump「的事件绑定。事件绑定的写法同组件的写法相同。它的意思是，监听点击这个动作，当用户点击这个动作后，将执行一个 on Tapjumpe 的函数，这个函数必须在页面的 js 中定义。下面的代码定义了 tap 事件的处理函数

代码中为 Page 方法的 Object 参数定义了一个函数：on T apjump。函数的名称可以任意指定，但必须和代码清单 4-28 中定义的 catchtap=" ont apjump「保持一致。当用户点击或者触碰「开启小程序之旅」这个按钮后，MINA 框架将执行 on T；这个函数，并将一个 event》对象作为参数传递到函数里。

保存运行代码，点击「开启小程序之旅」，页面将从 welcome 欢迎页面跳转到 post 文章页面。

## 4. 12 redirectto5 To

在上一小节中，我们在 on T apjump 函数里调用了 wx. Redirect 方法从而实现了页面跳转。小程序共提供了 3 个导航 APl，以帮助开发者实现页面跳转

wxredirect


WX navigate o


oWx. Switchtap (122100 版本新增

他们之间的区别是：redirect o》将关闭当前页面，跳转到指定页面；navigate T o 将保留当前页面，跳转到指定页面；而 switchtap 只能用于跳转到帯 itabbarg 的页面，并关闭其他所有非 tabbar 页面。

switchtab 页面将在后面学习 tabari 选项卡时再具体介绍，本节主要来看看 redirect 利和 navigate To 的区别。

redirect 和 navigate T o 在使用方式上完全相同，他们都接受一个 Object 对象作为参数。Object 寸象中最重要的属性是 urI，它将指定要跳转的页面路径。

请注意 ur 是页面的路径，不要加上文件的扩展名（如同 app. Json 中定义 pages - 样）。如果在页面路径后加上ー个「wxm'」，比如将 ur 设置为 ur:"./post/post.wwml", 页面无法跳转，并会报错。

Object 参数还可以接收 3 个方法，分别是

o Success 跳转页面成功时 MINA 框架将调用此函数。

fail 跳转页面失败时 MINA 框架将调用此函数。

complete 无论成功或者失败，MINA 框架都将调用此函数

具体写法可参考代码清单 4-29。

将这 3 个方法拿出来单独列举是因为在小程序中，几乎所有异步类型的 AP 都配备有这 3 个方法。七如后面要学习的操作反馈 API: Wx. Show Toast，获取用户信息 API: Wx. Getuserinfo 等。在以后的其他 AP 学习过程中我们就不再一一列举这 3 个方法了。

再次保存并运行以上代码，点击跳转后，页面将跳转到 post 文章页面。此时我们发现没有办法再返回到 elcome 页面了。这就是 redirect 的特点，它将卸载 welcome 页面，并执行页面的 onunload 事件函数。可以来验证一下，在 welcome. Js 里加入ー个 onunloadi 函数和一个 onhide 函数

运行代码，发现 Console 将输出 ' page is unload」，但并不会输出「page is hide」

再来看看 navigate T o。将代码清单 4-29 中的 Wx. Redirect 更改为 WXnavigate To。保存运行代码后将发现，navigate T o 跳转到 post 页面后，页面左上角有一个返回按钮，如图 4-23 所示。点击返回后还可以再返回到 welcome 页面。除此之外，navigate 将执行 onhide 事件回调，并输出了「page is hide」

所以，redirect 将关闭当前页面并将页面卸载；而 navigate To 仅仅会隐藏当前页面，还可以再次返回到被隐藏的页面。这是他们最重要的区别。

再来考虑一个问题。当 navigate o 跳转到 post 页面后，再次从 post 页面返回到 welcome 页面时，post 页面会执行 onhide】还是 onunload！呢？答案是会执行 post 页面的 onunload 函数（不能保证以后的版本是否还会更改，但目前的 130400 版本确实是会执行 onunload！函数）。也就是说，当从子页面返回到父页面时，子页面会被卸载。开发者可以仿照 welcome 页面自行验证。

但事实上，子页面执行 onunload 函数的行为是从 122100 版本后才更改的，在之前的版本中子页面返回到父页面并不会执行 onunload！函数，造成大量的子页面残留在小程序中。这在当时给开发者带来了巨大的困抗，还好官方在后续版本中更改了这个行为。页面是否被卸载是非常重要的行为，不卸载页面将使全局性的一些行为，比如音乐播放的处理，変得非常复杂。所以，了解这些页面的生命周期对于开发者来说是很重要的，否则极易引起 bug。

我们还可以再试试 wx, switch ab 这个方法，将 welcome. J s 中的 wx navigate To 更改为 WX. Switchtab，其他保持不変，运行一下代码。

页面无法执行跳转，且 Console 将输出 jump failed。原因之前我们解释过，switchtab 只能跳转到带有 tabari 选项卡的页面，而 post 页面并不带有选项卡，所以无法执行跳转。tabari 的配置将在后面讲到，现在开发者无须关心。

现在，我们暂时选取 navigate o 作为跳转方法。

## 4.13 小程序最多只能有 5 层页面

当我们使用 navigate 从父页面跳转到子页面后，就形成了 2 个页面层级。可以继续在子页面里使用 navigate To 跳转到子页面。

但小程序里强制规定，只允许有最多五层父子页面。所以请开发者注意，尽量避免多层级的交互方式。事实上，太多的子页面将严重影响用户的产品体验。建议页面最多不要超过 3 层。

redirect 不存在这个问题，因为当跳转到另一个页面后，上一个页面被强制卸载掉了。

14.114 冒泡事件与非冒泡事件

什么是冒泡事件？

冒泡事件指某个组件上的时间被触发后，事件还会向父级元素传递；父级元素还会继续向父级的父级传递，一直到页面的顶级元素。而非冒泡事件则不会向父级元素传递事件。

在 4.114 节中，我们使用了 tap 事件，监听点击或者触摸动作，而 tap 是一个冒泡事件。常见的冒泡事件类型还有下面几种

touchstart 手指触摸动作开始。

touchmove 手指触摸后移动。

touchcancel 手指触摸动作被打断，如来电提醒、弹窗

touched 手指触摸动作结束

otap 手指触摸后马上离开。

Longtan 手指触摸后，超过 350 ms 再离开。

相对于 PC 上的 Web 浏览器，小程序的事件并不多。需要注意的是，在 wxml 组件里注册事件时。不可以直接使用 tap="function"' 或 touchmove=" function「，需要在事件名之前添加 catchi 或者 bind 前缀。比如在 welcome 页面跳转时，我们就使用了 catchtapi 而并没有直接使用 tap。

bind 和 catch 有什么区别？

区别在于，对于以上几个冒泡事件，catch 将阻止事件继续向父节点传播，而 bind 不会阻止事件的传播

基本上所有的组件都有以上这些冒泡事件。

除以上 6 种事件外，如无特殊申明都是非冒泡事件，非冒泡事件大多不是通用事件，而是某些组件特有的事件。如《form/》的 submit 事件，<Input/》的 input 事件，<scroll-view/》的 scrol 事件寺

