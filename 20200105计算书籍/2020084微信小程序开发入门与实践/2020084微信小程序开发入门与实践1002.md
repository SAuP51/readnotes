# 1002

10.12 绑定处理后的电影数据在代码清单 10-15 的最后我们使用了以下代码进行数据绑定：

代码清单 10-19

var ready Data=1:

ready Datal] =f

category'title: category Title,

movies: movies

this set Data (ready Data)

这是一种动态设置数据绑定 key 的方法。由于我们并不知道当前处理的数据是哪一种电影类型（in Theaters、comingsoon、top250），因此将当前所处理的电影数据类型通过 settedkey 路传递到 processdoubandata 方法中，并通过 ready Datal_ settedkey 生成一个包含 setted Key 的 Javascript 对象。

假设当前处理的数据是 in T heaters 类型，那么以上代码在最终调用 this. Setdata (readydata）时相当于以下形式：

代码清单 10-20

category Title：止在热映，

movies: movies

如果当前处理的数据是 coming Soon 类型，那么以上代码在最终调用 this. Setdata 时相当于以下形式

这样的写法实际上考验的是开发者对 Javascript 动态属性的理解。此时，保存并运行代码，电影首页显示如图 10-12 所示的样式。

如果数据没有正确加载，请参考下节的内容。

10.13http 和 https 在小程序中的使用说明

为了保证数据的安全性，小程序中强制要求使用 https 且所访问的 https 地址必须在小程序的后台账号中被加入到可信域名中。图 10-13 是小程序开发账号的 htts 可信域名配置的示意图。

该配置项位于小程序账号的「设置」→「开发设置」选项中。理论上，小程序是不允许使用 ht 请求来获取数据的，也不允许访问未在可信域名列表中配置的 https 地址。

以上限制的前提条件是：在真机上。

如果是在客户端的开发工具中，有以下几种方法可以不需要遵守以上两个规则。

(1) 第一种方法

如果在创建小程序项目时选取的是无 appid（必须拥有小程序账号才可以获得），那么开发工具不会限制你访问 htps，更不会比对可信域名列表。这种方法的缺点就是：当你偶尔想真机预览下小程序时，还需要重新新建项目并填入 appid。

(2) 第二种方法

如果在创建小程序项目时填入了 appid 那么默认情況下小程序将强制你使用 https 且会将你所访问的 https 地址与可信域名列表做比对。如果你试图在一个配置了 appid 的小程序项目客户端开发工具中访问 http 地址，那么开发工具会报错，如图 10-14 所示。

无论你使用 http 或者使用不在可信域名列表里的 https 地址都将提示图 10-14 所示的错误（可信域名列表不能够设置 htp，所以试图访问 http 地址一样会提示不在可信域名列表中）。

解决的办法是，在可信域名列表中配置你要访问的 https 域名。

(3) 第三种方法

小程序在开发工具侧边栏的「项目」选项卡中提供了「开发环境不校验请求域名以及 TLS 版本」的选项，勾选这个选项你可以随意在开发工具中使用 http 或者未加入 https 可信列表的 https 地址。

以下是一些建议

如果你没有 appid，那么只能选择无 appid。

如果你有 appid，那么建议在新建项目时填写这个 applo，并在开发期间勾选「开发环境不校验

请求域名以及 TLS 版本」，待正式发布或者需要真机预览时再去小程序账号中配置你所使用的

https 地址。如果项目中没有使用网络请求，那么真机预览时也不需要配置 https 的可信域名列表

如果你在 Orange Can 项目中遇到无法访问的问题，可以参考上面所描述的内容。

10.14 跳转到更多电影页面

之前，我们完成了电影首页的编写。电影首页总共展现了 3 种类型的电影，共 9 部。如果我们需要査看每种类型的全部电影，就需要编写「更多电影」这个页面。「更多电影」是通过点击电影首页的「更多」按钮来打开新页面的，如图 10-15 所示。

首先新建 more- movie 页面。在 app. Son 文件的 pages 数组下新增 more- move 页面的路径，如下代码所示：

黑色加粗部分代码是新增的页面路径。添加以上代码后保存项目，将自动生成 more- movie 页面的 4 个页面文件。

我们首先实现跳转到 more- move 页面的代码。通过图 10-15 可以看到，「更多」按钮是位于 movie-ist-tpl 模板中的。我们回顾一下 movie- -list-tpl.Wxm 中的代码。

在 movie- -list-tpl.Wxm 中的 view class="more》标签上，我们已经注册了ー个 on ap 事

件，且在这个标签上也已经绑定了一个 data 数据：data- category="{ category Title｝「。

实现跳转到 more- movie l 页面的关键就在于实现这个 onmoret ap 函数，并在 onmoret ap 函数中使用 wxnavigate 方法跳转到 more- movie 页面中去。同时，我们还必须将 category Title 这个变量同时传递到 more- movie 页面里去，从而使 more- movie 页面能够准确地加载「更多」的电影数据

在 movie JSE 中新增以下代码，以实现 onmoret ap 方法。开发者可能会觉得奇怪，「更多」按钮是位于 movie-ilst-tpl 模板中的，但应这个按钮的 js 方法却要写在另外一个页面的 js 文件 movie. S）中。

这确实是非常奇怪也难以理解的。关于这个问题，我们已经在前面的内容中讲解过：小程序只实

现了模板化，而没有实现组件化，模板是不具备运行 Javascript 代码能力的。所以，我们只能将模板的业务逻辑编写在其他页面的 js 文件中，再将处理好的业务数据传递到模板中。

代码非常简单，这里就不再做过多得解释了。

加入以上代码后，保存并运行项目，点击电影首页中的「更多」按钮将可以打开 more- movie 页面

10.15 编写 move-grid-tpl 模板

如同我们在实现电影首页页面时所做的，我们首先来编写「更多电影」页面所需要的模板 movie-grid-tp이模板。

图 10-16 展示了 move-grid-tpl 模板的实际效果图。

这个模板将像「九宮格」一样放入很多的电影（真实的数据远不止 9 部电影），以展示更多电影的效果。

在 /pages/ move 下新建一个 move-grid 目录，并在目录下新建 moie-grid- tpl wxml 和 move grid-tpl.Wxss 文件。

我们首先来编写 move-grid-tpl 模板的骨架。在 move-grid-tpl.Wxml 文件中加入以下代码：

我们可以看到 movie-grid-tpl 的骨架代码非常简单。为什么这么几句代码就可以实现复杂的「九宫格」' 效果

模板再次发挥了巨大的复用作用。很明显 move-grid-tpl 仅仅起到的是组织布局的作用，而核心的骨架代码已经被封装在了 movie-tpl 模板中。我们在 movie-grid-tpl 中的 block 标签中循环调用 movie-tpl 模板，以实现显示多部电影的目的。

在之前编写的 movie-list-tpl 里，我们已经使用过了 movie-tpl，这里再次使用 movie-tpl 就体现

了模板的优势，它避免了我们重复编写 Wwm 代码。笔者认为用好模板将大大简化代码，提高代码的可阋读性与可维护性。

接着编写 move-grid-tpl 模板的样式代码。在 move-grid- tpl WXSS 文件中加入以下样式代码：

同样要注意引入 move-tpl.wxss 文件。

10.16 编写「更多电影」页面

在编写完 more- movie 页面所需要的核心 template 模板后，我们来编写 more- move.wxm 文件。

令人吃惊的是，你几乎不需要编写任何代码，只需要在 more- movie.wxml 页面中引入 movie grid-tp이模板即可。

在 more- movie.Wxml 页面中加入以下代码：

代码清单 10-26more- movie 页面的骨架 more-movie wxml

 <import src="/movie-grid/movie-grid-tpl wxmi"/>

 <template is="movicgridtpl"data="1 (movies "/

接着编写 more-move 页面的样式。在 more- movie.Wxss 文件中加入以下代码：

代码清单 10-27more- movie 页面的样式 more-movie Wxss

 (C import"./movie-grid/movie-grid-tpl wxss"

几乎不需要编写代码，我们就完成了 more- movie 页面的骨架和样式代码的编写工作。

接着我们还需要编写 more- movie 页面的 js 代码。more- movie 页面的 js 代码所需要完成的工作几乎同 move 电影首页的 js 代码相同。依然遵守着获取数据つ处理数据つ绑定数据的步骤。

实际上，获取数据→处理数据→绑定数据的流程几乎是小程序 js 文件编写的通用思路与步骤。在 more- move 页面中添加以下代码

首先，我们在 data 中设置 moves 绑定变量的初始化值。movies。变量将最终被用作 Wxml 的数据绑定变量。

接着，在 on Load 函数中接收由 movie 电影首页传递过来的 category：分类。根据分类的不同拼接不同数据访问 APl 的地址。这里我们没有在 AP 的 URL 后面附带 start 和 count 参数，如果不附带这两个参数，那么默认将一次加载 20 条电影数据。

为了避免反复编写 WX. Requestl 的复杂结构，我们在 uti 模块中编写了ー个 http 方法，作为所有豆辦 AP이调用的公共方法，当我们需要访问豆瓣 API 时，不需要重复调用 wxrequest 方法，只需要调用这个封装好的 htt 方法即可。utilhttp 方法接收两个参数：第一个参数是需要访问的 API 地址；第二个参数是一个回调函数，用来处理豆瓣 AP 的返回结果

processdoubandata 方法同 move 电影首页中的 processdoubandata 类似，都是用来处理豆瓣的返回数据，并在处理完成后将处理的数据进行绑定。由于在 more- movie 页面中我们已经明确了电影类型，因止此 processdoubandatal 的编写简単了很多，只需要明确处理「正在热映」「即将上映」和「top250」3 种类型中的一种即可。

下面来看看 utilhttp 方法是如何编写的。在 util. S 文件中加入 http 方法。

将所有调用豆瓣 AP 的操作封装成一个函数的好处是，一旦调用操作和流程发生变化，只需要修改这个函数即可。比如，header 的 content-type 支持 application/json 取值，无须在多处修改，只需要修改 utilhttp 方法即可。

编写完 http 方法后，记得使用 moduleexports 方法将 http 方法暴露出去，以供其他页面 / 模块访

代码清单 10-30 暴露 htt 方法 util. Js

module exports=f

get Difftime: getdifttime

convert Tostars Array: convert Tostars.

httphttp

黑色加粗部分为新增代码。

保存并运行项目，再次点击「更多」按钮，页面将从 movie 电影首页跳转到 more- movie（更多电

影）页面，且 more- movie 页面正确地呈现出 20 部电影，如图 10-17 所示。

10.17 实现页面下拉刷新的「三部曲」

下拉刷新是 APP 上经典的一个动作。本节我们将学习如何在小程序中实现下拉刷新数据的功能。在小程序中，不需要自己实现下拉刷新代码编写。小程序已经为我们准备好了下拉刷新的相关配置和 AP。

实现一个页面的下拉刷新操作需要分为 3 步

步骤 01 在页面的 json 文件中配置 enablepulidown Refresh 选项，打开下拉刷新开关。

步骤 02 在页面的 js 文件中编写 Onpulldownrefresh！图数，完成自己的下拉刷新逻辑。

步骤 03 编写完下拉刷新逻辑代码后，主动调用 wx. Stoppuiidownrefresh 函数停止当前页面的

下拉刷新。

我们首先来完成第一步。在 more- movie. Son 文件中加入以下代码：

当在 more- movie.json 中加入以上代码后，more- movie 页面的下拉刷新就开启了。此时下拉 more- movie 页面将出现下拉效果。由于下拉刷新的等待标示默认是白色，因此你无法明显地看到下拉刷新的等待状态标示。

我们可以修改等待标示的默认颜色，在 more- movie」json 文件中添加一个配置项。

代码清单 10-32 配置下拉刷新图标的默认颜色 more-movle json

enablepuiiidownrefresh": true

background'textstyle": " dark

这样当再次下拉刷新 more- movie 页面时，我们将看到等待标示，如图 10-18 所示

当然，你也可以在 app-json 的 window 配置项中配置 backgroundtextstyle: "dark「选项，这将导

致所有页面的下拉刷新等待标示都变成 dark。

同理，你也可以在 app. J sonl 的 window 配置项中配置 enable Pulldown Refresh: true 选项，这将导

致所有页面都开启下拉刷新。

接着我们来完成第二步。当页面打开下拉刷新开关后，每当用户下拉页面都将触发执行页面的 ONPULIDOWN Refresh 函数。这就是小程序给我们编写下拉刷新逻辑的函数。在 more- movie. S 文件中编写 on Refresh！函数。

整个函数的代码非常简单，仅仅是再一次访问了豆瓣 AP 并重新获取了最新的第 1 到第 20 条数

据

注意，在函数中我们获取当前豆瓣 APl 的 URL 地址时使用了 this.data. Equestre（这个变量是在

on Load 函数中保存下来的）。所以，我们修改一下 more- movie 页面的 on Load 函数，在 onload 函数中将当前访问的 URL 地址记录一下。

黑色加粗部分为新增代码。

编写完以上代码后，我们可以反复尝试下拉刷新 more- move 页面。当然，从 U 上是无法直接看到刷新效果的，因为豆瓣的电影数据不可能更新得非常频繁。我们可以尝试打开【Network 面板，观察一下每次下拉刷新后是否有向豆瓣发送请求，如果有请求发向豆瓣，就说明 onpulidown Refresh 函数成功触发了

图 10-19 所示的示意图显示了 3 次下拉刷新 more- movie 页面后【Network）面板的请求发送情

况

最后，我们来完成下拉刷新「三部曲」中的第三步，主动停住页面刷新状态。停住页面刷新状态非常简单，在合适的时机调用 Wx. Stoppulldownrefresh 方法即可。

我们需要考虑的是在什么时候调用 wx. Stoppuiidownrefresh（）。当然应该是在处理完豆瓣返回数据并再次调用 this. Setdata 重新绑定数据后调用 WX. Stoppulldownrefresh（）函数。

在 more- movie. S 页面的 processdoubandata 方法中调用 WX. Stoppulidownrefresh（）即可。

黑色加粗部分为新增代码。

完成以上代码后，more- move 页面的下拉刷新操作就全部完成了。下拉刷新三部曲是笔者总结的编写下拉刷新功能时的常见思维步骤，以供开发者参考。

10.18 在模拟器中可执行下拉刷新但在真机中无法执行下拉刷新的常见错

在开启下拉刷新开关时，我们需要在页面的 json 文件中设置 enablepull Down Refresh 选项为 true。如果不小心将 enablepulidown Refresh 选项设置成了字符串「true」，而非 Boolean 类型的 true，就将导致在模拟器中可执行下拉刷新但在真机上（仅测试 OS 系统）无法执行下拉刷新的现象。

虽然官方文档明确地指出 enablepull Refresh 配置选顼的值类型是 Boolean，但真机行为同开发工具中行为不一致显然是不能接受的，这将增加测试成本，并有可能引起严重的 bug

10.19jion 中的 backgroundcolore 配置的是哪里的颜色

官方文档中对 oackground Color 这个配置项的解释是「配置窗口的背景色」，但这个文档中并没有明确解释窗口是什么、处于小程序的哪个部位。很多开发者都尝试设置 backgroundcolor，但均无法看到设置效果，这会让人误以为这个配置选项是无效的，造成这个误解的主要原因是开发工具模拟器中的小程序和真机上小程序在执行下拉动作时有一些区别

开发工具模拟器中的小程序是无法向下拉动的（如果不设置下拉刷新），但在真机上，无论你是否设置下拉刷新，导航栏以下的页面部分都可以向下拉动。拉动后，在导航栏和页面中间会有块儿「空白」，backgroundcolor 可以设置这块儿空白的颜色。

在模拟器中，可以通过设置下拉刷新看到这块儿区域。我们可以做一个测试来看看效果，在 more- movie. J son 文件中增加一个 background Colori 配置选项。

黑色加粗部分为新增代码。

增加以上配置选项后，再次下拉刷新 more- movie. JS 页面，我们将看到如图 10-20 所示的刷新效果

注意图中框起来的页面部分。这个部分的颜色将变

成我们在 more- movie. Son 文件中设置的 background Colori 颜色：黑色。

真机上的小程序存在一个问题，当配置导航栏颜色后，由于在真机上，即使不设置页面的下拉刷新，也会存在一个下拉的动作，露出一块儿白色的区

域。这块儿白色的区域非常难看，我们可以通过设置页面的 background Color 属性来配置这块儿叉域的颜色。

首先在 app. Son 中配置全局的窗口背景颜色。

首先在 app son 中配置全局的窗口背景颜色。

代码清单 10-38 配置全局窗口颜色 app. Json

window": f

navigation Barbackgroundcolor": "#4A6141

backgroundcolor": "#4A6141

接着，将 welcome 页面的窗口颜色单独配置。

代码清单 10-39 配置 welcome 页面的窗口颜色 welcome, json

navigation Barbackgroundcolor" "#ECCOA8",

backgroundcolor": "#ECC0A8

通过以上设置将使小程序在真机上，即使下拉页面，也不会出现「空白」。

10.20 实现上滑加载更多数据

上滑加载更多数据又是另一个经典的 APP 操作。在本节中，我们将在小程序的 more- movie 页面中实现这个经典的操作。

目前的 more- movie 页面只能显示最多 20 条数据，因为豆瓣 API 最多只允许我们一次加载 20 条数

据，若想显示更多的电影数据，则需要实现分步加载。在传统的 Web 网页上，我们通常是通过分页来实现显示更多数据。在移动端，更常见的操作是不考虑页码，通过不断地上滑页面来实现加载更多数据。

实现上滑加载更多的关键点在于何时触发「加载更多」这个操作。很明显，当页面「触底时」就可以执行「加载更多」这个操作了。

小程序在页面的 Page 中提供了ー个 on Reach Bottom 函数。onreach Bottom 将在每次页面上滑

触底后触发执行。所以，我们只需要编写小程序提供的 onreach Bottom 函数即可实现 more move 页面的上滑加载更多数据的功能。

在 more- movie. S 页面中新增 on Reach Bottom！函数。

以上代码是实现上滑加载更多操作的核心代码。在 on Reach Bottom 函数中，我们拼接了一个 nexturl 作为取下一组电影数据的 URL。stat 指定起始电影的条数，该数值等于当前页面已经绑定的电影条目条数，count：指定了最多取 20 条（当然不指定 count 也是可以的，因为默认最多取 20 条）。

现在的问题是，我们如何知道当前已经显示了多少条电影条目呢？

此时，我们需要调整下思路。我们将 this.data. Moves 这个数组视作一个保存当前页面所有电影数据的数组。每当新增加 20 条数据后，我们都需要将新增的 20 条数据追加到这个 this.data. Movies 数组中

数据可以通过合并的形式追加到 this.data. Moves 数组中，那么如何将新增的电影数据在 U 上追加到已显示的电影后面呢？回顾一下我们在关于文章评论的 7.16 节中是如何将新的评论追加到已存在评论后面的。再次强调，要使用数据绑定的思维，而不要使用习惯的 DOM 思维来考虑问题。没有追加」，只有重新绑定和渲染整个 this.data. Movies 数组。所以，我们要做的就是将新加载的电影数据与已存在的电影数据合并在一起，并更新 this.data. Movies。

修改 more- movie s 文件中的 processdoubandata！函数。

黑色加粗部分标记出了新增以及修改的代码。加粗部分代码将每次新增加的电影数据同已存在的电影数据合并在一起，并再次使用 this. Setdata 进行数据更新。this. Setdata 在做数据更新的同时也更新了 this.data. Moves 这个変量，以确保 this.data. Movies 变量永远记录的是当前页面的全部电影数据。

还有一个小问题是我们要考虑的，即当 more- movie 页面多次加载数据后如何处理下拉刷新这个操作。假设我们已经加载了 5 次共 100 条电影数据，那么此时去下拉刷新 more- movie 页面，理论上应该更新全部的 100 条数据，但是对于豆瓣电影没有必要这样处理。我们简化一下处理流程。无论 more- move 页面有多少条电影数据，每当执行下拉刷新操作时都清空所有已存在的电影数据，重新加载最新的前 20 条数据。

根据以上思路，修改 ONPUIIDOWN Refresh 函数。

黑色加粗部分为新增加的代码。当下拉刷新触发 onpulldownrefreshi 函数后将 this.data. Moves 清空。

完成以上代码后，现在每当我们在 more- movie 页面上滑触底后页面都将触发 on Reach Bottom 事件，从而实现加载更多电影数据

10.21 动态设置导航栏 oading 图标

我们在前面实现了 more- move 页面的下拉刷新电影数据与上滑加载更多电影数据的操作，但是整个加载数据的过程体验并不是那么好，总觉得缺少了点什么

拿上滑加载更多电影数据来看，从触发加载数据到数据显示，整个过程没有等待提示，当数据加载完成后「突然」就显示了出来。

虽然我们建议目前的小程序不要使用太多的特效，但是必要的等待提示是用户最基本的心理预期，还是可以加上的。

在前面的章节中，我们学习过 wx. Show Toasty 提示。Wx. Showt）将在页面的中间位置显示

个模态或者非模态（showtoast 的 mask 属性決定是模态还是非模态）的提示框。

笔者认为，对于 -loading 状态提醒，用这种置于页面中心位置的侵入式提醒体验并不好。Loading 并不需要很强的信息通知，用户不需要阅读文字，只需要能够感觉到正在加载即可，所以使用「侵入式」的 NX. Showtoast 并不是太合适。我们希望有一个「非侵入式」的 loading 状态提醒，只让用户从心理上感觉到页面正在加载即可。

小程序提供的一个 AP 方法 NX. Shownavigationbarloading（）非常适合用于 loading 状态提醒。通常来说，Wx, shownavigationbar Loading）和 wx, hidenavigation Loading（）是成对出现的个负责显示 loading 状态图标，一个负责隐藏 oading 状态图标。

图 10-21 显示了导航栏 loading，状态图标的效果。

考虑一下，我们需要在 more- move 页面的哪些操作中调用 Wx. Shownavigationbarloading（）显示 loading 状态图标又需要在什么地方调用

Wx, hidenavigationbar Loading（）隐藏状态图标。

基本上，每次去豆瓣取数据时就应该显示 loading 状态，当数据处理完豆瓣电影数据并使用 this. Setdata 更新电影数据后应该调用 Ww: hidenavigationbar Loading（）方法隐藏 ading 状态。

具体到 more- mover 页面，我们可以在 onload 初始化加载电影数据时、on Reach Bottom 滑动加载更多电影数据时以及 Onpulldownrefresh 下拉刷新电影数据时调用 Wx. Shownavigation Barloading（）显示 oading 状态图标，而在 processdoubandata 中处理完豆瓣数据后调用 wx. Hide Navigation Bar Loading0) 隐藏状态图标。

在以上几方法中分别添加 Wx, shownavigation Barloading（）与 wx. Hidenavigationbarloading（）方法。

在以上几段代码中，黑色加粗部分为新增加的代码。

添加完以上代码后，开发者注意观察一下当正在加载数据时和数据加载完成后导航栏 loading 图标的显示和隐藏效果。

这里要特別说明以下 3 点

第一，下拉刷新时可以不使用导航栏的 oading 状态图标，因为下拉刷新本身在页面的窗体部分就有一个 oading 状态图标，如图 10-18 所示。

第二，在以上代码中，我们没有考虑数据加载失败的情况。如果数据加载失败，程序就无法进入 processdoubandata 方法中，从而导致无法执行 wx. Hidenavigation Bar Loading（）方法，导航栏的 wading 图标一直显示。Orange Can 只是一个示例项目，如果完全模拟真实项目，需要写太多同小程序无关的代码，所以建议开发者在真实的项目中注意容错处理。「永远不要相信外部环境」是每个开发者要时刻牢记于心的真理。开发者可以尝试将隐藏 loading 图标的代码放在 wx. Requestl 请求的 complete 函数中，这样无论数据加载是否成功都将隐藏 oading 图标。

第三，在 onload 数中调用 Wx. Shownavigationbarloadingl 函数设置页面导航栏是有风险的，原因我们已在 6.9.2 小节中解释过。当前版本没有问题，并不代表未来版本不会有问题，何况在 onready 页面生命周期之后再操作界面元素是官方文档中明确说明的。所以建议开发者最好还是在页面的 on Readyp 函数中动态设置导航栏 loading 状态，同官方文档的要求保持一致。下面给出在 more- movie 页面的 onreadyp 函数中设置 loading？状态的代码，开发者可自行选择是否使用以下代码，毕竟在 130400 版本中在 onload 函数中设置 loading 状态也是没有问题的。

从设置 loading 状态标示这个小示例中我们应该能体会到小程序到底简单在什么地方。你无须过多考虑 loading 应该怎么去提示，小程序已经帮你「安排」好了。虽然这些固化的 API 让程序显得很没有个性，但是小程序的特性就是用完即走。有时候牺牲一些个性化与美观度，换来更高的开发效率与更低的开发成本是值得开发者考虑的。

当然，如果你不满意小程序的 loading，完全可以自行编码来实现自己理想的 Loading 状态机制。

10.22 电影搜索

在本节中，我们将实现电影搜索功能。电影搜索的效果图，如图 10-22 所示。

我们并没有选择使用一个新的页面来编写电影搜索的功能，电影搜索位于 ove 电影首页。当激活搜索时，电影首页的资讯面板信息被隐藏，电影搜索面板被显示；相反，当退出电影搜索时电影搜索面板被隐藏，而电影资讯面板将被显示。

下面我们在电影首页中实现这个显示与隐藏的效果。在 move.wxml 中添加并修改以下代码：

黑色加粗代码是添加并修改的代码。

首先我们添加了一个《view class==" search「》容器，在该容器的内部实现了ー个 - inpute 的搜索栏 placeholder 属性设置了 inputa 的默认占位文字；placeholder- class 属性指定了 placeholder？样式类的类名，该样式将在随后被添加到 move.WXss 文件中。bindfocus 事件将实现鼠标或者手指激活 inpute 时显示搜索面板，bindconfirm 事件将实现提交搜索信息的功能。XX-img 将实现点击后关闭（隐藏）搜索面板。

同时，在《view class=" container「》这个电影资讯面板上增加一个属性 wx: f { containershow} y「，这个属性也是用来控制电影灸讯面板显隐状态的标识位。

最后，我们增加了一个《cview class="search- panel"'》。这个面板就是电影搜索面板，主要用来显示搜索结果。

可以看到，在电影搜索面板中并没有编写任何代码，我们再一次地使用了 move-grid-tpl 模板。所以，我们在代码的顶部再次引用了 movie-grid-tp 模板。

添加完电影搜索的骨架代码后，我们来编写电影搜索的样式。在 move.Wxss 文件中添加以下同电影搜索相关的样式：

黑色加粗部分为新增代码。记得在代码的顶部引用 move-grid-tpl 模板的样式。

当编写完以上代码后，保存并运行项目，发现电影首页的电影内容「消失」了。由于我们没有正确地在 movie 页面的 is 文件中设置搜索面板同电影资讯面板的显隐控制变量，因此电影资讯面板默认被隐藏了。

下面在 movie. Js 的 data 变量中设置 searchpanelshow 与 containershow 的默认值。

黑色加粗部分是新增代码。除了设置「containershow: true」让电影资讯面板显示、search Show: false」让搜索面板隐藏外，我们顺便将搜索结果的初始化变量 search Result 也加入 data 変量中。

此时保存并运行代码，将出现如图 10-23 所示的效果。

以上代码实现了搜索面板与电影面板的初始化状态。现在，当用户激活 input 搜索栏准备输入关键字开始搜索时，我们需要显示搜索面板并隐藏电影灸讯面板。已经注册在 input 组件上的 onbindfocus 事件将实现这个显隐切换效果。

在 movie. JSE 中添加 on Bindfocus 事件响应函数。

当用户激活 iinput 组件后将执行 on Bindfocus 函数。这将隐藏电影资讯面板，并显示搜索面板，准备接受用户输入，如图 10-24 所示。

用户通过点击图 10-24 中 input 搜索框右侧的 X 图片，可以关闭搜索面板并再次打开电影资讯面 板。在 move.js 中添加点击 X 图片的事件响应函数 on Cancellmgtap。

在上述代码中，我们除了切換两个面板的显隐状态外，同时清空搜索结果 search Result，保证下次再次进入搜索面板时，搜索面板不会记录上ー一次的搜索结果。将 input Value 的值设置为空字符串将保证 input：组件所记录的用户输入值也一并被清空。

需要注意的是，Input 组件的输入文本是无法设置字体的，因为在小程序中 Input 组件是一个 native 组件，字体必须使用系统字体，所以无法设置 font- family。在真机上运行时，它也将被设置为真机系統的默认字体。

当用户输入关键字并按键盘上的「回车」或者点击真机上的「完成」后，小程序将触发 inpute 的 bindconfrn 事件，并执行已经注册在 input 上的事件响应函数 onbind Confirm。

在 movie. S 文件中添加 on Bind Confirm 事件响应函数

On Bind Confirm 的代码非常简单，首先获取到用户的输入值 key Word，这个值稍后将被附加到豆辧电影搜索 API 的 URL 地址中。

豆瓣电影的搜索 AP 地址为 / 2/move/ search? q= keyword｝，我们只需要将获取到的 key Word 附加在 APl 地址中并调用 this. Getmovielistdata 方法即可。this. Getmovie Listdata 方法早在编写 movie 页面的电影数据显示时已经编写好，这里只需要调用即可。

this. Getmovie Listdata 接收 3 个参数，searcher 是豆瓣 AP 的数据访问地址，" serach Result「指定将处理完毕的豆瓣数据绑定到 searchresult 变量上，以提供给 xml 显示数据

 <template is="moviegridtpl "data"t. Searchresult) "/>

 

10.23 电影详情页面下面我们来编写电髟详情页面。

先思考一下电影详情页面的入口在哪里。任何一个显示电影封面（见图 10-25) 的地方都应该能够点击进入到电影详情页面，这些入口遍布在电影首页、电影搜素、更多电影等多个地方。好在

我们是使用 emplate 模板构建的电影页面结构体系，所有的电影单体元素都集中在 movie-tpl 这

个 template 模板里。也就是说，只需要在 move-tp이模板上注册相应的点击事件即可。

在 10.4 节中，我们已经在代码清单 10-5 中注册了 move-tpl 的点击事件 onmoviet ap。现在要做的就是在每个包含 move-tpl 的页面中编写 on Movie T ap 事件响应函数，并在事件响应函数中将页面跳转到 move- detail 页面。

首先，新建 move- detaill 页面并注册这个页面。在 app. Son 的 pages？数组下注册 move- detail 页面

黑色加粗部分为新增代码。保存后开发工具将自动在 pages/movie/ movie- detail l 目录下新建 move- detaill 页面的 4 个页面文件。

在以下两个使用过 movie-tp이模板的页面 js 文件中编写 onmoviet ap 事件响应函数

movie. S

more-movle s

注意以上两段代码所设置的 wx navigate Tof 的 urI 参数值是不同的。我们同时还将所点击电影的 id 号附加在 ur 中，传递到 move- detail 页面中。movie- detail，只有知道电影的 id 号才能够正确地加载电影详情数据。

从以上两段代码，我们也可以再次看出小程序模板的缺陷：模板不能运行自己的业务逻辑代码。onmovie T ap 的业务逻辑本应当属于模板自身的业务逻辑，但由于模板不可以运行 js 代码，因此只能将本属于模板的业务逻辑编写在调用模板的页面 js 代码中。在 Orange Can 项目中，我们幸运地只在两个页面引用了 move-tpl 模板，但如果有十几个地方引用了 move-tpl 模板，就不得不在这十几个地方一次编写上述代码。

当然，可以将模板的业务代码编写成一个类似于 utl 一样的模块，并在其他页面里引用这个模块，但 movie Tap 里的代码终究还是

属于 move-tpl 的，无论放在什么地方都不如放在模板自己的业务逻辑文件中。

编写完以上代码后，无论是在 movie 页面、more- move 页面还是是在电影搜索的结果页面上，点击任意电影都将跳转到 movie- detaile 电影详情页面。

接下来，我们需要编写 movie- detail 电影详情页面的骨架与样式。电影详情页面的效果如图 10

26 所示。

10.24 电影详情页面的骨架和样式

本节我们开始着手编写 move- detail 电影详情页面的骨架与样式代码。在 move- detail.wxml 文件中添加以下代码：

注意，在 move- detail 页面中我们同样使用了 stars-tpl 模板，记得在代码的顶部引入这个模板文件

骨架代码中并没有什么新鲜的知识，唯一值得关注的是我们使用了一个 scroll-view 组件。这组件用于横向展示多张演员图片，这些演员图片会「突破」手机尺寸的限制，在横向出现滚动条。图 10-27 展示了 scroll-view 的横向滚动效果图。

Scroll--View 组件的 scroll-x7 和 scroll-y 分别设置组件的横向和纵向是否出现滚动条，如果想使用横向 scroll-vien，就请设置 scroll-x="true

scroll-View 组件的横向排布要注意以下几个要点

如果 scroll-view 下排列的多个子元素是块级元素（比如 vew），就直接对 scroll-view 设置 display: flex 和 Tex- direction: ow，不会使子元素自动成为水平排列。如果不使用 scrol-view 而将容器元素換成 view，那么设置 display: flex 和 Tex- direction: r ow 是可以使子元素自动成水平排列的。

如果想让 scroll--View 下的 view 元素水平排列，一种可行的方法是将子元素 view 设置为 inline block 或者 inline-fex。

子元素有可能会出现换行的情况，需要在容器上设置 white- Space: no wrap。

我们会在后面的章节中详细讲解 croll-view 的一些高级用法，现在我们只需要掌握这些 scroll view 的简单用法即可。

这里顺便提一下，scroll-view 中的 bindscrolltolower 事件也可以用来实现加载更多数据（类似于 Page 页面的 on Reach Bottom）。当 scroll-view 滚动到底部或者右边时将触发这个事件，实现原理请参考 more- movie 页面的 on Reach Bottom 函数。

实际上 Orange Can 项目最初在编写 more- movie 页面加载更多数据时也是使用的 scroll-view 的 bindscrolltolowerg 事件，但微信在 130400 版本更改了一些规则，官方文档中是这样描述的：在滚动 scrl~ vew 时会阻止页面回弹，所以在 scrl- vew 中滚动是无法触发 onpuiidownrefresh 的

在 130400 版本之前，scroll-view 的滚动同 on Pulldown Refresh 下拉刷新事件是不冲突的，但版

本更新后若使用 scroll-view 则在 scroll- -viev 组件中下拉页面是无法触发 Onpulldownrefreshil 函数的。正是基于这个原因，笔者最后没有使用 scrolll-view 来实现 move-grid-tpl 模板，而是改为使用普通的 view，并使用 Page 的 on Reach Bottom 函数实现了加载更多数据的功能。

除此之外，scroll-View 还有以下几个需要注意的地方：

请勿在 scrol~iew 中使用 textarea、map、canvas、video 组件。

scroll-into-view 的优先级高于 scrol-top。

在滚动 scroll-view 时会阻止页面回弹，所以在 scroll-view 中滚动是无法触发 onpulidown Refresh 的。

若要使用下拉刷新，请使用页面的滚动，而不是 scroll-view，这样也能通过点击顶部状态栏回到页面顶部（经过测试发现，必须点击手机的状态栏而非小程序的导航栏才能返回页面顶部。请在豆瓣이p250 的「更多电影」页面测试此特性），如图 10-28 所示。

关于 scr 的更详细介绍和高级用法请参考 13.2 节，本节我们仅使用 scroll-view 的基本功能。接着编写 movie- detail I 页面的样式。将以下代码添加到 move- detail.Wxss 文件中：

同样记得在代码的顶部引入 stars-tp이模板的样式文件。webkit-ter: blur (20px）实现了图片模糊的效果。

由于现在并没有编写页面的逻辑文件，因此我们暂时无法看到页面的显示效果。

10.25 编写电影详情页面的业务逻辑代码

现在编写 move- detail 电影详情页面的业务逻辑代码在 movie- detail. Js》文件中添加以下代码

整个代码逻辑非常简单，仅仅是获取数据并处理数据。豆瓣 A 获取电影详情数据的 URL 为 / V2/movie/ subject/ Isubjectid}。

需要注意的是，豆翔的许多电影由于年代久远而导致数据有所缺失，这会造成很多「空值」情况。有些空值只会让数据无法显示，但程序不会报错；有些空值则会直接导致程序终端运行。对于第二种空值，我们一定要做容错处理。

导致程序终端的空值多是由于对象是 null 而我们却尝试去读取空对象的属性，这样的行为导致程序报错，无法继续运行。如果是字符串 null，那么绑定一个空字符串程序是不会报错的。

豆瓣电影的数据结构非常复杂，无法一次将所有的属性都做容错处理，所以建议遇到错误时再回头编写容错代码。比如上述代码中对 directors 的属性处理就属于容错性处理。

在以上代码中，又调用了两个 util 函数：uti. Converttostarsarray 和 uti. Converttocastinfos。现在在 uti 模块中编写这两个函数。

黑色加粗的代码是新增代码。

保存并运行代码，点击任意一张电影海报都可以将页面跳转到 move- detaill 贞面，并正确显示电影详情数据。

10.26 预览电影海报

豆瓣的电影海报是比较精美的，我们可以尝试在 movie- detail 电影详情页面新增一个预览电影海

报的功能。

点击 movie- detaild 中悬浮在头图上的电影海报将打开一张电影海报大图，如图 10-29 所示。红色框所框选的区域就是触发点击事件的区域。

在之前编写文章评论时我们已经讲解过图片预览。同时，在编写 movie- detail wxml 文件时已经在这个 Cimage 上注册了 viewmoviepostlmg 事件。现在我们只需要实现 viewmoviepostimg 事件响应函数即可。

在 move- detail. Js 文件中添加 viewmoviepostlmg 函数。

代码清单 10-60 编写图片预览函数 movie-detailjj

览电影海报

view Moviepostlmg: function (event) t

var src=event. Current Target dataset, src

current: sre

保存代码，尝试点击小海报，将打开一张大图

电影详情页面是非常值得分享的内容，开发者可自行用我们之前讲到的分享 API 实现电影详情页面的分享功能

10.27 设置电影页面的导航栏标题

所有配置或者是动态设置导航栏标题的方法在之前的章节中已详细讲解过，本节就不赘述了。下面直接给出配置代码。

首先，配置 movie 电影首页的导航栏标题，在 movie. Son 文件中新增以下代码：

接着，设置 more- movie 更多电影页面的导航栏标题。在 more- move. S 页面中添加以下代码，以保证 more-move 页面的导航栏标题被设置为当前电影的电影分类

代码清单 10-62 保存当前电影类型 more-movle, s

on Load: function  (options) f

var category =options. Category

this data. Navigate Title=category

∥。省略若干行代码

以上代码黑色加粗部分为新增代码。将 ategory 电影类型暂时保存在 data 变量中，再在 more

movie. Js 的 on Ready 函数中读取这个变量并动态设置导航栏标题。

代码清单 10-63 动态设置导航栏标题 more-movle. S

on Ready: function 0) #

wx. Setnavigation Bar Title (

title: this data. Navigatetitle

wx show Navigation Barloadingo

最后，我们还需要将电影详情页面的导航栏标题动态设置为当前显示电影的电影标题。在 move- detail. Js 文件的 processdoubandatal 中新增一小段代码。

代码清单 10-64 动态设置导航栏标题 movie-detail. Js

processdoubandata: function (data) t

∥省略若干行代码

this. Setdata (!

movie. Movie

w. Setnavgation Bartitle (

title: data. Title

黑色加粗部分为新增代码。

编写完以上代码后，3 个电影页面的导航栏标题就全部设置完成了。

