# 07 收藏、评论、点赞与计数功能

本章内容有一定的难度，但其中的技巧和知识还是很丰富的。本章通过编写几乎所有内容型应用都会附带的「评论」「点赞」「读计数」「收藏」等功能，来学习使用小程序的交互反馈组件、缓存的应用、图片选择和预览、屏蔽关键字、录音、拍照以及播放录音等功能。

## 7.1 收藏、评论、点赞、计数功能准备工作

接下来我们将要连续实现 4 个非常有意思的功能，这些功能在内容型应用中是非常常见的，分别是收藏、点赞、评论和计数。

我们先来编写收藏、评论和点赞的功能按钮。阅读计数是一项被动功能，无须用户有意识地主动

触发。在 post- detail.wxm 中新增一段工具栏代码。

黑色加粗部分为新增代码

在 post- detail. Wxml 页面的 container 中添加了一段《view class="tool「》的相关代码。该代码实现了收藏、评论和点赞 3 个功能按钮。每个功能按钮都绑定了对应的点击事件，注意 View 组件上的 catchtap 属性。除此之外，我们还在每个功能按钮上使用 data-post-id 绑定了当前文章的 id

unum、commentnum 和 collectionnum 等数据已经在 5.13 小节中全部添加到了 data. Js 文件中

接着编写 3 个功能按钮的样式。

保存刷新后，3 个功能按钮将出现在 post- detail l 页面的正下方，如图 7-1 所示。

## 7.2 文章收藏功能

我们首先来实现文章收藏功能。文章收藏功能需要记录两个变量值

自己是否收藏了文章。如果自己收藏了，那么需要将收藏的图片更換为已收藏。

所有用户收藏文章的总数量。需要注意的是，由于我们的数据库只在本地，无法多次收藏同篇文章，所以收藏数量永远只能在初始数量的基础上 + 1 或者 - 1, 分别对应取消收藏和点击收藏两种状态。但在真实的项目中，这个收藏数量却是要受到所有用户取消、收藏文章动作影响的。同样的情况也会出现在文章点赞」这个功能里。

当页面从 post 跳转到 post- detail 时，我们就需要知道该文章是否已被用户收藏。在 data. Jsl 中，我们使用 collection Status 这个属性表示文章是否已被收藏，这个变量的类型是 Boolean。那么如何根据 collectionstatus 这个变量的取值来动态切換收藏图标呢？

熟悉传统 Web 开发的读者很容易想到用 jquery 获取 image 标签，再动态地设置 Image 的 src 属性。再次强调，小程序没有 dom，一切都是数据绑定，请抛弃 dom 的思维方式。

7.2. 条件渲染：Wxif 与 wx else

collectionstatus，只有两种取值：true 或者 false。我们需要做的是，当 collectionstatus 为 false 时，显示图 7-2 未收藏状态的图标，而当 collectionstatus 为 true 时，显示图 7-3 收藏状态的图标。

以上需求是不是就是编程中非常经典的 f else？如果 wxml 组件也像 js 代码一样有 fele 就可以解决动态显示收藏图片的问题。下面来看看如何实现这个功能。

小程序提供了 wx: f 与 welse 来实现条件渲染。当変量为 true 时，执行 Wwx: f，否则将执行

Wx: else。修改收藏按钮的 Wxm 代码如下：

上述代码中我们添加了两个 images 组件，分别是收藏和未收藏图片。这两个 image？组件各有一个 Wx: f 和 wx: lse 属性。当 post. Collection Status 为 true 时将显示 NX_app_ collected.png 图片而当 post. Collectionstatus y falsel 时将显示 Wx_app_ collect. Png 图片。

由于我们已经在 data-js 文件中将部分文草的收藏状态设置为 true，因此保存并运行项目，发现所

有 collectionstatus 为 true 的文章，其收藏图片都将显示 WX_app_ collected.png，如图 7-4 所

刀 N

如果变量 ilength 的取值大于 5, 那么将显示数字 1。

如果变量 ilength 的取值大于 2 且小于等于 5, 那么将显示数字 2

以上条件都不满足，就显示数字 3。

你还可以添加更多的 lif 分支，以实现更多级别的条件判断

7.2.2 实现收藏点击功能

在 7.2.1 小节中，我们仅仅是在 post- detail l 页面加载时读取了该文章对于当前用户是否为收藏状态，并正确地设置和显示了这个状态。

在这个小节中，我们将实现用户点击图片进行文章的收藏和取消收藏功能。首先我们继续完善

DBPOST 这个数据库操作类。在 Bpost 类中添加一个方法，用以处理文章的收藏操作

该方法中调用了 Poste 类的 updatepostdata 方法，这个方法我们还没有编写

在 DBPOST？类中添加 updatepostdata 方法。该方法是处理点赞、评论、收藏、阅读的核心方法。

我们目前仅处理 collect 这一种操作，后续我们将继续在代码清单 7-6 的 switch case 中添加评论、读数、点赞等处理分支。

这样，Dbposti 就具备了处理文章收藏的能力。当用户点击收藏按钮后，在点击事件函数中调用 DBPOSTE 的 collect 方法即可。

处理文章收藏动作的事件函数是 on Collection ap，这个事件函数已在代码清单 7-1 中被注册在了收藏功能按钮上。我们只需要在 post- detail. Js 中编写这个方法即可。

7.2.3 交互反馈 Wx: showt oast

现在，我们已经实现了文章的收藏与取消收藏功能，但收藏功能的体验并不好，用户在收藏和取消收藏后没有任何交互反馈提示。

小程序提供了一些交互反馈 A 来帮助开发者处理交互相关的问题。目前，小程序提供了以下 4 个交互反馈 AP이

wxshowt oast w. Hide Toast wx. Showmoda Wx. Showactionsheet

我们选用 wx. Showt oast (object）来制作文章收藏功能的交互反馈。

其中，object 参数的 itl 属性用于设置提醒消息的内容；duration 设置提醒的自动消失时间，最长 10000 富秒，默认值为 1500 毫秒；icon 可以设置一个小图标，其取值只能是 success 和 oading; mask 指定是否显示透明的蒙层，以防止触摸穿透，默认值为 false

mask 主要用来防止用户连续点击收藏按钮。开发者可执行尝试将 mask 设置为 true 和 false 时的不 同效果：当 mask 为 true 时连续点击收藏图标，图标不会连续做出收藏 / 取消收藏的响应；当 mask 为 false 时，就会不停地响应用户的点击操作。

Wx. Showtoastl 的效果如图 7-5 所 f 示。

## 7.3 文章点赞功能

文章点赞功能的实现思路同收藏几乎是一样的。首先在 Bpost.js 中增加点赞的方法。

代码清单 7-9 添加处理点赞操作的方法 Dbpost. Js

∥点赞或者取消点赞

upo t

var data =this. Updatepostdata ('up);

return dat

接着在 DBPOST 的 updatepostdata 方法中处理当 case 为 up 时的情况。下面给出 updatepostdata

的全部代码

黑色加粗部分为新增代码。代码清单 7-10 同代码清单 7-6 相比，仅仅增加了 case 为 up' 时的这段代码。很明显，我们可以看到处理点赞的逻辑同处理收藏时的逻辑几乎一样：改变 up Status 的状态，并对 unum 这个计数变量做相应的增减操作。

我们编写完 DBPOST 中关于点赞的接口后，接着编写 post- detail. Js，和 post- detail. Wxme 中关于点

赞的相关代码。

Onuptap 方法响应用户点赞的动作。当用户点击点赞按钮后，onuptap 方法将调用 Dbpost 的 up 方法并将返回的最新数据使用 this. Setdata 更新。

类似于收藏功能，我们还需要使用条件渲染 wx: f 改写 wxml 中的点赞按钮。

以上代码将在 post. Upstatus》为 true 时显示 WX_app_iked.png，当 post. Upstatus 为 false 时显示 wx_app_like. Png.

在编写完以上代码后，保存运行项目，点击点赞按钮，图片会不断切換，点赞数也将相应地 + 1 或者 - 1

很多开发者可能还不太习惯使用数据绑定的方式来做样式、状态的切换，但数据绑定的写法确实非常简化、方便。我们只需要在 js 中改変各类变量的状态和值，前端组件就会响应我们的操作，动态地做出变化

## 7.4 本地缓存的重要性及应用举例

提供本地的 key& value 缓存机制是小程序的一大特点，善用本地鍰存将可以极大地改善客户端的体验与服务器的性能。

前几个小节中，我们大量地使用了本地缓存来模拟服务器的数据库。这样做一方面是因为我们并没有真实的服务器，必须依靠客户端的缓存能力来记录数据；另一方面是因为即使在真实的项目中我们拥有自己的远程服务器，也依然需要在客户端管理本地缓存。

举个例子，如果我们要实现一个城市列表插件，就必然要获取全国所有城市的信息。全国大概有 600 多个城市，这么大的数据量难道每次打开这个插件都要去服务器取城市数据吗？这些城市的数据相对非常稳定，并不会频繁变化，每次都去服务器加载是对流量和服务器性能的严重消耗。

所以，最好的解決方案就是将城市数据保存在本地缓存中，而不是每次都去服务器请求数据。

在一个高性能的产品中，缓存的重要性是不言而喻的。建议开发者将本地缓存视作一个本地的

key& value 数据库，并封装一些类和公共方法，提供给项目中的各个调用方。最好不要让 getstorage、setstorage 等方法充斥在项目的每一个角落。

Orange Can 项目中的 Bpost 类就是一个不错的示例，它实现了对缓存的良好管理，并向调用方提供了一系列可读性非常强的 AI。建议开发者参考 Bpost 并将这种思路应用到自己的项目中。

## 7.5 支持文字、图片、拍照、语音上传的文章评论

文章评论不仅可以发表文字，还可以上传图片和语音。评论页面将使用一个全新的 post

comment 页面，它属于 post- detaill 的子页面。我们将通过点击评论功能按钮跳转到 post comment 页面。

首先，在 app. Son 的 pages 数组下注册 post- comment 页面。

代码清单 7-13 注册 post- comment 页面 app. Son

pages

pages/welcom

pages/post/post

post-detail/post-detail

pages/post/post-comment/post-comment

保存后将自动在项目里创建 post- comment E 目录以及页面的 4 种类型文件。post- comment 将作

为 post- detaile 的子页面。在 post. JS 中添加以下代码：

代码清单 7-14 on Comment ap 方法 post-detail. Js

uncomment Tap: function  (event) t

var id =event. Current Target dataset. Postld:

wx. Navigatcto (

url: ' /post-comment/post-comment?id="+ id

以上代码将携带当前文章的 d 号并跳转到 post- comment 页面

## 7.6 文章评论页面的实现步骤与思路

构建文章评论页面的思路分为两部分

加载并显示当前文章已存在的评论。实现添加新评论的功能。

这个思路不是做特定功能的思路，而是一种适用于大部分前端功能的通用思路，就像我们在 post- detail l 页面中去编写点赞、收藏等功能时一样，先显示点赞和收藏的数量、状态，再考虑实现点赞和收藏的操作功能。

我们来按照以下步骤逐步构建整个文章评论模块的相关页面和功能

在 post- comment. JSE 中获取并绑定文章评论数据。

编写 post- comment 页面的 wxml 和 wxs 显示文章评论数据。

编写添加新评论的功能。

## 7.7 获取并绑定文章评论数据

我们在 data. S 中《从童年呼嘯而过的火车》这篇文章下面模拟了 4 条评论数据（comments 数组）。

按照 7.6 节中分析的思路，首先应当从缓存数据库中读取这 4 条数据并将数据绑定到框架中。首先在 post- comment. JS E 中增加以下代码

以上代码引入了 Dbposti 鍰存数据库操作类，同时在 on Load 函数里接收由 post- detial. Js1 传递过来的 posted。接着实例化 DBPOST，再调用 DBPOST 的 getcommentdata 方法得到评论数据，最后使用 this. Setdata 将评论数据绑定到框架中。

很明显，我们的 Dbpostl 中缺少 getcommentdata 方法，现在来编写这个方法。在 Dbpost JSI 中新增以下代码

在 getcommentdata 这个方法中，我们还调用了 compare With Time 和 uti. Getdiff Time 这两个方法。compare Time 用于将评论按照时间降序排列，保证最新的评论在最上方 util. Getdifftimey 将评论的时间戳转化为「多少分钟前，多少小时前，昨天，月日」等格式。下面我们来实现这两个方法。

在 DBPOST JSE 中添加 comparewithtime 方法，代码如下

接着实现 util. Getdifftime 方法。这个方法属于公共方法，我们新建一个 uti 文件，将所有的公共方法都放置到这个 uti 文件中。

在根目录下新建文件夹 util，在 uti 文件夹下新建 uti! js 文件并在该文件中新增以下代码

上述 getdiff Time 方法中调用了 Date 的 format 方法。继续添加 formati 这个方法。需要注意的是，format 方法被添加在了 Date 的原型链上，这样所有 Date 类型的变量都将自动拥有 formati 这个方法。

不需要深入研究上面这段代码，只需要知道它的作用即可。最后，在 util. JSE 的末尾添加以下代码

代码清单 7-20 添加 module. Exports util. Js

module exports=t

g

这样 utl! js 这个模块就编写完成了。为了在 Dbpost.js 中引用这个模块，我们需要在 DBPOST, jse 中使用 require 来引用 uti 模块。

编写完以上代码后，Dbpostl 的 get Commentdata 就完成了。现在，在 post- comment.js 的 on Load 方法里就可以正确获取文章的评论数据。开发者可自行在代码清单 7-15 中使用 console.log (comments）来验证一下是否能够正确获取到文章评论。需要注意的是，我们仅仅在《从童年呼嘯而过的火车》这篇文章里设置了 4 条评论数据，其他文章是没有评论数据的。开发者可根据自身的需求修改 data. JSE 中的初始化数据。注意，修改完 data. Sh 后一定要用开发工具清除一下缓存，并重新运行项目，之后更改才能生效。

图 7-6 是输出的《从童年呼嘯而过的火车》这篇文章的 comments 変量。

Comments 数组中包含了 4 个 Object）对象，每一个对象代表着一条评论。

我们的评论支持文本、图片和录音 3 种类型。开发者可以对比一下图 7-6 中的 content 属性，在该属性下，img 数组是评论中的图片；txt 是评论中的文本；而 audio 是评论中的音频。注意，img 是数组，txt 是字符串，而 audio 是对象。

对于一条评论，有以下几条规则：

图片类型评论最多只能包含 3 张图片

·音频类型评论只能包含一条音频。

·一条评论可以同时包含文字和图片。

·音频类型评论不能包含文字和图片。

这样，我们就完成了获取并绑定文章评论数据这个步骤。在下一节中，我们将编写 post

comment 页面的 Wwml 和 WXss 文件来显示这些已绑定的数据。

## 7.8 显示文章评论数据

读取到文章评论数据后，我们需要编写 post- comment 页面的 Wwml 和 wxss 文件以显示这些数据。在 post- comment.wxml 中增加以下代码

整个代码里所用到的知识点都已经在前面的内容中讲到过，每条评论都会对 3 种类型的评论做处

理

我们重点来看看上述代码中的几个 wx: f 条件渲染

 <view cl ass="comment-txtwx: i f- itemcontent.xt">

这里的 wx: if 将判断 item. content.txt 有没有值，如果没有，那么整个 view 都不会显示；如

果有，就将显示文字评论。

 <view class=comment-vicew: f-i m. I&&imnt diou

这里的 Wx 将判断 audio 是不是空值，如果不是空值接着判断 audio 这个对象的 ur 有没有

值，只有满足这两个条件才会显示音频评论。

 <view class=comment-imgw: f=em. T mglength! =0">

这里的 wx: if 将判断 img 这个数组是不是空，如果不是空，就将显示多张图片。

正如我们之前提到的，WX: f 的应用是非常灵活的，开发者应当理解这种用法。

post- comment 的 wxml 编写完后，接着来添加评论列表的样式。

以上代码中有部分样式使用了 position: absolute，这是为了后面编写新增评论的功能而准备的。保存运行代码，post- comment！将显示如图 7 ー 7 所示的界面。

如果此时我们尝试去点击第二条评论的语言播放，就会发现它并没有效果，原因是初始化数据中的语音给的是一个假的 urI。这里只是为了展现语音评论的显示效果，在后面的章节中我们将真实地新增和旙放语音评论

## 7.9 实现图片预览

在 7.8 节中，我们所有的图片都以固定尺寸显示，并将 Image 的 mode 设置为了 aspectfill 本节我们将为图片添加预览功能。

无须自己编写图片预览插件，小程序已经为我们提供好了图片预览的接口 wx. Previewlmage (object）。它有以下两个重要属性：

current 当前显示图片的链接，不填则默认为 urls 的第一张。

urs 需要预览的图片链接列表，类型为数组。

这里要注意的是，urls 是一个数组，可以支持多张图片。它实际上类似于ー个相册，可以左右滑动查看多张图片.

修改 post- comment.wxm 中 class=" comment-img「这个 vew 组件内容。

以上代码在原有代码的基础上增加了以下属性

在每一张 cimage 图片上注册一个事件 catchtap-"previewing「，用来相应点击图片的操作。在 block 标签上新增 Wx: for- index: =" imgldⅹ「，用以定义图片序号。

在每一张 imagel 图片上绑定了ー个自定义属性：data- comment-idx="fidx} y「，用来绑定当前

评论在评论数组中的序号，并在 previewing 方法中获取这个序号。idx 已在《block wx: for="{comments} y"wx: for-item="item"wx: for- index="idx「》标签中定义。

在每一张 imagee 图片上绑定一个自定义属性 data-img-idx=" timgldxih「，用来绑定图片在图片数组中的序号，并在 previewing 方法中获取这个序号。

接着在 post- comment. Js 中实现 previewing 这个方法。

注意 wx. Previewimage 的用法，它接收一个 object。对象，对象的 urls 数组定义了一组需要预览的图片 url；而 current 定义了当前展示的图片 url

完成以上代码后，保存刷新项目

这时，我们会发现点击评论中的某一张图片后会打开图片预览窗口，但图片并不会显示出来。

wx. Previewimage 在当前 130400 版本中有以下几个情况会造成无法预览图片

wx. Previewlmage 只能预览位于网络中的图片，而无法预览本地图片。我们初始化数据中的图片是位于本地的，所以无法预览。开发者可以将 data.js。文件中的文章评论图片地址更换为以 http 开头的网络地址

除了网络地址和本地地址，还有一种地址是小程序的临时文件地址，对于这样的临时文件地址，同样在模扠器中无法预览，但在真机中却可以预览。关于临时文件地址，我们将在后面学习 Wx. Chooselmage 方法时看到

注意，在目前的 130400 版本中，本地文件既无法在模拟器中预览，也无法在真机中预览；临时地址文件无法在模拟器中预览，却可以在真机中预览。

130400 版本的下ー个版本已经放出了 beta 测试版，官方文档在版本说明中指出有可能会修复 Wx, oreviewimage 不支持 ocallde 的问题。经下载测试版测试，开发工具中可以预览来自临时文件地址的图片，但依然不可以预览本地图片。

总体来说，这些怪异的现象对我们开发小程序影响不大，因为在真实项目中评论显示的图片都来自于服务器，所以无论是在模拟器中还是在真机中都可以预览。

## 7.10 实现提交评论的界面

在前几节中我们完成了评论的显示功能。在这一节中我们将实现如何提交一条文本类型的评论。提交评论的功能区域如图 7-8 所示

点击提交功能区域最左侧的声音图标将可以由发送文本切換到发送语音，点击右边的加号图标将

可以选择图片和拍照。

我们一步步地完成以上各项功能。

首先需要完成的是文本类型评论的提交功能。在 post- comment. Wxm 文件中新增一段代码，以

显示评论区域。

接着编写 post- comment 页面的样式，在 post- comment. WXSS 文件中新增以下样式：

保存后，可以看到评论框的大致模样。当然，我们还没有为评论框编写任何逻辑代码，此时开发工具有可能会报错。

需要注意的是，代码清单 7-27 中的部分样式在代码清单 7-26 中并未全部用到，但我们在后续的代码中将会使用到。

下面我们来对 wxml 里的新增代码关键部分做一些解释

<view hidden-"{ usekeyboardflag}" class=" Input-item「》表示录音输入框

<view hidden="{! usekeyboardflag} y" class=" Input-item「》表示键盘输入框。

以上两个评论框由 usekeyboardflag 这个 Boolean 変量来控制显示或者隐藏。usekeyboardflag 变量将由 catchtap="' switchinputt ype「这个事件来控制。

catchtouchstart="recordstart「和 catchtouchend_=" recorded「将开启录音和结束录音

<cinput class=" input keyboard- -input「》实现文字内容的录入。关于 Input 组件的使用，我们将在后面详细介绍

catchtap=" sendmoremsg「将实现向内容中添加图片和拍照选择框的功能

catchtap=" submitcomment「将实现评论内容的最终发送功能

## 7.11 wxf 与 hidden 控制元素显示和隐藏

在小程序中，最常用的显示 / 隐藏 U 元素的方法有两种：一种是之前我们介绍的 wx:f, 另外一种是 hidden。我们特别在代码清单 7-26 中使用了 hidden 这种方式来控制元素的显示和隐藏效果。

在代码清单 7-26 中，注意以下两段代码。

 <view hidden= (tusekeyboardflag) "class="input-item">

 <view hidden=" [! usekeyboard Flag) "class="input-item">

hidden 的使用方式与 Wx: f 类似，都是通过一个状态变量来控制元素的显示和隐藏。

当 usekeyboardflag 为 true 时，第 1 个 view (hidden={ usekeyboardflag｝）将被隐藏，而第 2 个 View (hidden="{! usekeyboardflag}「）将被显示。当 usekeyboardflag。为 falsel 时，则第 1 个 view 被显示，第 2 个 vew 被隐藏。

那么 wx: f 和 hidden 之间有什么异同吗？

Wx: if 的切換和渲染机制较为复杂。当 Wx: f 进行切換时，MINA 框架有一个局部渲染的过程，它确保条件块在切换时销毀或重新渲染。

同时 wx: f 也是惰性的，如果初始渲染条件为 false，那么框架什么也不做，在条件第一次変成真的时候才开始局部渲染。

相比之下，hidden 就简单得多了，组件始终会被渲染，只是简单地控制显示与隐藏。

一般来说，Wx: f 有更高的切換消耗，而 hidden 有更高的初始渲染消耗。因此，在要频繁切換的情景下用 hidden 更好，在运行时条件不大可能改变时用 wx: f 较好。

## 7.12 实现文字评论框和语音评论框的切换

编写完页面的 Wwml 和 Wxss 文件后，我们来继续编写这些组件的业务逻辑。

首先实现「按住说话」和「说点什么吧。」这两个组件的切換效果。之前我们提到过，实现语音和文字评论框切换的效果关键是控制 usekeyboardflag 这个变量。

代码清单 7-28 初始化 usekeyboard Flag post-comment, S

usekeyboardflag: true

在 post- comment.JS 文件的 Page (object）方法的 data 属性下新増一个 usekeyboardflag 变量作为初始化的数据绑定变量。usekeyboardflag 初始值为 true 将导致评论框默认显示为键盘类型的输入框。

接着编写 switchinputt ype 方法来切換 usekeyboardflag 这个控制变量

此时，点击评论框最左侧的小图标将可以实现语音评论框和文字评论框的相互切換效果。

接着实现发送文字评论的功能。在实现发送文字评论功能之前，我们需要学习一个非常重要的组件：Input 组件。

## 7.13 input2 组件

Input 组件是最为重要的数据输入组件，比如我们这里要输入用户的评论信息时就需要用到这个组件。input 组件目前拥有以下若干属性

value String 类型，设置 Input 输入框的初始内容。

type String 类型，input 组件目前有 4 种类型，即 text、number、idcard、digit，默认是 text 类型

password Boolean 类型，如果设置为 true，就会用 * 号来遮蔽输入，默认为 False。

placeholder String 类型，输入框为空时的占位符。所谓占位符，就是当输入框内没有任何用户输入时默认显示的文字，比如 post- commenti 页面文字输入框中默认显示的「说点什么吧

placeholder-- style String 类型，指定 placeholder 的样式。可以将 placeholder 的样式编写在这里，形如组件中的 style 属性一样，只不过 placeholder- style 属性专门用来编写 placeholder 样式，而非编写整个 inputr 的样式。比如你可以这样写：placeholder- style-" color: #33 B: font size: 24rpx

Placeholder- class String 类型，如果你不想在组件的标签上写样式，就可以使用这个属性来指定一个已编写好的 CSS 类名，如同标签的 class 属性一样使用。

disabled Boolean 类型，用于设置是否禁用 nput 组件，默认值为 fale。

maxlength Number 类型，最大输入长度。设置为 - 1 的时候不限制最大长度，认值为 140。

o cursor- Spacing Numbera 类型，指定光标与键盘的距离，单位是 pX。取 inputt 距离底部的距离

和 cursor- Spacing 指定的距离的最小值作为光标与键盘的距离，默认值为 0

focus Boolean 类型，自动获取焦点并拉起键盘，默认值为 false。如果某个页面的 Input 组件包 含这个 focus / 属性，且将其值设置为 true，那么当进入这个页面后光标将自动定位到 Input 中，且会自动拉起输入键盘

以上是 inputp 的所有属性。接下来我们看看 input 组件的 4 个事件，这 4 个事件才是 input 组件的重

点和难点：

bindin bindfocus bindblur

bindconfirm

注意以上事件和我们常用的 catch、bind 开头的通用事件是有区别的。它们是由 MINA 框架直接指定的，不需要在事件名称前再添加 catch 和 bind，干万不要写成 bindbindinput 或者 catchbindinput。

止此外，以上 4 个事件都属于非冒泡事件，这是它们和 catch、bind 等通用前缀事件的重要区别。形如 catchtap 等事件通常都是冒泡事件。

首先来看看 bindinput。bindinput 事件较为特殊，具有以下几个特点：

当用户输入字符时触发。

每当用户输入或者删除一个字符时，bindinput 事件都会触发一次

可以在事件响应函数中使用 return 返回一个字符或者字符串，该字符串将替换 input 输入框的显

示文本

它非常适合用来做「即时搜索」的功能。

bindfocus，当 input 组件获取焦点时触发。我们将在本书后面的电影部分看到这个事件的用法。

bindblur，当 linput 组件失去焦点时触发

bindconfirm,122100 版本新增事件，专门用来响应真机上点击键盘「完成」按钮的事件 input：输入值都是在事件对应的响应函数中使用 event. Detail. Value 来获取的。

## 7.14 bindinput 事件

考虑到一些特殊的输入法键盘或者用户的习惯，我们除了支持点击真机键盘上的「完成」按钮发送文字评论外，还实现了一个小程序里的「发送」按钮。

我们先来实现自定义的「发送」按钮。实现自定义发送评论功能的第一步就是能够在 js 中获取 Input 的 value 输入值。我们使用 bindinput 事件来获取 inpute 的输入值。

在 post- comment. Js 文件中新增以下代码：

使用事件的 event》对象下的 detail. Value 来获耿 input 的输入值，并将这个值保存在 this.data 中。

除此之外，我们在代码中加入了一段 console. Log (val），一起来看看 bindinput 事件是如何响应用户输入的

在 Input 输入框中不断输入任意字母，比如 q，再不断地删除 q。在 onsale 面板中将看到如图 7-9 所示的输出。

可以看到，每次输入一个 q 都会触发 bindinput 事件，并 console 出当前的 input 值；每次删除一个字符 q 同样会触发 bindinput 事件，并输出当前的 Inputt 值。

## 7.15 屏蔽评论关键字

bindinput 还有一个有意思的特性，就是在事件响应函数中可以 return ー个值来代替当前的输入值，并显示在 Inpute 中。下面一起来看一下效果

将 bind Commentinpute 函数内部的代码临时更改为以上代码（请注意在测试完毕后还原成之前的代码）。

保存代码后，在 Input 组件中不断地输入字符「a」，Input 组件将显示如图 7-10 所示的内容

很明显，每次输入 q 后都会被更改为 q+

这个 return 的机制非常适合用来过滤关键字。如果不想让用户输入 qq」「微信号」等关键字，就可

以用这种方式强制过滤掉。

我们以屏蔽 qq」这个关键字为例来看看如何实现屏蔽关键字。

以上代码实现了当用户输入「aq」时，自动被替换成「*」。注意，最后 return 的是一个 object 对象，该对象的 value 表示要替换的文本值，而 cursor 表示光标所处的位置

其实我们不需要关心 cursor 光标的位置，以上代码只是为了告诉开发者可以控制光标的位置。如果只想屏蔽掉关键字，只需要以下几行代码：

当用户在 Inputi 中连续输入两个 q 后，屏蔽关键字的效果如图 7-11 听示。

## 7.16 实现自定义发送按钮

在实现自定义发送按钮功能之前，请将 bind Commentinpute 函数恢复成代码清单 7-30 中的代码。在代码清单 7-30 中，我们成功地获取了用户的输入，并将输入文本保存到了 this.data 変量中

发送按钮的事件响应函数是 submit Comment。在 post- comment. Jsp 的 Page 函数中添加以下代

码

Submit Commenti 中首先构建了一条新的评论 newdata。需要注意的是，new Datal 中硬编码了当前用户的用户名，头像分别是「青石」和「avatar-3.png」

当组装完这个 newdata 的评论对象后，我们还需要经过以下 4 个步骤

步骤 01 将 newdata1 保存到缓存数据库，以便下次打开评论页面时可以显示这条 new Data

步骤 02 显示评论发表成功的提示。

步 03 将当前发表的评论添加到评论列表中，并显示这条新添加的评论。

步骤 04 清空 Input 组件，准备接收下一条评论。

以上 4 个步骤分别对应着代码清单 7-34 中最未尾的 4 个方法调用。

首先来完成步骤 1。在 DBPOST 中新增 new Comment 方法，用来保存新评论到缓存数据库中。

该方法内部再一次调用了 this. Updatepostdata 方法。我们来修改一下 updatepostdata 方法，让其能够支持新增评论」。完整的 updatepostdata 如下

相比之前的 updatepostdata 方法，我们为该方法新増了一个参数 newcomment，用以接收新的评论数据；接着在 case 中新增了ー个 case comment' 分支，用来处理新增评论。

这样步骤 1 就完成了。接着我们来编写步骤 2: 显示评论发表成功的提示。

在 post- comment. Js 中新增 showcommitsuccess Toast 方法

以上代码将完成步骤 2, 继续来编写步骤 3: 将当前发表的评论添加到评论列表中。

在拥有 DOM 节点的对象中，比如在传统网页中，如果我们想插入一条评论，需要新增一个 DOM 节点，并将这个 DOM 节点 insert 插入到 DOM 数组中

在小程序中，我们没有 DOM，也只有一种方式可以操作数据，即数据绑定。不存在「新增一个 DOM，再将 DOM 节点插入到 DOM 对象数组中」这样的思路。

如果我们需要在已有的 n 条评论中插入一条评论，并在 U 中显示这 n+1 条评论，我们只能将这 n+1

条评论全部重新做数据绑定。我们在实际项目中会有大量插入元素的需求，请开发者牢记这个思路

在 post- comment, JSE 的 Page 方法中新增以下方法：

以上方法重新去媛存数据库中加载全部的评论并再次使用 this. Setdata 将全部评论进行数据绑定

最后完成步骤 4: 清空 input？组件，准备接收下一条评论。

清空 input 组件的方法很简单，将 inputi 的 valuei 属性重置为空字符串即可。在 post- comment.Js 的

Page 方法中添加以下代码

Resetalldefaultstatus 方法重新绑定了 keyboardlnput Value，将其值设置为空字符串。注意 keyboardinput Value 在之前的代码中已经被绑定到了 Input 组件的 valuei 属性上了。

完成以上 4 个步骤后保存并运行代码。先在输入框中输入一段文字，再点击右侧的发送按钮，条评论就会出现在评论列表中，且这条评论位于评论列表的 J 顶部。

## 7.17 同时支持模拟器回车、真机点击「完成」发送评论

到目前为止，我们已经实现了自定义发送按钮发送评论的功能。我们再来实现在模拟器中以敲击键盘回车发送评论和在真机中点击键盘「完成」发送评论的功能。

如果想在模拟器中买现回车发送评论消息的功能，可以使用以下几个 Input 事件

binchang

bindblur bindconfirm

binchang 在早期版本中是有的，但官方在后来的文档中去掉了这个事件，截至 130400 版本，binchang 依然有效。虽然它依然有效，但是不建议使用官方文档未明确说明的事件。

bindblur 可以触发回车的原理是，点击回车后，Input 组件将失去焦点，从而触发 bindblur 事件

bindconfirm 可以在真机上响应键盘的「完成」点击事件，同时也可以在模拟器中响应键盘的「回车」敲击事件。

拿 bindconfirm 举，修改。Input 组件为如下代码：

我们仅仅在 input 组件上新增了ー个 bindconfirm 事件，这个事件的响应函数与自定义发送按钮所向应的事件函数相同，同样都是 submit Comment。这样就可以同时实现自定义发送按钮发送评论、模拟器回车发送评论和真机上点击「完成」发送评论的功能。

开发者还可以依次将 bindconfirm 更換为 bindbluri 和 binchang，看一下它们的效果。虽然以上 3 个事件都可以实现回车的效果，但建议使用 bindconfirm 事件作为 Input 的「确定」事件。

## 7.18 图片与拍照评论的界面实现

我们接着实现图片和拍照评论。先来实现以下效果：当点击 + 号按钮后，出现选择图片和拍照的界面，如图 7-12 所示。

首先在 post- comment.wxml 中添加图 7-12 所示的骨架代码。

注意，以上代码位于《<view class="Input-box「》这个 View 的内部，与《view class=="send-msg box「》平级。如果无法找到这段代码的准确位置，请下载源代码查看。

对应的 CSS 代码已在代码清单 7-27 中添加完毕，不需要再次编写。

这段代码的开头部分有一段 hidden="! sendmoremsgflag} y「。sendmoremsgflag 变量将控制整个面板的显示和隐藏。默认状态下它是隐藏的，所以我们首先在 post- comment. Jsh 的 Page 方法 data 属性下设置 sendmore Msgflagt 的初始状态。

Sendmoremsg Flage 的状态被我们设置成了 false。这样在默认状态下图片与拍照面板是不会显示的

事实上，即使我们不在 data 下面设置 sendmoremsgflag，面板依然不显示，因为如果找不到这个変量，默认这个変量的取值就是 false。为了代码的可读性，建议开发者将变量明确地在 data 属性中标注出来。这样的习惯应该成为我们开发小程序的一个小小约定。

keyboardlnput Value 変量也是基于这个原因而设置了一个空的字符串。keyboardlnputvalue 是之前控制 Input？组件初始值的变量，我们在代码清单 7-39 中使用了这个変量，开发者可自行回顾

接着实现 sendmoremsg 方法，它将切換 sendmoremsgflag 变量，以实现面板的切换和隐藏。

sendmoremsg 方法已经被我们在代码清単 7-26 中注册到了以下图片的 catchtap 事件上。

在 post- comment, JSE 的 Page 中新增 sendmoremsg 方法。

成以上代码后，我们再次点击 + 号图标，拍照面板将动态地显示和隐藏

## 7.19 实现从相册选择照片与拍照

在成功显示照片面板后，我们需要实现从相册选择照片和拍照上传照片的功能。小程序提供了

个 AP이: Wx. Chooselmage (object）来实现这个功能。

我们首先在 data 変量中新増一个数组来保存已选择图片的 URL

每选择一组图片，我们都会将图片的 URL 保存在 choosefiles 这个数组中。

在代码清单 7-41 中，我们分别在「照片」和「拍照」这两个图片按钮上注册了同一个事件 chooselmage 事件。点击这两个图片按钮后将执行 chooselmage 方法。在 post- comment.Js 中编写这个事件方法。

解释一下上述代码。我们选择一次评论内容中最多只允许发送 3 张照片。Leftcounti 检测当前已经选择了多少图片，如果超过了 3 张就直接 return，不能再执行下面的 Wx. Chooselmage 方法。

如果还不到 3 张，就多次选择照片，一直到选满 3 张为止

我们重点看下 wx. Chooselmage 方法。

Wx. Chooselmage (object）接收两个主要的参数：count？和 sourcet ype。count 指定一次最多可以选择多少张图片

sourcet ype 指定是拍照生成照片还是从手机相册选择照片。注意，它是一个数组，可以有以下

几个取值：

T'album]

camera

 [, 'camera"]

第一个取值将直接打开相册，并可以选择照片。注意，无论是在开发工具中还是在真机上都可以支持多选。

第二个取值将直接打开相机并拍照生成照片。注意，在开发工具中，cameral 取值不会打开相机拍照，只会打开相册。

第三个取值将打开如图 7-13 所示的图片界面。

[' album, camera！】可以让用户自行选择是拍照还是从手机相册选择。需要注意的是，在开发工具中这个取值不会出现这样的选择框。开发工具中只会直接打开相册，因为开发工具没有拍照功能

我们分别选取第一个和第二个取值，对应面板中的「照片」和「拍照」功能。

var sourcet ype- event. Currentt arget. Dataset. Category】这段代码決定了当前选择的是哪一种方式。

当选择照片或者拍照成功后，将进入 wx. Chooselmage 的 Success / 方法中，success 方法将接收个框架传入的 res 参数。在 success 方法中加入 console.log (res), res 的输出结果如图 7-14 所

重点是 tempfilepaths 这个数组，它装载了我们选择的 3 张图片（来自相册或者拍照）的 URL。注意，这个 URL 是图片的临时地址

拿到图片的地址后，我们就可以将这些图片地址添加到 imgarr 中，并将 imgar 绑定到 choosefiles 変量中。一旦 choosefiles 变量被绑定了数据，Wxml 代码中的《block WX: for="choosefiles} y" WX: for- index=idx「》将循环显示这些图片，如图 7-15 所示。

需要注意的是，你并不需要一次选择 3 张，可以分多次选择，但最多只能选择 3 张。

## 7.20icon 图片

在 7.19 节中，我们实现了图片的选择功能。注意看图 7-14, 每张图片的右上角都有一张小图片

这个小图片并不是我们自定义的图片，而是由小程序的 icon 组件提供的图片。

在代码清单 7-41 中有一段代码：

 <icon class=remove-icon'type=cance"size=23

color=# B2B2B2 catchtap=deletelmagedata-idx=fix

这段代码就是 icon 组件的用法。icon 组件非常简单，只有 3 个属性：

type icon 的类型，取值可以是 success、success_no_ circle、info、warn、waiting、

cancel、download、search、clear。我们在代码中选用的是 cancel。

o Sze con 图片的大小，单位是 px。color 颜色，同 CSS 的 color 图 7-16 所示的是不同类型的 icon 示意图。

如果开发者对项目样式要求不是很高，建议尽量选择 icon 组件。

## 7.21 删除已选择的图片

当我们选择好图片后，存在想删除图片并重新选择的可能，所以还需要支持图片的删除功能。

刪除功能是通过点击图片右上角的 icon 图标来实现的。我们已经在 Wxm 代码的 icon 组件中注册了 deletelmage 事件。

在 post- comment, JSI 中添加 deletelmage 方法。

代码清单 7-46 deletelmage 方法 post-comment. Js

∥別除已经选择的图片

deletelmage: function (event)

var index=event. Currenttarget dataset. Idx

that = this

that data. Choosefiles splice (index, 1)

that. Setdata (f

choosefiles: that data. Choosefiles

刪除图片的逻辑非常简单，只需要获取当前删除图片的序号，并将该图片的 URL 从 this.data. Choosefiles2 数组中删除，重新绑定 choosefiles？变量即可

保存并重新运行代码，就可以通过点击已选择图片右上角的叉叉按钮删除图片了。删除图片后，

可以重新选择图片

## 7.22 在小程序中使用 CSS3 动画

虽然 MINA 框架提供了小程序专有的动画 API，但是我们依然可以在小程序中使用 CSS3 动画。我门建议开发者尽量使用 CSS3 动画，因为目前版本小程序的动画存在较多 bug，使用起来并不是很方便。后面我们也会介绍小程序的动画，这里先来看看如何在小程序中使用 CSS3 动画。

我们使用 CSS3 动画对 7.2.1 节中删除图片的操作做一个特效。在代码清单 7-41 中，有一段这样的代码

 <view class="file-box fdeletelndex=idx? deleting:

如果 deletelndex 的值等于当前图片的序号，就说明该图片是要被删除的，需要添加一个 deleting

田。

以下代码是 deleting 动画的 CSS 代码：

这段动画已经在代码清単 7 ー 27 中添加到了 post- comment.wXSs 中，这里就无须再添加了我们需要做的就是在删除图片时执行这段 CSS3 动画。修改 post- comment. JSE 中的 deletelmage

方法，以支持 CSS3 动画效果

在新代码中，我们使用了一个 deletelndex 変量，正如在 7,18 节中所讲的，最好将这些变量都在页面的 data 属性中设定一个初始值（当然不设置直接使用也可以）。在下面的代码中，将 deletelndexi 设置为 - 1, 表示当前没有删除任何图片。

在定义了 deletelndex 変量后，在删除图片时首先使用 this. Setdata 方法更新 deletelndex 変量值为当前删除图片的序号，使用 this. Setdata 将立即执行数据绑定，使被删除的图片立即添加并执行个 deleting 动画（正如本节开头所分析的那样）。动画执行的时间为 500 毫秒，所以我们使用 settimeout 函数延迟 500 毫秒后再真实地删除这张图片。

注意，一定要记得将 deletelndex 的值恢复为 - 1, 否则动画执行将出错。

大多数动画的编写方式都如本节中所展示的方式那样，只是动画的效果不同而已。开发者可以举反三，尝试不同的动画效果。

适度使用动画将大大提升客户端的体验，需要注意的是不要过度使用动画，特别是在一些性能不好的手机上，动画将大大消耗手机性能。建议能不用动画就尽量不用，毕竟小程序是即用即走，做太多动画的意义不大。

## 7.23 实现图片评论的发送

在前面我们已经完成了图片的选择和删除功能，接着实现发送图片评论。

实现发送图片评论的方式非常简单，只需要将当前 this.data. Choosefiles 所保存的图片地址存入数据缓存中，并重新渲染评论列表即可。我们来修改一下 submit Comment 方法，这个方法我们已经在发送文字评论时实现过。

相比之前的 submitcomment 方法，我们只是将 tis.data. Choosefilesi 这个保存图片 URL 的数组加入到了 newdatat 中，这样 new l 中不仅仅包含有 txt 文本，还包括 img 图片。

在发送完图片评论后，还彁要清空已选择的图片，并在此隐藏图片选择面板。修改 resetalidefaultstatus 方法，代码如下

相比之前只重置了 keyboardinput Value 变量，这里还重置了 choosefiles？変量和 sendmoremsgflag 变量。重置 choosefiles？変量将清空图片选择面板中已选择的图片，重置 sendmoremsgflag 变量将再次隐藏图片选择面板。

需要注意的是，图片和文字可以存在于同一条评论中。开发者可以尝试发表几条带图片的评论。如果此时你点击评论中的图片，就会发现图片无法显示。关于这一点我们已在 79 节中提到过在开发工具中是无法预览这些图片的。如果是在真机中，这些图片可以被正常预览。最新的 140600 版本修复了这个问题，现在可以在开发工具中预览上传的图片

## 7.24 实现语音消息的发送

目前为止，文字和图片评论的发送功能已全部完成，接下来我们学习如何发送语音评论。需要注意的是，语音消息的相关组件已在 7.10 节中实现，并在 7.12 节中实现了文字评论和语音评论之间的切换效果，大家可以回顾一下。

语音评论需要真机的支持，虽然在模拟器中有麦克风就可以实现录音并可以生成录音文件，但在后续的函数调用和播放上存在不少 bug。所以，下面的代码虽然在模拟器上不会报错，但无法实现录音效果。如果你不能够在真机上运行小程序，建议简单浏览下本节，了解内容即可。

发送语音评论的操作过程为：

切换到语音发送状态（点击最左側的声音图标）。长按「按住说话」这个按钮。说话。

松开「按住说话」，语音消息自动发送。

要实现按住和松开这两个动作，我们需要使用小程序的 touchstarti 和 touched 事件。对于

touchstart，我们已注册了事件函数 recordstart；而对于 touched，我们已注册了 recorded。下面实现这两个事件函数。

按住录音按钮后将执行 recordstart 函数。函数首先绑定了变量 recoding Class，这个变量将改变录音按钮的样式，使其变成正在录音的样式。

接着记录了当前录音开始的时间，并保存在 this 变量中。

接着调用 Wx. Startrecord 录音 APl。WX. Startrecord 只接受 3 个方法作为参数，分别是 success、fal 和 compelte。

如果录音成功就执行 success，录音失败则执行 fail 无论录音成功还是失败，都将执行 complete。

发生以下两种情况将会结束录音：

当主动调用 wx. Stoprecord 时。

如果没有主动调用 wx. Stoprecord，那么在录音开始 1 分钟后自动结束录音。

在我们的 Orange Can 顼目中并未处理录音 1 分钟自动结束的情况，开发者可根据自身需求来处理这种情况。

对于业务逻辑，我们需要在用户松开录音按钮时结束录音。下面编写 recorded 方法结束录音。

在 recorded 方法中首先将按钮的样式还原，接着记录录音结束的时间，并将其保存在 this 变量中。最后调用 wx. Stoprecord 方法结束录音。

当用户松开录音按钮后，代码将执行 recordstartp 中的 success / 方法或 fail 方法（complete 方法当然也会被执行）

在 record Starte 的 success 方法中，我们首先计算语音时长，接着调用 submitvoice Comment 方法发送语音评论。在 post- comment.JS 中增加以下代码来实现语音评论的发送

发送语音评论的思路与发送文本、图片的思路几乎一样。首先新增一条评论数据，并将 audio 对象存入评论的 audio 属性中；然后调用 DBPOSTE 的 newcomment 方法将评论数据保存到存数据中；接着弹出操作结果提示；最后重新渲染评论列表。

语音不可以和文字、图片混合在一条评论中，只能单独作为一条评论

需要注意的是，当前 130400 版本有一个奇怪的现象：在模拟器中，录音结束后既不会执行 Wx. Startrecordi 的 success，也不会执行 fail，只会执行 complete 方法，即使 PC 接有麦克风也是如此。在真机中则可正常执行 success。

## 7.25 实现语音消息的暂停与播放

下面我们来实现评论列表中语音的播放与暂停功能。

语音评论的播放需要满足以下几个播放场景。假设有两条语音一一 A 语音和 B 语音，当点击 A 语音时

果 A 语音处于未播放状态，就开始播放 A 语

如果 A 语音处于暂停状态，就则继续播放 A 语音。

当点击 B 语音时：

·B 语音的行为同上述的 A 语音。

当点击 B 语音时：

B 语音的行为同上述的 A 语音。

无论 A 语音处于何种状态，都将立刻被中断；被中断后，再次点击 A 语音，A 语音将重新开始播放。

下面我们来实现语音擂放的功能。在代码清単 7-22 里，我们已经将 catchtap=" playaudio「这个事件注册到了语音评论的组件中，下面实现 playaudio 这个事件响应函数

在 post- comment. Js 中添加 playaudio' 代码。

在 playaudio 方法中，我们使用到了一个 this.data. Currentaudio 变量，这个变量保存了当前正在播放的语音文件的 URL，同时它也将作为语音播放的控制开关。按照我们之前所约定的规则，对于这样的变量，我们在使用时最好在 data 中预先定义ー下。

小程序提供了一个 wx. Play Voice 方法，用于播放语音；同时提供了ー个 wx. Pause Voice 方法，用于暂停语音播放；以及一个 wx. Stopvoice 用于停止语音播放

wx.play Voice 具有以下 4 个参数：

sleath 需要播放的语音文件的文件路径。

success 接口调用成功的回调函数。fail 接口调用失败的回调函数。

complete 接口调用结束的回调函数（调用成功、失败都会执行）。

语音擂放有一个特点：如果调用 vx. Pause Voice 暂停了语音播放，那么再次调用 wx.play Voice 播放同一个文件时就会从暂停处开始擂放。如果想从头开始播放，需要先调用 wx. Stop Voice。

我们来分析一下代码清单 7-54。

每次点击语音，playaudio 都将先从事件的 event 参数中获取要擂放语音的 URL 地址 urI

接着判断该 ur 与正在播放的语音地址（this.data. Currentaudio）是否相同，如果相同就说明用户要暂停当前语音的播放，所以调用 wx. Pausevoice 方法来暂停语音播放。暂停语音播放后，请将 this.data. Currentaudio 变量设置为空值。

如果 url 与 this.data. Currentaudio 不同，就需要调用 Wx, play Voice 来播放语音。

到底是播放新语音还是继续擂放上次暂停的语音不需要用户来控制，wx. Playvoice 自身会记录上次旙放语音的 ur，它将自行做出比对：如果两次播放的 urI 相同，且第一次播放的语音没有播放完（被暂停了），就将继续上一次语音的播放；如果第二次播放的语音与第一次不同，就直接播放新语音。

上面的逻辑强调的是第一次播放的语音没有播放完，如果已经播放完了，就将重头开始旙放第次的语音。

要特别注意 wx, play Voice 的 completel 函数，这个函数只有在语音完全播放完成后才会执行，如果暂停了播放，complete 函数是不会被执行的。同样，WX.play Voice 的 success！函数也是如此。

## 7.26 用户授权

小程序如果想使用某些特定的 AP，是需要用户主动授权的。比如，当获取用户敏感信息时，以及调用 wx. Startrecord 接口录音时，都需要用户主动授权，如图 7-17 和图 7-18 所示。

在本项目中，如果用户第一次使用录音功能，就会弹出如图 7-16 所示的请求授权提示。当用户

授权后，下次再使用录音功能时将不会再弹出这个提示框

我们可以在开发工具中清除用户的授权数据，让授权提示框再次出现。

开发工具的侧边栏里有一项缓存】按钮，如图 7-19 所示。清除工具授权数据）可以清除开发工具中用户授权数据缓存。清除手机授权数据】可以清除手机上的授权数据媛存。清除缓存后，授权数据框将再次出现。

这里要提醒开发者，一定要处理用户拒绝授权的场景，否则程序

有可能发生非常严重的错误。

## 7.27 解決真机运行时评论页面滑动卡顿的问题

在真机上运行 Orange Can，会发现评论页面在上下滑动时过程并不是那么的流畅，体验非常

差

在页面容器中加入以下 CSS 代码可以解決这个问题：

加粗部分代码是我们在 comment-main-box 类下新增的一段代码，加入这段代码后，post comment 页面的滑动将非常流畅。

## 7.28 文章阅读计数功能

到目前为止，我们已经完成了文章的收藏、评论和点赞功能，接着完成最后一个文章计数功能。

每次进入 post- detail 页面时，当前文章的阅读数需要增加 1 次。在 post- detail. SI 中增加一个阅读数加 1 的方法。

Add Times 方法中再一次使用到了 Dbpost！中的方法。在 Bpost! js 中新增以下方法

接着在 Dbpost 类的 updatepostdata 方法中增加一个 case' reading' 来处理阅读数加 1 的情况。下面给出 updatepostdata 方法的最终代码

加粗部分代码是新增代码。

编写完以上代码后，记得在 post- detal.js 中的 onload 方法中调用一下 add Times 方法。

加粗部分代码是新增代码。

完成以上代码后，每次点击进入页面的详情页阅读数都会加 1

需要注意的是，本项目并没有实现实时刷新。进入某篇文章的详情页面后，再返回文章阋读列表页面，此时阅读列表中的阅读数并没有加 1, 当我们刷新项目或者下次进入小程序时，文章列表的阅读数将会被更新

