# 0401. Laravel 框架中使用的 HTTP 协议基础

在 Web 开发中，HTTP 协议作为客户端和服务器端交互的准则实现客户请求的发送及响应信息的获取，在构建 B/S 结构应用中，前端工程师专注于酷炫多彩的页面实现、功能强大的 UI 框架设计等，后端工程师专注于复杂的业务流程、可扩展 — 低耦合的架构设计等，因此常常忽略了两者之间交互的环节，即 HTTP 协议部分。然而，HTTP 协议作为 Web 开发的基础，无论是前端还是后端，工程师只有掌握了这部分内容才能在软件开发这条道路上走得更远、更坚实，才能抓住一些问题的本质进行解决。同时，也只有了解 HTTP 协议的基本内容，才能更好地掌握 Laravel 框架，因为该框架中无论是请求获取、响应生成还是 session 实现等内容都和 HTTP 协议密切相关。本章将概要地介绍 HTTP 协议的内容，如需更加深入地了解，读者可以参看 HTTP 相关的书籍。

4.1　HTTP 发展与相关网络技术

通常情况下，在浏览器地址栏中输入一个正确的网络地址就会获得一个网页显示，这种功能是如何实现的呢？首先，可以明确的是网页并不是本机上的，而是存储在互联网的某一台服务器上，那么就需要解决三个关键问题：第一是获取内容所在目标服务器，第二是相互间传递消息，第三就是解析服务器返回的内容。获取目标服务器地址通过统一资源定位符 （Uniform Resource Locator，即 URL）实现，相互间信息的传输通过超文本传输协议（HyperText Transfer Protocol，即 HTTP）实现，而服务器返回内容的解析通过超文本标记语言（HyperText Markup Language，即 HTML）实现。下面将围绕这三个问题介绍 HTTP 的发展和相关网络技术。

4.1.1　HTTP 发展

HTTP 协议的最初设想是 Tim Berners Lee 于 1989 年提出的，当时用来解决不同地域的研究学者实现技术知识的共享问题，而在 1990 年即诞生了世界上的第一台服务器和浏览器。在随后的二十几年中，HTTP 协议获得了长足的发展，主要经历了三个版本：第一个版本是 HTTP 协议诞生到正式标准的建立，这个阶段的版本被统称为 HTTP/0.9 版本；第二个版本是 1996 年 5 月正式公布的标准版本，被命名为 HTTP/1.0 版本，标准规范由 RFC1945 记录；第三个版本是 1997 年 1 月公布的 HTTP/1.1 版本，标准规范由 RFC2068 记录。目前大部分服务器都使用 HTTP/1.0 和 HTTP/1.1 版本，对于目前正在发展的 HTTP/2.0 版本还需要一定的时间进行普及。

不同版本的 HTTP 协议发展是与各阶段 Web 需求分不开的，起初 HTTP 协议主要为了实现文本资料的共享，所以 HTTP/0.9 的请求只有一行，只支持 GET 方法，只能接收 HTML 文本的响应。后来，为了实现客户端和服务端进行数据交互，HTTP/1.0 加入了 POST 等方法，同时 HTTP 协议传输的内容也扩展到图片、动画等格式。接着，为了提升在 HTTP 协议下工作的服务器的性能，HTTP/1.1 在 HTTP/1.0 的基础上进行了增强，增加了包括默认长连接保持等功能。

4.1.2　与 HTTP 协议相关的网络技术

HTTP 协议是一种应用层协议，它的实现离不开其他的网络技术，与其关系密切的就有 TCP、IP、ARP、DNS 等。

对于网络技术，最常听到的就是 TCP/IP 协议，实际上 TCP/IP 协议并不是指某种协议，而是为实现计算机间通信的网络体系。在计算机通信的发展过程中，诞生了很多网络体系，包括 TCP/IP、OSI、IPX/SPX 等，每一种网络体系中包含很多相应的协议，这些协议的集合被称为协议族，其中 TCP/IP 协议族标准是由国际互联网工程任务组（The Internet Engineering Task Force，简称 IETF）制定的，包括 IP、TCP、UDP、HTTP、ARP 等协议。OSI（Open Systems Interconnection，即开放式通信系统互联）协议族标准是由国际标准化组织（International Organization for Standards，简称 ISO）制定的，包括 FTAM、VT、CONP 等协议。IPX/SPX 协议族标准是由 Novell 公司制定的，包括 IPX、SPX、NPC 等协议。目前，经常接触到的是 TCP/IP 网络体系和 OSI 网络体系，其中 OSI 所定义的协议虽然没有得到普遍应用，但是其设计的 OSI 参考模型经常被用于网络协议制定，而 TCP/IP 已经成为全世界范围内共同遵循应用的一种通信协议标准，该标准也使得不同硬件和系统的网络设备可以进行互相通信。

为了使复杂的网络协议变得简单化，协议通常被分层处理，OSI 协议被分为七层，而 TCP/IP 协议被分为五层。在这种分层模型中，每一层的实现都需要下一层提供特定的服务，而本层实现的功能又为上一层提供服务，层与层之间遵循「接口」的约定，而两台机器同层间遵循「协议」的约定。每一层会将上一层传过来的数据附加一个首部，而加上首部的数据被送到下一层，下一层会将接收到的数据包当成整个数据并加入本层的首部，每一层首部至少都包含两部分信息，一部分是接收者和发送者的地址，另一部分是上一层的协议类型。对于接收者和发送者的地址，数据链路层使用 MAC 地址、网络层使用 IP 地址、传输层使用端口号。结合协议分层模型可以得到 HTTP 协议在发送者和接收者间经过的分层处理，如图 4.1 所示，该结构也相当于 TCP/IP 协议的模型结构。

图 4.1　HTTP 协议分层结构

上面的分层结构只是一个模型，对于协议的细节没有进行定义，协议的具体定义和实现可以参看其他书籍。这里为了真实了解各层数据包的结构信息，通过 Wireshark 软件抓取浏览器访问百度网站的 HTTP 数据包进行分析，数据链路层数据包首部格式、网络层 IP 数据包首部格式、传输层 TCP 数据包首部格式、应用层 HTTP 数据包首部格式分别如图 4.2～图 4.5 所示。每一层都包含发送者和接收者目的地址及上一层协议，对于传输层，由于数据包发送到 80 端口，默认 80 端口是由服务器监听的网络端口，所以在该端口号接收的数据包都由服务器来解析。

图 4.2　数据链路层数据包首部格式

图 4.3　网络层 IP 数据包首部格式

图 4.4　传输层 TCP 数据包首部格式

图 4.5　应用层 HTTP 数据包首部格式

通过上面实际 HTTP 协议数据包的抓取和分析，已经基本了解了数据包的封装格式，但数据包是如何从一台主机发送到另一台主机的呢？读者可能听说过 TCP 连接三次握手、IP 路由等概念，这些概念都是零散的，不足以支撑数据包的主机间发送，这里简要介绍一下整个发送过程的原理。

TCP/IP 协议对于数据链路层没有进行详细定义，但这层是实现 TCP/IP 通信至关重要的一层。数据链路层用于提供两个直接相连的网络设备间的通信，而网络层用于提供两个直接或通过路由器等中间网络设备相连的两个网络设备间的通信。因此，要实现互联网中任意两台主机间通信，需要用到两张表，分别是地址转发表和路由控制表，地址转发表记录 MAC 地址与主机间及端口与主机间的关系，用于在数据链路层实现直连主机间通信，而路由控制表记录 IP 地址与主机间及网络号与网段间的关系，用于在网络层实现互联主机间的通信。目前，在网络各个节点（如交换机、路由器等）上不需要手动设置这些表，而是通过自学习来自动生成的。下面通过一个具体实例来介绍主机间是如何实现通信的。

假设在一个网络结构拓扑中，主机 A、B、C 由交换机连接形成一个网段，主机 D、E、F 由交换机连接形成一个网段，而两个网段间由两台路由器进行互联，形成一个网络结构，如图 4.6 所示。

图 4.6　网络结构图

数据包在网络传输过程中，每个节点会根据数据包的地址信息来判断该数据包应该从哪个端口发出并发向哪里，这里就需要 MAC 寻址和 IP 寻址来实现。其中，MAC 寻址需要参考地址转发表，而 IP 寻址需要参考路由控制表。对于网络中计算机间的通信则存在两种情况：第一种是在同一个网段内的主机间通信，如主机 A 给主机 C 发送数据，可以简单地称为网段内通信；第二种是在不同网段的主机间通信，如主机 A 给主机 D 发送数据，可以称为不同网段间通信。

这里所说的网段实际上就是一个广播域，即一台主机发送广播数据包，能够收到该广播数据包的所有主机形成的一个区域。那么一台主机如何判断发送的目标主机是否在同一个网段内呢？这是根据主机网络配置中的 IP 地址和子网掩码来判断的，如果目标主机的 IP 地址在子网掩码的网段内，则表示发送地址为同一个网段，否则认为是不同网段的，其中 Windows 7 系统主机网络配置如图 4.7 所示。

图 4.7　Windows 7 系统主机网络配置

图 4.6 中主机 A 的 IP 地址为 192.168.1.10，假设子网掩码为 255.255.255.0，该子网掩码的二进制前 24 位都为 1，如果目标主机的 IP 地址前 24 位与主机 A 的 IP 地址相同即为同一个网段，如主机 C 的 IP 地址为 192.168.1.12，其中前 24 位与主机 A 的 IP 地址相同，因此为同一个网段，而主机 D 的 IP 地址为 192.168.5.10，前 24 位与主机 A 的 IP 地址不同，则不是同一个网段。下面将分别讨论同一个网段内和不同网段间主机的数据通信过程。

网段内数据包的发送是离不开 ARP 协议（Address Resolution Protocol，即地址解析协议）的，该协议是数据链路层协议，可以利用请求包和响应包通过一台主机的 IP 地址获取它的 MAC 地址。如上面介绍的实例，主机 A 需要发送数据包到主机 C，则需要知道主机 C 的 IP 地址，但是却不知道主机 C 的 MAC 地址，因此无法完成数据包数据链路层首部的封装。此时，就需要主机 A 通过 ARP 协议来获取主机 C 的 MAC 地址。首先，主机 A 发送一个 ARP 广播请求，其中网络层首部的源 IP 地址为主机 A 的 IP 地址，而目标 IP 地址是主机 C 的，源 MAC 地址是主机 A 的，目标 MAC 地址则全是 1，这个请求包首先会传送到交换机 M，交换机 M 的 1 号端口收到该 ARP 请求广播包后会读取包中源 MAC 地址和目标 MAC 地址，假设交换机此时 MAC 地址转发表为空，则会将源 MAC 地址（即主机 A 的 MAC 地址）与对应的端口 1 存放到表中，当交换机再从其他端口接收到发往该 MAC 地址的数据包时就会直接将数据包发往端口 1，而不会发往其他端口，这个过程就是交换机的自学习过程。由于交换机查看到数据包的目标 MAC 地址全是 1，于是会将该数据包通过其他所有端口广播出去，此时主机 B 和主机 C 都会收到该 ARP 广播请求包，由于其中的目标 IP 地址与主机 B 的 IP 地址不同，主机 B 会将该数据包丢弃，而主机 C 接收到该 ARP 广播请求包后，发现与自己的 IP 地址相同，就会生成 ARP 响应数据包，数据包的源 IP 地址和源 MAC 地址为主机 C 的 IP 地址和 MAC 地址，数据包的目的 IP 地址和目的 MAC 地址为主机 A 的 IP 地址和 MAC 地址，同时记录主机 A 的 IP 地址与 MAC 地址，放入自己的 ARP 缓存表中。此时，该 ARP 响应包通过交换机 M 时，它会再次检查源 MAC 地址和目标 MAC 地址，并将源的 MAC 地址（主机 C 的 MAC 地址）与端口 3 对应存放到地址转发表中。对于目标 MAC 地址，会首先查找地址转发表，由于之前记录了该 MAC 地址（主机 A 的 MAC 地址）与端口 1 对应，交换机只将该 ARP 响应包从端口 1 转发出去，于是主机 A 接收到该 ARP 响应包，通过解析后将主机 C 的 IP 地址与 MAC 地址放入自己的 ARP 缓存表中。此时，已经获取到了主机 C 的 MAC 地址，可以完成数据包的数据链路层封装了，即将主机 C 的 MAC 地址作为目标 MAC 地址。最后，主机 A 将数据包发送出去，当数据包到达交换机 M 时，由于地址转发表中已经记录了目标 MAC 地址与端口 3 对应，于是会将该数据包通过端口 3 转发出去，主机 C 接收到该数据包后上交到数据链路层，数据链路层会判断 MAC 地址与自己的 MAC 地址是否相同，这里 MAC 地址相同，于是进行数据链路层解析，解析完成后上交到传输层，传输层会判断 IP 地址与自己的 IP 地址是否相同，这里 IP 地址相同，于是完成传输层解析后再上交到网络层，如此一层层解析，最终完成一个网段内两台主机间数据包的传输和解析。

对于不同网段间的两台主机通信过程，这里以主机 A 与主机 D 间的通信为例，条件相同，主机 A 知道主机 D 的 IP 地址，而不知道该主机的 MAC 地址。在实现数据链路层封装时会检查主机 D 的 IP 地址是否跟自己在同一个网段（如上面介绍通过本机的 IP 地址与子网掩码判断），通过判断发现主机 D 与主机 A 不在同一个网段内，这时会用到主机网络配置的第三项 —— 网关配置，在实际中网关的功能可能会大于路由器，即对应 TCP/IP 协议模型中传输层到应用层的数据处理部分，不仅具有路由的功能，可能还会包括协议转换、防火墙等功能，但至少要能够实现路由功能。对于本实例中的网关设置即为路由器 X 的端口 1 的 IP 地址，即 192.168.1.1，于是主机 A 首先将数据包发送给路由器 X 的端口 1，此时源 IP 地址和源 MAC 地址是主机 A 的，目标 IP 地址是主机 D 的，而目标 MAC 地址是路由器 X 端口 1 的，如果主机 A 目前不知道路由器 X 端口 1 的 MAC 地址，则跟网段内通信方式一样，通过 ARP 协议获取该 MAC 地址。当数据包发送到路由器 X 端口 1 时，路由器 X 会查看数据包的目标 IP 地址并查找自己的路由表，找到通往目标 IP 网段的路由，如果没有相关的路由信息，则会丢弃该数据包，当通过路由表查找到通往目标 IP 网段的发送端口为端口 2 时，于是把数据包传到端口 2 上，并由端口 2 传输到路由器 Y 端口 2 上，路由器 Y 会再次查询目标 IP 地址和自己的路由表，查找到目标 IP 所在网段的发送端口为端口 1，于是将数据包传到端口 1 并发送出去，通过交换机 N，主机 D 会接收到该数据包，从而完成主机 A 与主机 D 间的数据通信。在这期间，路由器会通过路由表查找到下一跳的 IP 地址，如果不知道 MAC 地址则通过 ARP 协议获取。路由器的路由表一般也是通过自学习获取的，这个过程的算法很多，最具代表性的有两种，即距离向量算法和链路状态算法，同时也需要 RIP、EGP 等路由协议的支持，这里就不详细介绍了，读者如果需要可以查看相关书籍。

对于以上讨论，用到了图 4.7 中主机网络配置的前三项。「DNS」是域名解析，即当通过浏览器访问某个域名的服务器时，会首先将域名发送给 DNS 服务器，DNS 服务器将域名解析成实际 IP 地址，从而完成地址的访问。通过以上对相关网络技术的简单介绍，了解了支撑 HTTP 协议传输的 TCP/IP 协议的基本实现原理，不管是数据包封装的方式还是主机间传输的方式，在实现 Web 客户端和服务端相互通信后，接下来需要了解两者间交互内容的协议，即 HTTP 协议。

4.2　HTTP 协议简介

4.2.1　HTTP 协议工作流程

在前面已经了解多种不同协议及协议中规定的数据包封装和基本功能，HTTP 协议与其他协议一样，也需要以特定的方式进行数据包的封装，并按照一定的流程实现通信交互，而基于 HTTP 协议的请求 / 响应模式的信息交互过程可分为四个步骤。

（1）客户端与服务器需要建立连接，如 TCP 连接。

（2）连接建立后，客户端向服务器发送一个请求，请求报文由三部分组成：请求行、消息报头、请求内容。

（3）服务器接到请求后，解析该请求并返回响应信息，响应报文由三部分组成：状态行、消息报头、响应内容。

（4）客户端接收服务器所返回的信息并进行解析、处理和显示。

通常，浏览器访问一个页面，需要发出多次请求获取不同的响应内容，在 HTTP/1.0 版本中默认是传输一次数据就关闭连接，而在 HTTP/1.1 版本中默认为持久连接，即一次 TCP 连接可以完成多次 HTTP 请求。是否支持持久连接，是由消息报头中的 connection 字段决定的，如果请求或响应中的 connection 设置为 close，则客户端和服务器的连接为非持久连接。

4.2.2　请求报文和响应报文结构简介

HTTP 协议的请求和响应数据包一般被称为请求报文和响应报文，根据协议标准，请求报文和响应报文是由报文首部、空行和报文主体组成的，而请求报文的首部又由请求行、请求首部字段、通用首部字段、实体首部字段组成，响应报文的首部由状态行、响应首部字段、通用首部字段、实体首部字段组成。请求报文和响应报文的具体结构如图 4.8 和图 4.9 所示。

根据以上结构，可以将 HTTP 协议报文包含的内容分为五类：一是请求行，由请求方法、请求 URL、HTTP 版本组成；二是状态行，由 HTTP 版本、状态码、原因短语组成；三是首部字段，包含了请求首部、响应首部、通用首部、实体首部四种类型，一般由名字和值组成；四是其他报文首部字段，包含一些 RFC 中未定义的首部内容；五是报文主体，由任意数据组成。一个访问页面 http://www.sina.com.cn/ 的请求报文和响应报文如图 4.10 和图 4.11 所示。接下来逐个进行讨论。

图 4.8　请求报文结构

图 4.9　响应报文结构

图 4.10　请求报文

图 4.11　响应报文

（1）请求行。

请求行中的请求方法用来描述服务器应该执行的操作，而请求 URL 指定了操作的资源，HTTP 版本用来标识客户端使用的 HTTP 版本。对于图 4.10 中访问新浪网站请求报文的请求方法为「GET」，请求 URL 为「/」，即网站根目录，HTTP 版本为「HTTP/1.1」。在 HTTP 规范中定义了一组方法，用于指定服务器的响应动作，如 GET 方法是指从服务器获取一个文本，具体请求报文方法及其功能描述如表 4.1 所示。

表 4.1　HTTP 请求报文方法及其功能

方法名称 功能描述 是否包含主体数据

GET 从服务器获取文本 否

POST 向服务发送客户端数据 是

PUT 上传客户端的文件到服务器 是

DELETE 从服务器上删除一个文件 否

HEAD 只获取服务器响应的首部 否

OPTIONS 获取服务器可以执行的方法 否

TRACE 对经过代理服务器的报文进行追踪 否

（2）状态行。

状态行包含响应报文服务器使用的 HTTP 版本、数字状态码和原因短语，对于图 4.11 响应报文的状态行，其中 HTTP 版本为「HTTP/1.1」，数字状态码为「200」，原因短语为「OK」。HTTP 的状态码共分为五大类，用于描述返回的响应结果。实际 HTTP 规范中定义的状态码有几十种，比较具有代表性的状态码及含义如表 4.2 所示。

表 4.2　HTTP 响应报文状态码及含义

（3）首部字段。

首部字段是构成 HTTP 报文的基本要素之一，这部分包含的信息也最为丰富，主要用于规定客户端和服务端在处理请求和响应时的操作。通常，根据首部字段的用途可以分为四类，分别是通用首部字段、请求首部字段、响应首部字段和实体首部字段。首部字段通常由字段名和字段值构成，中间通过「:」分隔。下面分别简要介绍四类字段的作用和部分首部字段的含义。

·通用首部字段

通用首部字段一般用来提供 HTTP 报文的最基本信息，这些信息无论是请求报文还是响应报文都可以使用，主要用于描述 HTTP 协议本身。比如描述 HTTP 是否持久连接的 Connection 字段、HTTP 发送日期的 Date 字段、用于缓存控制的 Cache-Control 字段等。下面列出常用的通用首部字段及含义，如表 4.3 所示。

表 4.3　HTTP 报文通用首部字段及含义

通用首部字段名 功能说明

Connection 用于指定客户端 / 服务器间连接的选项，例如指定连续连接或者通过「close」选项通知服务器在响应完成后关闭连接

Date 报文创建的日期

Transfer-Encoding 指定报文主体数据的编码方式

Update 发送端协议准备升级为新版本

Via 报文经过中间节点 (网关、代理等) 的信息

Cache-Control 指定缓存行为

Warning 错误通知

·请求首部字段

请求首部字段一般用于 HTTP 请求报文中，主要描述客户端的版本、处理能力等信息，用于帮助服务器更好地提供请求响应的字段，如告诉服务器只接收某种响应内容的 Accept 字段、发送 Cookies 的 Cookie 字段等。下面列出常用的请求首部字段及含义，如表 4.4 所示。

表 4.4　HTTP 报文请求首部字段及含义

请求首部字段名 功能说明

Accept 客户端可处理的媒体类型

Accept-Charset 客户端优先接收的字符集

Accept-Encodiing 客户端优先接收的编码方式，如 gzip

Accept-Language 客户端希望的语言种类

Authorization 授权信息，通常用于对服务器发送的 WWW-Authenticate 首部进行应答

Cookie 用于客户端向服务器发送一个令牌

Cookie2 用来说明客户端支持的 Cookie 版本

From 客户端的 E-mail 地址，由一些特殊的 Web 客户程序使用，浏览器不会用到它

Host 请求资源所在服务器的主机和端口

If-Modified-Since 只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回 304「Not Modified」应答

Referer 包含一个 URL，客户端从该 URL 页面出发访问请求页面

User-Agent 客户端信息，如客户端应用程序名称、版本等

UA-OS 客户端主机上的操作系统名称、版本等信息

UA-Pixels 客户端显示器像素信息

·响应首部字段

响应首部字段是描述 HTTP 响应本身的字段，一般用于 HTTP 响应报文中，主要用于描述响应主机的信息、功能等，通过响应首部字段有助于客户端处理响应，并在将来发出更适合服务器的请求，如定时刷新的 Refresh 头、设置 Cookie 的 Set-Cookie 头等。下面列出常用的响应首部字段及含义，如表 4.5 所示。

表 4.5　HTTP 报文响应首部字段及含义

响应首部字段名 功能含义

Age 响应资源创建的时间

Set-Cookie 在客户端设置一个 Cookie，服务器用来对客户端进行标识

Server 服务器应用程序软件的名称、版本等信息

Retry-After 当资源不可用时，在此期间再次发送请求

Refresh 表示浏览器应该在多长时间之后刷新文档，以秒计

·实体首部字段

实体首部字段用于描述 HTTP 报文主体数据的字段。由于报文主体可以存在于请求报文和响应报文中，所以这种类型首部字段可以应用在这两种类型的报文中。实体首部字段用于描述主体内容的元信息，包括实体信息类型、长度、压缩方法、最后一次修改时间、数据有效性等，以便告诉接收者如何进行处理，如 Content-Language 用于描述报文主体的语言等。下面列出常用的实体首部字段及含义，如表 4.6 所示。

表 4.6　HTTP 报文实体首部字段及含义

实体首部字段名 功能含义

Allow 资源主体可以支持的 HTTP 请求方法

Content-Location 通知接收端主体的 URL，用于接收端定位到该资源

Content-Encoding 主体适用的编码方式

Content-Language 解释主体时适用的语言

Content-Length 主体的大小，通常以字节数表示

Content-MD5 主体的 MD5 校验和

Content-Type 主体的对象类型

HTTP 协议作为应用层协议离不开 TCP/IP 协议的支持，本章从网络协议开始，对 HTTP 协议进行了简单的介绍，要想了解 Laravel 框架的方方面面，那么这些底层的知识是必须要掌握的，只有了解这些才能对 Laravel 框架底层实现有更深刻的认识。对于 Web 应用无非是获取请求、返回响应，而请求的获取与响应的返回又需要满足 HTTP 协议才能正常工作，Laravel 框架的底层使用了 Symfony 的模块用于处理 HTTP 请求和响应，可以看出 Laravel 框架在构建过程中也大量使用了已有的模块，这也将是未来软件开发的趋势。