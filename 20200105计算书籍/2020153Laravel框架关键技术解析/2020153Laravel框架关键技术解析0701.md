# 0701. 请求到响应的生命周期

前面已经讲了很多内容，但很多人看到这里可能还是一头雾水，因为前面都是讲 Laravel 框架的某个部分，虽然把有些部分讲得很细，但读者可能依然不知道 Laravel 框架到底是怎么工作的，仿佛是盲人摸象，只是摸了一小部分，在思维中产生的概念一定是不全面的。可能有人会问为什么不一开始就讲请求到响应的生命周期，这样一下子就能全面了解了。其实，如果基础的东西没有一个概念，讲整体依然不好理解，总之学习一项新技术总是要经历迷雾的阶段，这个阶段没有什么好方法，死记硬背记住一些概念就好了，不要急，很快就要清晰了。

当读者了解了 Laravel 框架的整个运行流程，清楚请求到响应的整个生命周期中每一步是用来做什么的、实现什么目标的，那么读者将对驾驭 Laravel 框架更有信心，对改造和排错更能胸有成足、了然于心。

7.1　程序启动准备

要了解 Laravel 框架的整个运行流程，那么首先要看的就是入口文件写了什么，再一步步向下探索整个脉络，就像读 C 语言程序首先要读 main 函数一样。在 Laravel 框架中，所有的请求入口文件是 public 目录下的 index.php 文件。当第一次看到入口文件时，可能会被它的简洁所震撼，这么简单的几行就清晰地展示了请求到响应的整个生命周期，下面先给出 index.php 文件的代码，然后将分别介绍。

文件 laravel\public\index.php <?php require __DIR__.'/../bootstrap/autoload.php'; $app = require_once __DIR__.'/../bootstrap/app.php'; $kernel = $app->make (Illuminate\Contracts\Http\Kernel::class); $r e s p o n s e = $k e r n e l->h a n d l e ($r e q u e s t = I l l u m i n a t e\H t t p\Request::capture ()); $response->send (); $kernel->terminate ($request, $response);

程序的启动准备阶段是入口文件中的代码「require_once __DIR__.'/../bootstrap/app.php'」部分，主要实现了服务容器的实例化和基本注册，包括服务容器本身注册、基础服务提供者注册、核心类别名注册和基本路径注册，在注册过程中，服务容器会在对应属性中记录注册的内容，以便在程序运行期间提供对应的服务。程序启动准备阶段具体过程如图 7.1 所示。

图 7.1　程序启动准备阶段流程

7.1.1　服务容器实例化

入口文件「iindex.php」的第一句包含 bootstrap 文件夹下的 autoload.php 文件，用来实现类的自动加载功能。文件的第二句是调用 bootstrap 文件夹下的 app.php 中的代码，主要用来实例化服务容器，并注册 Laravel 框架的核心类服务，为后面自动生成 $kernel 核心类实例提供基础。这部分就是本小节将要介绍的请求到响应生命周期的准备阶段，接下来将详细介绍准备阶段都做了哪些工作。下面是准备阶段的源码：

文件 laravel\bootstrap\app.php <?php $app = new Illuminate\Foundation\Application ( realpath (__DIR__.'/../') ); $app->singleton (Illuminate\Contracts\Http\Kernel::class, App\Http\Kernel::class); $app->singleton (Illuminate\Contracts\Console\Kernel::class, App\Console\Kernel::class); $app->singleton (Illuminate\Contracts\Debug\ExceptionHandler::class, App\Exceptions\Handler::class); return $app;

这里面重要的是第一句代码，用来实现服务容器的实例化过程，后面几句是向服务容器中绑定核心类服务，并返回服务容器实例，一目了然。在服务容器的实例化过程中，在构造函数中对服务容器中的服务进行了绑定。在第 6 章中的服务容器小节，介绍了服务容器的实现方法，而这里需要了解的是服务容器中都绑定了哪些服务，这些服务用来做什么，将在什么时候用到。那么，先看一下服务容器的构造函数都绑定了哪些服务。需要注意的是，服务容器的实例化参数是 Laravel 框架的根目录地址。下面是构造函数及其相关的源码，文件夹 Illuminate 位于 larave\vendor\laravel\framework\src 目录下，这里约定后面的文件路径中以 Illuminate 开头的都是省去了前面的目录结构。

文件 Illuminate\Foundation\Application.php// 创建一个新的服务容器 public function __construct ($basePath = null) {$this->registerBaseBindings (); $this->registerBaseServiceProviders (); $this->registerCoreContainerAliases (); if ($basePath) {$this->setBasePath ($basePath);} }

1．注册基础绑定

服务容器第一句代码用来绑定基础服务，主要是绑定容器实例本身，使得其他的对象可以很容易得到服务容器实例，其中服务容器中设置了一个静态变量 $instance，该变量是在 Container 容器类中定义的，因为 Application 类继承了 Container 容器类，所以继承该静态变量，可以通过 Container 中的静态函数 getInstance () 直接获取服务容器实例。另外，为服务容器实例绑定了不同的服务别名，记录在 $instances 共享实例数组中，可以通过这些别名的任何一个找到服务容器实例。注册基础绑定的主要源码如下：

文件 Illuminate\Foundation\Application.php// 向容器中注册基础绑定 protected function registerBaseBindings () { static::setInstance ($this); $this->instance ('app', $this); $this->instance ('Illuminate\Container\Container', $this); } 文件 Illuminate\Container\Container.php// 在容器中注册一个已经实例化的共享实例 public function instance ($abstract, $instance) {if (is_array ($abstract)) {list ($abstract, $alias) = $this->extractAlias ($abstract); $this->alias ($abstract, $alias); } unset ($this->aliases [$abstract]); $bound = $this->bound ($abstract); $this->instances [$abstract] = $instance; if ($bound) {$this->rebound ($abstract); } }

在注册基础绑定过程中，将会向服务容器的共享实例数组中注册两个单例服务，服务名称分别为「app」和「Illuminate\Container\Container」，对应的实例对象即为服务容器本身。

2．注册基础服务提供者

接下来，将进行基础服务提供者的注册。服务提供者的注册是 Laravel 应用程序的启动和运行中最重要的行为之一，因为它为服务容器添加应用需要的各种服务，毕竟服务容器再强大，如果里面什么都没有装，那也是没有用的。在服务容器的构造函数中只注册了最基础的两个服务提供者，随着 Laravel 应用程序的运行还会有很多服务提供者被加载注册，这里我们先看看服务提供者是如何被注册的。

文件 Illuminate\Foundation\Application.php// 注册基础服务提供者 protected function registerBaseServiceProviders () { $this->register (new EventServiceProvider ($this)); $this->register (new RoutingServiceProvider ($this)); } // 在服务容器中注册一个服务提供者 public function register ($provider, $options = [], $force = false) {if ($registered = $this->getProvider ($provider) ＆＆ !$force) {return $registered;} if (is_string ($provider)) {$provider = $this->resolveProviderClass ($provider); } $provider->register (); foreach ($options as $key => $value) {$this [$key] = $value; } $this->markAsRegistered ($provider); if ($this->booted) {$this->bootProvider ($provider); } return $provider; } // 如果服务提供者已经存在，则获取这个实例对象 public function getProvider ($provider) {$name = is_string ($provider) ? $provider : get_class ($provider); return Arr::first ($this->serviceProviders, function ($key, $value) use ($name) {return $value instanceof $name;}); } // 通过类名实例化一个服务提供者 public function resolveProviderClass ($provider) {return new $provider ($this); } // 启动规定的服务提供者 protected function bootProvider (ServiceProvider $provider) {if (method_exists ($provider, 'boot')) {return $this->call ([$provider, 'boot']); } }

我们来提炼一下基础服务提供者注册所必须的步骤，一是实例化服务提供者，这部分内容是通过 resolveProviderClass () 函数完成的；二是调用服务提供者的 register ()，该函数用于向服务容器中注册服务；三是标识该服务提供者已经注册过了，这部分内容是通过 markAsRegistered () 函数实现的；四是如果应用程序已经启动过了，主要是程序中需要使用的服务提供者都已经注册完毕，则会调用服务提供者的 boot () 函数。每个服务提供者都继承自 Illuminate\Support\ ServiceProvider 类，该类有个 register () 虚函数，所以每个服务提供者必须实现这个函数，用来填充服务容器并提供服务。同时，应用程序会在适当时候统一调用服务提供者的 boot () 函数，但这个函数服务提供者可以不实现，因为在 Illuminate\Support\ ServiceProvider 类中的魔术方法__call () 提供了该函数的处理。所以，如果自己需要设计服务提供者来进行服务注册，则需要继承该类并实现这两个函数。

3．注册核心类别名和应用的基础路径

由于 Laravel 框架的类是基于命名空间的，所以类名都比较长，为此在服务容器中为一些常用的类注册了别名，在后面程序中会通过别名来代替这个类名。基础路径是指应用程序关键目录的路径，服务容器中也将注册这些信息。

文件 Illuminate\Foundation\Application.php// 在容器中注册核心类的别名 public function registerCoreContainerAliases () { $aliases = [ 'app' => ['Illuminate\Foundation\Application', 'Illuminate\Contracts\Container\Container', 'Illuminate\Contracts\Foundation\Application'], 'auth' => 'Illuminate\Auth\AuthManager', // 这里省略了别名数组中部分内容 ]; foreach ($aliases as $key => $aliases) {foreach ((array) $aliases as $alias) {$this->alias ($key, $alias); } } } // 注册应用的基础路径 public function setBasePath ($basePath) {$this->basePath = rtrim ($basePath, '\/'); $this->bindPathsInContainer (); return $this;} // 在容器中绑定应用程序的基础路径 protected function bindPathsInContainer () { $this->instance ('path', $this->path ()); foreach (['base', 'config', 'database', 'lang', 'public', 'storage'] as $path) {$this->instance ('path.'.$path, $this->{$path.'Path'}()); } }

可以看到，在 registerCoreContainerAliases () 的 $aliases 数组变量中定义了整个框架的核心服务别名，在服务解析过程中，需要根据实例化的类或接口名称查找服务别名，然后通过服务别名获取具体的服务。至此，应用程序的准备工作已经完成了，这里已经生成了服务容器，在服务容器中注册绑定了基础的服务提供者、服务别名和基础路径。

7.1.2　核心类（Kernel 类）实例化

服务容器实例化后，就可以通过服务容器来自动实例化对象了。于是，Kernel 类就通过服务容器自动化创建而成，即 index.php 文件中的「$kernel = $app->make (Illuminate\Contracts\Http\Kernel::class);」。那么我们又在什么时候注册的服务呢？前面已经介绍过，在 laravel\bootstrap\app.php 文件中，实例化服务容器之后就注册了三个服务，其中就包括这个核心类接口。在注册服务时，服务名一般是接口。在 Contracts 命名空间下存储的都是接口，而提供的服务则是具体类、实例对象或返回实例对象的回调函数。

由于注册的服务只是具体类名，所以可以通过反射机制来实例化，并通过反射机制自动解决构造函数中的依赖关系。于是，通过服务容器实例化 App\Http\Kernel 类时，这个类只是定义了 $middleware（中间件）和 $routeMiddleware（路由中间件）两个数组属性，其中中间件是请求进入路由处理前的处理类，而路由中间件是请求进入路由处理后的处理类，所以这里可以添加新的中间件处理类，只要按照中间件的设计原则进行设计，并在中间件数组的正确位置添加类名，在处理请求的过程中就会调用新添加的中间件处理过程，这部分内容在 Laravel 框架的设计模式中具体介绍过。可以看到，Laravel 框架对于扩展就是这么简单，这也得益于框架设计的艺术性。

因为 App\Http\Kernel 类继承了 Illuminate\Foundation\Http\Kernel 类，所以实例化过程中会调用该类中的构造函数，下面是构造函数源码。

文件 Illuminate\Foundation\Http\Kernel.php// 创建一个新的 HTTP 核心类实例 public function __construct (Application $app, Router $router) {$this->app = $app; $this->router = $router; foreach ($this->routeMiddleware as $key => $middleware) {$router->middleware ($key, $middleware); } }

可以看到，Kernel 类的构造函数是存在依赖的，两个依赖分别是 Illuminate\Contracts\Foundation\Application 和 Illuminate\Routing\Router 类型，这里依赖的类型要加上命名空间才能正确定义。其中，对于 Illuminate\Contracts\Foundation\Application 类名我们定义了别名，在上一小节的核心类别名中定义的，于是得到服务名为「app」，而名称为「app」的服务在上一小节注册基础绑定过程中已经注册了，即为服务容器的实例；对于 Illuminate\Routing\Router 类也注册了别名为「router」，而名为「router」的服务则是在注册基础服务提供者 RoutingServiceProvider 类的 register () 函数中注册的，即获取 Illuminate\Routing\ Router 类的实例。在实例化路由类（Router）的时候还会存在依赖，依然通过服务容器自动生成。这里我们看到了服务提供者和服务容器是如何配合来完成依赖注入的整个过程。完成了服务容器和核心类（Kernel 类）的实例化之后，接下来该处理请求了，这才是我们的目标。

7.2　请求实例化

在 Laravel 框架中，完成准备工作后，将进行请求的实例化。什么是请求？其实就是客户端发送的一个请求报文，这个报文包括请求行、请求首部和请求实体。这部分内容在 HTTP 协议中进行了介绍，这些都可以看做参数和值的对应，在 Laravel 框架中我们将其分类并保存在 Illuminate\Http\Request 类的实例对象中，于是请求也就转换为一个实例对象，在处理请求的过程中，只需要处理这个实例对象就可以了。请求实例的创建是通过 Illuminate\Http\Request 类的 capture () 静态函数完成的，即 $request = Illuminate\Http\Request::capture ()，这个函数的源码如下：

文件 Illuminate\Http\Request.php// 通过服务器提供的变量创建一个 HTTP 请求实例 public static function capture () { static::enableHttpMethodParameterOverride (); return static::createFromBase (SymfonyRequest::createFromGlobals ()); } // 创建一个请求实例通过 Symfony 实例 public static function createFromBase (SymfonyRequest $request) {if ($request instanceof static) {return $request;} $content = $request->content; $request = (new static)->duplicate ($request->query->all (), $request->request->all (), $request->attributes->all (), $request->cookies->all (), $request->files->all (), $request->server->all ()); $request->content = $content; $request->request = $request->getInputSource (); return $request;}

首先要说明一点，Laravel 框架的底层用了很多 Symfony 框架的功能模块，开源提倡「不必重复发明轮子」，Laravel 框架的设计者认为 Symfony 底层设计得足够好了，也就拿过来用，这也是模块化开发的优势，哪个模块好，拿过来就用，如果没有模块化开发理念、没有 PSR 规范、没有 composer 工具，这一切是无法实现的。其实 Laravel 框架也是借鉴了大量其他框架的设计理念后才开发出来的，包括 Symfony、ruby on rails 等。所以，在吸收了 Laravel 框架的设计理念后，读者也可以站在它的肩膀上创新了。

通过上面的代码可以看到，Laravel 框架的请求实例是在 Symfony 请求实例的基础上创建的。而 Symfony 框架的请求实例是通过 createFromGlobals () 静态函数实现的，接下来介绍 Symfony 框架对请求是如何进行实例化封装的，这也是请求实例化的重点。

文件 vendor\symfony\http-foundation\Request.php// 通过 PHP 的全局变量创建一个新的请求实例 public static function createFromGlobals () { $server = $_SERVER; if ('cli-server' === php_sapi_name ()) {if (array_key_exists ('HTTP_CONTENT_LENGTH', $_SERVER)) {$server ['CONTENT_LENGTH'] = $_SERVER ['HTTP_CONTENT_LENGTH']; } if (array_key_exists ('HTTP_CONTENT_TYPE', $_SERVER)) {$server ['CONTENT_TYPE'] = $_SERVER ['HTTP_CONTENT_TYPE']; } } $request = self::createRequestFromFactory ($_GET, $_POST, array (), $_COOKIE, $_FILES, $server); if (0 === strpos ($request->headers->get ('CONTENT_TYPE'), 'application/x-www-form-urlencoded') ＆＆ in_array (strtoupper ($request->server- >get ('REQUEST_METHOD', 'GET')), array ('PUT', 'DELETE', 'PATCH')) ) {parse_str ($request->getContent (), $data); $request->request = new ParameterBag ($data); } return $request; }

在 Symfony 框架中，是通过 PHP 的全局数组作为参数来实例化请求的，其中包括 $_GET、$_POST、$_COOKIE、$_FILSE 和 $_SERVER，只是开始先对 $_SERVER 中的参数进行了一下处理，因为 PHP 的一个 bug，当 PHP 的接口类型为 cli-server 时，会将 Content-Type 和 Content-Length 的值存储在 HTTP_CONTENT_TYPE 和 HTTP_CONTENT_LENGTH 两个字段中，这里需要对其进行修改，然后这些全局数组交给请求创建工厂。

// 请求创建工厂 private static function createRequestFromFactory (array $query = array (), array $request = array (), array $attributes = array (), array $cookies = array (), array $files = array (), array $server = array (), $content = null) {if (self::$requestFactory) {$request = call_user_func (self::$requestFactory, $query, $request, $attributes, $cookies, $files, $server, $content); if (!$request instanceof self) {throw new \LogicException ('The Request factory must return an instance of Symfony\Component\HttpFoundation\Request.'); } return $request; } return new static ($query, $request, $attributes, $cookies, $files, $server, content); }

如果自定义了请求工厂方法，则可以将自定义的工厂方法赋值给属性 $requestFactory，否则将通过 new static 来完成请求的实例化。new static 的语法可以参看 PHP 的重要性质中的后期静态绑定部分。

// 构造函数 public function __construct (array $query = array (), array $request = array (), array $attributes = array (), array $cookies = array (), array $files = array (), array $server = array (), $content = null) {$this->initialize ($query, $request, $attributes, $cookies, $files, $server, $content); } // 初始化请求实例的参数 public function initialize (array $query = array (), array $request = array (), array $attributes = array (), array $cookies = array (), array $files = array (), array $server = array (), $content = null) {$this->request = new ParameterBag ($request); $this->query = new ParameterBag ($query); $this->attributes = new ParameterBag ($attributes); $this->cookies = new ParameterBag ($cookies); $this->files = new FileBag ($files); $this->server = new ServerBag ($server); $this->headers = new HeaderBag ($this->server->getHeaders ()); $this->content = $content; // 省略部分参数初始化内容 }

请求相关信息的参数是通过 ParameterBag、FileBag 等类的实例来封装的，其中 FileBag、ServerBage 等类也继承了 ParameterBag 类，相应的参数存储方式是相同的，只是添加了更多的参数处理函数功能。

这里只是介绍了 Laravel 框架的请求实例化过程，在开发过程中还需要对请求的实例进行不同的操作，包括对请求参数的访问和存储等，这部分内容将在后续章节详细介绍。

7.3　处理请求

在完成了请求实例化后，将进入对请求实例的处理阶段，即「$response = $kernel->handle ();」过程。请求的处理是服务器应用程序的核心功能，通过不同的处理方式最终返回形形色色的响应，实现不同的功能。如何提供可扩展的请求分发处理模块是服务器框架程序成功的关键，本书前面已经简单地介绍了路由和控制器，这只是请求处理过程中两个分发点而已，下面将介绍整个处理的流程。具体源码如下：

文件 Illuminate\Foundation\Http\Kernel.php// 处理一个输入 HTTP 请求 public function handle ($request) {try { $request->enableHttpMethodParameterOverride (); $response = $this->sendRequestThroughRouter ($request); } // 省略异常处理部分代码 $this->app ['events']->fire ('kernel.handled', [$request, $response]); return $response; }

请求的处理是通过 sendRequestThroughRouter () 方法实现的，通过该方法名就可以看出来，即通过路由传输请求实例。这里需要注意一点的是，enableHttpMethodParameterOverri de () 方法会使能请求拒绝，被使能后在请求处理过程中会添加 CSRF 保护，即在客户端与服务端进行交互时，服务端会发送一个 CSRF 令牌给客户端，也就是一个 cookie，在客户端发送 POST 请求时需要将该令牌也发送给服务端，否则将拒绝处理该请求。

7.3.1　请求处理准备工作

在上一小节中，介绍了应用程序运行的准备环节，而要实现请求的处理，还有很多基础工作要做，根据 Laravel 框架的注释，将这个过程称为「拔靴带」过程，通俗的理解就像「拔靴带」一样，一个环节接一个环节进行处理。这里包括环境检测、配置加载、日记配置、异常处理、外观注册、服务提供者注册和启动服务共七个步骤，下面将对其中几个步骤的关键环节进行介绍。首先看一下这七个步骤是如何启动的，具体源码如下：

文件 Illuminate\Foundation\Http\Kernel.php protected $bootstrappers = ['Illuminate\Foundation\Bootstrap\DetectEnvironment', 'Illuminate\Foundation\Bootstrap\LoadConfiguration', 'Illuminate\Foundation\Bootstrap\ConfigureLogging', 'Illuminate\Foundation\Bootstrap\HandleExceptions', 'Illuminate\Foundation\Bootstrap\RegisterFacades', 'Illuminate\Foundation\Bootstrap\RegisterProviders', 'Illuminate\Foundation\Bootstrap\BootProviders',]; // 将请求通过中间件和路由处理 protected function sendRequestThroughRouter ($request) {$this->app->instance ('request', $request); Facade::clearResolvedInstance ('request'); $this->bootstrap (); return (new Pipeline ($this->app)) ->send ($request) ->through ($this->app->shouldSkipMiddleware () ? [] : $this->middleware) ->then ($this->dispatchToRouter ()); } // 针对请求为应用程序「拔靴带」public function bootstrap () { if (! $this->app->hasBeenBootstrapped ()) {$this->app->bootstrapWith ($this->bootstrappers ()); } } 文件 Illuminate\Foundation\Application.php// 执行 bootstrap 类的数组 public function bootstrapWith (array $bootstrappers) {$this->hasBeenBootstrapped = true; foreach ($bootstrappers as $bootstrapper) {$this ['events']->fire ('bootstrapping: '.$bootstrapper, [$this]); $this->make ($bootstrapper)->bootstrap ($this); $this ['events']->fire ('bootstrapped: '.$bootstrapper, [$this]); } }

上面提到了，在请求处理的准备阶段共有七个环节，每一个环节是由一个类来负责实现的，而每个类都会有一个 bootstrap () 函数用于实现准备工作，这七个类名就存储在 Illuminate\Foundation\Http\Kernel 类的 $bootstrappers 数组属性中。在请求发送路由之前，首先通过 bootstrap () 函数来完成准备工作，该函数会调用服务容器实例中的 bootstrapWith () 函数，这里将通过代码「$this->make ($bootstrapper)」完成每个准备类的实例化工作，然后调用准备类的 bootstrap () 方法实现准备工作。

1．环境检测与配置加载

环境检测阶段是对程序运行的环境进行总体配置，这部分内容实际上和配置加载的功能是相同的，都是配置应用程序的运行环境，包括系统配置、身份认证配置、缓存配置、数据库配置、文件系统配置和 sessions 配置等。这些配置都是以文件形式提供的，其中环境检测文件是 Laravel 框架根目录下的.evn 文件，而配置加载的配置文件是 laravel\config\ 目录下的所有文件，两者的关系可以看做是主从的关系，即在配置加载过程中设置的参数都可以在.evn 文件中进行设置，而.evn 中对环境的配置将会覆盖配置加载项，当然也可以修改成不覆盖。说简单点，就是将一些重要的配置参数从 laravel\config\ 目录下的文件中提取到.evn 文件中，这样易于随时修改。首先给出环境检测加载的源码：

文件 Illuminate\Foundation\Bootstrap\DetectEnvironment.php// 执行 bootstrap () 函数 public function bootstrap (Application $app) {try { D o t e n v::l o a d ($a p p->e n v i r o n m e n t P a t h () , $a p p->environmentFile ()); } catch (InvalidArgumentException $e) {} $app->detectEnvironment (function () {return env ('APP_ENV', 'production'); }); } 文件 laravel\vendor\vlucas\phpdotenv\src\Dotenv.php// 在指定目录下加载.env 文件 public static function load ($path, $file = '.env') {if (!is_string ($file)) {$file = '.env';} $filePath = rtrim ($path, '/').'/'.$file; // 省略异常处理部分代码 // 通过自动检测行结尾来读取文件每一行到数组中 $autodetect = ini_get ('auto_detect_line_endings'); ini_set ('auto_detect_line_endings', '1'); $lines = file ($filePath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES); ini_set ('auto_detect_line_endings', $autodetect); foreach ($lines as $line) {if (strpos (trim ($line), '#') === 0) {continue;} if (strpos ($line, '=') !== false) {static::setEnvironmentVariable ($line); } } } public static function setEnvironmentVariable ($name, $value = null) {list ($name, $value) = static::normaliseEnvironmentVariable ($name, $value); if (static::$immutable === true ＆＆ !is_null (static::findEnvironmentVariabl e ($name))) {return;} putenv ("$name=$value"); $_ENV [$name] = $value; $_SERVER [$name] = $value; }

DetectEnvironment 类的 bootstrap () 函数通过 Dotenv::load () 静态函数实现.env 文件的配置加载，在.env 文件中配置项以「配置项 = 参数值」的形式给出，最后通过静态函数 setEnvironmentVariable () 给配置项「putenv ("$name=$value")；」设置环境变量，并在 $_ENV 和 $_SERVER 全局数组中记录。

对于配置加载，是通过 LoadConfiguration 类的 bootstrap () 函数实现的。部分源代码如下：

文件 Illuminate\Foundation\Bootstrap\LoadConfiguration.php// 加载配置文件 public function bootstrap (Application $app) {$items = []; if (file_exists ($cached = $app->getCachedConfigPath ())) {$items = require $cached; $loadedFromCache = true;} $app->instance ('config', $config = new Repository ($items)); if (!isset ($loadedFromCache)) {$this->loadConfigurationFiles ($app, $config); } date_default_timezone_set ($config ['app.timezone']); mb_internal_encoding ('UTF-8'); }

首先会查找是否有缓存的配置文件，如果有将先加载，这样加载配置项速度快，否则将文件顺序加载。对于程序配置项，将会存放到一个仓库类 (Repository 类) 实例中，而该类的实例被添加进服务容器的共享实例数组中，服务名称为「config」，以后就可以用该名称通过服务容器自动获得需要的配置参数。在完成仓库类的实例化和服务绑定后，将通过 loadConfigurationFiles () 函数进行配置项的加载。接下来介绍加载的实现过程。

文件 Illuminate\Foundation\Bootstrap\LoadConfiguration.php// 加载所有配置文件的配置项 protected function loadConfigurationFiles (Application $app, RepositoryContract $config) {foreach ($this->getConfigurationFiles ($app) as $key => $path) {$config->set ($key, require $path); } } // 获取应用程序的所有配置文件 protected function getConfigurationFiles (Application $app) {$files = []; foreach (Finder::create ()->files ()->name ('*.php')->in ($app->configPath ()) as $file) {$nesting = $this->getConfigurationNesting ($file); $files [$nesting.basename ($file->getRealPath (), '.php')] = $file->getRealPath ();} return $files; } 文件 Illuminate\Config\Repository.php// 设置配置项 public function set ($key, $value = null) {if (is_array ($key)) {foreach ($key as $innerKey => $innerValue) {Arr::set ($this->items, $innerKey, $innerValue); } } else {Arr::set ($this->items, $key, $value); } }

对于配置项的加载，首先需要获取配置文件，通过 getConfigurationFiles () 将 Laravel 框架下的配置文件全部读取出来并存储到 $files 数组中返回，该过程是通过服务容器获取配置文件的路径（代码「 $app->configPath ()」），然后通过 Symfony 组件中的探测类（Symfony\Component\Finder\Finder 类）实现文件的识别，最后提取出文件名和文件路径并以关联数组的形式（如「app」=>「D:\WWW\laravel\config\app.php」）存储到 $files 数组中返回。对于配置文件，每个文件返回一个数组，这里通过「require ' 文件路径 '」的形式获取配置项数组，最后通过仓库实例的 set () 函数添加到仓库中。

前面讲到，.env 文件中的配置项会覆盖配置文件中的配置项，其实是通过 env ('APP_DEBUG', false) 函数实现的，evn 函数是 Illuminate\Foundation\helpers.php 文件中定义的，该文件定义了一些全局函数，可以在其他文件中调用。evn 函数先检测环境变量，如果该环境变量存在，则返回环境变量，如果不存在则用第二参数作为返回值。前面讲到，在环境检测过程中，配置项已经通过 putenv () 设置为环境变量。

这里加载配置的目的是为在后面的程序运行过程中经常用到这些配置项时，可以通过服务容器方便地获取这些配置，「$app ['config']['app.aliases']」和「$app->make ('config')->get ('app.aliases')」两种方法都是获取「laravel\config\app.php」文件中键名为 aliases 的值，即外观别名数组，因为在 Container 类和 Repository 类中都实现了 ArrayAccess (数组访问) 接口，而 $app ['config'] 相当于调用该实例的 offsetGet ($key) 方法，具体读者可以看一下源码，这里就不再赘述了。通过这部分的讲解，我们对于后面很多类似的用法将不再陌生了。

2．外观注册

接下来介绍一下外观注册，因为在后面很多地方都用到了外观别名 (所谓外观别名，就是给类名起了一个简洁而方便应用的别名)，通过外观别名调用对应实例的属性和方法。根据官方文档上的介绍，外观别名的主要目是为了测试的方便，但在程序中很多地方也用到了外观别名，比如路由，读者可能还会对 Route::get ("路径"，"响应函数") 这样的用法感到困惑，会以为 Route 是一个类，但是却找不到一个这样的对应类，其实这就是通过外观别名实现的，通过本节读者将了解它的全部。我们先看看在注册过程中做了什么，下面是部分源码：文件 Illuminate\Foundation\Bootstrap\RegisterFacades.php

public function bootstrap (Application $app) {Facade::clearResolvedInstances (); Facade::setFacadeApplication ($app); AliasLoader::getInstance ($app->make ('config')->get ('app.aliases'))->register ();} 文件 Illuminate\Foundation\AliasLoader.php// 创建一个别名加载的实例对象 public static function getInstance (array $aliases = []) {if (is_null (static::$instance)) {return static::$instance = new static ($aliases); } $aliases = array_merge (static::$instance->getAliases (), $aliases); static::$instance->setAliases ($aliases); return static::$instance; }

同样，外观注册是通过 RegisterFacades 类的 bootstrap () 函数完成的，而外观注册也可以分为两个步骤来介绍，一是完成外观自动加载类的实例化并将外观别名数组添加到该实例中，这里需要与 composer 的自动加载类进行区别；二是完成外观自动加载类中的自动加载函数的添加。对于外观自动加载类 (AliasLoader 类) 的实例化是通过类的静态函数 getInstance () 实现的，而外观别名是在实例化过程中通过参数传入的，外观别名通过代码「$app->make ('config')->get ('app.aliases')」获取，这句代码就用到了配置加载的内容，即获取加载的 app.php 配置文件，返回数组中的键值为「aliases」的数组值。可以通过源码查看一下该配置文件，了解一下都注册了哪些外观别名，由于篇幅原因，这里就不列举了。

// 在自动加载栈中注册一个自动加载函数 public function register () { if (!$this->registered) {$this->prependToLoaderStack (); $this->registered = true; } } // 将这个加载函数加到自动加载栈的开始处 protected function prependToLoaderStack () { spl_autoload_register ([$this, 'load'], true, true); } // 加载一个类的别名 public function load ($alias) {if (isset ($this->aliases [$alias])) {return class_alias ($this->aliases [$alias], $alias); } }

在完成自动加载类的实例化后，会调用 register () 函数向类自动加载栈的开始处加入一个新的加载函数，即通过代码「spl_autoload_register ([$this, 'load'], true, true);」实现。需要说明的是，实际上 PHP 的自动加载函数除了魔术方法__autoload () 可以使用外，还可以在自动加载函数堆栈中添加自定义的自动加载函数，composer 提供的自动加载方法和外观自动加载方法都注册在这个堆栈中，而且外观自动加载在最前面。当对一个类进行自动加载时，要按照自动加载堆栈中注册的函数顺序完成自动加载，所以，所有类的自动加载都会先经过外观自动加载函数的处理，这个函数就是 AliasLoader 类实例的 load () 函数，该函数的作用是为外观类设置一个别名，即外观别名，当用户通过外观别名访问类时，实际上访问的是对应的外观类。

需要说明的是，对于别名 Laravel 框架中有两个，一个是容器核心别名，定义在 Application 类中，而存储在 Application 类实例的 $aliases 属性中 (实际上该属性是在 Container 类中，因为 Application 类继承 Container 类，所以继承了这个属性，这里没有给出加上命名空间的全部名称)；另一个是外观别名，定义在 app.php 配置文件中，程序运行后存储在 AliasLoader 类实例的 $aliases 属性中。

下面我们看看通过外观别名是如何实现类似于 Route::get ("路径"，"响应函数") 这样的函数调用的。对于这种函数的处理，程序首先会加载类 Route，由于注册了外观别名，那么自动加载栈的第一个函数是 AliasLoader 类的 load () 函数，而该函数会查找外观别名对应的类名，于是找到 Route 类的别名为 Illuminate\Support\Facades\Route 类，于是加载这个类，然后调用该类的静态方法 get ()，而这个类没有这个静态方法。同时，对于外观类（在空间 Facades 下的类）都继承自 Illuminate\Support\Facades\ Façade 外观父类，所以从这个父类中查找这个静态函数，而父类中也没有对应的静态函数，但是却有一个__callStatic () 魔术方法，所以找不到静态方法时会调用这个魔术方法，接下来会调用一个 getFacadeAccessor () 静态方法，每一个具体的外观类都需要实现这个静态方法，该方法的目的就是返回别名类所对应的在服务容器中服务的名称，对于 Illuminate\Support\Facades\Route 类来说，返回的是「router」，接着通过服务容器获取对应的实例对象，这里对应的是 Illuminate\Routing\Router 类的实例，即通过「static::$app [$name]」实现，最终将会调用这个 Router 类实例中的 get () 方法。绕了一圈，终于绕出来了，现在明白注册外观的真正用途了吧，后面的如 Request::input () 等都是通过外观别名完成最终函数调用的。

3．服务提供者注册

服务提供者注册为应用程序运行提供服务支持，在应用程序启动的准备阶段进行了基础服务提供者的加载，但这些服务只能应对前期启动阶段，而对于后期请求处理需要用到的数据库服务、认证服务、session 服务等还远远不够，所以这里会绑定后期使用的服务。首先给出部分源码：

文件 Illuminate\Foundation\Bootstrap\RegisterProviders.php// 服务提供者注册 public function bootstrap (Application $app) {$app->registerConfiguredProviders ();} 文件 Illuminate\Foundation\Application.php// 注册所有配置的服务提供者 public function registerConfiguredProviders () { $manifestPath = $this->getCachedServicesPath (); (new ProviderRepository ($this, new Filesystem, $manifestPath)) ->load ($this->config ['app.providers']); }

在服务提供者的注册过程中将服务提供者分为三类，即 when 类、eager 类和 deferred 类。when 类是注册事件，只有当事件发生时才会自动注册这个服务提供者；eager 类会直接加载，加载方式和注册基础服务提供者的过程相同；deferred 类的服务提供者存储在列表中，需要加载时才会加载。在 Laravel 框架中，提供了一个文件记录服务提供者的类别信息，即「laravel/bootstrap/cache/services.json；」，而该路径是通过 getCachedServicesPath () 函数获取的。服务提供者的注册经过两个步骤，第一步是服务提供者仓库的创建，即 registerConfiguredProviders () 函数中的 new ProviderRepository () 过程，第二步是通过 load () 函数进行注册。创建服务提供者仓库时需要提供该文件的路径参数，同时调用 load () 函数时会添加 app.php 配置文件中关于服务提供者的内容。那么两者之间是什么关系呢？通过下面的代码进行介绍。

文件 Illuminate\Foundation\ProviderRepository.php// 注册应用的服务提供者 public function load (array $providers) {// 加载 larave\bootstrap\cache\services.json 文件中的服务提供者 $manifest = $this->loadManifest (); // 加载服务清单，这里包含程序所有的服务提供者并进行了分类 if ($this->shouldRecompile ($manifest, $providers)) {$manifest = $this->compileManifest ($providers); } // 服务提供者加载事件，当这个事件发生时才自动加载这个服务提供者 foreach ($manifest ['when'] as $provider => $events) {$this->registerLoadEvents ($provider, $events); } // 提前注册那些必须加载的服务提供者，以此为应用提供服务 foreach ($manifest ['eager'] as $provider) {$this->app->register ($this->createProvider ($provider)); } // 在列表中记录延迟加载的服务提供者，需要时再加载 $this->app->setDeferredServices ($manifest ['deferred']); }

前面提到服务提供者的记录在两个地方存在，实际上在配置文件 app.php 的「providers」中存储的是应用程序运行过程中所有的服务提供者，但是对于服务提供者的类型没有进行划分。当进行服务提供者注册时，首先通过 loadManifest () 函数读取「larave\bootstrap\cache\services.json」文件，该文件不仅记录服务提供者，还对服务提供者进行了分类，即前面提到的三种类型，但是该文件是一个临时记录文件，记录的是上一次运行时服务提供者加载的情况，所以需要与当前程序的服务提供者进行比对，通过 shouldRecompile () 函数实现，如果临时文件 (services.json 文件) 记录的服务提供者与配置文件 (app.php 文件) 记录的相同，则直接使用临时文件中服务提供者的分类进行注册。对于 when 类服务提供者，通过 registerLoadEvents () 函数创建事件监听者，当事件发生时调用服务提供者的 register () 函数进行服务注册 (也可以称为服务绑定)。对于 eager 类服务提供者，则直接通过 createProvider () 函数实例化服务提供者并进行服务注册。对于 deferred 类服务提供者，则记录在服务容器实例的 $deferredServices 数组属性中，在使用服务容器的 make () 函数进行服务解析时，如果发现这个服务在延时服务数组中，则会注册这个服务提供者，再解析相应的服务。

服务提供者都继承于服务提供者基类 (Illuminate\Support\ServiceProvider)，该类是一个抽象类，其中定义一个抽象函数 register ()，所以每个服务提供者都需要实现该函数，而该函数中实现了服务注册的内容，所以服务提供者注册就是实例化服务提供者并调用该实例的 register () 函数，将服务绑定到服务容器实例中。

4．启动服务

准备阶段的最后一个步骤是启动服务，服务提供者必须要实现 register () 函数，还有一个 boot () 函数根据需要决定是否实现，主要用于启动服务，而该函数不是必须的，如果不实现会在父类中统一处理。而对于实现 boot () 函数的服务提供者，会通过 BootProviders 类进行统一管理调用。下面给出部分源码：

文件 Illuminate\Foundation\Bootstrap\BootProviders.php public function bootstrap (Application $app) {$app->boot ();}

对于服务提供者启动管理类 BootProviders 来说，实现比较简单，只是调用服务容器中的 boot () 函数就可以了，因为服务提供者的注册信息都记录在服务容器中。下面给出服务容器启动服务提供者的代码：

文件 Illuminate\Foundation\Application.php// 启动应用程序的服务提供者 public function boot () { if ($this->booted) {return;} $this->fireAppCallbacks ($this->bootingCallbacks); array_walk ($this->serviceProviders, function ($p) {$this->bootProvider ($p); }); $this->booted = true; $this->fireAppCallbacks ($this->bootedCallbacks); } // 启动给定的服务提供者 protected function bootProvider (ServiceProvider $provider) {if (method_exists ($provider, 'boot')) {return $this->call ([$provider, 'boot']); } }

从上面可以看到，在 Laravel 应用程序的服务容器中保存了服务提供者的实例数组，即 $serviceProviders 属性。这里包含了服务容器实例化过程中注册的两个基础服务提供者及在服务提供者注册过程中注册的 eager 类服务提供者，然后通过代码「$this->call ([$provider, 'boot']);」调用 $serviceProviders 属性中记录的每一个服务提供者实例的 boot () 函数，该函数主要是对相应的服务进行初始化，如对于数据库服务提供者 (Illuminate\Database \DatabaseServiceProvider 类) 来讲会建立数据库连接，而对于路由服务提供者 (App\Providers \RouteServiceProvider) 来讲会建立路由表等。这里介绍一下路由表的建立，数据库连接的建立会在后面数据库部分讲解。

文件 app\Providers\RouteServiceProvider.php： // 实现路由的配置 public function boot (Router $router) {parent::boot ($router); } 文件 Illuminate\Foundation\Support\Providers\RouteServiceProvider.php// 启动应用的路由服务 public function boot (Router $router) {$this->setRootControllerNamespace (); if ($this->app->routesAreCached ()) {$this->loadCachedRoutes ();} else {$this->loadRoutes (); $this->app->booted (function () use ($router) {$router->getRoutes ()->refreshNameLookups ();}); } } // 加载应用的路由 protected function loadRoutes () { $this->app->call ([$this, 'map']); }

在 Laravel 框架中，默认情况下路由配置服务提供者是最后一个注册并启动的，该类位于「app\Providers\」文件夹下，通过上面的代码可以看出，该类调用父类的 boot () 函数，父类会通过 loadRoutes () 函数调用本实例对象的 map () 函数，这里需要注意的是，通过服务容器实例的 call () 函数调用一个函数时会解决函数的依赖问题。本书前面介绍了服务容器解决类实例化时构造函数的依赖注入问题，实际上服务容器也可以解决函数调用的依赖注入问题，就是通过 call () 函数来实现的，其内部机制基本相同，也是通过反射机制来解决依赖的，这里就不展开介绍了。也就是说，路由配置服务提供者需要自己实现一个 map () 函数来实现路由配置。

文件 app\Providers\RouteServiceProvider.php// 为应用定义路由信息 public function map (Router $router) {$router->group (['namespace' => $this->namespace], function ($router) {require app_path ('Http/routes.php'); }); } 文件 Illuminate\Routing\Router.php// 创建一个路由组 public function group (array $attributes, Closure $callback) {$this->updateGroupStack ($attributes); call_user_func ($callback, $this); array_pop ($this->groupStack); } 文件 laravel\app\Http\routes.php（文件路径） Route::controller ('home', 'HomeController'); Route::get ('/', WelcomeController@index');

上文提到了通过服务容器的 call () 函数调用其他实例的函数可以解决依赖注入的问题，对于 map () 函数，依赖一个参数为 Illuminate\Routing\Router 类的实例，会通过服务容器来解决这个依赖，而这个实例对象 (以后可以将其称为路由器对象) 管理应用程序的路由情况，所有的路由配置信息最终都会记录在路由器实例对象中。map () 函数会调用路由器实例的 group () 函数，该函数会记录控制器命名空间，默认情况下是「App\Http\Controllers」，在解析路由时遇到的控制器名会自动加上该命名空间进行解析。然后会调用一个回调函数，函数只有一句代码「require app_path ('Http/routes.php');」，也就是包含并执行路由配置文件。前面已经介绍了路由的创建，这里通过 controller () 方法和 get () 方法定义了两个路由配置项，get () 方法会在路由器实例中生成一条路由信息，而 controller () 方法则会生成多条，与控制器中的方法相对应。下面进一步介绍路由信息是如何配置的。

文件 Illuminate\Routing\Router.php// 根据 uri 的前缀配置控制器路由 public function controller ($uri, $controller, $names = []) {$prepended = $controller; if (! empty ($this->groupStack)) {$prepended = $this->prependGroupUses ($controller); } $routable = (new ControllerInspector)->getRoutable ($prepended, $uri); foreach ($routable as $method => $routes) {foreach ($routes as $route) {$this->registerInspected ($route, $controller, $method, $names); } } $this->addFallthroughRoute ($controller, $uri); } // 注册一个控制器路由 protected function registerInspected ($route, $controller, $method, ＆$names) {$action = ['uses' => $controller.'@'.$method]; $action ['as'] = Arr::get ($names, $method); $this->{$route ['verb']}($route ['uri'], $action); } // 添加一条路由配置到路由集合表中 protected function addRoute ($methods, $uri, $action) {return $this->routes->add ($this->createRoute ($methods, $uri, $action)); }

通过 controller () 方法实现配置路由的过程要比 get () 方法复杂一些，首先会通过 prependGroupUses () 函数获取控制器的整个命名空间，上述实例得到的控制器类是「App\Http\Controllers\HomeController」，然后会根据路由前缀 (本实例中是「home」) 获取整个路由信息的配置数组，数组中每一项表示一个路由信息，包括请求方法和 URI 地址等，这些信息将逐项加入到路由集合中，即控制器实例的属性 $routes，而添加过程中不同的请求方法对应不同的函数，所以 controller () 方法最终也需要调用 get ()、post () 等方法配置路由。在完成路由配置后，整个启动阶段就基本完成了。

这里我们只讲解了七个「bootstrap」类中的五个类，也就对应七个准备环节中的五个环节，对于日志配置和异常处理两个环节通过名字我们就可以了解其主要作用，即对日志的记录和对异常处理进行配置，这里就不详细介绍了。

7.3.2　中间件

在请求处理的过程中，经过烦琐的准备工作，应用程序开始对请求进行处理了。对请求的处理，Laravel 框架是逐级进行的，首先是经过中间件的处理，然后经过路由处理，最后到控制器生成响应，这部分思想在 6.2.1 节装饰者模式中进行了介绍，对请求从中间件到路由处理再到响应生成整个过程中基本是以装饰者模式的思想进行处理的。那么中间件会对请求做哪些处理呢？下面给出部分源码：

文件 laravel\app\Http\Kernel.php protected $middleware = [\I l l u m i n a t e\F o u n d a t i o n\H t t p\M i d d l e w a r e\CheckForMaintenanceMode::class, \App\Http\Middleware\EncryptCookies::class, \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class, \Illuminate\Session\Middleware\StartSession::class, \Illuminate\View\Middleware\ShareErrorsFromSession::class, \App\Http\Middleware\VerifyCsrfToken::class,]; 文件 Illuminate\Foundation\Http\Kernel.php// 将请求通过中间件和路由处理 protected function sendRequestThroughRouter ($request) {$this->app->instance ('request', $request); Facade::clearResolvedInstance ('request'); $this->bootstrap (); return (new Pipeline ($this->app)) ->send ($request) ->through ($this->app->shouldSkipMiddleware () ? [] : $this->middleware) ->then ($this->dispatchToRouter ()); } // 设置路由分发回调函数 protected function dispatchToRouter () { return function ($request) {$this->app->instance ('request', $request); return $this->router->dispatch ($request); }; } 文件 Illuminate\Pipeline\Pipeline.php public function __construct (Container $container) {$this->container = $container; } // 设置被送入「管道」的对象 public function send ($passable) {$this->passable = $passable; return $this; } // 设置导管数组 public function through ($pipes) {$this->pipes = is_array ($pipes) ? $pipes : func_get_args (); return $this;} // 以一个回调函数为终点执行「管道」处理 public function then (Closure $destination) {$firstSlice = $this->getInitialSlice ($destination); $pipes = array_reverse ($this->pipes); return call_user_func (array_reduce ($pipes, $this->getSlice (), $firstSlice), $this->passable ); } // 获取一个用来代替应用处理「洋葱」层的回调函数 protected function getSlice () { return function ($stack, $pipe) {return function ($passable) use ($stack, $pipe) {if ($pipe instanceof Closure) {return call_user_func ($pipe, $passable, $stack); } else {list ($name, $parameters) = $this->parsePipeString ($pipe); return call_user_func_array ([$this->container->make ($name),$this->method], array_merge ([$passable, $stack], $parameters)); } }; }; }

在 Laravel 框架中，很多注释和代码名称已经非常形象地表达了程序代码的功能，代码注释中将中间件称为「洋葱」层，将整个处理流程称为「管道」，有些地方会用到这些名词，如果读者理解了真正的含义就会更容易理解程序。对请求的处理阶段，首先对管道类 (Pipeline 类) 进行了实例化，分别通过 send () 函数和 through () 函数将请求实例和中间件数组赋值给管道实例，而最终的处理是通过 then () 函数完成的，该函数有一个参数，这个参数是经过「管道」后的终点处理函数，即下一步的路由处理。而 then () 函数其实就是将整个中间件数组通过服务容器生成实例，并对这些实例的 handle () 函数和传入的终点处理回调函数进行组装，形成一个递归调用的回调函数，再进行调用，最终完成「管道」的逐级处理。如果对这部分代码理解有困难，请先阅读第 6 章中请求处理管道的内容。

对于初始的 Laravel 框架程序，中间件包括 CheckForMaintenanceMode、EncryptCookies、AddQueuedCookiesToResponse、StartSession、ShareErrorsFromSession 和 VerifyCsrfToken 共六类，定义在「laravel\app\Http\Kernel.php」文件中的 $middleware 数组中，分别用来完成验证维护模式、Cookie 加密、添加响应 Coookie、开启会话、共享 Session 错误和 CSRF 保护六个部分，其中一部分重要的内容将会在后面其他章节中进行详细介绍。如果在程序开发过程中需要添加新的中间件，可以按照这几个类进行设计并添加到中间件数组中。经过对这部分的了解，添加中间件应该非常简单了。

7.3.3　路由处理生成响应

对于 Laravel 框架，请求是通过路由与控制器的响应函数对应的，对于路由的设定在第 5 章「Laravel 框架初识」部分已经介绍过，是在「laravel\app\Http\routes.php」文件中定义的，那么这部分内容这么关键，为何在程序运行中没有看到呢？其实整个路由表的生成是在请求处理的准备工作中的启动服务过程中完成的，通过 RouteServiceProvider 中的 boot () 函数实现。下面将按请求处理的步骤逐步介绍，让读者对请求的处理过程有一个全面的了解。

1．路由匹配

在路由的定义过程中，通常有两个参数，一个是 URI（唯一资源标识符），另一个是处理函数或处理函数定位，而大部分是处理函数定位，即控制器中相应的函数。那么，在路由表中就会请求形式与处理函数的对应信息，每一个对应信息为一个路由，通过 Illuminate\Routing\Route 实例进行保存，而所有的路由信息又通过 Illuminate\Routing\RouteCollection 实例保存形成路由表，而路由表则由 Illuminate\Routing\Router 类实例保存，这就是路由信息的结构。对于请求的处理，首先是在路由信息结构中找到对应的路由，即对应的 Illuminate\Routing\Route 实例，下面是这部分源码：

文件 Illuminate\Foundation\Http\Kernel.php// 获取路由分发回调函数 protected function dispatchToRouter () { return function ($request) {$this->app->instance ('request', $request); return $this->router->dispatch ($request); }; }

上面提到，所有的路由信息其实都保存在一个 Illuminate\Routing\Router 类实例中，而这个类实例存储在 Kernel 类的实例当中，于是通过「$this->router->dispatch ($request)；」将请求信息传递给路由信息存储实例。

文件 Illuminate\Routing\Router.php public function dispatch (Request $request) {$this->currentRequest = $request; $response = $this->callFilter ('before', $request); if (is_null ($response)) {$response = $this->dispatchToRoute ($request); } $response = $this->prepareResponse ($request, $response); $this->callFilter ('after', $request, $response); return $response; } // 分发请求到指定路由并返回一个响应 public function dispatchToRoute (Request $request) {$route = $this->findRoute ($request); $request->setRouteResolver (function () use ($route) {return $route;}); $this->events->fire ('router.matched', [$route, $request]); $response = $this->callRouteBefore ($route, $request); if (is_null ($response)) {$response = $this->runRouteWithinStack ($route, $request); } $response = $this->prepareResponse ($request, $response); $this->callRouteAfter ($route, $request, $response); return $response; } // 通过实例栈启动给定的路由 protected function runRouteWithinStack (Route $route, Request $request) {$middleware = $this->gatherRouteMiddlewares ($route); return (new Pipeline ($this->container)) ->send ($request) ->through ($middleware) ->then (function ($request) use ($route) {return $this->prepareResponse ($request,$route->run ($request)); }); }

在路由信息存储实例中，通过「$route = $this->findRoute ($request);」来查找请求对应的路由实例，查找主要是根据请求的方法和请求 URI 来实现对应，当查找到请求对应的路由后，请求将会传递到对应的路由中去处理，即「$route->run ($request)」。

文件 Illuminate\Routing\Route.php// 执行路由动作并返回响应 public function run (Request $request) {$this->container = $this->container ?: new Container; try {if (!is_string ($this->action ['uses'])) {return $this->runCallable ($request); } if ($this->customDispatcherIsBound ()) {return $this->runWithCustomDispatcher ($request); } return $this->runController ($request); } catch (HttpResponseException $e) {return $e->getResponse ();} } // 将请求发送到常规分发器去处理 protected function runWithCustomDispatcher (Request $request) {list ($class, $method) = explode ('@', $this->action ['uses']); $dispatcher = $this->container->make ('illuminate.route.dispatcher'); return $dispatcher->dispatch ($this, $request, $class, $method); }

在请求对应的路由中，会检测是否使用常规的控制分发器去处理，在初始的 Laravel 框架中使用的是常规控制分发器，通过服务容器自动生成这个控制分发器，这个服务是通过服务提供者 ControllerServiceProvider 注册的，下一步将会把请求及路由中关于处理函数的信息交给控制分发器去处理，这里对路由中关于处理函数的信息是以控制器类名和函数名给出的，即 $class 和 $method。

2．控制器生成

在控制分发器中，将会根据路由提供的响应函数信息来实例化控制器类，并调用对应的响应函数生成响应的内容部分。下面给出部分源码：

文件 Illuminate\Routing\ControllerDispatcher.php// 分发一个请求到一个给定的控制器中的方法 public function dispatch (Route $route, Request $request, $controller, $method) {$instance = $this->makeController ($controller); $this->assignAfter ($instance, $route, $request, $method); $response = $this->before ($instance, $route, $request, $method); if (is_null ($response)) {$response = $this->callWithinStack ($instance, $route, $request, $method); } return $response; } // 通过服务容器创建控制器实例 protected function makeController ($controller) {Controller::setRouter ($this->router); return $this->container->make ($controller); } // 调用给定的控制器实例的对应方法 protected function callWithinStack ($instance, $route, $request, $method) {$middleware = $this->getMiddleware ($instance, $method); return (new Pipeline ($this->container)) ->send ($request) ->through ($middleware) ->then (function ($request) use ($instance, $route, $method){return $this->router->prepareResponse ($request, $this->call ($instance, $route, $method) ); }); } // 调用给定的控制器实例的方法 protected function call ($instance, $route, $method) {$parameters = $this->resolveClassMethodDependencies ($route->parametersWithoutNulls (), $instance, $method); return $instance->callAction ($method, $parameters); }

在控制分发器中，首先根据控制器类名，通过服务容器进行实例化，再通过调用控制器实例对应的方法 ($instance->callAction ($method, $parameters)) 来生成响应的主体部分。这里需要注意，请求并不是都能正常地到达处理函数生成响应，因为还有权限等问题，那么 Laravel 是如何对请求的权限等信息进行控制的呢？这是中间件发挥了作用。在控制器的构造函数中，可以通过「$this->middleware ('auth');」来声明该控制器中处理函数在处理请求过程中需要进行对应中间件的处理，这里当然也可以指定哪些处理函数在响应请求时需要经过中间件。当声明了中间件后，就会在 callWithinStack () 函数中获取对应的中间件信息，即「$middleware = $this->getMiddleware ($instance, $method);」，然后通过「管道」方式进行处理。在 Laravel 框架中，对于身份验证等功能就是这样实现的，在响应之前首先经过「auth」中间件 (在 laravel\app\Http\Kernel.php 文件中的 $routeMiddleware 数组中定义) 的 handle () 函数进行处理，如果验证通过将会进行响应处理，否则重定向到登录页面，这部分内容在后面的章节中还会详细介绍。

3．响应生成

经历了层层的处理，应用程序终于找到了对应请求的处理函数，这里假设就是 Laravel 框架的欢迎页面。对于不同的应用可能生成的响应主体是不同的，对于移动应用可能响应的就是一些 JSON 格式的数据，而对于网页应用响应的可能是一个 HTML 页面。对于 HTML 页面，在第 5 章中的视图部分进行了介绍，但是没有涉及生成的过程，在这里将分析这个生成过程。下面是部分源码：

文件 laravel\app\Http\Controllers\WelcomeController.php// 显示视图到屏幕 public function index () { return view ('welcome'); } 文件 Illuminate\Foundation\helpers.php// 根据给定的视图名称得到视图内容 if (! function_exists ('view')) {function view ($view = null, $data = array (), $mergeData = array ()) {$factory = app ('Illuminate\Contracts\View\Factory'); if (func_num_args () === 0) {return $factory;} return $factory->make ($view, $data, $mergeData); } } 文件 Illuminate\View\Factory.php// 生成视图实例 public function make ($view, $data = array (), $mergeData = array ()) {if (isset ($this->aliases [$view])) $view = $this->aliases [$view]; $view = $this->normalizeName ($view); $path = $this->finder->find ($view); $data = array_merge ($mergeData, $this->parseData ($data)); $t h i s->c a l l C r e a t o r ($v i e w = n e w V i e w ($t h i s , $t h i s->getEngineFromPath ($path), $view, $path, $data)); return $view; }

对于视图的生成实际上是通过实例化 Illuminate\View\View 类实现的，在 View 实例中包含了视图文件路径、名称、数据及它的编译引擎等，接下来将会根据生成的响应主体生成响应实例。在 Laravel 框架中对响应的封装是通过 Illuminate\Http\Response 类完成的，而该类的底层也用到了 Symfony 框架中的 Response 类，即 Symfony\Component\HttpFoundation\Response 类。

文件 Illuminate\Routing\Router.php// 根据给定的内容创建响应实例 protected function prepareResponse ($request, $response) {if ( ! $response instanceof SymfonyResponse) {$response = new Response ($response); } return $response->prepare ($request); } 文件 laravel\vendor\symfony\http-foundation\Response.php// 在响应传输到客户端之前进行准备 public function prepare (Request $request) {$headers = $this->headers; if ($this->isInformational () ll $this->isEmpty ()) {$this->setContent (null); $headers->remove ('Content-Type'); $headers->remove ('Content-Length'); } else {if (!$headers->has ('Content-Type')) {$format = $request->getRequestFormat (); if (null !== $format ＆＆ $mimeType = $request->getMimeType ($format)) {$headers->set ('Content-Type', $mimeType); } } $charset = $this->charset ?: 'UTF-8'; if (!$headers->has ('Content-Type')) {$headers->set ('Content-Type', 'text/html; charset='.$charset); } elseif (0 === stripos ($headers->get ('Content-Type'), 'text/') ＆＆ false === stripos ($headers->get ('Content-Type'), 'charset')) {$headers->set ('Content-Type', $headers->get ('Content-Type').'; charset='.$charset); } if ($headers->has ('Transfer-Encoding')) {$headers->remove ('Content-Length'); } if ($request->isMethod ('HEAD')) {$length = $headers->get ('Content-Length'); $this->setContent (null); if ($length) {$headers->set ('Content-Length', $length); } } } if ('HTTP/1.0' != $request->server->get ('SERVER_PROTOCOL')) {$this->setProtocolVersion ('1.1'); } if ('1.0' == $this->getProtocolVersion () ＆＆ 'no-cache' == $this->headers->get ('Cache-Control')) {$this->headers->set ('pragma', 'no-cache'); $this->headers->set ('expires', -1); } $this->ensureIEOverSSLCompatibility ($request); return $this; }

从上面可以看到，响应最终是封装在 Illuminate\Http\Response 实例中的，其中不仅包括了控制器处理函数得到的响应主体，还包括根据请求生成的响应头的内容。至此，从请求的发出到响应的生成就已经完成了，接下来就是将响应发给客户端并记录相关的信息。

7.4　响应的发送与程序终止

7.4.1　响应的发送

到这里，对 HTTP 请求的响应已经生成了，接下来需要将封装在 Illuminate\Http\Response 实例中的响应以 HTTP 响应的形式发送给客户端，实现一个请求生命周期的最后环节。响应的发送是在 laravel\public\index.php 文件中通过「$response->send ();」实现的。

文件 laravel\public\index.php $response->send (); 文件 laravel\vendor\symfony\http-foundation\Response.php// 发送 HTTP 响应头和内容 public function send () {$this->sendHeaders (); $this->sendContent (); if (function_exists ('fastcgi_finish_request')) {fastcgi_finish_request (); } elseif ('cli' !== PHP_SAPI) {static::closeOutputBuffers (0, true); } return $this; } // 发送 HTTP 头部内容 public function sendHeaders () { if (headers_sent ()) {return $this;} header (sprintf ('HTTP/% s % s % s', $this->version, $this->statusCode, $this->statusText), true, $this->statusCode); foreach ($this->headers->allPreserveCase () as $name => $values) {foreach ($values as $value) {header ($name.': '.$value, false, $this->statusCode); } } foreach ($this->headers->getCookies () as $cookie) {setcookie ($cookie->getName (), $cookie->getValue (), $cookie->getExpiresTime (), $cookie->getPath (), $cookie->getDomain (), $cookie->isSecure (), $cookie->isHttpOnly ()); } return $this; } // 发送 Web 响应的内容 public function sendContent () { echo $this->content; return $this; }

响应的发送包括两部分内容，分别是响应头信息的发送和响应主体内容的发送。响应头信息包括状态行、首部字段和 Cookie 的发送，状态行和首部字段是通过 header () 函数完成的，Cookie 的发送是通过 setcookie () 函数完成的，这里的 Cookie 内容主要是 session 的 ID 及 CSRF（跨网站请求伪造）令牌，一个用于会话控制，另一个是防止 CSRF 攻击。在响应发送完成后，通过调用 closeOutputBuffers () 静态函数完成缓冲区的释放。

7.4.2　程序终止

在完成 HTTP 响应的发送后，接下来进入程序生命周期的最后阶段 —— 程序终止，对于 Laravel 框架，程序终止主要是完成终止中间件的调用。

文件 laravel\public\index.php $kernel->terminate ($request, $response); 文件 Illuminate\Foundation\Http\Kernel.php// 调用终止中间件的 terminate 方法 public function terminate ($request, $response) {$middlewares = $this->app->shouldSkipMiddleware () ? [] : array_merge ($this->gatherRouteMiddlewares ($request), $this->middleware ); foreach ($middlewares as $middleware) {list ($name, $parameters) = $this->parseMiddleware ($middleware); $instance = $this->app->make ($name); if (method_exists ($instance, 'terminate')) {$instance->terminate ($request, $response); } } $this->app->terminate ();}

中间件的内容在前面小节已经介绍过，在「App\Http \Kernel」类的 $middleware 数组属性中进行管理，默认情况下，需要终止的中间件就是指这个数组中记录的中间件，然后会通过服务容器依次实例化相应的中间件并调用 terminate () 函数。在 Laravel 框架默认情况下，只有会话中间件存在该函数，主要用于会话记录，即用户状态信息的记录，这部分内容会在第 12 章中介绍，这里只需要了解在程序终止阶段还会调用中间件，如果有需求可以在这部分添加相应的功能。

本章介绍了请求到响应的整个执行过程，主要可以归纳为四个阶段，即程序启动准备阶段、请求实例化阶段、请求处理阶段、响应发送和程序终止阶段。每个阶段都有相应的职责功能。程序启动准备阶段主要完成文件自动加载的实现、服务容器的实例化、基础服务提供者的注册及核心类的实例化等，核心类实例对象用于控制请求实例对象生成和处理过程的各个环节，而服务容器实例化是为整个过程提供资源服务。请求实例化阶段是将请求信息以对象的形式进行记录保存的过程。请求处理阶段首先是准备请求处理的环境，包括环境加载、服务提供者注册等七个环节，然后将请求实例通过中间件处理及通过路由和控制器的分发控制，使得不同请求通过相应的处理函数进行处理并生成响应的过程。响应发送和程序终止阶段是将响应返回给客户端并记录与客户端有关的信息等工作。这就是 Laravel 框架的整个生命周期过程。