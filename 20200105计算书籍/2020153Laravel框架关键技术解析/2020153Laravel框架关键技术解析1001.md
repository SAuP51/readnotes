# 1001. 数据库及操作

对于服务器程序的设计，数据库是很重要的一部分，对应数据库接口设计的好坏决定了扩展性、开发效率和执行效率。Laravel 框架通过统一的接口实现对不同数据库操作的封装，使得对数据库的连接和操作变得非常容易，与数据库相关的配置在文件「config\database.php」中，可以通过修改配置文件来决定到底使用何种数据库。目前，Laravel 框架支持 MySQL、Postgres、SQLite 和 SQL Server 四种数据库。

10.1　数据库迁移与填充

数据库的迁移和填充作为开发数据库的辅助手段可以极大提高开发效率，使得对数据库的管理和控制变得简单。我们知道对于程序的源代码有版本控制工具，如 subversion 和 GIT 等，而在实际程序开发过程中，经常都是迭代的开发方式，数据库架构也会不断变化，数据库迁移实际上可以看做是数据库的版本控制，通过在 Laravel 框架下建立数据库迁移文件，可以很容易地实现不同数据结构间的切换，而数据库填充可以通过文件控制数据中的数据内容，使得程序的测试变得容易，下面将分别介绍这两部分内容。

10.1.1　数据库迁移

Laravel 的数据库迁移其实是定义了一个统一的接口来实现数据库架构的创建和维护，而这种统一的接口与底层的数据库及其操作语言都是无关的，Laravel 中通过 PHP 语言来定义这些接口并实现数据库架构的描述，当需要将这个数据库架构移植到所支持的数据库后端时，只需要执行这个描述文件就可以了，这样就为数据库架构的修改和维护提供了极大的方便。

一个数据库迁移文件对应的是在「laravel\database\migrations\」目录下的一个 PHP 文件，迁移文件使用 PHP 语言来描述，即使对 SQL 语句不了解，一样可以实现数据库架构的设计，而文件的执行是通过 artisan 命令来完成的，需要注意的是，artisan 命令需要在 Laravel 框架的根目录下执行。接下来具体介绍数据库迁移的相关步骤。

（1）数据库配置。

要实现数据库迁移，首先需要对数据库账号信息进行配置，而对数据库账号信息的配置文件有两个，分别是「laravel\config\database.php」和「laravel\.env」，其中.env 文件是主配置文件，因为该文件中配置的参数会覆盖 database.php 中的参数，这里主要修改.env 中的配置参数，主要有数据库位置、数据库名、账号名和密码，这些参数根据自己的计算机环境进行配置即可。

（2）迁移文件的建立。

完成配置后，就可以创建迁移文件了，迁移文件需要存储在「laravel\database\ migrations\」目录下，而文件的名字则需要以 YYYY_MM_DD_HHMMSS _create_tableName_table.php 形式创建，其中前面是一个 UTC 时间戳识别，后面 tableName 为数据库表的名称，当然也可以直接使用 artisan 命令创建迁移文件，命令为「php artisan make:migration create_tableName_table」。通过 artisan 命令创建的文件已经在文件中给出了迁移文件的基本结构，其中包含两个方法，分别是 up () 方法和 down () 方法，其中 up () 方法是执行迁移命令时创建的表结构，而 down () 方式是执行回滚时删除的表结构。

（3）迁移文件的设计。

数据库迁移文件的设计实际上就是对数据表的操作和维护，在 Laravel 框架中是通过结构生成器（Schema 类）来实现的，该类提供了一组与数据库无关的数据表生成方法，通过这些方法可以实现数据表的创建、删除和修改等功能。下面是一个简单的迁移文件实例。

文件：laravel\database\migrations\2014_10_12_000000_create_users_table.php <?php use Illuminate\Database\Schema\Blueprint; use Illuminate\Database\Migrations\Migration; class CreateUsersTable extends Migration { // 执行迁移 public function up () {Schema::create ('users',function (Blueprint $table){$table->increments ('id'); $table->string ('username',32); $table->string ('account',32) ->unique (); $table->string ('password',60); $table->rememberToken (); $table->unsignedInteger ('addtime'); $table->tinyInteger ('state')->unsigned ()->default (1); }); } // 回滚迁移 public function down () { Schema::drop ('users'); } }

这里通过 artisan 命令创建了迁移文件，只需要在 up () 方法和 down () 方法中添加相应的结构生成器方法来实现对数据表的操作，上面的实例在 up () 方法中通过 Schema 类 create () 方法创建一个名为「users」的数据表，该数据表中包含一个自动增量的 id、32 位长度的名字和账号、60 位长度的密码、记录令牌（rememberToken，相当于 100 位长度 varchar）、无符号整型的时间和小整型的状态，而在数据表生成器中还有更多的字段类型、字段修饰和创建索引方法可以使用，这些方法及与数据库对应的描述如表 10.1、表 10.2 和表 10.3 所示。

表 10.1　字段类型方法表

添加字段类型函数 功能描述

$table->bigIncrements ('id'); id 自动增量，使用相当于 bigInteger 类型

$table->bigInteger ('votes'); 相当于 bigInt 类型

$table->binary ('data'); 相当于 blob 类型

$table->boolean ('confirmed'); 相当于 boolean 类型

$table->char ('name', 4); 相当于 char 类型，并带有长度

$table->date ('created_at'); 相当于 date 类型

$table->dateTime ('created_at'); 相当于 dateTime 类型

$table->decimal ('amount', 5, 2); 相当于 decimal 类型，并带有精度与基数

$table->double ('column', 15, 8); 相当于 double 类型，总共有 15 位数，在小数点后面有 8 位数

$table->enum ('choices', array ('foo', 'bar')); 相当于 enum 类型

$table->float ('amount'); 相当于 float 类型

$table->increments ('id'); 相当于 Incrementing 类型 (数据表主键)

$table->integer ('votes'); 相当于 integer 类型

$table->json ('options'); 相当于 json 类型

$table->longText ('description'); 相当于 longText 类型

$table->mediumInteger ('numbers'); 相当于 mediumInt 类型

$table->mediumText ('description'); 相当于 mediumText 类型

$table->morphs ('taggable'); 加入整数 taggable_id 与字串 taggable_type

$table->nullableTimestamps (); 与 timestamps () 相同，但允许 NULL

$table->smallInteger ('votes'); 相当于 smallInt 类型

$table->tinyInteger ('numbers'); 相当于 tinyInt 类型

$table->softDeletes (); 加入 deleted_at 字段于软删除使用

$table->string ('email'); 相当于 varchar 类型

$table->string ('name', 100); 相当于 varchar 类型，并指定长度

$table->text ('description'); 相当于 text 类型

$table->time ('sunrise'); 相当于 time 类型

$table->timestamp ('added_on'); 相当于 timestamp 类型

$table->timestamps (); 加入 created_at 和 updated_at 字段

$table->rememberToken (); 加入 remember_token 字段，使用类型为 varchar (100)

表 10.2　修饰方法表

添加字段修饰 功能描述

$table->float ('amount')->first () 将此字段放在表的首位 (只能在 MySQL 中使用)

$table->float ('amount')->after ('column') 将此字段方法放在其他字段后面 (只能在 MySQL 中使用)

$table->string ('email')->nullable () 表示此字段允许 NULL

$table->float ('amount')->default ($value) 指定此字段的默认值

$table->integer ('votes')->unsigned () 配置整数为非负数

表 10.3　索引方法表

索引类型 功能描述

$table->primary ('id'); 加入主键 (primary key)

$table->primary (array ('first', 'last')); 加入复合键 (composite keys)

$table->unique ('email'); 加入唯一索引 (unique index)

$table->index ('state'); 加入基本索引 (index)

数据表字段生成时是支持链式操作的，如实例中关于账户和状态字段的设置分别是「$table->string ('account',32) ->unique ();」和「$table->tinyInteger ('state')->unsigned ()->default (1);」，其中账户 (account) 字段设置为 32 位 char 类型，其实 string 函数相当于可以设置长度的 varchar (变长度字符型) 类型，而状态 (state) 被设置为无符号的小整型，并通过 default (1) 设置默认值为 1。

（4）执行数据迁移。

执行数据迁移可以通过 artisan 命令来完成，针对上述实例，执行迁移命令实现「users」数据表的建立，而执行回滚迁移实现「users」数据表的删除。具体命令如下：

php artisan migrate 执行迁移 php artisan migrate:rollback 执行回滚迁移

通过上面四个步骤，就可以完成一次数据库迁移，对于复杂的数据库架构，可以在一个文件中设计多个数据表，也可以在多个文件中设计数据表，进而实现对数据库版本的控制。

10.1.2　数据库填充

在对程序进行测试时，很多时候需要数据库有相应的测试数据，如果这些测试数据需要手动通过 SQL 语句来加入，那将会是件非常麻烦的事情，好在 Laravel 框架提供了数据库填充功能，可以通过 PHP 程序设计数据库的填充数据，并通过 artisan 命令自动执行填充，这样就可以实现对数据库中数据的版本控制。下面介绍数据库填充的相关步骤。

（1）构建模型类。

模型类在 Laravel 数据库的操作中是个很重要的概念，可以将一个模型类看做是一个封装数据表的类，通过模型类就可以对这个数据表进行相应的操作。模型类将会在 Eloquent ORM 中详细介绍。下面给出针对「users」数据表的模型类代码：

文件 laravel\app\User.php <?php namespace App; use Illuminate\Database\Eloquent\Model; class User extends Model { public $timestamps = false;}

可以看到模型类非常简单，简单到无法看到这个类到底操作哪个数据表，其实对于模型类是可以设置数据表名称这个属性的，如果不设置，则默认以类名首字母小写后加上「s」作为数据表名称，如上例中定义的类名为「User」，所以数据表名称就为「users」，就是在数据库迁移过程中创建的数据表。将 $timestamps 属性设置为「false」，是因为默认情况下，对数据库添加数据时会自动添加 Laravel 框架定义的两个时间字段，而在数据库迁移时定义的时间字段不是 Laravel 框架提供的时间字段，所以这里将其设置为「false」，表示在添加数据时不再添加这两个时间字段，因为数据表中就没有设置 Laravel 定义的这两个时间字段。有了数据表名，那么对模型类的任何操作就会直接操作数据表，包括数据的增加、删除、修改和查找。

（2）数据库填充文件的设计。

有了数据表的模型类，就可以操作数据表了，也就可以进行数据库填充文件的设计了。数据库填充文件一般放置在「laravel\database\seeds\」目录下，该文件以一个类的形式创建，类名可以任意取，不过一般约定类名为数据表名后加上「TableSeeder」，对于这个实例，类名为「UserTableSeeder」。需要注意的是，文件名要与类名相同，否则无法自动加载类，同时该类要继承自「Illuminate\Database\Seeder」类，也可以通过 artisan 命令「php artisan make:seeder UserTableSeeder」自动创建填充文件。数据库填充设计代码如下：

文件 laravel\database\seeds\UserTableSeeder.php <?php use App\User; use Illuminate\Database\Seeder; class UserTableSeeder extends Seeder { public function run () {DB::table ("users")->delete (); for ($i=0; $i<10; $i++){User::create ([ 'username'=>'username', 'account'=>'account'.$i, 'password'=>'password'.$i, 'addtime'=>time (), 'state'=>1 ]); } } }

这里首先通过「DB::table ("users")->delete ();」语句将数据表中的数据删除，然后利用循环，通过「User」模型类的 create () 方法完成数据表中数据的添加，create () 方法需要一个关联数组作为参数，而这个数组就是数据表中需要添加的数据，键为数据表字段名称，值为数据表中对应字段需要添加的数据。这些方法的实现细节在后续章节中会详细介绍，这里只要先清楚每一步的作用即可。

完成上面填充文件的设计后，还需要做一件工作，即在相应的位置调用填充文件，这个位置就是 Laravel 框架中自带的填充文件「DatabaseSeeder.php」，也就是说在执行填充命令时，调用的是该类中的 run () 方法，而在该方法中注册填充文件，就会调用到自己设计的填充方法，从而完成数据填充。具体代码如下：

文件 laravel\database\seeds\DatabaseSeeder.php class DatabaseSeeder extends Seeder {public function run () {Model::unguard (); $this->call (UserTableSeeder::class); Model::reguard ();} }

（3）执行数据库填充。

执行数据迁移可以通过 artisan 命令「php artisan db:seed」来完成数据填充。执行完填充后，通过 phpMyAdmin 查看填充后的结果，如图 10.1 所示。

图 10.1　数据填充结果

10.2　查询构造器

在 Laravel 中，对数据库的访问可以通过查询构造器或 Eloquent ORM 实现，不同的方法实现不同的底层封装，这两种封装都有同一个目的，即对底层不同数据库提供统一的操作接口。默认情况下，Laravel 支持四种数据库系统，即 MySQL、Postgres、SQLite 和 SQL Server。也就是说，当服务器程序数据库改变时 (如从 SQLite 迁移到 MySQL 上)，如果对数据库的操作是通过查询构造器或 Eloquent ORM 实现的，那么只需要修改数据库配置文件的相关配置，对于程序不需要进行任何修改就可以实现，这样将会极大提高 Laravel 框架的扩展性。在 Laravel 的官方文档中，只是提供了这两种实现的方法，而对于底层的实现方式和原理没有说明，程序开发者需要真正地了解底层的原理和实现才能在学习中触类旁通，在开发时得心应手。本节先介绍查询构造器的实现原理，Eloquent ORM 的实现原理将在下节中介绍。

查询构造器的底层其实用到的还是 PHP 数据库抽象层的 PDO 扩展，该扩展是一个「轻量级」的数据库扩展，数据库的操作需要自己设计 SQL 语句来执行，而 Laravel 框架的查询构造器是在 PDO 扩展基础上设计的一个「重量级」的数据库扩展，它将 SQL 语句的设计都进行了封装，将需要变化的部分进行了分离并以配置文件的方式进行设置，对数据库常用的操作进行了封装，提供了统一的接口，更加方便使用。本节将通过 PHP 中数据库的操作、数据库连接的封装、查询构造器的实现、查询构造器的使用和查询构造器的数据库操作五个部分进行介绍，介绍过程将以 MySQL 数据库为例。

10.2.1　PHP 中数据库的操作

一般关系型数据库采用的是「客户机 / 服务器」的体系结构，客户端通过 SQL 语句操作服务端。在 PHP 中，有两大类操作数据库的扩展，一种是针对各数据库开发的专用扩展，如 MySQL 扩展、SQLite3 扩展；另一种是数据库抽象层，如 PDO（PHP Data Objects，PHP 数据对象）、ODBC（Open Database Connectivity，开放数据库互连）。在 PHP 开发中，以前的开发中大多使用专用扩展，因为 PDO 是在 PHP5.1 版本才引入的，而目前开发中大多使用 PDO 扩展。Laravel 框架中关于数据库操作的底层使用的就是 PDO 扩展。

那么这两种扩展有什么区别呢？一是开发思想不同，针对各数据库开发的专用扩展采用的是面向过程的思想开发的，而 PDO 扩展采用的是面向对象的思想开发的。二是提供的接口针对的数据库范围不同，专用扩展只是针对某一种数据库开发的，如 MySQL 扩展提供的接口只能操作 MySQL 数据库，当更改底层数据库时，就要重新安装相应数据库的扩展，也需要对数据库的操作代码重新编程；而数据库抽象层则针对多种数据库提供统一的接口，采用这种接口编写的程序，在更改底层数据库时，不需要重新安装数据库抽象层，但需要安装对应的数据库驱动，代码部分只需要修改少许的连接和设置等操作，其他对数据的操作不需要修改，扩展性好，其作用方式如图 10.2 和图 10.3 所示。三是安全性，在关系型数据库中，使用专用扩展需要解决 SQL 注入的问题，而使用 PDO 扩展可以避免这个问题。

图 10.2　通过专用数据库扩展操作数据库方式

图 10.3　PDO 扩展操作数据库方式

下面针对 MySQL 数据库介绍专用扩展和 PDO 扩展的用法，一是使读者了解两者的区别和效果，二是有助于读者了解 Laravel 框架关于数据库操作底层的实现，这部分内容将会在后面章节详细介绍。

1．MySQL 扩展应用

前面提到，专用 MySQL 扩展是采用面向过程的思想开发的，当 PHP 安装了 MySQL 扩展后，就可以直接使用相应的函数来执行 SQL 语句，从而完成对数据库的操作，这里用到的是 mysql_query () 函数执行 SQL 语句。一般将 SQL 语句分为两类：一类是执行 SQL 语句后有返回结果的，如 select 语句、desc 语句等；第二类是没有返回结果的，如 delete 语句、insert 语句等。对于没有返回结果的语句不需要设置返回值，可以通过 mysql_insert_id () 函数获取最后操作数据的行数及通过 mysql_affected_rows () 获取操作影响的行数。对于有返回结果的语句需要设置返回值，可以通过 mysql_fetch_assoc () 函数实现返回值的获取。下面给出一个简单的对数据库进行操作的源码：

<?php // 连接数据库 $link = mysql_connect ("localhost","root","root") or die ("Could not connect:" ．mysql_error ()); // 选择数据库 mysql_select_db ("Laravel"); // 执行插入语句 $sql1 = "insert into users (name, pass) values ('xiaofang', '111111')"; mysql_query ($sql1); echo "插入的 id 号：".mysql_insert_id ()."<br>"; echo "影响记录的行数：".mysql_affected_rows ()."<br>"; $sql2 = "insert into users (name, pass) values ('shuoshuo','222222')"; mysql_query ($sql2); echo "插入的 id 号：".mysql_insert_id ()."<br>"; echo "影响记录的行数：".mysql_affected_rows ()."<br>"; // 执行查询语句 $sql3 = "select * from users"; $result = mysql_query ($sql3); while ($row = mysql_fetch_assoc ($result)){print_r ($row); echo "<br>"; } // 执行修改语句 $sql4 = "update users set name='shuoshuo' where id=3"; mysql_query ($sql4); echo "更新影响记录的行数：".mysql_affected_rows ()."<br>"; // 关闭数据库 mysql_close ($link); 输出结果： 插入的 id 号：1 影响记录的行数：1 插入的 id 号：2 影响记录的行数：1 Array ([id] => 1 [name] => shuoshuo [pass] => 111111 ) Array ([id] => 2 [name] => shuoshuo [pass] => 222222 ) 更新影响记录的行数：1

通过上述源码可以看出，操作一个数据库需要四个步骤：一是连接数据库的服务端；二是选择数据库；三是准备 SQL 语句并执行；四是关闭数据库。这些步骤所用到的函数都是对应数据库专用的扩展函数，在扩展方面无法迁移到其他数据库，在安全性方面，因为是一次性完成 SQL 语句命令和数据的设定及编译（一般数据库将 SQL 语句从客户端发送到服务端时需要先编译才能执行），所以容易受到 SQL 注入的攻击。

2．PDO 扩展应用

目前，在 PHP 程序设计中对数据库的操作广泛采用 PDO 扩展方式，因为该扩展对不同数据库提供统一的接口，只需要添加相应数据库的驱动就可以实现数据库的迁移，扩展性更好。同时，PDO 将服务器端命令语句的编译和数据添加的分离思想应用到客户端，可以避免 SQL 注入的攻击，安全性更好。下面给出基于 PDO 扩展来操作 MySQL 数据库的源码：

<?php // 连接数据库 $dsn = "mysql:host=localhost; dbname=Laravel"; try { $pdo = new PDO ($dsn, "root", "root"); } catch (PDOException $e){echo "连接失败".$e->getMessage ()."<br>"; } // 使用 PDO 类中的 exec () 方法插入数据 $sql1 = "insert into pdousers (name, pass) values ('xiaofang','111111')"; $row = $pdo->exec ($sql1); echo "插入语句影响的行号为：".$pdo->lastInsertId ()."<br>"; // 使用 PDOStatement 类中的 execute () 方法插入数据 $sql2 = "insert into pdousers (name, pass) values (:name,:pass)"; $sta = $pdo->prepare ($sql2); $sta->execute (array ("name"=>'shuoshuo',"pass"=>'222222')); echo "插入语句影响的行号为：".$pdo->lastInsertId ()."<br>"; $sta->execute (array ("name"=>"shuoshuo2","pass"=>"212121")); echo "插入语句影响的行号为：".$pdo->lastInsertId ()."<br>"; // 通过 PDOStatement 的 execute () 方法执行查询语句 $sql5 = "select * from pdousers where id>:id"; $pdoSta = $pdo->prepare ($sql5); $pdoSta->execute (array ("id"=>0)); while ($row = $pdoSta->fetch (PDO::FETCH_ASSOC)){print_r ($row); echo "<br>"; } 输出结果： 插入语句影响的行号为：1 插入语句影响的行号为：2 插入语句影响的行号为：3 Array ([id] => 1 [name] => xiaofang [pass] => 111111 ) Array ([id] => 2 [name] => shuoshuo [pass] => 222222 ) Array ([id] => 3 [name] => shuoshuo2 [pass] => 212121 )

通过上述源码可以看出，采用 PDO 扩展对数据库操作的步骤与采用专用 MySQL 扩展对数据库操作的步骤几乎相同，但在实现方式上却不同。一是在 PDO 扩展中对 MySQL 数据库的操作方法中几乎没有与该数据库关联的部分，只有在建立连接时构造 DSN（Data Source Name ，数据源名称）时以「mysql:host=localhost; dbname=Laravel」的方式声明了数据库类型，而具体对数据库的操作方法与数据库类型无关，所以在数据库迁移时，只需要修改这个连接参数就可以实现，扩展性更好；二是在执行数据库操作时，可以先通过 PDO 类的 prepare () 方法将操作命令发送到服务端编译，再通过 PDOStatement 类的 execute () 方法将数据发送到服务端并执行，这种方法既可以提高多次执行同一条操作命令时的速度，也可以避免 SQL 注入的危险，所以效率、安全性都更高。

10.2.2　数据库连接的封装

在 PDO 扩展中，可以看到虽然提供了对数据库操作的统一接口函数，但是在与数据库连接时还是与数据库的类型存在关联，在数据库迁移时同样需要修改这部分内容。这里所说的数据库迁移与第一节中介绍的数据库迁移与填充中的迁移有所区别，第一节中所说的数据库迁移是指通过 PHP 文件的形式创建数据库表结构，可以很容易实现数据库升级及数据表从一种数据库迁移到另一种数据库中，而这里所说的数据库迁移是指应用程序从一种数据库迁移到另一种数据库上。

在 Laravel 框架中，将这部分需要变化的部分进行了分离，以配置文件的方式给出，只需要修改配置文件就可以实现对不同数据库的连接和操作，这也体现了设计模式中的封装变化原则，即找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起（Head First 设计模式）。当然，对于不同数据库还有很多其他不同的地方 (如语法构造的不同、结果处理的不同)，Laravel 框架也将这些针对不同数据库的接口封装成了类，根据配置文件的不同，在调用统一接口方法时，底层其实是使用不同的类方法来实现。目前，Laravel 框架支持四种关系型数据库，即 MySQL、Postgres、SQLite 和 SQL Server。所以只有了解了底层实现的方式，在开发过程中才能得心应手，如果需要添加对其他数据库的支持，也可以正确修改需要变化的部分。下面给出数据库连接创建过程的源码，由于这部分代码较多，所以只给出关键部分，并通过几个阶段进行分析。

1．数据库管理器阶段

在服务注册阶段，通过服务提供者「Illuminate\Database\DatabaseServiceProvider」注册了数据库管理器服务 (「DB」服务) 和数据库连接工厂服务 (「db.factory」服务)，通过上述服务可以获取数据库管理器实例 (DatabaseManager 类实例) 和数据库连接工厂实例（ConnectionFactory 类实例），其中数据库连接工厂实例作为数据库管理器实例的一个属性。下面介绍查询构造器实现过程中的数据库管理器阶段，其中部分实现代码如下：

文件 \app\Http\Controllers\WelcomeController.php// 使用查询构造器获取数据信息 public function index () { $users = DB::table ('users')->get ();}

对于查询构造器，当需要操作数据库时，可以使用类似「DB::table ('users')->get ();」的语法，其中「DB::table (‘users’)」部分是获取查询构造器，而「->get ()」是调用查询构造的方法实现相应数据表操作的过程。查询构造器的建立过程可以分为两个阶段：一个是数据库连接封装阶段，另一个是查询构造器生成阶段。本小节主要讨论数据库连接封装阶段，而这部分又可以分为四个步骤：一是数据库管理器阶段，二是数据库连接工厂阶段，三是数据库连接器阶段，四是数据库连接创建阶段。数据库管理器阶段主要用于生成数据库连接工厂，而数据库连接工厂管理着不同数据库连接器的创建，这个阶段会根据数据库配置信息生成相应数据库的连接器，在数据库连接器阶段会根据数据库配置信息生成相应数据库的 PDO 实例，而在数据库连接创建阶段则生成相应数据库的连接实例，用于封装对应的 PDO 实例、数据库配置等信息。下面介绍数据库管理器阶段。

文件 \Illuminate\Database\DatabaseManager.php// 动态地将方法传递给默认连接 ，此时 $method =「table」public function __call ($method, $parameters) {return call_user_func_array ([$this->connection (), $method], $parameters); }

对于「DB::」阶段，是通过 DB 的外观类 (Facades) 获取数据库管理器实例并调用其中的 table () 方法，因为该类中没有这个方法，所以调用魔术函数__call () 方法，该方法进而调用方法「[$this->connection (), $method]」，即 $this->connection () 返回实例的 table () 方法，而「$this->connection ()」将根据配置文件获取数据库连接实例，这也是数据库连接封装阶段的重点。

文件 \Illuminate\Database\DatabaseManager.php// 获取数据库连接实例 public function connection ($name = null) {list ($name, $type) = $this->parseConnectionName ($name); if (!isset ($this->connections [$name])) {$connection = $this->makeConnection ($name); $this->setPdoForType ($connection, $type); $this->connections [$name] = $this->prepare ($connection); } return $this->connections [$name]; } // 将连接的名称和读 / 写类型进行解析得到数据，此时 $name = null protected function parseConnectionName ($name) {$name = $name ?: $this->getDefaultConnection (); return Str::endsWith ($name, ['::read', '::write']) ? explode ('::', $name, 2) : [$name, null]; } // 获取默认连接的名字 public function getDefaultConnection () { return $this->app ['config']['database.default']; } // 创建数据库连接实例，此时 $name="mysql" protected function makeConnection ($name) {// 获取关于该名字数据库的配置 $config = $this->getConfig ($name); if (isset ($this->extensions [$name])) {return call_user_func ($this->extensions [$name], $config, $name); } $driver = $config ['driver']; if (isset ($this->extensions [$driver])) {return call_user_func ($this->extensions [$driver], $config, $name); } return $this->factory->make ($config, $name); }

首先，通过 parseConnectionName () 函数获取配置文件中关于默认数据库名称和类型的设置，而对于数据库配置信息的获取是通过 getDefaultConnection () 函数实现的，其中，配置文件为「laravel\config\database.php」，对数据库名称和类型的配置项为「default」项，Laravel 框架默认设置为「mysql」，于是返回的数据库名称和类型配置信息分别为「$name="mysql"」和「$type="null"」。

其次，通过 getConfig () 函数根据数据库名称获取对数据库的配置，包括数据库的驱动、主机地址、用户名、密码和使用的数据库名等，对于不同类型的数据库配置也不同。接下来进入数据库连接工厂阶段，需要注意的是，数据库连接工厂的实例 (「db.factory」服务) 在创建数据库管理器（「DB」服务）的时候作为依赖已经通过服务容器注入到数据库管理器中了。

2．数据库连接工厂阶段

前面提到 Laravel 框架默认支持四种关系型数据库，那么为了对上层提供统一的接口，需要在底层根据不同的配置调用不同的数据库驱动扩展，而这里 Laravel 框架使用了简单工厂设计模式，用来根据配置文件获取不同的数据库连接实例。下面给出数据库连接工厂阶段部分代码：

文件 \Illuminate\Database\Connectors\ConnectionFactory.php// 基于配置创建一个 PDO 连接 public function make (array $config, $name = null) {$config = $this->parseConfig ($config, $name); if (isset ($config ['read'])) {return $this->createReadWriteConnection ($config); } return $this->createSingleConnection ($config); } // 创建一个单独的连接实例 protected function createSingleConnection (array $config) {$pdo = $this->createConnector ($config)->connect ($config); return $this->createConnection ($config ['driver'], $pdo, $config ['database'], $config ['prefix'], $config); } // 基于配置创建一个连接器实例 public function createConnector (array $config) {if (!isset ($config ['driver'])) {throw new InvalidArgumentException ('A driver must be specified.'); } if ($this->container->bound ($key = "db.connector.{$config ['driver']}")) {return $this->container->make ($key); } switch ($config ['driver']) {case 'mysql': return new MySqlConnector; case 'pgsql': return new PostgresConnector; case'sqlite': return new SQLiteConnector; case'sqlsrv': return new SqlServerConnector;} throw new InvalidArgumentException ("Unsupported driver [{$config ['driver']}]"); }

上述代码根据数据库名称实例化对应的连接器，即 createConnector () 函数部分。连接器实例用来管理数据库连接创建阶段 DSN 字符串的产生、PDO 类的实例化及数据库配置的设置等。在 Laravel 框架默认配置中，使用 MySQL 数据库，即读写类型用同一个数据库，如果需要设计读写分离的数据库，可以在配置时对类型进行定义，之后将会在这部分起作用。

3．连接器阶段

在连接器阶段，针对不同的数据库将会有不同的实现，主要包括连接 DSN 名称及配置等。Laravel 框架用四个类分别封装了默认支持的四个数据库连接的过程，通过 connect () 方法提供统一的接口。下面给出这部分实现的代码：

文件 \Illuminate\Database\Connectors\MySqlConnector.php// 创建一个数据库连接 public function connect (array $config) {$dsn = $this->getDsn ($config); $options = $this->getOptions ($config); $connection = $this->createConnection ($dsn, $config, $options); if (isset ($config ['unix_socket'])) {$connection->exec ("use`{$config ['database']}`;"); } $collation = $config ['collation']; $charset = $config ['charset']; $names = "set names '$charset'". (!is_null ($collation) ? "collate '$collation'" : ''); $connection->prepare ($names)->execute (); if (isset ($config ['timezone'])) {$connection->prepare ('set time_zone="'.$config ['timezone'].'"' )->execute ();} if (isset ($config ['strict']) ＆＆ $config ['strict']) {$connection->prepare ("set session sql_mode='STRICT_ALL_TABLES'")->execute ();} return $connection; } // 根据配置创建一个 DSN 字符串 protected function getDsn (array $config) {return $this->configHasSocket ($config) ? $this->getSocketDsn ($config) : $this->getHostDsn ($config); } protected function getHostDsn (array $config) {extract ($config); return isset ($port) ? "mysql:host={$host};port={$port};dbname={$database}" : "mysql:host={$host};dbname={$database}"; } 文件 \Illuminate\Database\Connectors\Connector.php// 创建一个新的 PDO 连接 public function createConnection ($dsn, array $config, array $options) {$username = Arr::get ($config, 'username'); $password = Arr::get ($config, 'password'); return new PDO ($dsn, $username, $password, $options); }

从源码中可以看到，这里使用 PDO 扩展来实现连接的建立，即「new PDO ($dsn, $username, $password, $options)」，而对于不同的 DSN 名称，则通过 getDsn () 函数获取。在连接器阶段主要完成 PDO 类的实例化及对字符集、时区等的设置，即代码「$connection->prepare ($names)->execute ();」和「$connection->prepare ('set time_zone= "'.$config ['timezone'].'"')->execute ();」部分。

4．数据库连接创建阶段

不同数据库连接的实例其实是封装了对应连接的 PDO 类实例、请求语法类实例和结果处理类实例，从而为上层使用数据库连接实例提供统一的接口。部分代码如下：

文件 \Illuminate\Database\Connectors\ConnectionFactory.php// 创建一个新的连接实例 protected function createConnection ($driver, PDO $connection, $database, $prefix = '', array $config = []) {if ($this->container->bound ($key = "db.connection.{$driver}")) {return $this->container->make ($key, [$connection, $database, $prefix, $config]); } switch ($driver) {case 'mysql': return new MySqlConnection ($connection, $database,$prefix, $config); case 'pgsql': return new PostgresConnection ($connection, $database, $prefix, $config); case'sqlite': return new SQLiteConnection ($connection, $database, $prefix, $config); case'sqlsrv': return new SqlServerConnection ($connection, $database, $prefix, $config); } throw new InvalidArgumentException ("Unsupported driver [$driver]"); } 文件 \Illuminate\Database\Connection.php public function __construct (PDO $pdo, $database = '', $tablePrefix = '', array $config = []) {$this->pdo = $pdo; $this->database = $database; $this->tablePrefix = $tablePrefix; $this->config = $config; $this->useDefaultQueryGrammar (); $this->useDefaultPostProcessor ();} // 设置默认实现的请求语法 public function useDefaultQueryGrammar () { $this->queryGrammar = $this->getDefaultQueryGrammar ();} // 根据默认实现设置请求后置处理器 public function useDefaultPostProcessor () { $this->postProcessor = $this->getDefaultPostProcessor ();} 文件 \Illuminate\Database\MySqlConnection.php// 获取默认的 SQL 语法实例 protected function getDefaultQueryGrammar () { return $this->withTablePrefix (new QueryGrammar); } // 获取默认的结果处理实例 protected function getDefaultPostProcessor () { return new MySqlProcessor;}

通过上面的源码可以看出，对应数据库连接实例的创建依然使用简单工厂模式实现，对默认支持的四个数据库分别提供了四个数据库连接类，用于封装底层不同的实现方法。这四个数据库连接类都继承于 \Illuminate\Database\Connection 类，该类为数据库连接提供统一的接口，对于特殊的部分需要分别设计，如数据库 SQL 语法实例和结果处理实例对于四种数据库是不同的，需要单独设计。

10.2.3　查询构造器的实现

查询构造器类（Illuminate\Database\Query\Builder 类）实例封装了数据库连接实例、请求语法实例和结果处理实例，这里类的实例提供了统一的接口方法供查询构造器实例使用。下面是查询构造器实例化的部分代码：

文件 \Illuminate\Database\Connection.php// 针对一个数据表创建一个查询构造器 public function table ($table) {$processor = $this->getPostProcessor (); $query = new QueryBuilder ($this, $this->getQueryGrammar (), $processor); return $query->from ($table); } 文件 \Illuminate\Database\Query\Builder.php// 创建查询构造器实例 public function __construct (ConnectionInterface $connection, Grammar $grammar, Processor $processor) {$this->grammar = $grammar; $this->processor = $processor; $this->connection = $connection; } // 设置查询构造器针对的数据表 public function from ($table) {$this->from = $table; return $this; }

查询构造器实例是通过数据库连接实例的 table () 方法实现的，在其构造函数中可以看到对输入参数进行了类型约束，体现设计模式中的针对接口编程的原则。虽然这些接口的底层实现是不同的，但是接口功能是统一的，那么到达查询构造器这个层就可以对应用提供统一的数据库操作接口了。

10.2.4　查询构造器的使用

在查询构造器中已经实现了对底层数据库操作的封装，为上层应用提供了统一的数据库操作接口。重要的是，Larabel 框架通过查询构造器对 PDO 扩展进行了重新封装，使其提供的接口使用更加方便，主要表现在数据库操作不再需要专门设计 SQL 语句，而由底层的 SQL 语法规则实例来创建，对结果的处理也不用专门获取，而是由结果处理实例完成数据的处理后直接返回，因此，只需要调用查询构造器相应的方法就可以实现对数据库的增加、删除、修改和查询的操作。下面依然以「DB::table ('users')->get ();」为例，介绍通过查询构造器的 get () 函数完成数据库内容的查询功能，这里也分为两个阶段，即 SQL 语句准备阶段和 SQL 语句执行阶段。

1．SQL 语句准备阶段

这个阶段主要将查询构造器对应的方法翻译成相应的 SQL 语句。这里将 SQL 语句划分为不同的片段，片段名称存储在 SQL 语法规则实例 (MySqlGrammar 类实例) 的 $selectComponents 属性中，包括 'aggregate'、 'columns'、'from'、'joins'、 'wheres'、 'groups'、 'havings'、 'orders'、 'limit'、 'offset' 和 'lock'，针对每个片段都有相应的函数进行处理。下面给出部分实现代码：

文件 \Illuminate\Database\Query\Builder.php// 执行一个 select 请求命令，返回数据库查询结果处理后的最终结果 public function get ($columns = ['*']) {if (is_null ($this->columns)) {$this->columns = $columns; } return $this->processor->processSelect ($this, $this->runSelect ()); } // 通过连接执行 select 语句，获取数据库查询结果 protected function runSelect () { return $this->connection->select ($this->toSql (), $this->getBindings (), !$this->useWritePdo); } // 获取 SQL 查询语句 public function toSql () { return $this->grammar->compileSelect ($this); }

在查询构造器实例方法的调用过程中，会设置对应片段值，如代码「$this->from = $table;」和「$this->columns = $columns;」。针对本节中的实例，「$table」值为「users」，「$columns」值为「*」。SQL 语句准备阶段主要是通过 SQL 语法规则管理器解析 SQL 语句，这里通过 toSql () 函数实现，然后调用语法规则管理器的 compileSelect () 方法实现 SQL 语句的解析。

文件 \Illuminate\Database\Query\Grammars\Grammar.php// 编译一个 select 请求为 SQL 语句，返回「select * from 'users'」public function compileSelect (Builder $query) {if (is_null ($query->columns)) {$query->columns = ['*']; } return trim ($this->concatenate ($this->compileComponents ($query))); } // 翻译 select 语句中的必要组成部分 // 返回 array ("columns"=>"select *", "from"=>"from 'users'") protected function compileComponents (Builder $query) {$sql = []; foreach ($this->selectComponents as $component) {if (!is_null ($query->$component)) {$method = 'compile'.ucfirst ($component); $sql [$component] = $this->$method ($query, $query->$component); } } return $sql; } // 编译请求语句的「select *」部分，返回「select *」protected function compileColumns (Builder $query, $columns) {if (!is_null ($query->aggregate)) {return;} $select = $query->distinct ? 'select distinct ' : 'select '; return $select.$this->columnize ($columns); } // 编译请求语句的 from 部分，返回「from 'users'」protected function compileFrom (Builder $query, $table) {return 'from '.$this->wrapTable ($table); } // 连接 SQL 语句数组中的片段并去除空格 protected function concatenate ($segments) {return implode (' ', array_filter ($segments, function ($value) {return (string) $value !== ''; })); }

在对 SQL 语句解析过程中，首先需要根据查询构造器中设置的片段值构造对应的片段，如对于 select 查询语句会构造 select 片段，即通过 compileColumns () 函数实现「select $columns」部分，而 $columns 为默认值「*」，从而实现 select 查询语句中的「select *」部分，接着构造 from 片段，即通过 compileFrom () 函数实现查询语句中的「from $table」部分，这里实现为「from users」，最后通过 concatenate () 函数将两个查询语句片段组装成一个查询语句返回，即生成 SQL 语句「select * from users」。

2．SQL 语句执行阶段

完成 SQL 语句的翻译后，接下来需要执行 SQL 语句，而执行 SQL 语句也是通过 PDO 类的 prepare () 方法和 PDOStatement 类的 execute () 方法，对处理结果的获取则通过 PDOStatement 类的 fetchAll () 方法，只是这部分内容被查询构造器的接口函数封装了，下面给出具体实现代码，了解一下查询构造器底层的实现细节。

文件 \Illuminate\Database\Connection.php// 针对一个数据库执行一个 select 语句，其中 $query 就是上节中翻译的 SQL 语句 public function select ($query, $bindings = [], $useReadPdo = true) {return $this->run ($query, $bindings, function ($me, $query, $bindings) use ($useReadPdo) {if ($me->pretending ()) {return []; } $statement = $this->getPdoForSelect ($useReadPdo)->prepare ($query); $statement->execute ($me->prepareBindings ($bindings)); return $statement->fetchAll ($me->getFetchMode ()); }); } // 执行一个 SQL 语句并记录执行的上下文 protected function run ($query, $bindings, Closure $callback) {$this->reconnectIfMissingConnection (); $start = microtime (true); try {$result = $this->runQueryCallback ($query, $bindings, $callback); } // 省略异常处理部分代码 $time = $this->getElapsedTime ($start); $this->logQuery ($query, $bindings, $time); return $result; } // 执行 SQL 语句 protected function runQueryCallback ($query, $bindings, Closure $callback) {try { $result = $callback ($this, $query, $bindings); } // 省略异常处理部分代码 return $result; }

SQL 语句的执行是通过 select () 函数实现的，在该函数中调用 run () 方法，而该方法的第三个参数是一个匿名函数，这个匿名函数是执行 SQL 语句获取数据库操作结果的核心部分。在这个匿名函数中，通过 getPdoForSelect () 函数获取前期数据库连接实例中封装的 PDO 实例，通过 PDO 实例的 prepare () 方法准备 SQL 语句并返回 PDOStatement 类实例，然后调用该实例的 execute () 方法执行 SQL 语句，最后通过 fetchAll () 函数获取数据库操作结果，返回后再通过结果处理器进行数据处理与封装并将最终结果返回。

10.2.5　查询构造器的数据库操作

通过上面四个小节以「DB::table ('users')->get ();」为例介绍了查询构造器实现的原理及底层实现方法，其实通过查询构造器可以实现对数据库的增加、删除、修改和查询等操作，虽然功能不同，但是原理是相同的，下面介绍部分操作的方法。

1．增加信息

对数据库中的某个表增加数据主要有两个函数可以实现，分别是 insert () 和 insertGetId ()，其中 insert () 函数接收数组数据，可以同时添加一条或多条数据，返回值为 bool 型，而 insertGetId () 函数也接收数组数据，但一次只能添加一条数据，返回值为添加数据行的自动递增 id 号。下面给出相关函数使用方法的实例。

向「users」数据表中添加一条数据：

DB::table('users')->insert( ['name' => 'shuoshuo', 'pass' => ‘222222’] );

向「users」数据表中同时添加多条数据：

DB::table('users')->insert([ ['email' => 'taylor@example.com', 'votes' => 0], ['email' => 'dayle@example.com', 'votes' => 0] ]);

向「users」数据表中添加一条数据并获取自动递增的 id 号：

$id = DB::table('users')->insertGetId(['email' => 'shuoshuo', 'pass' => ‘212121’]);

2．删除数据

数据删除可以通过 delete () 函数和 truncate () 函数实现，delete () 函数可以直接使用，也可以通过 where () 函数以链式方式添加删除条件，直接使用时是删除数据表中所有的数据，而添加条件后是删除所有符合条件的数据。truncate () 函数是清空数据表中的内容，也是删除数据表中的数据，结果和直接使用 delete () 函数相同，只是 delete () 函数是一条一条删除数据的，而 truncate () 函数是释放数据表的空间，速度比 delete () 快得多，并且 delete () 函数的底层是使用 DML 语句来操作数据库，而 truncate () 函数的底层是使用 DDL 语句来操作数据库。下面给出两个函数操作数据库的具体实例。

删除「users」数据表中的数据:

DB::table('users')->where('id', '>', 10)->delete();

删除「users」数据表中的所有数据:

DB::table('users')->delete();

清空「users」数据表:

DB::table('users')->truncate();

3．修改数据

数据的修改可以使用 update ()、increment () 和 decrement () 等函数实现，其中 update () 函数也可以通过 where () 函数以链式形式添加修改条件，输入参数为修改后的数据，以数组的形式给出。increment () 和 decrement () 函数是对一个字段的值进行增加或减少，如果只设置字段，则自增或自减 1，如果设置字段和值，则增加和减少相应的数值。下面给出相应函数操作数据库的具体实例。

更新「users」数据表中的一条数据：

DB::table('users')->where('id', 2)->update(['pass' =>「111111」]);

自增或自减「users」数据表中的一个字段的值，分别增加或减少 1 或 10:

DB::table('users')->increment('score'); DB::table('users')->increment(‘score’, 10); DB::table('users')->decrement(' score’'); DB::table('users')->decrement(' score', 10);

4．查询数据

数据库的查询主要通过 get () 函数实现，数据库的操作最为复杂的就是查询，为获取准确的数据，需要设计合适的查询条件，而 Laravel 框架的查询构造器为查询条件的设置设计了很多接口，可以通过链式方式添加这些条件，如 where ()、whereBetween () 和 whereIn () 等函数，如果对 SQL 语句有所了解，根据这些函数名就可以了解添加条件的基本内容。下面给出相应函数操作数据库的具体实例。

获取「users」数据表中所有的数据：

$users = DB::table('users')->get();

获取满足 where 条件的数据：

$users = DB::table('users')->where('votes', '>', 100)->get();

获取满足 where 或 orWhere 条件的数据：

$users = DB::table('users') ->where('votes', '>', 100) ->orWhere('name', 'John') ->get();

获取在 whereBetween 区间中的数据：

$users = DB::table('users')->whereBetween('votes', [1, 100])->get();

获取在 whereIn 值中的数据：

$users = DB::table('users') ->whereIn('id', [1, 2, 3])->get(); $users = DB::table('users') ->whereNotIn('id', [1, 2, 3])->get();

10.3　Eloquent ORM

在 Laravel 框架中，提供了另一个数据库扩展，即 Eloquent ORM，该扩展实现了 Active Record 模式与数据库进行交互，使得操作数据库变得极为简单。这里先从概念上理解 Eloquent ORM 是什么。ORM 英文是 Object Relational Mapping（对象关系映射），这是一种面向对象编程中用于解决不同系统间数据转换的方案，相当于创建了一个「虚拟对象数据库」，通俗的理解就是将数据库中复杂的结构封装成更加容易使用的接口提供给用户。在 Laravel 中，Eloquent ORM 就是实现这样的功能。而 Active Record 模式也遵循标准的 ORM 模型，即数据库中每个表对应一个类，而类的实例对应于数据表中的一行记录，数据表中的字段映射到实例对象的属性。根据上述准则设计模型类，从而完成对数据表的增加、删除、修改和查询等操作。

10.3.1　Eloquent ORM 的底层实现

在 Laravel 框架中，Eloquent ORM 扩展的底层依然使用的是查询构造器实现的，这里通过简单对比两者的区别来理解 Active Record 模式的思想。在查询构造器中访问数据表时需要通过 table () 函数给定表名，而在 Eloquent ORM 中每个类就对应一个数据表；查询构造器查询结果返回的是数据数组，而在 Eloquent ORM 中返回的则是类的实例对象，每个实例对象对应一行数据；在 Eloquent ORM 中类直接封装了对该数据表的操作，使用时更加方便。下面依然通过一个简单的实例来介绍 Eloquent ORM 的底层实现，然后通过一个实例来介绍模型类中封装的方法。

1．模型类的创建

下面介绍模型类的创建和操作。一般模型类存放在 laravel\app 目录下，当然也可以根据实际需求放置在其他位置，只要符合 composer 自动载入的规范就可以。这里在 laravel\app 目录下建立一个 User 类并继承自 Model 类，这样一个 Eloquent ORM 模型就创建了，通常也称它为模型类，$timestamp 属性用于表示 Laravel 框架自定义时间字段无效，因为在设计表的时候没有用这个字段。就这样简单，一个模型类就创建完成了，虽然你觉得自己什么都没做，但是这个类已经与一个数据表生成了对象关系映射，通过操作这个模型类，就可以操作对应的数据表了。下面先通过这个模型类获取表中所有的数据，来看看它到底是怎么工作的，只需要通过「User::all ();」语句就可以实现上述功能。具体实例代码如下：

文件 laravel\app\User.php <?php namespace App; use Illuminate\Database\Eloquent\Model; class User extends Model { public $timestamps = false;} 文件 laravel\app\Http\Controllers\UserController.php <?php namespace App\Http\Controllers; use App\User; use App\Http\Controllers\Controller; class UserController extends Controller { public function index () {$data = User::all (); var_dump ($data); } }

2．模型类的实现原理

在新创建的模型类中其实什么都没有做，就可以实现对数据库操作的相关功能，而这些功能都是在继承类 Model 中完成的。但是，没有无条件的便利，因为底层是事先实现好的，在使用时就需要准守它的规则，那么需要对底层的实现原理有一个清晰的认识才能更好地去应用。下面就通过上一节中介绍的实例，逐步了解模型类实现的流程，这里也将其分为两个阶段：第一阶段是 Eloquent ORM 查询构造器的生成，第二阶段是操作命令的执行。本实例是查询数据表中的所有数据。首先，介绍第一阶段，这里给出部分代码细节：

文件 \Illuminate\Database\Eloquent\Model.php// 从数据表中获取所有模型 public static function all ($columns = ['*']) {$instance = new static; return $instance->newQuery ()->get ($columns); } // 创建一个新的 Eloquent 模型类实例 public function __construct (array $attributes = []) {$this->bootIfNotBooted (); $this->syncOriginal (); $this->fill ($attributes); }

这里首先通过「new static;」语句生成一个模型类实例，用到了后期静态绑定，生成 App\User 类的实例，在本实例中，因为没有传递任何参数，所以构造函数并没有执行有意义的工作，这部分将在后期封装数据时再来介绍。对于后期静态绑定可以在 PHP 的重要性质中了解相关内容。接下来将通过「$instance->newQuery ()」语句生成 Eloquent ORM 查询构造器。

文件 \Illuminate\Database\Eloquent\Model.php// 针对模型类对应的数据表生成一个新的查询构造器 public function newQuery () { $builder = $this->newQueryWithoutScopes (); return $this->applyGlobalScopes ($builder); } // 获取查询构造器 public function newQueryWithoutScopes () { $builder = $this->newEloquentBuilder ($this->newBaseQueryBuilder ()); return $builder->setModel ($this)->with ($this->with); } // 获取针对一个连接的查询构造器 protected function newBaseQueryBuilder () { $conn = $this->getConnection (); $grammar = $conn->getQueryGrammar (); return new QueryBuilder ($conn, $grammar, $conn->getPostProcessor ()); } // 通过模型类获取数据库连接 public function getConnection () { return static::resolveConnection ($this->connection); } // 获取一个连接实例 public static function resolveConnection ($connection = null) {return static::$resolver->connection ($connection); } 文件 \Illuminate\Database\DatabaseManager.php// 获取一个数据库连接的实例 public function connection ($name = null) {list ($name, $type) = $this->parseConnectionName ($name); if (!isset ($this->connections [$name])) {$connection = $this->makeConnection ($name); $this->setPdoForType ($connection, $type); $this->connections [$name] = $this->prepare ($connection); } return $this->connections [$name]; } // 为模型类创建一个新的 Eloquent 查询构造器 public function newEloquentBuilder ($query) {return new Builder ($query); } 文件 \Illuminate\Database\Eloquent\Builder.php public function __construct (QueryBuilder $query) {$this->query = $query; }

前文中介绍到，Eloquent ORM 的底层使用了查询构造器来实现，这里通过 newBaseQueryBuilder () 函数创建一个基础查询构造器，而这个基础查询构造器中的数据库连接最终也是通过数据库控制器 (Illuminate\Database\DatabaseManager 类实例) 的 connection () 函数实现的。同时，SQL 语法规则实例和结果处理实例与上一小节中介绍的也是相同的，所以对于这个基础查询构造器无论是对应的类还是内部封装的相关属性都与上一小节介绍的查询构造器相同。在完成基础查询构造器的实例化后，通过 newEloquentBuilder () 函数对该查询构造器进行封装，实现 Eloquent 查询构造器的创建。

文件 \Illuminate\Database\Eloquent\Builder.php// 为模型查询构造器设置一个模型实例 public function setModel (Model $model) {$this->model = $model; $this->query->from ($model->getTable ()); return $this; } 文件 \Illuminate\Database\Query\Builder.php// 设置所要查询的数据表 public function from ($table) {$this->from = $table; return $this; } 文件 \Illuminate\Database\Eloquent\Model.php// 获取模型关联的数据表 public function getTable () { if (isset ($this->table)) {return $this->table; } return str_replace ('\\', '', Str::snake (Str::plural (class_basename ($this)))); }

在完成 Eloquent 查询构造器的实例化后，也就获取了与数据库的连接、SQL 语法规则和结果处理的功能，Eloquent ORM 与上一节查询构造器操作数据库不同的是，这里还需要封装其他部分，包括模型类实例和数据表名称等，主要是需要封装模型类实例，因为对数据库的操作不再以数组的形式交互，而是通过这个模型类实例来与数据库进行交互。数据表名称是通过 Model 类对象的 getTable () 函数获取的，如果对象中的 $table 属性存在值，则使用该数据表名，如果不存在，则以模型类名的复数作为数据表名，即通过代码「str_replace ('\\', '', Str::snake (Str::plural (class_basename ($this))));」实现，这就是为什么创建的模型类没有指定数据表名，依然可以操作数据库中的数据表的原因，在本实例中，默认的数据表名为「users」。

3．对数据库的操作

通过上一小节知道 Eloquent 查询构造器为 \Illuminate\Database\Eloquent\Builder 类的实例，而该实例又封装了查询构造器 \Illuminate\Database\Query\Builder 类的实例。在完成 Eloquent 查询构造器的实例化后，将实现对数据库的操作，即「$instance->newQuery ()->get ($columns);」中的 get () 方法部分。接下来将介绍 Eloquent 查询构造器中数据库操作方法实现的原理。

文件 \Illuminate\Database\Eloquent\Builder.php// 执行一个 select 查询语句 public function get ($columns = ['*']) {$models = $this->getModels ($columns); if (count ($models) > 0) {$models = $this->eagerLoadRelations ($models); } return $this->model->newCollection ($models); }

在调用「User::all ()」查询语句时首先是调用 Model 类的 all () 方法，然后构造 Eloquent 查询构造器 (Eloquent\Builder 类实例，注意与 Query\Builder 类区别)，从而调用该实例的一个 select 查询语句的 get () 方法来实现。在 SQL 语言中使用 select 查询语句来完成所有的数据库查询任务，这里用 get () 方法只实现了查询中常用的一部分功能，即「select $columns from $table」，而 $columns 和 $table 表示要查询的数据字段名和数据表名。这个过程分为两个步骤：一是完成数据的查询，二是实现数据的封装。下面将介绍数据是如何被查询的及数据最终被封装成什么形式。

文件 \Illuminate\Database\Eloquent\Builder.php// 获取模型类实例的集合 public function getModels ($columns = ['*']) {$results = $this->query->get ($columns); $connection = $this->model->getConnectionName (); return $this->model->hydrate ($results, $connection)->all ();}

在 getModels () 函数中实际上完成了数据的查询，即通过「$this->query->get ($columns);」获取查询数据，这里的 $this->query 实际上封装的是查询构造器类实例，通过查询构造器的 get () 方法获取查询数据，数据的形式是数组。也就是说，对于数据库的增加、删除、修改和查询等功能的底层实现是依赖查询构造器来实现的，而查询构造器对数据库增加、删除、修改和查询等功能的底层实现是依赖 PDO 扩展来实现的，就这样通过一层层封装不断为使用者提供更加优秀的数据库操作接口。接下来介绍 Eloquent ORM 是如何封装结果数据的，这部分是通过 hydrate () 实现的。

文件 \Illuminate\Database\Eloquent\Model.php// 为一个数组创建一个模型类实例的集合 public static function hydrate (array $items, $connection = null) {$instance = (new static)->setConnection ($connection); $items = array_map (function ($item) use ($instance) {return $instance->newFromBuilder ($item); }, $items); return $instance->newCollection ($items); } // 创建一个新的模型类实例 public function newFromBuilder ($attributes = [], $connection = null) {$model = $this->newInstance ([], true); $model->setRawAttributes ((array) $attributes, true); $model->setConnection ($connection ?: $this->connection); return $model; } // 通过数组设置模型类实例的 attributes 属性 public function setRawAttributes (array $attributes, $sync = false) {$this->attributes = $attributes; if ($sync) {$this->syncOriginal ();} } // 创建一个新的 Eloquent 集合实例 public function newCollection (array $models = []) {return new Collection ($models); } 文件 Illuminate\Support\Collection.php// 创建一个 \Illuminate\Support\Collection 类实例 public function __construct ($items = []) {$this->items = is_array ($items)? $items: $this->getArrayableItems ($items); }

获取查询数据后将对数据进行封装，通过 array_map () 函数对数组中的每项进行处理，处理函数为一个匿名函数，该匿名函数中调用 newFromBuilder () 函数进行数据处理，该函数通过 newInstance () 函数实例化一个 Model 类，并将数据赋值给该实例的 $attributes 属性。接着实例化一个 Illuminate\Database\Eloquent\Collection 类实例，该类继承自集合类 Illuminate\Support\Collection，并将 array_map () 函数生成的模型类实例数组传递给集合类构造函数，最终将查询获取的数据以 Eloquent 集合的形式进行封装，而 Eloquent 集合中存储的是一个模型类实例数组，每一个模型类实例对应查询的一条结果。

10.3.2　Eloquent ORM 的使用

前面已经介绍了 Eloquent ORM 的实现原理，下面介绍它的使用。由于数据库操作的内容非常多，因此无法做到面面俱到，这里通过一个实例来介绍一些常用方法的使用，如果在应用中需要了解更多可以查看官方手册。

1．数据表的创建与数据填充

为了介绍 Eloquent ORM 的使用，首先需要构建数据表并添加相应的数据。要完成数据表的创建和数据填充一般需要三个步骤：一是在数据库中创建对应的数据表，二是对应每个数据表创建模型类文件，三是完成数据库的填充。在数据表的创建和数据填充过程中，可以使用 artisan 命令来创建相应的数据迁移文件。数据表创建时可以通过「php artisan make:migration create_blogs_table --create=blogs」命令创建「blogs」数据表，同理创建其他的数据表迁移文件，然后通过「php artisan migrate」命令完成数据库中数据表的创建。在创建数据表模型类时可以使用「php artisan make:model Blog」命令来创建对应的模型类。在实现数据填充时可以通过「php artisan db:seed」命令执行数据填充。这部分内容可以参考本章第一节的内容，下面分别介绍三个步骤的实现细节和实现代码。

（1）建立几个数据表。

Schema::create(' blogs', function(Blueprint $table) { $table->increments('id'); $table->string('title'); }); Schema::create('author', function(Blueprint $table) { $table->increments('id'); $table->string('name'); $table->integer('blog_id'); }); Schema::create('comments', function(Blueprint $table) { $table->increments('id'); $table->string('content'); $table->integer('words'); $table->integer('blog_id'); }); Schema::create('subjects', function(Blueprint $table) { $table->increments('id'); $table->string('name'); }); Schema::create('blogs_subjects', function(Blueprint $table) { $table->increments('id'); $table->integer('blog_id'); $table->integer('subject_id'); });

这里使用数据库迁移创建了 5 个表，第一个是文章表（blogs 表），第二个是作者表（authors 表），第 3 个是评论表（comments 表），第 4 个是专题表（subjects 表），第五个是文章与专题关系表（blogs subjects 表）。每个表除了记录相应的内容外，还记录了表之间的关系，这里的关系假设如下：一篇文章只能有一个作者，一个作者只能发表一篇文章，即一对一关系；一篇文章有多条评论，即一对多关系；一篇文章可以在多个专题中，一个专题可以记录多篇文章，即多对多关系。这里涉及到的对应关系分别是一对一关系、一对多关系和多对多关系，其中多对多关系在 blog_subjects 表中进行记录。

（2）根据数据表建立 Eloquent 模型类。

class Blog extends Model {// 以下字段可以被批量赋值 protected $fillable = array ('title'); // 不使用 Laravel 提供的默认时间 public $timestamps = false; // 定义文章模型关系，一篇文章只能有一个作者 public function author () { return $this->hasOne ('App\Author'); } // 一篇文章有多条评论 public function comments () { return $this->hasMany ('App\Comment'); } // 一篇文章可以在多个专题中，一个专题可以包含多篇文章 public function subjects () { return $this->belongsToMany ('App\Subject','blogs_subjects','blog_id', 'subject_id'); } } class Author extends Model {protected $fillable = array ('name', 'blog_id'); // 新的表名，不使用默认 authors 表名 protected $table = 'author'; public $timestamps = false; // 定义关联关系 public function blog () { return $this->belongsTo ('App\Blog'); } } class Comment extends Model {protected $fillable = array ('comment', 'words','blog_id'); public $timestamps = false; public function blog () { return $this->belongsTo ('App\Blog'); } } class Subject extends Model {protected $fillable = array ('name'); public $timestamps = false; public function blogs () { return $this->belongsToMany ('App\Blog', 'blogs_subjects', 'subject_id', 'blog_id'); } }

上文提到，可以使用「php artisan make:model Blog」命令来创建对应的模型类，这里定义了前四个表的模型类，而关系数据表在模型类中用于构建关系，通过 $fillable 定义可以批量赋值内容，批量赋值就是通过模型类的构造函数将数据表中的一行数据一次性赋值，实际上是通过 Model 类的 fill () 函数来完成的，当然也可以通过对模型类的属性依次直接赋值。通过 $table 定义数据表的名称，如果没有定义则会使用默认数据表名。通过 hasOne ()、hasMany ()、belongsTo () 和 belongsToMany () 函数可以定义表间的关系。

（3）为数据表填充数据。

创建数据填充类 BlogSeeder 并继承自 Seeder 类，改写 run () 方法。需要注意的是，在执行 artisan 命令时，实际上执行的是 Laravel 默认数据填充文件 DatabaseSeeder.php 中的 run () 方法，需要在该方法的 call () 方法中添加创建的填充文件，即添加代码「$this->call (BlogSeeder::class);」。

文件 laravel\database\seeds\ BlogSeeder.php <?php use App\Blog; use App\Author; use App\Comment; use App\Subject; use Illuminate\Database\Seeder; use Illuminate\Database\Eloquent\Model; class BlogSeeder extends Seeder { public function run () {// 清空所有表数据 DB::table ('blogs')->delete (); DB::table ('author')->delete (); DB::table ('comments')->delete (); DB::table ('subjects')->delete (); DB::table ('blogs_subjects')->delete (); // 填充 blogs 表，创建三篇文章 $php = Blog::create (array ( 'title' => 'PHP 的未来 ' )); $java = Blog::create (array ( 'title' => 'Java 的未来 ' )); $html5 = Blog::create (array ( 'title' => 'HTML5 的未来 ' )); // 命令行文字提示 $this->command->info ('The blogs are seeded!'); // 填充 author 表 Author::create (array ( 'name' => 'PHP 的作者 ', 'blog_id' => $php->id )); Author::create (array ( 'name' => 'Java 的作者 ', 'blog_id' => $java->id )); Author::create (array ( 'name' => 'HTML5 的作者 ', 'blog_id' => $html5->id )); // 填充 comments 表 Comment::create (array ( 'content' => 'PHP 多用于服务器程序编写 ', 'words' => 13, 'blog_id' => $php->id )); Comment::create (array ( 'content' => 'PHP 是无类型编程语言 ', 'words' => 11, 'blog_id' => $php->id )); // 填充 subjects 表 $language = Subject::create (array ( 'name'=> ' 计算机语言 ', )); $program = Subject::create (array ( 'name'=> ' 编程语言 ', )); // 关联 blogs 与 subjects $php->subjects ()->attach ($language->id); $php->subjects ()->attach ($program->id); $java->subjects ()->attach ($language->id); $java->subjects ()->attach ($program->id); $html5->subjects ()->attach ($language->id); } }

这里在文件数据表（blogs 表）中添加三篇文章，题目（title 字段）分别为「PHP 的未来」、「Java 的未来」和「HTML5 的未来」，为了简化文章没有添加内容。在作者表（author 表）中添加了三个作者，分别是「PHP 的作者」、「Java 的作者」和「HTML5 的作者」，记录在 name 字段中，同时在 blog_id 字段记录发表的文章 id 号。在评论表（comments 表）中添加两条评论，都是对「PHP 的未来」文章的评论，即在 blog_id 字段中记录了该文章在数据表中的 id 号。在专题表（subjects 表）中添加两个专题，分别是「计算机语言」和「编程语言」，其中 PHP 和 Java 既属于计算机语言也属于编程语言，而 HTML5 只属于计算机语言。对于上面的实例可能有些与实际不符，这里只是假设这样。

2．CRUD 操作的实现

前面已经完成了数据表的建立、模型类的创建和数据库中数据的填充，接下来将实现数据库的简单操作。这里对数据库的操作不仅包括数据的增加、删除、修改和查询，还包括对数据表间关系的查询。下面给出具体实例代码。

（1）在 blogs 数据表中增加新数据。

1) 通过 create () 函数以批量赋值的方式实现数据添加。

Blog::create (array ('title'=> 'Python 的未来 ' ));

2) 通过属性赋值和 save () 方法实现数据添加。

$blog= new Blog; $blog->title= 'Ruby 的未来 '; $bear->save (); // 增加数据

3) 通过 firstOrCreate () 或 firstOrNew () 方法增加数据，这两个函数首先查询相关记录，如果不存在才会去创建。

// 查询或创建记录 Blog::firstOrCreate (array ('title' => 'JavaScript 的未来 ')); // 查找并生成实例 $blog = Blog::firstOrNew (array ('title' => 'CSS3 的未来 ')); $blog->save ();

需要注意的是，虽然 firstOrCreate () 和 firstOrNew () 两个方法都是查询数据，如果不存在就创建新的记录，但在创建新记录时还是存在差别的，firstOrCreate () 方法是创建数据模型实例并存入数据库，而 firstOrNew () 方法只创建了数据模型实例，还没有添加进数据库，需要再执行一次 save () 函数，才能实现数据的增加。

（2）查询相应数据表中的数据。

1) 获得所有记录。

$blogs = Blog::all();

2) 通过 id 查询数据。

$blog = Blog::find(1);

3) 通过指定字段名查询数据。

$blog = Blog::where ('title', '=', 'PHP 的未来 ')->first ();

4) 查询字数大于 10 个的评论数据。

$commentss = Comment::where('words', '>', 10)->get();

5) 查询字数大于 10 个小于 15 个的评论数据。

$commentss = Comment::whereRaw(「words>10 or words<15」)->get();

（3）更新数据表中的记录。

1）通过 Eloquent ORM 更新一条记录首先要查询到它，然后更改数据模型实例的属性，最后调用 save () 方法完成数据更新。

// 将内容为「PHP 是无类型编程语言」的评论修改为「PHP 变量名以 $ 开头」，并将评 // 论字数由 11 变为 10 // 先查询到它 $comment = Comment::where ('content', '=', ' PHP 是无类型编程语言 ')->first (); // 修改属性 $ comment ->content ="PHP 变量名以 $ 开头"; $comment->words = 10; // 保存 $comment->save ();

2）通过 update () 函数实现模型更新。

$affectedRows = Comment::where ('content', '=', 'PHP 是无类型编程语言 ')->update (array ('content' => 'PHP 变量名以 $ 开头 '));

（4）删除数据表中的记录。

删除记录可以通过 delete () 方法或 destroy () 方法实现，其中 delete () 方法为实例方法，需要查询到相应的数据并通过模型实例调用，而 destroy () 方法可以直接调用，通过索引删除记录。

1) 通过 delete () 方法删除记录。

// 查找并删除记录 $blog = Blog::find (6); $blog->delete (); // 删除字数多余 10 个的评论 Comment::where ('words', '>', 10)->delete ();

2) 通过 destroy () 方法删除记录。

// 删除 id 为 7 的单条记录 Blog::destroy (7); // 删除 id 为 1、2、3 的三条记录 Blog::destroy (1, 2, 3);

3．数据表间关系的查询

在实际项目开发中，很多数据表都不是孤立存在的，而是与其他数据表存在一定的关系，如一对一关系、一对多关系和多对多关系，而 Eloquent 可以根据定义直接进行关系查询，获取与本数据表相关联的数据。

（1）一对一关系查询。

在上述数据表中，文章表中的数据与作者的关系为一对一关系，下面通过文章字段查找作者的相关数据信息。实例代码如下：

// 查找标题为「PHP 的未来」的文章 $php= Blog::where ('title', '=', 'PHP 的未来 ')->first (); //「PHP 的未来」的作者 $auth = $php->author; // 作者的名字 $auth->name; // 也可以使用更快捷的方法来获得作者的名字 $auname = $php->author->name; echo "文章「PHP 的未来」的作者:".$auname.'</br>'; 输出结果： 文章「PHP 的未来」的作者：PHP 的作者

对于数据表的关系查询，首先要在模型类中定义相应的关系，如在 Blog 模型类中通过 author ()、comments () 和 subjects () 函数分别定义一对一、一对多和多对多关系，当查询到数据表中的一条数据时，该数据被封装在一个模型类实例中，于是可以通过属性的形式来查询对应关系的数据，即通过代码「$php->author」查询作者的信息。

（2）一对多关系。

在上述例子中，文章和评论是一对多的关系，如标题为「PHP 的未来」的文章有两条评论，内容分别是「PHP 多用于服务器程序编写」和「PHP 是无类型编程语言」。下面给出一对多关系查询的实例代码：

// 找到标题为「PHP 的未来」的文章 $php = Blog::where ('title', '=', 'PHP 的未来 ')->first (); // 获取该文章的评论并输出 foreach ($php->comments as $comment) echo $comment->content ．' ' ．$comment->words.'</br>'; 输出结果： PHP 多用于服务器程序编写 13 PHP 是无类型编程语言 11

（3）多对多关系。

在上述实例中，文章和专题是多对多关系，一篇文章可以属于多个专题，一个专题可以拥有多篇文章。这里简单地假设两个专题，分别是计算机语言和编程语言，其中标题为「PHP 的未来」、「Java 的未来」和「HTML5 的未来」都属于计算机语言专题，而只有「PHP 的未来」和「Java 的未来」属于编程语言专题。下面给出多对多关系查询的实例代码：

// 查找标题为「PHP 的未来」的文章 $blog = Blog::where ('title', '=', 'PHP 的未来 ')->first (); // 查看该文章属于的专题 echo "文章「PHP 的未来」属于专题：</br>"; foreach ($blog->subjects as $subject){echo $subject->name.'</br>'; } // 查找名称为「编程语言」的专题 $program = Subject::where ('name', '=', ' 编程语言 ')->first (); // 查找属于「编程语言」专题的文章 echo "专题「编程语言」包含文章：</br>"; foreach ($program ->blogs as $blog){echo $blog->title.'</br>'; } 输出结果： 文章「PHP 的未来」属于专题： 计算机语言 编程语言 专题「编程语言」包含文章： PHP 的未来 Java 的未来

Laravel 框架中关于 Eloquent ORM 的内容很多，因为篇幅原因无法全部详细介绍，这里只介绍了部分使用方法及实现的原理，如果需要了解更多可以查看源码和官方文档。

本章从 PHP 对数据库扩展开始，重点介绍了 Laravel 框架中查询构造器和 EloquentORM 的底层实现。数据对于一个应用就像心脏对于人一样能够为整个应用带来活力，其性能的好坏直接决定了应用程序的性能，而很多情况下数据库的性能是受不当的增加、删除、修改和查询影响的，所以在使用这些模块带来便利的同时，也需要深入地了解底层的实现，否则可能会设计出功能齐全、性能低下的应用。就拿 ORM 来说，ORM 映射最大的好处是将数据表的结构映射成一个类对象，那么就可以将数据以对象的形式进行封装使用，程序的编写将变得高效而且结构清晰，但是 ORM 映射的使用有时也存在困难，对于单个数据表来说问题不大，但是对于多个表而且表间存在不同的关系时，采用 ORM 映射查询就需要注意了，如果使用不好会严重影响程序的性能，这就需要开发人员将底层的实现机制了解清楚，在进行数据库操作的时候哪些操作会严重影响性能要有认识，这样才能搭建出一个高性能的应用。