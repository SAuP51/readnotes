重读《重构》，呼唤匠艺（译者序）

透明

2019-03-17 08:49:43

        

2009 年，在为《重构》第一版的中译本再版整理译稿时，我已经隐约察觉行业中对「重构」这个概念的矛盾张力。一方面，在这个「VUCA」（易变、不确定、复杂、模糊）横行的年代，有能力调整系统的内部结构，使其更具长期生命力，这是一个令人神往的期许。另一方面，重构的扎实工夫要学起来、做起来，颇不是件轻松的事，且不说详尽到近乎琐碎的重构手法，光是单元测试一事，怕是已有九成同行无法企及。结果，「重构」渐渐成了一块漂亮的招牌，大家都愿意挂上这个名号，可实际上干的却多是「刀劈斧砍」的勾当。

如今又是十年过去，只从国内的情况而论，「重构」概念的表里分离，大有愈演愈烈之势。随着当年的一线技术人员纷纷走上领导岗位，他们乐于将「重构」这块漂亮招牌用在更宽泛的环境下，例如系统架构、乃至组织结构，都可以「重构」一下。然而基本功的欠缺，却也一路如影随形。当年在对象中的刀劈斧砍，如今被照搬到了架构、组织的调整。于是「重构」的痛苦回忆又一遍遍重演，甚而程度更深、影响更广、为害更烈。

此时转头看 Martin Fowler 时隔将近廿载后终于付梓的《重构》第二版，我不禁感叹于他对「微末功夫」的执着。在此书尚未成型之前，我和当时 ThoughtWorks 的同事们曾有很多猜测，猜 Fowler 先生是否会在第二版中拔高层次，多谈谈设计乃至架构级别的重构手法，甚或跟随「敏捷组织」、「精益企业」的风潮谈谈组织重构，也未为不可。孰料成书令我们跌破眼镜，Fowler 先生不仅没有拔高，反而把工夫做得更扎实了。

对比前后两版的重构列表，可以发现：第二版收录的重构手法在用途上更加内聚，在操作上更加连贯，更重视重构手法之间的组合运用。第一版中占了整章篇幅的「大型重构」，在第二版中全数删去。一些较为复杂的重构手法，例如

复制「被监视数据」

、

塑造模板函数

等，第二版也不再收录。而第二版中新增的重构手法，则多是

提炼变量

、

移动语句

、

拆分循环

、

拆分变量

这样更加细致而微的操作。这些新增的手法看似简单，但直指大规模遗留代码中最常见的重构难点，正好补上了第一版中阙漏的细节。这一变化，正反映出 Fowler 先生对于重构一事一贯的态度：千里之行积于跬步，越是面对复杂多变的外部环境，越是要做好基本功、迈出扎实步。

坏味道、测试先行、行为保持的变更动作，是重构的基本功。在《重构》第二版里，重构手法的细节被再度打磨，重构过程比之第一版愈发流畅。细细品味重构手法中的前后步骤，琢磨作者是如何做到行为保持，这是能启发读者举一反三的读书法。举

保持对象完整

重构手法为例，第一版中的做法是在原本函数上新添参数；而第二版的做法则是先新建一个空函数，在其中做完想要的调整之后，再整体替换原本函数。两相对比，无疑是新的做法更加可控、出错时测试失败的范围更小。

无独有偶，我在 ThoughtWorks 时的同事王健在开展大型的架构重构时，总结了重构的「十六字心法」，恰与

保持对象完整

重构手法在第二版中这个新的做法暗合。这十六字心法如是说：

旧的不变新的创建一步切换旧的再见

从这个视角品味一个个重构巨细靡遗的做法，读者大概能感受到重构与「刀劈斧砍」之间最根本的分歧。在很多重构（例如最常用的

改变函数声明

）的做法中，Fowler 先生会引入「很快就会再次修改甚至删除」的临时元素。假如只看起止状态，这些变更过程中的临时元素似乎是浪费：为何不直接一步到位改变到完善的结果状态呢？然而这些临时元素所代表的，是对变更过程（而非只是结果）的设计。缺乏对过程的精心设计与必要投入，只抱着对结果的美好憧憬提刀上阵，遇到困难就靠「奋斗精神」和加班解决，这种「刀劈斧砍」不止发生在缺乏审慎的「重构」现场，又何尝不是我们这个行业的缩影？

是以，重构这门技艺、以及 Fowler 先生撰写《重构》的态度，代表的是软件开发的匠艺 —— 对「正确的做事方式」的重视。在一个浮躁之风日盛的行业中，很多人会强调「只看结果」，轻视做事的过程与方式。然而对于软件开发的专业人士而言，如果忽视了过程与方式，也就等于放弃了我们自己的立身之本。Fowler 先生近廿载对这本书、对重构手法的精心打磨，给了我们一个榜样：一个对匠艺上心的专业人士，日积月累对过程与方式的重视，是能有所成就的。

十七年前，我以菜鸟之身读到《重构》，深受其中蕴涵的工匠精神感召，在 Fowler 先生与侯捷老师帮助下，完成了本书第一版的翻译工作。如今再译本书第二版，来自 ThoughtWorks 的青年才俊林从羽君主动请缨与我搭档合译，我亦将此视为匠艺传承的一桩美事。新一代程序员中，关注新工具、新框架、新商业模式者伙矣，关注面向对象、TDD、重构之类基本功者寥寥。林君年纪虽轻，却能平心静气磨砺技艺，对基本功学而时习，颇有老派工匠之风。当年藉由翻译《重构》一书，我从 Fowler 先生、侯捷老师身上学到他们的工匠精神，十余年来时时践行自勉。如今新一代软件工匠的代表人物林君接手此书，必会令工匠精神传承光大。

据说古时高僧有偈云：「时时勤拂拭，勿使惹尘埃」。代码当如是，专业人士的技艺亦当如是。与《重构》的诸位读者共勉。

      

软件工程的江湖

云水

2009-11-30 11:03:04

纵览武侠江湖，制胜法门不外两项，内功和外功。二者得一可天下去得，但最终皆入内外兼修之境

倚天是自内而外，先修内功九阳真经，然后以此为基础，加上太极拳和太极剑，最终成就天下第一高手

笑傲是自外而内，先学独孤九剑，后学吸星大法，最后学易筋经。

神雕也不外如是，玉女心经算是外功，内功则是独孤求败之法门。

只修内不修外，好比万贯家财而不知用，张无忌也要得传太极方可天下去得。

只修外不修内，终是一场空。令狐冲身怀独孤九剑，在义救向问天时几乎丢掉性命。

软件工程的自动化测试和设计模式，近似武侠世界的内功和外功

自动化测试好比内功，没有自动化测试为根基，每做一次修改，都可能引发不可思议错误，若没有自动化测试，最终进入无测试死循环。

设计模式好比外功，重构的方法好比剑招，剑招固然重要，但更重要的是知道什么时候用什么剑招，心中无招，信手挥洒，皆是模式。

内里明心见性，心如磐石，护体神功，自动化测试；

外求格物致知，游刃有余，独孤九剑，设计模式。

而 <重构> 好比五岳剑谱，是独孤九剑之基础功夫，令狐冲是在思过崖看到五岳剑派的剑谱和破法，然后发了疑情，然后才接受独孤九剑的思想并最终继承之，而练成之后，随心所欲，五岳剑谱的剑招还是常用的，所以讲独孤九剑与五岳剑谱只是外功的不同阶段而已。

学会了五岳剑谱，才能更好地领会独孤九剑，学会了独孤九剑，才能更好地把握什么时候用什么剑招。

《重构》->《设计模式》

超越重构思想

Apollo

2008-05-06 07:42:40

书中说过重构的思想由来已久，只不过没人写成书籍罢了。

个人感觉如果你看完这本书只看到了思想，那你就错过了很多有价值的东西。小步骤的重构，如何最大限度的不引入 bug 才是书中要告诉大家的。像了解重构思想，只看前几章就够了。我个人认为书中最有价值的东西恰恰是进行重构时不起眼小步骤。嘿嘿，小弟的个人观点。

有几个问题

KP

2006-08-31 14:09:55

整体通俗易懂，翻译过程有些小错，不知道有没有勘误表

(1) 184 页下面范例跳了好几步

(2) 187 页范例，数组说三个元素，代码只列出两个，"失败场次" 没有了，

(3) 282 页，的代码 sentAlert () 函数好像有问题，变成递归了.

(4) 306 页，Raname Method 明显是印刷错误了.

《重构》的重构

你猜你猜我是谁

2019-03-19 22:33:14

        

我虽有第一版，但是买来后一直束之高阁，原因有很多，譬如是用 Java 写的啦（是的我对 Java 有偏见）、被人借过啦，不一而足。直到听说第二版要出版后，而且是用 JavaScript 写的，我才猛地惊了：难道又要重复当年我买完 CSAPP 第二版以后又买本第三版的悲剧（第三版是 64 位操作系统，第二版是 32 位）？

惊是惊完了，没有进展，书依旧没读。直到异步社区搞活动，第二版的迷你版奉上，一百页左右，到手就哗哗哗看完了 —— 才发现这本书是多么易读。

先说作者，作者曾经也是写 Java 的，后来貌似不喜欢 Java 了（正常人都会这样吧），先是跟人合著了本 Ruby 版的重构，然后 —— 又应上了那个说法：所有能用 JavaScript 写的东西终将用 JavaScript 写成。这本关于重构的书，终于用 JavaScript 做了重构。当我在书里看到 Object.assign、Lodash 和箭头函数时，我的内心感到了快乐。尤其是小步重构到后来，函数体里都转成箭头函数和 lambda 表达式，hmm，真香。

这个迷你版的第一二章都是完整的，到后面具体到重构细节就只是摘录，不过还比较连贯，不影响理解。不知道是谁选出来的迷你版，蛮妙啊。

书的第一章从一个例子开始，一步步地重构，看得人如痴如醉 —— 这可不是玩笑，重构的精妙能将人完全代入。而且这个例子，也随着时代的变迁进行了场景修改，第一版是用的影碟出租屋的例子，但是现在基本上很少有人租碟了，所以改成了剧场看剧，嗯很时髦，也算是一种「重构」吧。

书里对重构这个词进行了阐释：重构！== 更改，尤其是不等于影响函数正常工作的更改。在作者的概念体系里，重构是小步的、不影响函数行为的迭代式更改，嗯，跟敏捷的概念有点像。重构跟性能优化很像：都是修改代码且不影响行为。但前者是为了理解、便于修改；后者是为了性能而改。

关于重构和加新功能的配合，作者把它们比喻成两顶帽子 —— 你戴或者不戴，什么时候戴，都随你，但是你要清楚自己戴着哪一顶帽子。

重构的时机，在书中看来，应该是不得不重构时：譬如添加新功能前，重构能让修改更容易；帮助自己理解代码时，重构能让代码更易懂；捡垃圾时，重构可以改掉屎一样的代码（你懂的）。

同样，也有不需要重构的时候：比如这段代码凌乱但是跟我无关、也不需要修改或是在某个隐藏得很好的 API 下。又或者重写更容易，那就重写吧。

另外，关于变量命名的经验：作者喜欢把所有返回值变量命名成 result，学到了 —— 这样能一眼就知道变量的作用。以及，因为 JavaScript 是动态类型语言，所以作者喜欢在变量命名里加类型，尤其是加入不定冠词，比如 aPerformance。

Anyway，重构不是银弹。我认为重构是需要在对代码的业务逻辑、对系统的边界、以及前人的意图都有所理解的基础上才能做的事情。依然记得刚入职时跟着同事们一起 pair programming，看着他们一步步地把代码重构时那种爽感。相信这也是一本常看常新的书啦。再多说一句：完整的测试用例才是重构的关键前提。以及，如之前看的《程序员的呐喊》里说的那样，如果你的 team 里都是天才程序员，管他什么重构不重构的，哈哈哈哈。

可惜大部分 team 都是由像我这样的庸人组成 :)  最好还是每个人会一些重构让世界更美好吧。

      

重构，感动

来，见证奇迹！

2019-03-20 11:13:07

        

《重构》第二版来了！

很高兴有机会能够提前阅读这本神奇的书籍！很多年前就已经阅读过第一版《重构》！那时候就给我很大的冲击！说实话，开始并没有对这一版抱有太大的希望！但是当翻开书卷的那一刻，我还是很庆幸没有因为自己的执念而放弃掉这样一本真心重构了的好书！

可以说，新版的《重构》绝不仅仅是使用新的语言或者是更好的纸张重新印刷了一遍！而是作者对于自己认知和理念的再一次升华的分享！对于我这个老读者而言，感受到的是满满的诚意！

时代是进步的，新的开发诉求，新的理念，而这本书也很好的跟上了这些变化！用更好的角度，更优秀的理念打动了我！

至于书的内容，我不想提前剧透！如果你足够幸运，你会读到这本书，相信你会体会到自己的升华！

感谢作者，感谢 2019 年能有这样让我感动的一本好书！

      

程序员的工具书

Austin

2006-03-13 16:15:58

这本书一开始读的是英文，不过 Martin Fowler 本身好像就不是一个 Native 的英语国家的人。所以他的英文写的也是比较容易懂的。

这个书第一章是一个完整的重构的例子，虽然现实中不可能如此完美而孜孜不倦的重构，不过作为一个例子，是非常的好的，让你能为重构的力量所震撼。

之后就是一些重构的方法，Martin 将这个方法一一归类，其实他只是起到一个总结的作用，但是这样的总结也是一种开创性的工作。从另一个书《设计模式》也可以得到证明（这书也是总结了对象设计的 23 中常用模式，而现在俨然已经成为经典中的经典）。

所以，我觉得也不用看得很仔细，只要知道有这么多重构的方法，然后用的时候翻翻就可以了，所以我说它是一个工具书。

如何在不完全理解代码和缺乏测试的情况下重构

Sean

2012-08-13 13:38:08

组里最主要的 Service 已经运行了几年了，目前大约有 40000 行代码，不少部分缺乏 Unit Tests。每次看代码的时候都有一种想重构的冲动。

不过什么时候才重构呢？经理那里是不好交差的 —— 他们关心的是新功能的实现速度。有的时候重写反而（对程序员）的发展更好，因为工作量明显的可以看到。所以重构不过是谁都不愿意做的脏活累活，能拖就拖。

于是就有了一个难题：代码不容易理解，所以才想重构；可不理解又如何重构呢？等自己理解了又懒得重构了，先把手头的任务做完再说吧，重构就留给下一个人吧。

我认为《重构 —— 改善既有代码的设计》的贡献就在于教你如何在不完全理解代码的情况下安全的修改代码。

一次和经理讨论到了重构，他说重构要在有完善的测试情况下才能安全的进行。可是眼前的代码测试 Coverage 不到 20%，而且因为正是代码的设计导致其难以测试，这种情况下该怎么办呢？是先努力写测试，然后再重构，还是先重构，然后在测试呢？我觉得可以采用书中提到的已经验证是安全的重构方法先进行重构，重构和加测试交替进行。

非常好的一本书，重构（第 2 版）王者归来！

姓名学会

2019-03-20 10:59:46

        

谢谢异步社区让我有幸读到重构（第 2 版）这本书，距离上一版本已经过了 20 年这次的版本使用的是

JavaScript 语言描述

。

什么叫重构

本书对它名词的定义是对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。它的目的是使得软件更容易被理解和修改。重构不会改变软件可观察的行为即重构之后软件功能一如既往。

为何重构重构是个工具，它可以 (并且应该) 为了以下数个目的而被运用：1. 重构改进软件设计。如果没有重构，程序的设计会逐渐腐败变质.2. 重构使用软件更易被理解.3. 重构助你找到 bugs.4. 重构助你提高编程速度.

重构可以改进软件的设计，代码结构的流失是累积性的，越难看出代码所代表的设计意图就越难保护其中设计，于是该设计就腐败的越快，经常性的重构可以帮助代码维持自己该有的形态。在重构的过程中深入理解代码不仅能揪出 bug 还能提高代码的可阅读性从而提高编程效率。

何时重构 1. 三次法则：第一次做某件事时只管去做；第二次做类似问题的事会产生反感，但无论如何还是做了；第三次再做类似的事，你就应该重构.2. 如果你发现自己需要为程序添加一个特性，而代码结构使你无法很方便地那么做，那就先重构那个程序，使特性的添加比较容易进行，然后再添加特性。同时注意：重构之前，首先检查自己是否有一套可靠的测试机制。这些测试必须有自我检验能力.3. 修补错误时进行重构.4. 复审代码时进行重构. （完）

      

经典之作，再续前缘

xdlkc

2019-03-20 11:22:05

        

最近在对自己负责的项目进行大规模重构及微服务升级，正好赶上了《重构》这本经典之作的升级，第一版其实就已经拜读过，现实很多程序员都比较浮躁，关注新技术，新领域，像作者这样一直给我们灌输如何写好代码的思想更值得我们学习及吸收；在阅读第二版样章时感受最深刻的一点是，重构老代码时其中遇到的所有坏代码的表现基本都被作者所提到，让我不得不佩服大牛的编程功底及编程思想；另一方面自己本身是写 JAVA 的，所以在读第一版可能在代码层面感触更深，但是相比第一版，第二版在原有的基础上一方面换成较为通用的 JavaScript 语言，另一方面多了目前编程领域一些新东西，尤其是最近热度比较高的函数式编程领域。无论是哪个版本都是经典之作，也都是想要提升整体编程能力的必读之作。我推荐阅读本书最好的时机就是边重构边学习，了解作者如何分辨坏代码，以及如何让很多人动都不敢动的「死代码」重换新生。

      

五星推荐

清风迅来

2019-03-20 11:53:43

        

曾经一直想买一本《重构》第 1 版，然后就没有然后了？

没想到 18 年后，《重构》居然出了第 2 版。

最近读了《重构》第 2 版的迷你书，给我的感受是：

这本书不仅可以视为重构的参考指南，也提供了大量编程技巧和程序示例有助于写出更好的程序；而且作者的文风很有趣，自己读这本书时不会「《重构》从入门到入睡」。

一、先说说自己的经历

。

在一家创业公司从事前端开发 6 年了，这个过程中大半时间忙于堆砌业务代码，新项目一个接一个，虽然经历了前端技术栈的不断更迭，但回顾过去 6 年，发现自己陷入了某种「低水平勤奋」：看似不断在学习新技术，但是对于本身代码质量没有「刻意练习」，而是一直停留在舒适区。

同样，项目也很少会进行重构，更多的只是技术栈的迭代更替（jQuery -> requirejs -> Vue ->  React）而忽略了代码本身的质量。又由于经常项目都是个人独立完成，缺少与他人的协作，问题一直在堆积，越积越多却不自知。

二、再说说这本书。

a) 首先这本书在结构上很用心，

本书的第 1 章节，为了让读者对重构有更直观的认识（以及避免读者从入门到入睡），并非先 Talk 一大堆历史、原理，而是直接 Show you the code，通过一个示例说起，先让读者对重构过程有一点点感觉，随后再在后续的章节介绍相关原理。

而如果你是一个看书习惯先看前言的读者，那么可以在前言了解该如何有效阅读这本书：前言中详细地标注了以下问题应该阅读哪些章节：重构是什么（What） 、为什么应该重构（Why）、在什么地方重构（Where），以及如何重构（How）。

本书最后还附有「坏味道与重构手法速查表」帮助读者寻找灵感

b) 其次，这本书在细节上很用心，

1. 书中经常会邂逅一些奇怪的东西

这里施展的不全是标准的封装变量 (132) 手法，我刻意为设值函数取了一个又丑又长、容易搜索的名字，因为我有意不让它在这次重构中活得太久。

这里的「

封装变量（132）

」实际对应着这个重构手法在书中的页数，虽然看起来有点奇怪，但大大方便了读者去查阅相关内容。

2. 书中偶尔会邂逅一些幽默的句子

除了上面那句「

有意不让它在这次重构中活得太久

」，还有一些感受一下：（顺便给译者们打 call）

问题在于，当我努力让程序运转的时候，我不会想到未来出现的那个开发者。是的，我们应该改变一下开发节奏，让代码变得更易于理解。重构可以帮我让代码更易读。

…… ……

关于这一点，我没必要表现得多么无私。很多时候那个未来的开发者就是我自己。

3 书中会有和第 1 版重构对比之处

诸如：

7.1 封装记录 (Encapsulate Record)

曾用名：以数据类取代记录 (Replace Record with Data Class)

c) 最后，内容上也很用心，

《重构》第 2 版，作为重构指南在重构示例中，不仅告知了该如何重构，也深入分析了

为何要这样重构

。

更重要的几乎每一步都有详细的说明，并且每一个重构步骤都很小，非常具体，而不会出现下面的情况…… 非常照顾读者的阅读体验；而资深架构师则可以有选择性地阅读。

怎样画马

三、最后，一句话总结

这本书可以视作

一位随时在线的编程 & 重构导师

。

附一张简单整理的思维导图～

《重构》第 2 版迷你书，思维导图整理 by 清风迅来

      

让重构成为一种代码习惯

瞧不 shi，，,

2019-03-12 11:23:43

        

无论你是初出江湖的编码小农，还是深耕多年的程序大牛，这本书都值得你深度品读。

常常我们说的代码简洁性、易读性、健壮性，都并非一日之功，需要在日常的迭代中不断持续的进行重构，重构的事情我们常常挂在嘴边，却往往无从下手，本书以作者丰富的编程经验和思想，总结了一套非常实用的重构的基本方法与准则，让你更好的理解重构的思想精髓，找到适合自身以及团队的代码整洁之道！

      

20 年后经典升级，更适合当下

真实

2019-03-20 10:34:56

        

重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。20 多年前，正是《重构：改善既有代码的设计》第 1 版的出版，使重构终于从编程高手们的小圈子走出，成为众多普通程序员日常开发工作中不可或缺的一部分。如今，Martin Fowler 的《重构：改善既有代码的设计》一书已经成为全球有经验的程序员手中的利器，既可用来改善既有代码的设计、提升软件的可维护性，又可用于使既有代码更易理解、焕发出新的活力。

这本备受关注的第 2 版在第 1 版的基础上做了全面修订

，反映了编程领域业已发生的许多变化。第 2 版中介绍的重构列表更加内聚，并用 JavaScript 语言重写了代码范例。此外，第 2 版中还新增了与函数式编程相关的重构范例，旨在教会读者如何在没有类的环境下开展重构。

新版沿袭了第 1 版的结构，依次解释什么是重构，为什么要重构，如何通过「坏味道」识别出需要重构的代码，以及如何在实践中成功实施重构（无论用的是什么编程语言）。

这些变化很细微，但是涉及到方方面面。变化细微是因为书的基本结构没有改变。书的开篇是一个开放式的例子、一个章节的原则、一个「代码坏味道」的调查和一个测试的介绍。这本书的主体仍然是重构，原来有 68 个重构示例，作者保留了其中 10 个，新增了 17 个。

虽然书的整体结构变化不大，但是文字的变化却很多。

每一个章节和重构示例都几乎是从零开始重写，作者几乎没有复制粘贴旧版中的文字。

针对内容更新，作者 Martin Fowler 曾说：」新版重新调整重心，将重点更少地放在类上。虽然这听起来可能就像将「提取方法」的名称更改为「提取函数」一样简单，但它确实需要重新思考每个重构的所有方面。我需要重新考虑动机，经常需要重新设计。至少结构需要详细审查，通常都需要完全重写。对此我没有做详细的记录，但我觉得引用一个相对简单的旧的重构，就要重新考虑两个重构。「

强力推荐。

      

《重构》(第 2 版) 书评～（迷你书读者）

Frank_Jia

2019-03-13 15:56:19

        

《重构第二版》书评

我非常开心能够通过异步社区发送的迷你书成为了《重构》第二版的首批读者，当我收到来自异步社区刘鑫同学的邮件之后就开始了阅读，几天时间读完了前 6 章，有一些感悟和大家分享。

有一句非常古老的工程谚语「如果它还可以运行，那就不要动它。」，但是正如 Martin 在前言里所写的那样，遵循这样的建议，这个项目在 6 个月后最终走向了失败。我目前还在高校中研究软件工程理论，和工业界看待工程问题的角度不同，学术界更关心软件工程高层抽象的问题，换句话说学术界不关系某个特定场景下的解决方案，而关心能够顶层的设计，因此在学术界研究软件工程和软件架构更多的是思考如何「更好」或者「更优美」地进行设计，而在最近一年的时间里面，我们的课题组走访了近 20 个向微服务架构迁移的软件研发公司，他们的现状就是：需要保证在业务不会受到影响的情况下实现重构，一个不是非常严谨的比喻就是「在高速公路上为汽车换轮胎」，业务高速发展不能停滞，而如果不及时重构软件系统，那么最终将会像 Martin 在书中描述的一样，最终「代码太复杂，无法调试，也无法将性能调优到可接受的水平」。因此，重构是一门软件艺术。

此外，在《重构》的第二版中，第三章 代码的坏味道，也就是 Bad Smell，这正是目前对于架构进行评估的所需要的各个关键点所在。《重构》的第二版不仅仅是对于第一版的修改和完善，Martin 几乎完全重写了这本书，在文中也不乏直接与第一版的《重构》进行对比的部分，对于老读者而言，也能够找到新的亮点。

总结而言，Martin 的这本《重构》第二版值得我们用时间和精力去品读和学习。

      

很值得看的一本书

Arthur.Li

2019-03-20 11:02:26

        

重构第一版在家睡了有一年多了，说实话对于这样一本好书自己没有认真读完非常感到惭愧。

好在前几天突然看到重构第 2 版发布了，还是原作者还是原来的翻译。很有幸成为第一批中文版读者，

获得的迷你版电子书，不到一百页。

看着也没有那么累，很喜欢里面用 js 语言作为例子，里面的过长函

数、全局数据、冗余元素等等平时遇到的问题都有提到。不过有一点体验不太好就是可能是电子书着急

发布第一版的缘故，有的代码排版看着有点乱，纸质书应该可以。很建议大家读一读。

      

更推荐 Clean Code

飞林沙

2010-10-10 11:56:20

无容置疑，这是一本经典的书，正如推荐所说，是这本书让重构这个看似高深莫测的话题走进了寻常程序员的世界。

可是我们不得不注意这本书的出版日期，是七八年前，和设计模式一样，当年的设计模式那是高手的工具，开口闭口带那么一两句，工厂，单例，会让人对你崇拜至死。可是现在开口闭口不说出点中介者，访问者，你都不好意思说你学过 Java，学过 C#。

同样，随着时代的变迁，这本书的很多观点早已被人们所潜移默化的接受。而且书中所提供的很多解决办法也早已被现在的 IDE，被现在的类库，语法（例如扩展方法）变得有些过时。

所以我在看这本书的时候我并没有详细去看他的做法，而是主要看他的动机和目的，此外略看一下他的范例，我觉得这就足够了。

如果 MF 能够在现在重出一本《重构》，我想我一定会马上买下来。

此书需要放在桌旁，反复阅读！

是想法而非技巧

Alex.C

2008-04-08 09:58:54

《重构》给我最大的收获，其实是想法而非技巧。

开发人员的完美主义倾向，容易变成他们做 Big Design Up Front 的驱动力。而在现实的环境中，时间、资源等约束条件，通常不会允许我们进行过于详细的设计。

我认为最好的做法是，轻量级的设计 + 适当的重构，迭代地开发出满足各种约束条件的产品。

重构也是 art

元创

2006-05-21 19:59:38

重构是设计，设计是 art, 重构也是 art.

一个函数三行只是语不惊人死不休的说法，是对成百上千行代码的矫枉过正。

更一个般的看法是一个函数应该写在一页纸内。但举一个上百行的极端例子也是可能的。比如某种数值计算。

重构的意义应该在 XP 的背景下看，如果没有重构，XP 的方法从逻辑上就不完整，这才是它的最重要意义。

当然，代码作为设计，写得像英语一样，其中的例子的确让人印象深刻。而且对我非常有影响，现在我也程序时，需要写注释时，我总是先找一找是不是有用代码代替注释的办法。

完美主义者的书

archer

2010-11-01 11:25:31

我觉得这本书吧，技巧性十足，但实用性不够。为什么呢？因为他的解决方法是建立在你知道问题出在哪里的基础上，但往往我们的难点在于不知道问题具体在哪里。

这本书适合学习，学习一些好的设计方法，以便将来什么时候来用。我买这本书的时候，正好在重构一个比较大的项目，但读了几天与我的项目严重脱钩。

重构不光在于重构代码、重构类，还需要考虑重构功能、重构交互、重构接口，这本书指导不了什么。

另外，这本书中追求的完美解决方法，我宁可一步一步来改进达到这个效果。

总之内容太细，我读了不到 1/3 就没有再继续读下去。一些比较泛泛的经验分享非常少。嗯适合什么人读呢？正在学习设计模式的人吧

<重构 改善既有代码的设计 第 2 版> 读后的个人感受

Leo

2019-03-12 17:16:13

        

首先感谢异步社区，有缘读到由异步社区发起的《重构 改善既有代码的设计 第 2 版 》。让在来聊聊我对《重构》的感情。在我开发的 8 年时间里 Martin Fowler 的《重构》从 2015 年开始就一直陪着我，是我工位上的一本常用的工具书，指导书。使我在技术上和思维上得到提升。每一次读都有不一样的感受。在每一次的系统代码根据公司业务需要更改的时候我就会想起 Martin Fowler 老师的《重构》。

Martin Fowler 在 1.3 章节中说道「每当我要进行重构的时候，第一个步骤永远相同：那就是我得确保即将修改的代码拥有一组可靠的测试。而这些测试必不可少，因为尽管遵循重构手法可以使我避免绝大多数引入 Bug 情形。」

然后问自己，何谓重构？为何重构？何时重构？现在重构会给现在的系统造成的利弊？就像我去写一个功能的时候，刚开始没有去做封装，用到一个地方就要去写一次，我在好多地方用到了都要去写，当我抽取出来封装成函数，我在要用的地方直接去调取它，这样的重构帮我提高了编程速度和提高了代码的质量。但在重构的过程中我也是快乐与挑战，快乐是以后开发和读代码更加舒服，挑战是重构不是一件简单的事情，需要去做好各项准备因为像作者提到「重构过程中有一二两时间不可用」。

重构是很多价值的工具，但只有重构还不行。重构前，先检查自己是否有一套可靠的测试机制。这些测试必须有自我检验的能力，毕竟重构可能破坏掉一些东西，我们要靠测试帮助我们发现这些问题，不要因为测试无法捕捉所有 bug 就不写测试，因为测试的确可以捕捉到大多数 bug。不过，说来惭愧，我在写 php 项目的时候写测试用例写的比较少，但在 Java 项目上写的还可以。

所以我经过 Martin Fowler 的《重构》和自己的一点小总结，像函数过长、参数过多、类过大、修改一个小功能，要对多个类进行修改、switch 语句等这样的我就考虑需要重构。当我在 Review 代码、修改 Bug、增加新功能的时候来重构。而我最基本的重构方法是细化方法，更小颗粒度、方法移动到别的类、抽象出新的类、内部类。

我个人力荐的技术书籍之一 Martin Fowler 的《重构》，它可以说是我作为程序员进阶的秘籍，何况它是已经由时间证明过的重要著作《重构》的新版上市。

      

要重构，但是不能过度重构。

楠

2008-11-01 15:07:43

也许是因为我主要用 c 编程，但是我也学过 Delphi,Java,Python 和 Ruby 这些面向对象。

看过这本书的感觉就是，重构的思想没错，现在软件越来越追求迭代式的开发。一开始很难写出完美的代码，就是要不断的改进。

但是我对作者的一些重构方法还是不赞成。那怕最简单的语句也要抽象成函数来注释。也许现在电脑速度的提升让人不追求效率了。

但是我在嵌入式上开发是绝对不能忍受的。

现在的电脑程序变得越来越慢，以后可能就会发现，瓶颈不是某两个点慢，而是一点点累积。一个系统假如核心部分 1 万次不同函数调用，每个函数慢 0.01 秒就已经超过用户体验所能容忍的程度。

而且我认为有时简单的赋值语句比函数更能说明问题。

要重构，但是不能过度重构。

      

了解重构

Twitch

2019-03-15 12:41:43

        

什么是重构？

所谓重构 (refactoring) 是这样一个过程：在不改变代码外在行为的前提下，对 代码做出修改，以改进程序的内部结构。重构是一种经千锤百炼形成的有条不紊的程 序整理方法，可以最大限度地减小整理过程中引入错误的概率。本质上说，重构就是 在代码写好之后改进它的设计。

重构精髓

重构的每个步骤都很简单，甚至显得有些过于简单：只需要把某个字段从一个类移到另一个类，把某些代码从一个函数 拉出来构成另一个函数，或是在继承体系中把某些代码推上推下就行了。但是，聚沙 成塔，这些小小的修改累积起来就可以根本改善设计质量。这和一般常见的「软件会 慢慢腐烂」的观点恰恰反。

重构过程带来的收益：

有了重构以后，工作的平衡点开始发生变化。我发现设计不是在一开始完成的，而是在整个开发过程中逐渐浮现出来。在系统构筑过程中，我学会了如何不断改进设 计。这个「构筑 - 设计」的反复互动，可以让一个程序在开发过程中持续保有良好的设计

      

Hi, 重构 （迷你书读者）

CJ

2019-03-15 13:01:35

        

重构，认识你很高兴！

惨痛的教训：

认识你之前，维护已有的代码，我坚信只要代码能够正确运行，测试不提 bug, 能不动原代码尽可能的不动原代码。结果，

原项目越来越庞大，越来越臃肿，漫天飞舞着各种无效，重复的代码

，这还是一个好的消息，坏的消息是，我发现一个错误的时候，我不得不去查找整个项目中是否还存在一样的代码。对此我乐此不疲。

认识你之前，我一直认为重构很鸡肋的，因为我觉得重构就是对整个工程重新设计，代码完全重写，这就意味着前人的努力都是白费，公司前期的投入都打水漂了，总而言之就是工程量大，费时，成本高。尽管如此，以往的开发中，我也会尽可能的推动项目进行我所谓的重构。结果，虽不再有各种无效与重复的代码，但是 bug 层出不穷，如雨后春笋，灭了一茬又一茬，

不过是将一堆已知的 bug 换成了一堆未知的 bug 。

拨云见月：

认识你之后，你成功的改变了我固有的思想，让我明白重构并不是将代码完全重写，并不是用一堆未知的  bug 去换一堆已知的 bug。是从一个变量开始到一个函数再到一个类，一步一个脚印，逐步的让代码变得优雅，变得容易维护。

重构是可控的，可靠的，以尽可能小的投入换取大的回报。

《重构》 第 2 版，

也真正做到了开篇所讲「谈理论很容易流于泛泛，又很难说明如何实际运用，给出一个实例，就可以帮我把很多事情认识清楚」。《重构》大量简单明确的实例剖析，让重构不再处于云端，那么高深莫测，触不可即，js 语音的使用，照顾了尽可能多的编程者，更加明确了

重构是接地气的，是真实的。

最后，非常感谢异步社区，感谢刘鑫同学，让我认识了 《重构》。

      

重构就像画油画，需不断的修改打磨

taichirain

2019-03-20 01:36:32

        

《重构》这本经典之作终于在时隔二十年之后，迎来了第二版。有幸拿到了异步社区的精简预览版 (共 125 页)，读完之后，感叹作者马丁·福勒 (Martin Fowler) 一方面是 "重构" 技术的倡导者，另一方面也是身体力行践行 "重构" 这么技艺的大师。

第二版有几个明显的变化：

1、书中的示例代码语言由 Java 换成了大家更为熟悉的 JavaScript，可以让更多的读者能够轻松的阅读。

2、增加了一些颗粒度更小的重构手法，操作也更细腻。

这些变化的目的，是让这本书更容易理解。代码的重构与书一样，是为了让代码结构更清晰，更易读 (主要是指人的读)，也更容易扩展。用作者的话说就是：

任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员

。

学习一门技术、一个手艺，我们要把握两点：概念、规则。

首先我们了解一下重构（refactoring）的定义：

在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。重构是一种经千锤百炼形成的有条不紊的程序整理方法，可以最大限度地减小整理过程中引入错误的概率。本质上说，重构就是在代码写好之后改进它的设计。

作为一名程序员，内心深处都有一个理想（幻想）：如果某一天，有一个需求描述清晰、逻辑严密、文档完善，即使修改需求也是经过反复验证过的；开发时架构设计非常优良，能很方便的扩展新的功能，而且没有任何（极少）bug….

当然，这仅仅是一个理想的状态，现实中谁也没碰到过（据能查到的公开资料来看，是这样的）。

现实世界，「VUCA」（

易变、不确定、复杂、模糊

）横行，需求的不明确比比皆是，刚开始设计良好的架构，慢慢的变得杂乱无章，在某个角落里，甚至是充满着腐臭（代码的坏味道）。

这个时候怎么办？大部分人 / 公司的选择是，反正已经这个样子了，也不是我造成的，能将就着用就先用着吧，等到有时间再重构吧。可是这一天总是等不来，也没有人去实施重构，甚至不出问题也不会去测试。直到某一天负责这个项目的负责人实在忍受不了，跟开发团队说我们重构这套系统吧，给一个月的时间。于是开发人员加班加点的开始 "重构" 这套系统，然而由于基本功的欠缺，做出修改的时候过于乐观，没有测试、没有认真考虑行为保持的修改过程，痛苦回忆又一遍遍重演。最后，这套系统不堪重负，开发团队选择了重写。。。

这一幕在国内的公司中经常上演，如果解决上述问题？《重构》这本书给出了答案。

它的核心思想就是：

在代码写好之后改进它的设计

。哪怕手上有一个糟糕的设计，甚至是一堆混乱的代码，我们也可以借由重构将它加工成设计良好的代码。重构的每个步骤都很简单，甚至显 得有些过于简单：只需要把某个字段从一个类移到另一个类，把某些代码从一个函数 拉出来构成另一个函数，或是在继承体系中把某些代码推上推下就行了。但是，聚沙 成塔，这些小小的修改累积起来就可以根本改善设计质量。这和一般常见的「软件会慢慢腐烂」的观点恰恰相反。

甚至来说，大多数系统的设计，都是经历不断的迭代：设计 - 构筑 - 再设计，就像油画一样，反复的修改，才最后输出了成型的作品。

这本书篇幅不短（大概 400 多页），但是不要被吓到，作者在引言里也明确的说了，认真阅读完前四章，就可以选择性的开始动手重构代码，其他章节大可作为一个速查手册，遇到问题时再去查都来得及。

怎么能修改而又不造成破坏呢？第一是要测试先行，第二是识别代码的坏味道，第三要有靠谱的修改方法（保证每一步的修改后，程序仍能正常工作），是重构的基本功。

第一章，详细描述了一个小程序的重构过程：测试先行、修改命名、去除临时变量、提炼函数、内联函数、封装变量、拆分….

如果看过第一版的《重构》，会感觉很亲切，功能逻辑类似，优化了小程序的背景，让年轻的读者更容易理解；把使用的 Java 语言换成了 Javascript；使用了更细腻的手法，颗粒度很小，比如：如果要重构一个函数，首先建立一个空中间函数，等重构完成再删除旧的函数。

第二章，重构的原则，什么是重构、为什么要重构、什么时间重构、重构的挑战、重构与性能、自动化重构...

使用重构技术开发软件时的两顶帽子：添加新功能和重构。添加新功能的时候，就只管添加新的功能，然后对新功能进行测试，让其正常运行。重构时就不要添加新的功能点了，专注于调节代码结构。

不要等到非重构不可的时候，才去重构，而是一旦嗅到了代码中有 "坏味道"，就要开始重构的工作，这样会使你的整个开发过程变得更为顺畅，重构及测试也花不了太多时间，也许就是 10 分钟、8 分钟；尽量不要划出专门的时间做以小时为单位的重构，那样的重构也很难进行。

第三章，很著名的 "代码的坏味道"，可以作为践行重构过程中的一个行动指南（清单）

第四章，构筑测试体系

无论何时开始重构，第一个步骤永远是：确保即将修改的代码拥有一组可靠的测试。因此，构筑一套可靠的测试体系非常重要。

第五章以后就是这本书的核心 — 重构名录，书中给出了 60 多个可行的重构，每个重构都介绍了种经过验证的代码变换手法的动机和技术。

…...

      

强烈推荐！

墨水

2019-03-20 13:19:15

        

异步社区搞活动，发送了电子版的迷你书到邮箱，粗看了三遍，很不错！作为一个学习计算机专业的老人，虽然工作多年，但也只是写写 SQL 提个数据而已，只是人肉运维，去年公司号召大家转型，报名去学习了开发，感觉大家热火朝天的开发，只是想着做个漂亮的界面而已，其实，软件的灵魂还是算法，架构，这部书正好合适！这段时间做一个小小的项目（把提交书评的时间也记成今晚了，：（  ），感觉好多都是平时没有注意的点，学习的路还很漫长，代码还需要不停的重构！强烈推荐这书！

      

减少代码坏味道

清风

2005-08-23 23:07:38

重构，让我们的代码变得更顺畅，提高软件复用性。本书中提供了多种重构的手法，让我们的代码减少更多的坏味道。而且提供了很多重构工具的说明，以用来更好的帮助我们工作。

最后引用 Fred George 的一句话：一个 task 分配 2-4 小时，每个方法最多 3 行代码

coding guideline

bluebit

2008-04-20 12:45:33

        After coding,should read this to refector,

and before begin coding , should read this to avoid code bad smell.

Writing good code is like wrtiting goode article ,the spell、grammer、structure all affect quality.

Code is for machine to execute,and also need change、improve、read by others，it has a long life time then you think.

So good code is for you and others a better life.

      

重构可以帮你写出更好的代码

Wuqifu

2011-11-05 23:00:01

《重构》是一本简单实用的好书，每个靠写代码领工资的软件工程师都应该读一读。运用重构技术可以帮你写出更好的代码 —–这会让你和你同事在阅读、修改代码时轻松很多。

大学毕业后我用 vim + C 语言工作一年多，Visual Studio + C++ 工作两年半，现在用 Eclipse + Java 工作了一年半。我的感觉是 Java 较之 C++ 可以更快地写出更好的代码，这其中的原因自然有很多。在我看来 Eclipse 自带的 Refactoring 工具在其中功不可没，它让代码重构变得轻松有趣、一键搞定。没装 Visual Assistant 的 Visual Studio 连提取个函数都得手工把代码拷来拷去，乏味无趣。谁说 IDE 不重要？工欲善其事必先利其器，好的工具绝对让你事半功倍！

本书写作于 1999 年，用的 JDK 版本是 1.1，彼时 Eclipse 还没有诞生，代码重构时的做法还是一步一步按部就班地手工修改代码。现在 Eclipse 中的 Refactoring 菜单下已经集成了书中提到的众多常用重构手法，应该是从本书得到了不少借鉴。

附 Refactoring 菜单：

Rename Alt + Shift + R 

Move Alt + Shift + V 

Change Method Signature Alt + Shift + C 

Extract Method Alt + Shift + M 

Extract Local Variable Alt + Shift + L 

Inline Alt + Shift + I 

Extract Constant 

Convert Anonymous Class to Nested 

Move Type to New File 

Convert Local Variable to Field 

Extract Superclass 

Extract Interface 

Use Supertype Where Possible 

Push Down 

Pull Up 

Extract Class 

Introduce Parameter Object 

Introduce Indirection 

Introduce Factory 

Introduce Parameter 

Encapsulate Field 

以上所有的重构操作都可以 Ctrl + Z 一键撤销

以下是读书笔记：

第一章 重构，第一个案例

JUnit：测试在重构中非常重要，我们需要依赖测试检查是否引入新 bug。

SVN、单元测试、回归测试

小幅重构、及时测试，易于发现错误

自动化重构工具：Eclipse

代码应该表现自己的目的，变量名称是代码清晰的关键

唯有写出人类容易理解的代码，才是优秀的程序员

重构手法：

Extract Method 

Move Method 

委托 (delegate)

保留旧函数，让它内部调用新函数 (向后兼容）

Replace Temp with Query 

Query Method（可以加入 cache 机制）

运用多态 (polymorphism) 代替 switch 语句

Replace Type Code with State/Strategy 

Replace Conditional with Polymorphism

第二章 重构原则

1，所谓程序设计就是与计算机交谈，所以编程的核心就是『准确地说出你的意思』。

2，利用重构来帮助理解不熟悉的代码，重构是理解软件设计的最快方式。

3，『我不是个伟大的程序员：我只是有着很多好习惯的优秀程序员而已』

4，事不过三，过则重构。

5，每次提交代码前都找人 Code review。

6，间接层的价值：

允许逻辑共享（Pull up method, Pull up field）

分离「意图」与「实现」

封装变化

将条件逻辑加以编码 (多态)

7，哪怕你完全了解系统，也请使用性能测量工具来测试它的性能，不要臆测。(Benchmark)

第三章 代码的坏味道

1, Duplicated Code（重复的代码）

Extract Method, Pull up Method, Template Method 模式

2, Long Method（过长函数）

Rename Method; Extract Method; 

3, Large Class（过大类）

Extract Class; Extract SubClass; Extract Interface; 

4, Long Parameter List（过长参数列表）

Replace Parameter With Method; Introduce Parameter Object 

5, Divergent Change（发散式变化）

找出所有同一原因引起变化，运用 Extract Class 将它们提炼到另一个 Class 中

6, Shotgun Surgery（霰弹式修改）

运用 Move Field, Move Method 将所有需要修改的代码放进同一个类。

7, Feature Envy（依恋情结）

将总是一起变化的东西放一起。高内聚、低耦合。

8, Data Clumps（数据泥团）

Introduce Parameter Object; Preserve Whole Object 

9, Primitive Obsession（基本类型偏执）

Replace Data Value with Object; Replace Type Code with Subclass; Replace Type code with State/Strategy 

10, Switch Statements（switch 语句）

多态；Replace Type Code with Subclass; Replace Type Code with State/Strategy; Replace Conditional with Polymorphism; Introduce Null Object

11, Parallel Inheritance Hierarchies（平行继承体系）

Move Method; Move Field 

12, Lazy Class 

Inline Class; Collapse Hierarchy 

13, Speculative Generality（夸夸其谈未来性）

如果用不到，就不要去做。

14, Temporary Field 

Introduce Null Object 

15, Message Chains（过度耦合的消息链）

16, Middle Man（中间转手人）

Remove Middle Man; Inline Method 

17, Inappropriate Intimacy（狎昵关系）

高内聚、低耦合；Move Method; Move Field; Replace Inheritance with Delegation

18, Alternative Classes with Different Interfaces（异曲同工类）

Move Method; Extract Superclass 

19, Incomplete Library Class（不完美的程序类库）

Introduce Foreign Method; Introduce Local Extension 

20, Data Class（纯数据类）

Encapsulate Field 

21, Refused Bequest（被拒绝的馈赠）

Push Down Method; Push Down Field 

22, Comments（过多的注释）

Extract Method; Rename Method; Introduce Assertion

第四章 构筑测试体系

1，重构的前提是要有一套可靠的测试环境.(单元测试、回归测试、集成测试)

2，Class 应该包含它们自己的测试代码.

确保所有测试都完全自动化，让它们自己检查测试结果。

3，频繁运行测试，极限编程 XP。

4，测试你最担心出错的部分；考虑可能出错边界条件。

5，使用工具。(IDE, JUnit, PowerMock…)

第五章 重构名录

1，介绍重构手法时采用的标准格式：

> 名称 (name)

> 概要 (summary)

> 动机 (motivation)

> 做法 (mechanics)

> 范例 (examples)

2，重构技巧：小步前进，频繁测试。

第六章 重新组织你的函数

1，Extract Method（提取函数）

用函数的意图给它命名。

2，Inline Method，Inline Temp 

去掉无用的间接层

3，Replace Temp with Query； Introduce Explaining Variable 

4，Split Temporary Variable 

一个变量只承担一个责任

5，Remove Assignments to Parameters (不要对函数参数赋值)

在 pass by value 传值方式中，对函数参数的任何修改，都不会对调用端产生任何影响。Java 只使用 pass by value.(函数指针)

6，Replace Method with Method Object 

7，Substitute Algorithm（替换你的算法）

优先使用标准库 (STL, Collection 集合包，Apache Libs)

第七章 在对象间搬移特性

1，Move Method，Move Field 

2，Extract Class，Inline Class 

Single Responsibility Principal 

3，Hide Delegate，Remove Middle Man 

4，Introduce Local Extension 

运用 subclass 或是 wrapper 添加原始类的功能 (Is-A, Has-A)

第八章 重新组织数据

1，Self Encapsulate Field（自封装值域）

get/set 方法

2，Replace Data Value with Object（以对象取代数据值）

3，Change Value to Reference（将实值对象改为引用对象）

Change Reference to Value（将引用对象改为实值对象）

4，Replace Magic Number with Symbolic Constant 

以有意义的符号常量取代 magic number，提升可读性

5，Replace Type Code with Class（以类取代型别码）

Replace Type Code with State/Strategy（以 State/Strategy 取代型别码）

State 模式，Strategy 模式，Factory Method 模式

6，Replace Subclass with Fields（以值域取代子类）

创建子类的动机：添加新特性 (field)，改变行为 (method)

第九章 简化表达式

1，Decompose Conditional 分解条件式

2，Consolidate Conditional Expression 合并条件式

Consolidate Duplicate Conditional Fragments 合并重复条件代码片段

3，Remove Control Flag 

以 break 语句或 return 语句取代控制标记

4，Replace Nested Conditional with Guard Clauses 以卫语句取代嵌套表达式

卫语句要么从函数中返回，要么抛出一个异常

5，Replace Conditional with Polymorphism 以多态取代条件式

6，Introduce Null Object 引入 Null 对象

将 null 值替换为 Null Object。Example：Collections.emptyList () ;

7，Introduce Assertion 引入断言

assert 用来确认一定为真的先决条件

在交流上，断言帮助理解假设条件

在调试上，断言帮助找出 bug

第十章 简化函数调用

1，Rename Method 重新命名函数

函数名称应准确表达意图。

2，Add Parameter 添加参数

Remove Parameter 移除参数

3，Separate Query fromModifier 将查询函数与修改函数相分离

一个函数只做一件事。Exception：使用 cache 提高查询速度

4，Parameterize Method 令函数携带参数

Replace Parameter with Explicit Methods 以明确函数取代参数

StringUtils.isEmpty(string);  StringUtils.isNotEmpty(string); 

5，Preserve Whole Object 保持对象完整

Introduce Parameter Object 

6，Replace Parameter with Methods 以函数取代参数

7，Remove Setting Method；Hide Method 

8，Replace Constructor with Factory Method 以工厂函数代替构造函数

Factory Method 

9，Replace Error Code with Exception 以异常代替错误码

异常将程序正常逻辑与错误处理分开，使得程序更容易理解。unchecked 异常、checked 异常

10，Replace Exception with Test 以测试代替异常

异常只应用于意料错误之外的行为，不能替代成为条件检查

第十一章 处理概括关系

1，Pull Up Field 值域上移

Pull Up Method 函数上移

Pull Up Constructor Body 构造函数本体上移

Pull Down Method 函数下移

Push Down Field 值域下移

2，Extract Subclass 提炼子类

subclass 只能表现一组变化，delegation 委托可以表现不同变化

3，Extract Superclass 提炼超类

Template Method 模式

4，Extract Interface 提炼接口

Java 单继承多接口

5，Collapse Hierarchy 折叠继承体系

inline class 

6，Replace Inheritance with Delegation 以委托代替继承 Has-A

7，Replace Delegation with Inheritance 以继承取代委托 Is-A

代码雕刻必读

neal.seah

2013-03-08 17:14:54

第一遍于两年前，让我了解到 bad smell 们，还有那冗长的手法 catalog.

最近第二遍，回顾过去，虽然 bad smell 的提示和重构操作已经完全融入现代 IDE 中了，但总结下来它对我的影响还有如下:

1. 我常常通过重构来加深对代码的理解.

2. 让我变成一个十足的代码洁癖者，"刻" 代码上瘾的人在时间宽裕的时候的时间利用率实在堪忧啊。那些大牛总是拿散文家，音乐家，画家比程序员，怎么没有人拿雕刻家来作比呢。我相信我不孤独.

3. 结合 TDD, 她让我意识到：抵达最终满意的代码的最朴素的办法就是：一定要把步子迈的小一点 (尽管我们都知道要摒除 "迈大步" 这种 "陋习" 很难), 这背后包含着的是：不断的切分任务，不断的确认和分析需求，减少获得反馈的代价，不断地从反馈中学习.

软件大师的巨作

wangyangsheng

2019-03-18 15:50:12

        

前端 javascript 语言在二十年前也就网页的脚本语言，二十年后的今天，js 已经是前端、后端、PC 端、移动端都非常流行的语言，书中以 js 来讲解实例确实以时俱进，必能成为一本非常流行的软件巨作，书中实例也涉及到 js 函数式编程的应用重构技巧，和 java 的面向对象编程重构方法相比较，具有新颖独到，耳目一新感觉，很值得学习，总体上，书中的内容覆盖软件在代码层面的优化技巧，面面俱到，从面向对象编程到面向过程的函数式编程，内容精彩绝伦，不槐为大师之作，从多角度、多维度、从点到面、从总体结构到点面局部、从变量到参数、从类到方法、从命名技巧方法抽取都作出全面深刻的阐述，是程序员编程规范的必备参考书！

      

重构（第 2 版）读后感

豆友 193586195

2019-03-18 22:24:54

        

重构二十年，经典升级。

首先，非常荣幸参与重构（第 2 版）迷你书试读活动。作为刚入行新人，刚拿到重构（第 2 版）迷你书时是抱着了解了解心态去读这本书的。试读第一章时发现 范例是用 JavaScript 编写的，由于本人入行学的是 Python，刚开始看 JavaScript 代码确实造成了一些障碍，好在 Martin Fowler 大神所使用的范例都很好理解。这里提一个小小的建议，能否在代码中添加一些必要的中文注释，必要的注释会使我们这些没有学过 JavaScript 的新人在读代码时感觉更友好，也能够更准确的理解范例所表达的意图。

其次，通读之后本人分发现，之前以为本书只适合老司机这种想法是错误的。本书不但适合老司机，也适合新人，对新人编写代码非常有帮助。我做为新人在编写代码时也有代码可读性差的情况，后期功能调整时 BUG 不断。试读本书之后发现本书的核心就是 Martin Fowler 大神的重构思维：「何谓重构、为何重构、何时重构及如何重构」。理解掌握重构思维会使我在编写代码时可读性更高、维护更容易、代码 BUG 更少、测试更简单。

最后，本书内容质量上乘、翻译质量上乘。个人认为本书是程序员人手必备的一本书。强烈推荐！！！

      

刚刚好才是最好

三卅

2007-05-22 10:54:38

我觉得重构只是一种思想趋势，但不是硬杠杠，不能死搬硬套，更不能偏激

代码，是死的；人，是活的

还是一句话，具体情况具体分析

浅尝辄止，取其精华

MrROY

2012-01-06 16:21:54

这本书的价值还是很厚重的.

作者对代码的设计追求非常「过分」，这让我怀疑有些东西是否导致过度设计了。经过一段时间的思考和消化，我觉得作者的是希望把自己遇到的所以设计问题都浓缩在短短的代码中来，把每一个瑕疵都尽量去掉。

但是在正式的项目中，如果我们这样「吹毛求疵」的话，那么项目的周期很容易失控，所以我对本书的建议是，适度重构，不要过分设计。

我们把那些最容易导致问题的设计改掉，把那些方便但是设计可能不那么好的代码留下，等遇到问题的时候在解决，产生「逐步重构」。

重构，可以的！

枫之舞 sky

2019-03-13 21:25:49

        

读过设计模式相关书籍，而后读重构第一版。如今读了重构第二版的精简版的前 7 个章节，依旧收获不小。重构给我的感受绝非高深莫测的技术手段，而是对于编程这件小事儿的感悟。软件项目工程与建筑工程有一个很大的不同点，那就是代码可以重构，程序员可以在不断的迭代中逐渐完善自己的代码。几乎没有程序员能够在一开始就洞穿整个项目的始末，更何况需求是不断变化的，这种不确定性与不可控性迫使我们必须在变化中应对变化。重构给了程序员「改过自新」的机会。Java 多态替代 Switch 语句、提炼函数、内联变量、自己的命名风格、测试驱动、一步一个脚印、、、当你一点点的重构那些具有坏味道的代码时，最后定会有焕然一新的感觉，代码变得愈发通俗易懂、善解人意。作者字里行间流露出的是对编程的热爱与情怀。程序员应该对代码负责。编程之道，亦是生活之道。人生的轨迹也是在不断的重构中谱写，欲速则不达，给生命宽阔的广度去延拓、待人以清新简洁的面貌，让生命的篇章在重构中愈发有好味道！

      

值得一看

fellinlove

2006-03-22 12:22:44

是不是一定要一个方法只有两三行代码就叫好呢？是不是一遇到 switch 就要嗤之以鼻呢，一定要转为 state 模式呢？这中间一定要有效率与灵活性之间的折衷，而作者志不在此，这些应该需要的经验的累积，甚至是只可意会不可言传的。

         

重构

Jelly

2007-02-12 18:55:30

重构对软件设计来说是很重要的，不过过渡使用会出现副作用。目前国内的一些中小软件公司貌似都不很重视这个，尤其是做底层开发的公司，项目一紧张完全是在赶进度，导致日后代码及其难以维护... 唉...

马丁。福勒的 经典之作

billclod

2010-11-23 09:45:24

还是建议有一定代码经验的人去读，这是一本让老程序员能产生共鸣的书。里面很多的方法需要在实践中去体会，顿悟后再应用到实践中。

代码维护和重构实用技巧指南

王实

2011-02-03 11:58:10

利用春节的假期读完的这本书。

上学的时候比较迷恋设计模式，还记得在微软实习的时候自作聪明的给自己写的代码套上了很多模式，结果 mentor 手起刀落，通过简单的继承，接口就把所有模式给干掉了，让我着实汗颜。我想初接触软件设计模式的同学可能最容易犯的就是这类过度设计的错误，以学习为目的多使用设计模式无可厚非，但在实践在不加分析地套模式就是杯具了，很多时候，设计模式只会引入不必要的复杂性。

这本书已经被列入程序员必读书籍，展示了代码维护和重构的技巧，一个特点是全书提到的重构技巧很少涉及复杂的设计模式，实用性很强。此外，作者对于每种重构技巧展示了如何判断是否需要重构，如何重构，并配以实际的代码，可读性非常强。至于缺点，感觉对于一些简单的重构方法花费了过多的篇幅，略显拖沓。

推荐程序员小盆友可以花几天时间快速阅读，去掉代码中的「坏味道」。

思想大于一切

acAric

2015-10-28 14:12:20

可能这本书里面的很多技术已经过时，毕竟他出版了太久，但是从字里行间感受到作为一个程序员，最基本的价值观。

永远追求架构以及设计上的完美，虽然这些对于程序并无可见的好处。

我作为一个从业多年的码农，特别理解这种追求，但是在国内，有太多的行业不能有效的理解这种追求。毕竟，一切以利益为主，而这种比较含混的利益，本身就不在考虑之列。

重构

京墨

2016-03-16 10:41:36

首先需要庆祝一下，历时两个季度，断断续续的把这本书看完了。完整的看完一本书的感觉真好。

这本书一开始讲了代码的坏味道，列举了一些坏味道的表现，如函数体过长，代码重复等等，然后开始介绍一些重构手法，关于命名，表达式，数据，函数，类的手法都有。介绍的比较详细，在读这些手法时，作者也列举了很多例子，基本上每种手法都有相应的例子，还详细的描述的重构的步骤。这点对于不知道如何开始重构的人来说比较好，给了你一个解决问题思维模式，但同时也有一个问题就是，在读的过程读者并没有真正的去思考如果是自己遇到这样的代码该如何去做。所以这本书读起来到时不费劲。

在这本书里，「两顶帽子」的概念让人觉得有趣，重构的时候戴一顶帽子，添加新功能的时候戴另一顶帽子。软件开发的过程就是两顶帽子来回换着戴。重构的时候要求的是不改变代码的原有功能，得小心，安全的重构，需要做一些测试来保证自己的重构不会改变代码原有功能。

作者还提到了自己读博士的研究的方向就是重构，并在毕业之后向同事和其他人推广重构，这个倒是令我感觉挺意外。在今天看来，当然是我个人认为，重构的意识已经深入每个软件开发人员心里。在当时却是一种新奇的思想，作者在各个场合推广自己的思想，为大家讲重构的短期，中长期利益和好处。

在本书的最后还提到了重构工具，以及自动化重构。现在的 IDE 一般都有重构的功能，需要我们去熟悉和使用。

书常读常新，这本书也值得以后常常翻开来看。

以上。

定位比较尴尬的书

Lin

2016-10-08 14:54:01

《重构》这本书我觉得没什么意思。这本书有个矛盾点：对有丰富经验的程序员来说，这本书上面所提到的所谓手法已经是他们日常编程中已经熟练使用的，这本书只是给这些手法命了个名而已，看这本书毫无意义。而对于新手程序员来说，因为你没有一定的代码量，应该是看不懂书上说的那些重构手法的。你只能通过大量实践去学。而一旦经历了大量实践，你会发现这些重构手法不用他教你也会了，那看这本书又有什么用呢？

《重构：改善既有代码的设计》读书笔记

JH_Gao

2016-12-20 10:33:45

写于 2016-12-20 。

早上看完了《重构：改善既有代码的设计》一书。有些失望。或许是这本书面世太久，里面的方法到如今已经成了常识。但总的来说是一本可以快速浏览一遍的书，至少会坚定自己的一个信心：当代码经过自己的手时，它应该变得比之前更好。不要害怕重构，因为重构是一步一步来的，确保步子不太大，确保每一小步的正确性。然后一遍一遍来。花在重构上的时间，从更长的眼光来看，终将会为我们带来更高的开发效率，节省更多的时间。

我觉得重构的最核心理念是三条，一是更好的可读性，二是更合适的抽象，三是可测试性。

每个人都知道，代码更多是用来读而非运行的。可读性良好的代码，是优秀程序的基本要求，这个要求其实不低，尤其是在不对地修改迭代中，保持和改善代码的可读性，并不是那么容易。

我觉得，在可读性之上，建立合适的抽象，这才是程序员应该发挥我们聪明才智的地方。好的抽象能恰到好处地表达出程序的意图，让代码通用、容易扩展维护，同时又不至于抽象得太过导致得不偿失。

良好的设计应该是测试友好的，你能很容易地为一个方法添加单元测试。测试友好的代码天生就是解耦的鲁棒的，而在自动测试上所多花费的每一分钟，长期来看都会以多得多的回报率带来整体开发效率的提升。

《重构》阅读后的感受

陈大侠

2017-03-19 15:25:35

        

我读过几十本关于计算机程序设计的书籍，《重构》是其中对我帮助最大的一本。

如果问《重构》是不是所有计算机编程相关书籍里面最好的一本，那我想这个答案是否定的。像《深入理解计算机系统》，《算法导论》 这样的巨著，书中内容广泛且精深，表达的像是独立的小型世界，功力不够的阅读者，很难把握住它的全貌。因此，觉得这两本书写的好的读者就会把它们当成宝贝，但是也有读者会认为这两本书是一文不值的。对我而言虽然不至于觉得这两本书一文不值 ，但是书中的内容真的没有对我体现出多少价值，因为书里边的知识在我平时的工作中罕有使用的场景。

像我们这些平时画网页、写服务器的程序员，一些高深的计算机基础理论知识基本上对我们起不到任何帮助，我们迫切需要解决的问题是提升工作效率、让程序更加稳定、修改需求时能更加省心、让代码的可维护性提高，而这些问题都不是计算机科学技术领域的问题，而是属于软件工程的范畴，毫不夸张 《重构》这本书便是提升程序员解决这些问题的一本秘籍了。我想每个程序员在职业生崖的某个阶段会被自己代码质量这个问题困扰，比如说当业务一复杂 ，整个程序的逻辑就混乱不堪了，会有理不清剪还乱的那种感觉；当程序的功能要修改时，很难着手修改已经存在的代码功能，而是采用重写的方式去实现；自己写的代码，过了几个星期或者更久以后就不认了；等等这些问题都是降低程序员工作效率和让程序到处是 BUG 的万恶之源。而《重构》这本里面讲解的内容都是针对处理这类问题的，就像抗生素是细菌的天敌，能起到高效的灭杀作用，《重构》一书中的内容对于代码中存在的毛病也能起到同样的效果。

我看过的代码质量改善的书籍可以划分为三种

第一，设计模式类，如《设计模式》《headfirst 设计械》《大话设计模式》

第二，《代码大全》

第三，重构类，如《重构》《重构与模式》等

关于设计模式类的，那是声名在外，其中不乏有一些非常深刻而且有用的代码质量改善的道理，但是其中的大部份知识只能在书上写写，在现实的场景下完全用不到的，我写了这么多年的代码，设计模式还真没用上过几个。当然，学习设计模式有另一个好处，那就是吹牛逼的时候底气能足一点。实际应用的话真的被夸大了。

关于《代码大全》，这本书得确不错，但是书中介绍的内容实在太过于广泛了，这本书大概有 1000 多页，但是对于我而言，真正在工作中能的了帮助的最多也只有三百页左右，所以看《代码大全》这本书着实花了我不少的耐心，而且看完以后也没有那种畅快淋漓的感受，反而很想骂娘： 花了这么久的时候看了这么厚的一部书，居然只有一部份能用的。

看《重构》就不一样了，其中的每一章每一节总能找对自己工作有实际帮助的内容，因为书中讲解的都是一些每个程序员都会碰的到的常见问题，这才能带给阅读者继续阅读下去的动力。我看每一本书，当看到觉得知识点难以理解或者实用性有限的情况下，都会产生一些不耐的情绪，有时候是自己逼自己一定要继续看下去。然而，对于《重构》这本书我从头至尾都没有出现类似的情绪，就像看小说或者连续剧一样，给我带来的只有愉悦的感受，看完之后，我还迫不及待的用书中的知识去练手，我自己的多个项目的代码都按照书中讲解的技巧去优化，而且也能带来非常理想的效果。

我深信《重构》一书中的知识对我职业生崖带来的帮助是无与伦比的，因为已经得到了很好的实践。另外，我觉得没看过《重构》一书的程序员和看过《重构》一书的程序员在技术能力上的差距通过其它方面的知识很难得到弥补，除非他看过其它拥有类似《重构》一书中表达的思想的书籍。

因此，《重构》虽然并不是所有计算机技术类书籍中最优秀的一本书，然而它却是软件工程领域最优秀的一本书，它实用并且通俗易懂，适合每个程序员阅读，里面的技巧也是个每个程序员都能使用的，因为只要有代码的地方书中讲解的技术就有用武之地。

      

Clean code and Refactoring

Footprint

2017-05-08 00:44:49

最近我的团队需要帮助一家基金管理公司进行代码审核，所以把这个重构和 clean code 一并拿来快速重读了一遍。虽说距离这两本书的出版已经过去了将近 10 年，市面上不同种类的框架，开发 IDE 和各种利于重构代码的插件产品日新月异，不过书中介绍的很多明了和重构代码的技巧和因为在开发流程中对此的疏忽所照成的问题却依然值得学习和借鉴。只要在软件开发行业从业过几年的人想必都曾维护过遗留系统，随着新的需求或者系统缺陷的发现，团队往往需要及时的对系统进行迭代修复，这个时候如果遗留系统没有遵循清晰的开发规范，在加上原始的开发团队早已离开，那么这样就会对系统的进一步开发造成很大的困难。在这样一个情况下，扩大团队不但不会帮助解决问题，反而可能会更加缩减团队的效率。可能最后唯一的选择也许是组成新的团队，完全重写。新的团队不仅仅需要完成的新的需求而且要完成遗留系统之前的功能，取决于项目的大小，这个过程可能花费几个月甚至几年，抛开本身项目的风险不谈，这更是一种时间与资源的浪费。倘若新的团队由于预算和时间上的压力而同样忽视了遗留系统之中的问题，那么新的系统很快又会成为遗留系统，重演这之前发生的错误。

那么怎么才能在团队中增强这些理念呢？ 书中提出很多案例，结合自身在国外公司的一些经历，总结一下有几点。

1 良好的自动化测试。随着新的需求的到来，对原有系统的重构往往是难免的，这时候只有良好的测试覆盖，那么在对原有的代码的修改才会更加有保障。

2 团队达成基本的开发准则及一些重构工具的使用。无论是完成一个新的功能或者是修复一个系统漏洞，程序员花在读代码的时间要远远高于写。小在一个变量的命名，大到一个程序的架构，如果没有遵循一个基本的准则，那么随着系统复杂度的增长和团队人员的扩大，效率就难免变得低下。

3 团队内部可以采取结对编程，内部代码评审等方式来进一步保证项目的质量，而且有利于团队内部技术交流，团队的建设和开发流程的进一步完善。

4 持续集成和持续发布。这样不仅能极大的提高团队的工作效率，更能及时的提供反馈。

总之，书中的很多案例相信对大多软件从业人员都不陌生，甚至真是经历过，那么就更加值得人重视并且避免同样的错误。

重构：一项常常被忽略的基本功

王亮👨🏻‍💻

2019-06-04 09:22:06

        

讲真，我不是在本书上架的第一时间就入手的（你个假粉丝）。本月初的时候朋友和我说《重构》出第 2 版了，我才兴冲冲地下单，花了一个礼拜时间一口气把它读完后，才有了这篇书评。掩卷沉思，我无比赞同豆瓣网友「天心一」的评论：

这本书虽然很流行，但是应该看它而没有看的人，还是太多太多了。

一个老读者的自白

作为一个开发者，2012 年初识本书的时候，我在写 Java；2019 年本书再版，我在写 JavaScript。真是应了那句老话儿：「凡是可以用 JavaScript 来写的应用，最终都会用 JavaScript 来写。」

JavaScript 特别适合重构，因为它很容易写的无法维护。

当然这只是个玩笑，实际上作者也解释过：重构背后的理念和架构适用于任何编程语言，选择 JavaScript 只是因为它应用的比较广泛。无论使用哪种编程语言都可以写出优秀的或者糟糕的代码，同样也都可以以本书的思路和技巧进行重构。

使用 JavaScript 展示代码范例，并不意味这本书中介绍的技巧只适用于 JavaScript。

对比新旧两版，作者「重构」了这本书：前几章有所扩展，后几章结构调整较大，移除了原来的 12-14 章。总的来说，重构后的第 2 版更接地气、更适应时代：不再有「大型重构」，更多地聚焦操作的细节。

「Fowler 先生不仅没有拔高，反而把功夫做得更扎实了。」—— 摘自译者序

虽然本书的副标题是「改善既有代码的设计」，但通读全书之后，我觉得这本书对于设计新系统时如何避免「坏味道」也是很有指导意义的。

重构和敏捷开发是一对亲兄弟

提重构就不能不提敏捷开发，马丁·福勒本身就是敏捷开发的发起者之一。敏捷作为「当红炸子鸡」，与重构有着很多相似的地方。

一是，这两者都容易成为「挂羊头，卖狗肉」中的「羊头」，很多情况下，所谓的重构就是抽出时间来重写现有的几乎无法维护的代码，就如同很多「敏捷」只做到了「不拒绝需求变更」而没有真正做到响应变化；二是，它们实现起来都是一定难度且它们的实践过程可以是交叉的 —— 它们都着眼于具体细节而不是空架子，都欢迎变化，都强调小步快走、持续改进；三是，敏捷开发很重要的两个环节就是设计与重构，两者相辅相成，彼此互补，在实践的过程中保持较强的适应力。

重构的技巧

可以说，我在重构过程中遇到的问题大多都能在本书中找到答案。

我们看看作者对重构的定义：

** 重构（名词）：** 对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。

** 重构（动词）：** 使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

为何重构、如何重构、重构的原则与手法，都可以在这本书中找到。从第 5 章起作者提供了多达 300 页的重构名录、60 余项重构的具体技巧（老版本是 70 多项，新版本移除了大规模项目的重构）。我觉得这一份非常详尽的重构手法清单更接近于字典，适合粗读之后在用到的时候再具体查阅。

至于什么时候能够用到这份名录，作者在第 3 章也有介绍：当代码有了「坏味道」就可以着手进行重构了。所谓「坏味道」，我认为并非是一程不变的准则，而是需要根据团队、项目、采用的技术栈等各方面综合得出的一种无法定量描述的经验。所以，作者用了「味道」这样一种体验来代指需要重构的地方。在作者列出的每种「坏味道」中，都给出了对应的重构手法。虽然作者罗列的 20 多种「坏味道」覆盖面很广，但是你和你的团队仍然可以总结出自己的经验来指导重构。实际上，与第 1 版相比，第 2 版中的「坏味道」增加了「神秘命名」「全局数据」「循环语句」，删除了「不完美的库类」。

我认为本书最重要也最容易被忽略的章节就是第 4 章 ——

构筑测试体系

。在第 4 章中，作者通过一个生产计划的示例一步一步的构建了一个完整的单元测试体系。显然，掌握单元测试是有一定成本的，这就导致有些开发者（尤其是前端领域）完全不注重单元测试。他们认为测试是 QA 的职责，自己只需要保证冒烟测试通过即可。然而反直觉的是，良好的单元测试不但是重构的先决条件和好帮手，而且能帮我们整理设计的思路，从而更好的写出优秀的代码。因为在写单元测试的时候，我们会假设自己是一个「代码破坏者」，思考如何破坏代码的运行、寻找那些可能出错的边界条件。单元测试的编写和运行可以在写完代码后进行，也可以在写代码之前动手。先写单元测试再写代码的技巧叫作测试驱动开发（TDD），也是敏捷开发的基石之一。关于 TDD 的技艺，作者的好友 Kent Beck 专门写了一本书，即《测试驱动开发》。

作者在第 1 章的示例中提到：

「小步快走，代码永远处于可工作状态。」而且作者特意强调：「每当我要进行重构的时候，第一个步骤永远相同：我得确保即将修改的代码拥有一组可靠的测试。」

对于单元测试，我有一点小小的心得可以与大家分享：** 尽量编写纯函数。** 纯函数是没有副作用的函数，给出同样的参数值，纯函数总是返回同样的结果，它不依赖于参数以外的值。显然，纯函数更便于单元测试。

当然单元测试也不是万能的，它不可能检出所有的 bug，而且单元测试集的覆盖率也是一个见仁见智的指标，具体需要写多少单元测试，覆盖多少代码，都是需要我们在开发中结合实际情况自己权衡的。无论如何，单元测试一直是一中非常重要却常常被忽视的技能。

另外，我在开发实践中坚持一个「432」的原则，供大家参考：

一个类包括注释代码不要超过 400 行；

一个纯函数最好不要超过 30 行；

函数内循环嵌套最多 2 层。

重构的现状

有些朋友对「重构」是不支持甚至是深恶痛绝的。

一部分开发者不愿意把精力「浪费」在重构上

他们觉得重构是「给飞行中的飞机修引擎」，有可能出现很多问题却带不来多少拿得出手的成绩；重构总是会在「不经意间」破坏原有功能，带来的麻烦很多，投入与收益完全不成比例，也很少会是面试的重点，花精力在这上面实在是费力不讨好。

许多 leader 反对盲目重构

在创业公司里基本不会有重构的呼声，原因无须赘言；而在一些大企业里，leader 们也不是都喜欢重构，因为花时间重构意味着占用了开发新功能的时间，在代码还能跑起来甚至看起来跑得还不错的时候去重构无疑是画蛇添足；与重构带来的风险相比，重构带来的好处就不是那么有说服力了。

大部分 QA 对重构持谨慎的质疑态度

代码的变动意味着需要进行回归测试，而敏捷当道的时代，每个迭代中 QA 的关注重点都在新功能上，能够分配给回归测试的精力很有限，而在测试通过后的重构极有可能导致此次变更对 QA 不透明，无形中增加了上线的风险。

我认为以上几种反对重构的场景都是不恰当的重构导致的。

大家只是越来越接纳「重构」这个词，因为这个词听起来很好，有一种积极应对变化的感觉，但真正在做的还是跟以前一样，毫无规矩的修改。

在实践中，重构的要求是很高的：它需要有足够详尽的单元测试，需要有持续集成的环境，需要随时随地在「小步伐地永远让代码处于可工作状态」下去进行改善。正是因为许多项目的「重构」是在并不满足以上条件也没有经过成本估算、策略规划的情况下进行的，自然很容易导致失败。

水土不服

实际上，还有一部分开发者虽然认识到了重构是提升代码质量的有效手段，是诸如「在当下努力工作，以免日后有更多的活儿」此类观念的具现。然而在某种程度上说，这在当前 996.icu 大环境下是不适用的。关于这一点就只能见仁见智、自己衡量了。

没有银弹

最后，我想说一句：

没有银弹

。

重构和设计模式一样，是对于最佳实践的提炼，是一系列技巧的集合，它不是打通任督二脉的灵丹妙药。如果你是一个有追求但却从来没有系统地了解过重构的程序员（当然我不相信世界上会有这种程序员），那你会发现，你在日常工作中不经意间已经用过了这本书中提到的各种重构手法。

重构是注重实践的技艺，仅仅了解其理念而忽视实践则有如抟沙作饭，白费心思；而企图把它当做「万金油」来解决所有问题也只会陷入不恰当重构的陷阱，最终得不偿失。只有在合适的场景下恰当的实践，才会实现其应有的价值。

      

重构是程序员的基本素质

天心一

2007-09-01 16:58:59

第一次看有网友极力推荐这本书，就买了一本英文的来看，一下子就被吸引住了。

原来觉得编码可以天马行空，总想看看那些高手是怎么写代码的，现在觉得自己好像也是高手了，至少可以看得出哪些代码好，哪些代码差。真是感谢 Martin Flower。

现在自己做项目经理了，对于新来的有一些必需的要求，就是要懂得「重构」，不过很遗憾，刚毕业的或者工作了一两年的大学生们基本上不知道「重构」是什么意思，也不知道如何下手。

这本书虽然很流行，但是应该看他而没有看的人，还是太多太多了。

如人一样，我们的代码也终将死去，但现在，代码往往牺牲得太快了，一个项目一完，代码们也就完了。罪魁祸首，是我们的程序员。因为他们的代码，无法重用，因为他们很少做一件事情，重构！

重构是程序员的基本素质，否则，项目的代价太大了，不良代码满目皆是，像一个垃圾堆，但是制造垃圾的人还很牛气的认为自己是 IT 人士，会用 C++，Java 和很多让人听不懂的名词，很拽的。

所以，现在要加入我的项目的人，需要一项基本的素质 —— 重构。如果你不会，那么你来看看这本书，我相信，很短的几天，就足够了。

目前在读英文原版，不知道阿能坚持下去

卫星

2010-12-09 11:32:51

适合写过两年代码的开发人员的一本书。

示范代码难度不是很高，主要就是理解里面的一种精神了。

我才看了一章，希望能坚持看完。

      

重构是一种思想

IPLinger

2006-03-13 22:09:43

重构是个好的思想，第一次读此书是在大学里，张忠强介绍给我。后来在大学做项目的时候，每每遇到困难难以进行的时候，我就开始重构我的代码。现在到了公司，以 C 语言为主要开发语言，我同样在运用着重构的思想在工作，这次添加新功能完全是一边重构一边完成下来的。重构在我看来是一种思想或方法论，对于面向过程的 C 语言，找到合适的方法，同样适用。是不是有时间了，总结一下 C 语言的重构规则呢？

代码需要重构就像人要锻炼身体

WadeFelix

2010-12-29 19:32:11

代码的坏味道章节描述了常见的不良代码，而且基本上流行于各种编程语言。

第 6~11 章概括了一些 java 中的重构手法，是作者在实际操作过程中重构笔记的基础上总结而成，对于我们非 Java 程序员来说选择性阅读即可。

重构手法中包含了不少譬如提炼函数和内联函数这样的相反的操作，这可能会使人迷惑，究竟是遵循什么呢？恭喜你，你注意到了这一点，说明咱不是书呆子。你所要做的就是更进一步，找出为什么要提炼函数？又为什么内联函数？实践中你可能在这两种相反的操作中来回的徘徊，你确定不了哪个是好，其实 fowler 也给你说不准，事物是发展的，代码的环境在不断的变化，代码也只好因时而变。这些重构手法你只需阅读到有印象，然后碰见飘着坏味道的代码能想起来好像这本书上某个地方有说即可。

什么是重构？ What

—— 第二章

为什么重构？ Why

—— 第二章

哪些地方重构？Where

—— 第三章

什么时候重构？When

—— 第二章

如何重构？ HOW

——4~14 章

谁来重构？ Who

——You

大胆重构，无时无处不重构。

代码需要重构，就像人需要锻炼身体一样。身体不锻炼，当然还能活，但是要想活的好、活得久、活的有激情，锻炼身体必不可少。

重构除了能是代码活的好外，还能干什么？说不定你的某一次重构孕育着一个新的伟大的功能，可能重构时尚不觉察，但是重构着重构着或者重构后豁然一亮，这个功能不错嘛，甚至渐渐成了一个主要功能特点，在甚至改变了软件前进方向，改变同类软件竞技规则也不一定哦。Firefox 是怎么引入扩展功能的，咱不知，但现如今没有扩展功能都不意思叫浏览器啦。

怎么用好这本书

柳树

2017-12-06 15:42:46

        

这本书内容特别丰富，尤其是讲解各个重构丰富如何执行时，更是讲的非常详细。

但是就像书中作者提到的。「把你对重构的敬畏扔到太平洋里去」，也请你把读这本书的敬畏，扔到东海去。

在我看来，这本书就是重构方法的字典，就像你不会从头到尾看一遍《新华字典》一样，你也不需要把《重构》一字不落的看完。

你要看的，只有前面四章，包括一章讲解一个重构的案例，一章介绍重构的原则，一章介绍什么是代码的坏味道，还有一章对重构列表做一个概况性介绍。看完这四章，不需要两个小时。

然后你可以粗略地扫一遍其他的内容，主要是讲闻到各种代码的坏味道时，如何重构。

然后，你就可以把这本书放到你座位旁边，当你工作中或者学习中遇到丑陋的代码、闻到坏味道时，先想想这是哪种坏味道，大概要采用什么方法，然后再去《重构》这本字典里去查找详细的重构方法，然后，重构它！

最后附上思维导图：

（图片和 xmind 文件可到我的 Github 下载：

https://github.com/hzy38324/Hong-s-Xmind

）

      

重构万岁～

DavidTian

2012-07-31 16:10:11

英文版 :

花了一个月的时间读完了这本书的英文版本。对英语不太有自信的朋友（譬如我），建议对照着中文版来看。因为有些单词翻译过来还是不明白意思，譬如，‘nibble away’这个词，google 翻译为‘蚕食远’，而中文版翻译为‘慢慢处理’。

章节介绍：

第一章展示的小程序一下子就拉近了读者和重构之间的距离，顿时有种重构走下神坛的感觉。

第二章介绍理论知识，略带乏味。

第三章的 bad smells 一点点的让我想起，当初自认为写的很健壮的代码，但现在看来很有问题的。

5-12 章的精彩自不用多说。尤其是第 12 章 big refactorings，帮我瞬间拉回到四个最为普通的案例来。继承和委托应该使用哪一个，各自的优势是什么？如何将一个过程式的设计转变为面向对象式的？如何将表现和逻辑相分离？哇！！！看的太精彩太过瘾了！这些可都是程序员心中萦绕已久的问题啊！

13，14，15 章因为我资质较浅，没能参透... ...

16 章真的像作者说的一样，起到了画龙点睛的效果。尤其是作者提到的当你无法再继续重构下去的时候，等下来歇息一下，想一想，等想好了再继续出发。还有就是书中几乎每一页都有提到的'step by step' 简单精炼至极。

合上这本书后，按耐不住激动之情，马上来这里写下这些文字，以纪念这一个月来陪伴我度过无聊生活的‘朋友’。我相信我不会从此冷漠它，接下来的编程生涯我会带着他一起走完。

写出好程序的必由之路

草根程序员

2010-02-22 14:29:08

好程序不是写出来的，是改出来的，但是怎么才能改出好程序，看看这本书吧。它会引导你一步步让自己的程序变成艺术品。当然，要记住 The Pragmatic Programmer 说的话，足够好就行了！

影印版，对就是影印版

烟雨平生

2005-12-20 13:33:49

如果你希望自己的代码想自己书写的诗篇一样，平整，对仄，那么推荐你看一下这本书，如果你觉得你的英语不好，不要紧，好好学习一下你的英语吧。

重构 --- 解决问题的方法论

妙手一运

2009-08-29 23:15:46

重构代表了一种观点，是解决问题的一种方法论。

如果事物出现了问题，我们「闻」到了他散发出来的坏味道，那么我们应该重构这个事物。

而代码重构只是重构的一个方面而已。跳出代码重构这个框，我们可以看到更多的东西；

可能看到自己的工作生涯需要重构，于是我们不满现状，换一个工作；

我们不满自己的坏习惯，我们可以重构出一个新的习惯；

一个公司的运作出现了问题，我们重构部门的组织，砍掉正在做的项目，裁掉多年的员工，也可能合并……；

……

ps：我觉得其中的部分方法是为了重构而重构，真的没有必要。不过很多方法给了我启示。

看过一遍就可以放一边的书

虫

2011-11-23 21:59:01

的确如译者所说这书看过一遍就可以放在一边了，而不是做为工具书常常翻阅。

对来有多年经验的开发人员来说，重构应该在开发过程中不知不觉就应用的和掌握的。

这本书的价值在于它把大部分常用的重构手法都进行条款化，并明确指出了重构的工作要一小步一小步进行的，每一小步的工作都是为了保证原有程序的正确性。明确指出重构的工作应该在开发并行的，而不是纯粹如同开发暂停时对代码的整理。

对 Martin Fowler 的失望来源于此

langyu

2012-02-27 17:32:50

本来在项目中就有很多重构动作，没有看过相关的资料，怕偏失太多。但翻过这本书后就后悔了，收获不大。就是把一些基本的重构方法翻来覆去地凑。

我的经验是：重构是看到代码很恶心，或是架构不易扩展的时候，发自内心想动它，然后基于提高可维护性，可读性等原则所做的改变。

如果你是想从这本书上学会怎样重构或是提高重构能力？那么你会失望的。

记录一些精彩内容吧

清道夫

2016-07-10 21:16:53

整本书我觉得可以分三部分：第一部分 1-5 章，第二部分 6-12 章，第三部分 13-15 章。

第一部分主要是关于重构的概念和何时应该重构的，第二部分是具体讲解重构的各种方法，第三部分是一些是作者为了凑数和给朋友面子硬拼接上的。

第一部分是最精彩的推荐详读，并在其提到一种重构方法是就跳到相应的方法（都给出了页数）去具体看一下（重点读第三章 —— 代码的坏味道，和其中提到的重构方法），第二部分适合当作工具书查阅不必要整个读下来（虽然我还是一个个读了一遍），第三部分可以不看（我还是看了）。

这本书已经有些年头了，里面的几乎所有概念都成了共识或常识，但读起来还是有些收获的，一个是读完了未竟之书的喜悦，一个是对当时面向对象概念还未普及时作者们就能提出这么多精彩的观点和理论而感佩，还有就确实有些以前常用的重构手法不知道应该怎么称呼，现在知道了。

呵呵，好吧，我看完这本书纯粹是因为想要看完当年看了一半的书，治好我的强迫症。

以下是一些重点内容：

1. 不要为重构而重构。

2. 事不过三，三则重构。

3. 每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立的函数中。

4. 即使你想要提炼的代码非常简单，例如只是一条消息或一个函数调用，只要新函数的名称能够以更好的方式昭示代码意图，你也应该提炼它，但如果你想不出一个更有意义的名称就别动。

5. 如果某些数据和某些函数总是一起出现，某些数据经常同时变化甚至彼此相依，这就表示你应该将它们分离出去。

A light version of "Clean code" by Robert C. Martin

速速

2009-12-21 07:27:28

        A light version of "Clean code" by Robert C. Martin      

实战可参考性很强，力荐！

bdceo

2015-01-11 23:42:30

原本书中内容还是比较精彩实用的

可惜的是翻译老拖后腿，整体读起来还是算比较顺溜的

只是部分概念，原意，个人感觉翻译的还是有些生硬

花了几个月时间断断续续终于看完了

还是有很大收获的

合上书本，书中的重构手法依然回味无穷

跃跃欲试，在以后的实际工作中，多多演练

循序渐进提高编程技术，应该读这本书。

郁闷的 PP

2006-06-16 14:11:32

我的经历和大多数主流的程序员可能有些不同。

从做应用开始，小项目做得多一些。所有知识在使用中通过 google、msdn 等初学一次，不懂立即买本书来详细了解。

这本书确实给我带来了很多帮助，其实在看这本书之前就可以开始重构了，只是不知道这个名词。

不过楼上的高手说得好，重构出来的不一定非常好。所以最近又狂啃设计模式相关了。

重构是一种习惯

bearing

2006-08-18 12:45:21

第一次读的是 e 文的，一开始就被那个例子吸引了，读完后又觉得要在实际中加以实用，还是要看具体情况的。养成这种思考的习惯是重点。

编写良好代码的有效手段

Nick

2007-02-26 09:21:56

重构开启了另一种思维方式，他对开发人员思想上的启迪远胜于重构的具体步骤。

重构可以维持良好的代码结构，可读性，可扩展性，还可以帮助理解旧代码。

重构的意义

海桐

2007-09-29 10:34:58

做软件犹如一件艺术品，过程之中需要设计师不停的雕琢，不停的思考如何简约，如何美观，如此重构一番才会形成品质高，质量优的软件。

重构是一门基于对象抽象，封装，多态原则的方法论，而本书详细论述了各种方法，结合具体项目使用这些方法 ，将会发现抽象是门艺术，编程是快乐的事情。

重构

路人乙

2007-10-26 19:08:57

一口气读完前半部分，后边的就不好读了。

前面的东西，读起来感觉就像在复习一样，大师给出的总结是我要看的要点；后面的感觉理解起来比较困难。

这样的书适合快读，多读几次就透了。

其实重构是一种很自然的行为。

dragonzhou

2008-03-13 20:38:20

我看得是电子版 e 文，写得非常浅显易懂。应该是好几年前看的了吧。看完后回过头想想，重构每个人都会，也都做过。因为没有一件事一次就可以做好，需要不断地调整，修改。重构也是一种再思考的过程。书里面总结的方法有些我们也有做过啊。在配合各种 IDE 里面的工具，重构更是一种简单的动作了，也加速了开发啊。如果再配合敏捷开发，重构则是最基本不过的要求了。

flower 经典书籍

mack

2008-05-03 21:43:13

很久以前就在 javaeye 上看到 robbin 推荐这本书。

我自己买了一本中文译本，感觉通俗易懂。

前 4 章将的都是重构的一些基本理论，包括：重构是什么？为什么要重构？重构的必要的开发环境。

后续的章节将的是如何通过 flower 总结的规则进行软件重构。包括：长函数、抽象类提取等。

重构是用最小的步伐进行软件的抽象的步骤。

个人感觉根据提供的重构法则后面的序号进行快速的查看很有用。此书可以珍藏。

软件是演化出来的

魏理布赫

2008-07-11 19:37:28

一切真正有用的东西都是演化出来的！

这本书在一定程度上颠覆了软件必须先需求分析，再设计，再编码的传统模式。大可以一边分析需求，一边设计和编码，只要代码不是写得太烂，重构的效率是很好的。

写过代码后再看

BevisWu

2009-04-28 13:13:42

我第一次看这本书的时候是对 java 了解不多，只是听别我说这本书好，于是看了一下，可是看不懂。现在又重新拿起了这本书，感觉里面还是有用，在实际中要多用

法宝！！！

自强不吸

2009-05-05 19:41:40

十年前我还不了解《重构》，凭着满腔热情打算开发「JAVA 网络版中国象棋」，结果狠狠地碰了壁，碰得满头是包。

开发初期还是进展得满顺利的，我用尽了自己的十八般武艺：数据结构，设计模式，子类扩展，能搭上边的手段统统地派上了用场。功夫不负有心人：马走日象飞田，炮打隔山将，小卒一去不回还 -- 这个中国象棋软件已经俨然是一副象棋了，除了「网络对战」功能还没实现。

看到这活生生的成果，我曾开怀大笑，暗暗发誓，下一步开发将直指核心：「在一个大循环中，套进现有所有功能，同时监视 PC 对棋盘的操控。如此，则大事可成也！」按照我原先的编程风格，开始追加网络核心功能。加啊加，塞啊塞，好好一个系统终于开始支离破碎，非但新功能没加进来，就连原来的功能也失灵了。

大喜之后必有大悲。

为此我曾经极度郁闷，甚至怀疑自己精神分裂了，才导致「中国象棋」四分五裂。直到多年后拜读过《重构》，我才弄明白那个系统是怎么「死掉」的。

比如，有一「灵感派」建筑师，他施工时不靠图纸只靠灵感。这位大侠，转头是一块一块地砌，墙是一堵一堵地盖，砌到哪里算哪里。灵感驱使他盖了一道又一道墙，也是灵感让他在关键的地方添砖加瓦。末了这大侠抬头一看，大势不妙了。原来不知不觉间他打造了一道道围城，这围城没有出口，把自己牢牢困在中央，不要说房子无法继续施工，就连自己如何脱身都成了大问题。

这就是灵感派工程师的软肋。造房子如此，写程序也如此。

《重构》可以强化我们的薄弱环节，有了它我们可以拥有一系列构筑手段，一边造房一边调整。开工前，您基本不需要任何设计，开发部分功能后，您戴上「重构」的魔术帽，在不破坏原有功能的前提下，重新调整代码的结构，使您的系统更富有弹性，无论加入多少零散功能，都不影响系统的扩展性。

这样的系统开发可能失败吗？

总结的很好

mendynew

2009-06-12 12:48:44

看过本书，发现很多重构方法自己平时都曾用到。虽然书中对重构中的每一小步分的过于琐碎，但是就书籍来说，是应该的，至少可以给读者一个「谨慎」的提醒。是的，很多时候，我们可以将几步并为一步，但是往往测试后发现有问题又会回过头来一步一步修改。重构需要耐心！

看完之后，可以再回头仔细阅读第三章，作为总结，可以伴随以后的每一次重构。

对代码的精雕细琢

shelocks

2009-08-04 22:58:14

正如书名所言「改善既有代码的设计」，要写出漂亮的代码不可能一蹴而就。我想，这对大师也是一样的吧。就像磨刀一样，刀不磨不快，代码也需要反复地打磨。重构代码的目的就如同磨刀一样，打造出更「锋利「的代码，使代码达到更好的重用性、简洁性、清晰性和健壮性。

关于它，无须再多谈的一本书

牵手到老

2009-10-26 10:33:37

对于这本应该在软件开发领域里占据如此重要地位的一本书，似乎不需要再做额外的评价了。许多人将其视为与 GOF《设计模式》并列的巨著自有其道理。我想本书最重要的贡献是在计算机开发领域，总结并开创出一个新的领域 - 重构。由于本书的巨大影响力，重构工具已经并入到许多知名 IDE 中，比如 JAVA 领域份额最大的 Eciplise，以及.net 的 VS（本书成书之前只有 smalltalk 界支持）。

作为如此重要的一本书，邮电出版社到现在才推出英文版确实有有些晚了，我想国内的读者应该很早前就接触这本书了，这也是这里关于这本书评论如此之少的原因吧。不过值得肯定的是，人邮在原书基础上搞出个注释版出来，这种折中的方法可以说既保留了原作内容，又能在某些关键或者晦涩的地方给出注释，应该是一种不错的方式，值得肯定：）。

手头必备

Macyou

2010-01-06 21:07:26

本来是想买影印本的，不过没货，想想是侯捷翻译的，就买了这本。其实第一次看这本书的已经是很早的事情了，可能是那时候自己还不是怎么开窍吧，也没什么感觉。近来的一段日子，项目中总是需要自己去辨别那些 bad smell，并且进行重构。手边现在必备的书就是这本《重构》还有《Effective Java 2》。

很多的时候，都能从这里发现自己需要的对那些 bad smell 的解决方法。

重构要带着 TDD 一起看

nickcen

2010-01-31 17:50:45

所有技术都是有使用背景，和使用环境的。个人觉得，重构就应该是跟 TDD 一起做，而且在你掌握设计模式之前，重构可能对你意义不大，因为重构的目标就是能 refactor 到某些 pattern 上。

如果没有重构，软件将必然腐坏

代码罐头

2010-02-11 10:45:20

这本书比其他一些讲软件工程的更推荐

因为他更为实用

例如代码整洁之道以及程序员修炼之道等等

更多的是从理论上来讲求一些内容

虽然看起来更快更无痛

但是对于实际提升来说未必有效

编码其实和自行车一样

你不去骑它，纵然你学会 N 种骑车的理论

还是不能学会的

而重构这本书都是从很简单的例子出发

逐渐重构给你看

总结出的重构方法

你不一定需要记住，只要你知道怎么去做，学会做法就行

还有一本修改代码的艺术也很不错

不过里面的例子有些复杂.

经典图书新版上市，china-pub 即将首发

icekey

2010-02-21 16:50:50

经典图书新版上市，china-pub 即将首发，感兴趣的朋友一定不能错过，精彩样章，抢先试读：

http://www.china-pub.com/computers/common/mianfeisd.asp?id=196374

      

有理论有实践 —— 不可多得的好书

namsanx

2010-03-17 22:50:42

对我当前的工作帮助非常大，至少学到了一点，重构不是重写！

说服 PM 进行重构也不是见容易的事，重构不能带来性能的提升，不能使系统增加功能，不会对现有系统有任何本质的提升 —— 但它增强了代码的可维护性、可扩展性，这也许就是现有系统的本质的提升。

重构最好有自动化测试工具作为辅助，对于老系统的每一行代码的改动都应该小心翼翼。

重构建立在对设计模式有良好的理解基础之上。

重构是每一个追求完美的程序员必做的工作。

经典

爱次兔的喵喵虎

2010-04-04 21:52:03

这本书来回来去读了好几遍了吧，里面的重构方法我基本都忘了，只是那种对待 bad smell 的态度深深的刻在了我心中。。。实际上我从书中看的只有两点：不要容忍 bad smell 和 渐进。。。。这已经足够了。

精彩的思想

水月

2010-07-07 09:56:38

不得不感叹，十年前就有这样精彩的思想和这样精彩的对思想的实践，是多么了不起的一件事情。

在 JUnit 如此古老的时候，在几乎没有重构工具的时候，作者就已经敏锐的感觉到了重构的力量，并且引导着人们思考重构；今天完善的 Java 版的重构工具几乎都得益于这本经典著作。当然本书的思想并不局限于用来举例子的 java，里面的原则和技巧对于任何系统的重构都是有指导意义的。

期待新的进展

两把刷子

2010-07-15 17:47:28

很多年过去了，仍然记得当初读这本书时的期待。重构的思想由来已久，这本书提出的一个重要的思想就是面向工具，借助工具可以让重构行为更加可行，更加实用，书中的所有内容都是可以用工具实现的，虽然当时工具还没完善到那个程度。到了现在，java 和 c++ 的重构工具都有很多，我没有跟进，因为据说还是不太好用。期待有更好的重构工具问世，减轻我们为前辈程序员的不良代码而承受的负担。

条理化的重构

学游泳的鱼

2010-08-18 12:34:55

作者的高明之处在于将看似杂乱无章的重构行为分类整理，对每一类的重构条理化，转化为 step by step 的过程。

学习过 OOP、设计模式以及写过代码的人必读

蚂蚁

2010-09-10 17:50:31

之前读过好几本关于设计模式的书，总觉得读完之后不知用在何处。

这本书可以帮助你把设计模式的知识点运用到代码改善当中去。

此外，写过代码的同学，若是仔细读过此书，应该都会发现原来自己的代码写得多么不合理。因此，吸收此书的精华吧！

注：

1、本书的译者均为台湾的前辈，有些字词读起来不那么习惯，建议读《重构（英文注释版）》的，其实一点一点地读下去，不会有太大的坎。而且，它里面更新添加了更多的重构手法，值得！

2、幸运的是，《重构》的翻译版今年出新版的了，想必会有大大改进，期待着图书馆购入。

使用面向对象编译语言的程序员必备图书

malong

2010-09-13 17:24:32

两年前就看到许多程序员一再推荐这本书，但到现在才开始读（太懒了）。两章读一下来后真后悔没有早点读这本书，早点读就不至于写出那么多低质量的代码了。

书中包含许多重构手法，而且几乎每一个重构手法都详细地说明了在什么时候需要使用该手法，怎么样使用该手法，并有示例。总结归纳的很好，符合中国人的阅读习惯。

虽说是重构，但对于程序设计来说，这些手法也是设计方法的参考。在设计时就注意这些基本手法，相信代码质量将会更进一步。

英文生僻词不多，易读。结合 OOP 思想、原则一起学习更好

蚂蚁

2010-12-11 23:00:15

这本英文注释版的比起中译版本感觉更值，最后还添加了近 10 个最新的重构手法。

虽然读了该书的各种重构手法的具体操作步骤，作者也的确一步步给出了详细做法，但仍然还是觉得不够深刻。自己思考了一下，原来问题在于缺乏 OOP 思想、编程原则等等更加关键性、原始性知识的理解。恰好最近又重读了《冒号课堂》一书，这才对《重构》里面的一些手法又更深的理解了。很多重构涉及到类职责、类间依赖关系、类的层次结构、应对变化的技巧等等，OOP 思想和编程原则是更具指导性的关键知识。

常读常新的重构

志敏荐书

2011-02-23 08:48:21

本书凝聚了软件开发社区专家多年摸索而获得的宝贵经验，拥有不因时光流逝而磨灭的价值。今天，无论是重构本身，业界对重构的理解，还是开发工具对重构的支持力度，都与本书最初出版时不可同日而语，但书中所蕴涵的意味和精华，依然值得反复咀嚼，而且往往能够常读常新。

收获并没有达到期望

唐飞

2011-03-22 16:34:22

毕业后就一直坚持看书，这些书我主要划分为两类：专业技术书籍，和非专业技术书籍。阅读过的这两类书大概各占 50%。在我的经验中，专业类书籍普遍没有非专业类书籍带给自己的收获大。就像这本《代码重构》，在业界一直享有很高的评价，但是对我而言，看完之后的收获并不太多。在我看来，书中大部分重构方法，只是对我们经常使用到的编码方法进行了详细的描述而已。可能我的理解有失偏颇，因为这仅仅针对我个人而言。但是书中将编码看作艺术，以及作者所透露出的之于这门艺术的完美主义精神是我非常欣赏的。

细节早十年读会更好，整体一直有意义

竹十一

2011-04-26 12:21:12

这本书我读的是英文版，总体上来说细节部分要是比较 out 了，但是整体思想很值得吸收，可以仔细品味。

这本书也给了不少具体重构的方法，可以按具体情况采用。

有个原则需要指出：测试是重构的保证。

重构

tokyo

2011-09-02 15:37:53

把重构当工程来做。

重构：在不改变外部行为的前提下，对代码做出修改，以改进程序内部结构。

使用了 java 语言来讲述，非常喜欢！

足够的实践和经验是阅读本书时引起共鸣的条件之一，阅读时看前五章就好了，剩下的部分可以当做工具书，需要时查询。

根据引言和我的阅读，内容如下：

重构 第一章

为什么重构 第二章

什么地方重构 第三章

进行测试 第四章

进行重构：单独浏览后边条目

适合写过几千行代码的人

二元变量

2011-11-03 15:47:05

要写出高质量的代码无外乎，架构，设计模式，成例和代码风格，以及算法。这本书涵盖了成例和代码风格以及面向对象设计。学会这本书，也就掌握了如何书写可读性很高的代码。高可读的代码是设计模式和架构模式的基础。推荐写过几千行代码，又没有留意代码可读性的程序员来读这本书。

设计的演化方法

Jerome

2011-11-20 10:25:01

在看这本书之前，自己看过一些关于设计模式的书，也包括经典无比的《GoF》。《GoF》的牛已经不用我再去说明，但有一个事实是可以确定的 —— 如果你不去实践这些模式，在实际项目的设计中有意识地思考（至少初期应该如此），那么这些模式是不可能被真正理解的。

基于这一个前提，《GoF》这本书就内涵着一个巨大的问题：并不是每个人都有很丰富的项目经验的，即便是失败的经验都没有。这使得《GoF》的门槛变得相对较高，换句话说 —— 易实践性降低了。

《重构》这本书所讲述的方法，就是在设计的易实践性上做了文章。重构方法相当适用于敏捷开发模型，或者非敏捷的演化类型的开发模型，而在此之中最重要的两个字就是」演化「。

与 TDD 方法类似，重构也提供了一种方法改善既有的代码（令人感到惊喜的是验证改善过后的代码的一大基础措施就是测试！）。重构提供了一种方法论，甚至是具体情况对应措施的条目来改善代码的设计（而非 TDD 的达成目的为目标）。这样一来便可以解决在大量的用例中纠结类与类之间关系的尴尬境况。

有趣的是，重构前的代码往往朴素但却对应着实际上可用的设计模式。也就是说，这些代码，在好的方法论的指导下，可以渐渐演化成设计良好的代码 —— 这就是重构方法的易实践性。这更加证明了设计模式来源于生活而非枯燥的形式化理论推导。

我想对于想要理解设计模式的人而言，重构方法是对设计模式演化历史的一种角度，通过这个角度，我们就可以了解某一个模式所对应的原理性解释和它的演化动机 —— 这也是活学活用设计模式的重要前提。

C 语言的重构，没有发挥出更大的威力。

弹头 2012

2011-12-07 10:53:49

        

2005 年读过这本书，因为一直用 C 语言开发，感觉对于函数和模块级别，可用的重构方法非常有限，但还是对有了这样本书感到庆幸，还专门总结了一篇《C 语言下的重构方法》，现在来看，C 语言的束缚太多了，就不适合做业务软件。这本书因为作为《代码大全》的培训辅助用书，后来又读了一遍，并且做了很多重构演练，但是总觉得没有发挥出更大的威力。

如果想了解设计模式，请一定要读这本书

变身斯嘉丽

2012-02-01 16:14:57

断断续续的读了几个月，终于读完了，文中的内容虽然有些零散，甚至觉得要求过于完美，但是对于理解设计模式还是有很大的帮助，基本看完这本书，你就会明白设计模式最初是如何一步步的设计出来，其实就是重构的最终体现。虽然目前工作中仍然对于重构使用不多，公司也对这项事情不够重视，但我相信，在我以后的开发设计中，一定会有书中某个方法的体现。

重构

fhzh

2012-03-01 14:37:17

仓廪实而知礼节，衣食足而知荣辱，这物质文明与精神文明的层级关系也一语道破了程序设计的层次级关系。程序设计也是如此，先满足了功能需求，然后再对代码进行重新整理、组织，达到易读、易改、易扩展。这种对代码重新整理的过程就叫代码重构。

重构在不同的研发模式中的作用不尽相同。比如，在敏捷开发的研发模式中，重构的作用相当重要。敏捷开发运用迭代法进行产品开发，在迭代过程中分析、方案、代码同时发生，并且弱化方案，强化代码设计。在开发过程中，每次功能迭代程序员都根据现有代码进行重构，尽量运用已有的代码或函数，或者改造现有代码使其满足新功能需要。这样使代码实现高利用率，改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。

在过程式研发模式中，前期产品开发阶段重构的作用不太明显，而到后期产品维护阶段重构则较为重要。因为过程式研发在代码设计之前做了一系列工作 —— 需求、方案，这些工作要求产品的功能和方案固定化，并且如果方案做的特别细的话，每个函数的实现方式，甚至代码基本逻辑都已固定，到代码实现阶段只要把方案转化成代码就是。也就是说，在方案阶段已经把重构的工作做的差不多。在后期维护过程或功能添加的过程中，则会参考之前的代码。

我们目前用过程式研发模式，而我的研发水平处于实仓廪阶段，在方案设计时只是注重功能实现，而没有更多地考虑重构，后期维护也只是注重功能增加。久而久之，代码将会架构模糊，函数重用率低，质量低下，功能增加困难。看了《重构 - 改善既有代码的设计》之后，昨天我试着把事件模块做些简单的重构，不到一天竞重构掉了近 200 行代码。由此可见在重构方面做的还很不够。思想决定行动，意识决定高度，正如在实仓廪阶段也要不仅仅为了吃个饱，要把产品当成一种艺术品来做，在细处打磨。现在已经有重构的意识，接下来会在添加功能、修补错误和复审代码时尽量运用重构法则，对代码进行整体把握，强化重构。砍柴不误磨刀工。

说了这么多，再说说什么重构是什么，什么时候需要重构（来自《重构 - 改善既有代码的设计》）。

重构：为保持代码易读，易修改，在不改变代码外在的前提下，对代码做出修改，以改进程序内部结构，提高其可理解性，降低修改成本。

要重构的代码：可有可无的临时变量，重复代码，过长函数，函数功能过大，过长参数列，发散式变化，散弹式修改，数据泯团。

PS，「任何一个傻瓜都能写出计算机可以理解的代码，惟有写出人类容易理解的代码，才是优秀的程序员」—— 作者如是说。

经典书籍，看归看，真正懂和掌握光看完是远远不够的

Squirrel

2012-07-13 23:33:13

是一本重构的经典书籍。书中的例子都还是不错的。但重构毕竟很难用规模小的例子来讲重构手法带来的好处展现无遗。不过，通过这本书已经能够把重构和我们拉得很紧。留作枕边书吧，在程序人生中时不时翻一翻，悟一悟，定将受益匪浅，茅塞顿开！

这是作者很逻辑很规范的经验分享

银光

2012-08-05 17:19:16

一个多月断断续续的简略看完了这本书，有些地方看得很兴奋，作者表达的正是我想过的道理，而他表达得更好；有些地方让人幡然大悟，确实如此；也有些地方没看懂，有些就觉得废话太多了。

这本书更多的是经验上的分享，具体的技术细节虽然也不错，但远比不上授人以渔来得珍贵。

之前经历过一次很大的重构，实际上已经超越了重构而是重写，最后掉到了坑里。经历挫折之后，再来看这本书，很合适。如果能在重构之前就看到这本书里讲的道理会更好，只不过，可能也是不假思索的翻阅过去，坑还是依旧往里跳。

里边的一些总结，印象很深，那也是我在编码过程中感受到的。譬如:

两顶帽子。这个短语不止可以用在重构时，也可以用在个人平常工作中。一次做一件事情，不要两件事情混一块。一次只提交一个功能的代码到 svn，不要多次混在一起。这样子可以降低风险，以后出问题了也可以更容易的找到出问题的代码。对于团队合作来说，一次提交一个功能的代码，可以方便其它人学习、review 代码。

简单就是美。为了杀鸡去锻造一把杀牛的刀，局外者也许会觉得，哇，考虑好周到呀。但实际上没必要。为了微乎其微的未来可能性而构造了一个体系极度复杂的的系统，并不是一个好点子。在代码够用的前提下，简单最好。这就是 1.3 节里的那句话：「任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。」

不要大跨步。在项目的重构中期，我就发现了这个致命的问题，但已经无法逆转。重构的步伐很大，出现很多的错误，修复 bug 花费了非常多的时间。如果早点看这本书，即便记不住「小步前进」，看到书里头每一步都极小极小的例子，也能体会到作者给我们的经验：不要大步跨。

把重构融入到每一次迭代中。书中最后讲的「没有一位经理愿意听到他的开发成员说 ' 我们要停工三个月来清理以前的代码。' 而且开发人员本来就不应该这样做。大规模的重构只会带来灾难。」这也是我在重构中感受到的，我们就是这样掉到坑里的 -_-。还在坑里的时候，我发现重构的代码还是很丑陋，于是产生了一个想法：每个人都有整理代码的义务。就是说，每个人在添加代码时都要小步的去整理代码，而不是特地的去花时间大规模整理。所以当看到作者一直在强调要逐步改，很有共鸣。

书中还有很多有意思的句子，不过记忆不好，忘记了：(

代码的坏味道，讲得很不错。不过，在我们的实际编程中，有些坏味道我们并没有当回事，因为... 还有更坏的，那些小坏太普遍了。

说点题外话。

程序员真该看看这本书，当然，更应该看看代码大全。不过，很多人都不会看。

是产品重要，还是代码重要？很多时候你都不得不赶进度，老板要看的是产品出来了，可以抢着上线。把代码写得漂亮，产品出来晚了，挂掉了，再漂亮也没用。所以，很多人会为一时之利写出很垃圾的代码，久而久之，垃圾就成为一种习惯，你看到垃圾代码或者写出垃圾代码时，心安理得，觉得很自然。有什么办法呢？要让人们解决问题，就要让他们切身感受到问题。垃圾并不可怕，因为我们还可以重构。可怕的是，把垃圾代码当作一种习惯。感受下代码的坏味道吧。

做一个有很多好习惯的优秀程序员。

看书吸收的效率太低了，而这书又看得太快了，以后还得看看。

          

正在重构的朋友可以参考一下

小王爷

2013-08-30 14:30:20

《重构》这本书，讲的非常好，主要说了重构在一个项目中的重要行，还讲解了不少在开发中用到的方法和技巧，比如设计模式、测试、提炼接口、UML 图，非常好理解，都是大白话，简洁、明了，看书不用动太多的脑筋。如果你也是这个条战线上的人，建议读一读。

目的并不是为了重构代码，而是开始的时候，就将代码写好

shany

2014-02-25 22:09:01

很喜欢这本书，也经常给别人推荐这本书。很容易读，而且大部分内容都是我们平时碰到的。推荐给别人的目的并不是为了重构代码，而是开始的时候，就将代码写好。这点可能有些矛盾，不经历很多 bad smell 就不会觉得这书写得好～。

重构

JackChu

2014-04-12 20:45:13

最近在微博上看到有人在说 code review 的事。

回想自己，好久没有去 code review 了。

前两天听一同事评价另一同事代码，说写得真不错。

进一步反省一下自己最近的一些代码质量。

想要美，首先得知道丑。

那么哪些是丑的呢？

好久没有去看开源项目了，忙什么呢？

今天看《程序员修炼之道》里面也有重构的部分，一时把这本书翻来读读。

看到这本书在 2008 年就买了，可能也就买回来的时候看了下，也该再温习一下了

虽然经典但实用性有待实践

usc3l

2014-05-03 10:54:38

老实说，虽然很经典，但并没有感觉到太多的精彩，个人认为，

1、里面的 Java 版本太老了，有些重构可以用更好的方法，比如 enum

2、对于一些带有「坏味道」的代码，平时也会进行一些修整

3、面向对象的编程虽然便于后期扩展，但也带来了维护的麻烦

希望如果能重读的话能另有收获

重构工具的使用

Loki

2014-06-30 15:51:15

花了几个晚上，重新读了一遍《重构》，跟上次不一样，这次对照着把 IDEA 的重构工具过了一遍。

这本书最重要的价值，就是给现代化的重构工具提供理论支持，比较偏学术。而当你掌握了现代化的重构工具以后，其实已经没有必要再看这本书了。现代化的重构工具，可以把本书中花几分钟的「做法」，变成一个秒级的原子操作。

一年多前不熟悉 IDEA 的时候，感觉这本书很难看下去。或者看完不知道怎么使用。经过一年多，现在对 IDEA 的重构工具已经几乎烂熟。再看这本书，感觉其实已经可以不看了。

目前来说，感觉学习重构比较好的做法，是针对 IDE 的 Refactoring 菜单，把所有的重构工具都过一遍，并在日常中多多练习，直到变成一个编辑代码的原子操作。可以准备一些包含基础重构的 kata，经常做一些练习。

刚熟练掌握 vim 的时候，会欣喜于 vim 高效的编辑操作。而当熟练重构工具以后，会惊叹于如此高抽象层次的原子操作，带来的绝对是思维层次上的飞跃，以前你面对的代码，跟文本区别不大，而现在你面对的代码，才是有语法和语义的，高效的编程来源于更高的抽象层次。

对于 Java 这种比较笨拙的语言来说，现代化的重构工具更加的不可或缺。

打开一扇门

ansondeng

2014-09-29 21:55:34

重构时时刻刻都在做，知道或是无意识的情况下。所以总是以一种漫无目的地方式进行着。为了能系统的（更快的，但是没实现）掌握这种所谓的技能，才来读这本书。

本书结构比较简单：一上来就是重构的例子；接着讲为什么需要重构（重构的好处）；然后就是寻找在哪重构的方法，以及重构前的必要的准备（我认为最重要还是自测）；接着才是重头戏，丰富（冗长）的重构方法，可以当作手册用；最后总结重构的意义（和之前将为什么是不是有点重复）。

在 IDE (eclipse）中已经有专门的 refactor 模块，能很方便的实践重构，虽然没有书中如此完备。

书的作用还是在于引导，完全打开了一扇原来虚掩着的门。至于能走多远，还是要看之后的实践，我还差得远。今天以此书评自勉。

第二次拿起这本书

tanhe123

2014-11-30 11:47:52

第一次读的时候把本书通读了一遍，那时还是大二，没怎么写过代码，当时当真觉得重构是一门艺术.

重构需要敏锐的嗅觉，当嗅到一些坏的味道，便立刻脱下 "添加功能" 的帽子，开始进行重构。重构时快乐的，原本乱糟糟的代码，三下五除二，就成了优美的、赏析悦目的艺术。

使用重构，能减轻人的负担。因为不用纠结一个良好的设计而难以下笔，想起来便写一点，边写边重构，可以说没有重构，软件不会有更多好用的功能，原因是添加一个功能，往往会导致一堆的 bug，我们往往疲惫于 bug 的修复。

至今为止，我还在求学路上，明白自己还欠缺很多东西。

过了一年，再拿起本书，竟有些许的感动。

第二次拿起本书，而这一次会好好的研究下，加油加油，我最棒！！！

第二次读

tanhe123

2014-12-11 16:05:54

第一次读完后，发现很多并没有理解，但是也有些已经能够在平时使用了。因此第二次特意将之前看不懂的地方重新翻了一下，尤其是代码的坏味道，我还把它背了一遍。

现在用的是 idea，自带的工具很强大，配合本书的技巧，超级强大。

非常难得的一本把重构讲的深入浅出的书

Tekkaman

2015-04-02 15:05:03

在 douban 上偶然看到这本书，当时评分是 9.0，花三天时间从头到尾看了一遍，真是醍醐灌顶。

重构原来不是什么高大上的东西，而是时时刻刻进行的无数个小东西。

敏捷 + 重构，简直就是双剑合璧，所向无敌。

NVN

不二家

2015-06-23 09:09:27

书中说过重构的思想由来已久，只不过没人写成书籍罢了。个人感觉如果你看完这本书只看到了思想，那你就错过了很多有价值的东西。小步骤的重构，如何最大限度的不引入 bug 才是书中要告诉大家的。像了解重构思想，只看前几章就够了。我个人认为书中最有价值的东西恰恰是进行重构时不起眼小步骤。嘿嘿，小弟的个人观点。

      

n,

chengbo

2015-06-30 09:10:56

书中说过重构的思想由来已久，只不过没人写成书籍罢了。个人感觉如果你看完这本书只看到了思想，那你就错过了很多有价值的东西。小步骤的重构，如何最大限度的不引入 bug 才是书中要告诉大家的。像了解重构思想，只看前几章就够了。我个人认为书中最有价值的东西恰恰是进行重构时不起眼小步骤。嘿嘿，小弟的个人观点

      

重构的基础

Roc

2015-11-18 16:50:58

软件设计很难一部到位，如何在已有的代码上面微调，使得代码更容易阅读，更容易修改。同样对于遗留代码，随着软件的变化，结构不是那么清晰，如何使得软件结构，代码更清晰。重构可以帮助你做到

重构的定义： 就是不改变程序的外在观察行为，而改变程序的内部结构，使得更容易阅读和维护。

什么时候重构？ 坏味道。直观来说当代码理解起来比较困难时，语义不清晰时。就来重重构。使得更能表达设计，目的。

如何保证重构带来的风险，测试，Unit Test。快速，安全。

书中详细告诉那些是坏味道？

常见的重构手法：

函数，表达式，数据结构，对象，继承，接口（方法签名）来详细告诉如何重构。

如果你是新手，看看之后有经验再读，完全是另一番天地。

如果是老手，个作者会有共鸣，作者一而再再二三的强调，真是经验。

但是重构，还是要在实践中操练，才能赢得经验。重构好换就是经验。从这个角度可以说重构是一门艺术。

       

重构的基础

Roc

2015-11-18 16:50:58

软件设计很难一部到位，如何在已有的代码上面微调，使得代码更容易阅读，更容易修改。同样对于遗留代码，随着软件的变化，结构不是那么清晰，如何使得软件结构，代码更清晰。重构可以帮助你做到

重构的定义： 就是不改变程序的外在观察行为，而改变程序的内部结构，使得更容易阅读和维护。

什么时候重构？ 坏味道。直观来说当代码理解起来比较困难时，语义不清晰时。就来重重构。使得更能表达设计，目的。

如何保证重构带来的风险，测试，Unit Test。快速，安全。

书中详细告诉那些是坏味道？

常见的重构手法：

函数，表达式，数据结构，对象，继承，接口（方法签名）来详细告诉如何重构。

如果你是新手，看看之后有经验再读，完全是另一番天地。

如果是老手，个作者会有共鸣，作者一而再再二三的强调，真是经验。

但是重构，还是要在实践中操练，才能赢得经验。重构好换就是经验。从这个角度可以说重构是一门艺术。

       

不错，有点小遗憾

小夫

2016-01-08 14:41:03

第一章的例子很震撼，原来可以这样一步步地把烂代码变成好代码。后面具体的重构方法可读性有点差，更像是一本工具书，缺乏了具体的案例支持，想了解各个重构方法的用途和威力就有点难。先给出「做法」再给出「范例」的编排方式也不是很适合理解，如果反过来可能效果会好一些。

我能理解作者这种列举各条方法的做法，因为很多方法确实很细碎不容易举出好例子，找一个能涵盖所有方法的例子更是不可能，不过可以多举举个例子啊，多写几个像第一章那样的章节，在尽量没有 overlap 的情况下把所有的方法都 cover 到，这样读起来一定爽。据说《重构与模式》是这么写的，等着看看吧。

前面的翻译水平很好，读的很流畅，后面却有不少地方让人摸不着头脑，好在都有范例，看代码也能知道作者的意图。

再说一点，以前听到重构这个词总有点怕怕的，总以为指的是对现有项目的大改，重新架构？是架构师应该做的事？是对已有的低质量项目的大手术？其实并不是，就像作者说的，重构是发生在开发过程中的对代码的小改动、小提升，是通过积少成多来体现效果的。重构并不是一件要把开发暂停下来，要拿出专门的一大块时间来做的事，而应该是每当我们发现了代码中的坏气味或者发现我们的新需求很难被满足的时候就应该做的事。这么说来，重构这个翻译有点太吓人了，至少把之前的我吓到了。

最近买 / 读的这几本技术书给我一种睁开眼睛看世界的感觉，之前一直觉得自己内功浅薄，而且找不到提升的路径，看了这几本书知道了原来这是有清晰的学习路径的，it feels good.

从现代编程角度看此书已经有些过时

栋仔

2016-06-25 15:40:52

这本书使用的例子程序来自 java1.2 版本，你就知道此书的年龄有多老。

然而年纪大并不是缺点，就像设计模式那么大的年纪仍然发光发热，成为不朽经典。更何况本书顾问还有四巨头之一。

之所以说它老旧，是因为，书中的例子在现代的 eclipse 编码工具作用下已没有意义，而这部分的内容将占据本书的二分之一。

其次，作为编程两年以上经验的人员老说，本书很多东西是你扫一眼就懂的。

但是书中仍然有很多经典的思想让其栩栩生辉：

1. 将长函数分为短函数。

2. 总是将人看作的编码的目标对象而不是机器。

3. 重构时与设计模式的结合。

4. 单元测试思想。

5. 重构无止境

。。。

总的来说，实际经验偏少的同学应该仔细品味，会让你少走弯路，甚至建议公司购置一本为新人培训；对于经验丰富的编程人员来说也未尝不是一个鞭策自己编码规范的好书。

最后，该书应该重构了。。。

提炼的一些 Tips

remones

2016-07-30 18:00:03

        

0. 重构必须伴随着单元测试，每一步重构完成之后，必须验证测试通过（TDD 才是坠吼的！！1. 功能函数细拆，将整段逻的部分实施 extract method, 并与之 meaningful 的函数名称 2. 函数应该放在它所使用的数据的所属对象内 3. Replace Temp with Query，一点也不同意，特别是在 Python 这种性能不算高的动态语言里，尽量减少多余的函数调用就显得有必要了 4. 对逻辑判断语句，可以引入解释性变量替代 5. 类或子类取代类型码，例如在定义 model 时，表示 state 类型可以封装在一个子类中 5. 将双向关联改成单向关联，双向关联的模块或者类，单拆出一个控制关联关系的模块 6. 代码中不要出现 magic number7. 字段封装，Python 中的 descriptor 就是针对这个 attr 做的非常棒的设计 8. 以多态取代条件分支 9. 拒绝捕捉所有的异常目的：使项目的代码分层良好，Keep Clean，可读性和复用性高，易于被单元测试所覆盖。

      

重构原则

王兵

2016-11-30 16:35:36

### 设计一个「类」的时候有什么原则

+ 终极目标：提升代码的可理解性。

+ 一个类应该是一个清楚的抽象，处理一些明确的责任。

+ 封装，每个对象应该尽可能少了解系统的其他部分。这样一旦发生变化，需要了解这一变化的对象就会比较少。

+ 修改函数和查询函数分开设计，在查询函数里不要做任何修改，同时最好用 get 和 set 命名。

### 重构的基本原则？

1. 添加新功能，和重构不可同时进行，重构时不加新功能，加新功能时不重构。

2. 重构时不应该添加任何测试。

3. 小步前进，频繁测试。

4. 一个函数应该且只应该完成一件事情。

### 对一个对象 / 函数来说，哪些地方很可能需要重构？

1. 拥有太多实例变量

2. 有超过百行的函数

3. 函数的参数超过三个

4. 牵一发动全身，如果经常一个改动需要在许多不同的类内做出小修改。

5. 如果有些数据项经常会成群地出现在一起，很可能需要拥有他们自己的对象。判断方法是删掉这些数据项中的一项，如果其他的数据立刻变得没有意义，那么说明他们应该在一起。

### 重构的方法有哪些？

1. 分解函数

+ 当看到一个过长的函数或者一段需要注释才能让人理解用途的代码，把这段代码放到一个独立函数里面去

+ 函数命名应该以「做什么」而不是「怎么做」来命名。

    

2. 用对象取代函数

+ 如果有一个大型函数，其中对局部变量的使用使你无法使用 Extract Method，考虑把这个函数放进一个单独的对象中。然后再分解函数。

    

3. 移动类字段

+ 如果一个 A 类里的一个字段与 B 对象有更多的交流：经常被后者调用，考虑把 A 中的这个字段放到 B 里。

    

4. 移动类函数

+ 与移动类字段相似：如果一个 A 类里的一个函数与 B 对象有更多的交流：或者调用后者，或者被后者调用，考虑把 A 中的这个函数放到 B 里。但优先考虑移动类字段。

    

5. 分解类

+ 如果类的责任过于复杂，考虑分解这个类，抽象出一个新类。

+ 一个方法是思考如果把这个函数或者变量去掉之后，是不是其他的函数或变量就没有意义了？

+ 另一个方式是某些特性需要用一种方式子类化，而另一些特性需要用另一种方式子类化，那就意味着这个类需要分解。

6. 隐藏委托（Delegate）

+ 如果某个 Client 必须通过对象 A 的某个字段获得另一个对象 B，然后调用 B 的函数，那么 Client 就必须知道这一层委托关系，如果这一层委托关系发生变化，就不得不通知 Client，可以在把在 A 中放置一个简单的委托函数，将委托关系隐藏起来，去掉这一层依赖。

+ 当 Client 调用 B 的所有函数都被 A 承包了，Client 也就不需要知道 B 对象了。

+ 隐藏委托也是一把双刃剑，会使委托类 A 非常臃肿，这时候直接调用 B 反而可能更好，掌握合适的隐藏委托程度。

    

7. 外加函数

+ 尽量不要重载原始类函数，如果需要增加新功能，可以继承原始类，增加新函数。

    

8. 公开的字段自封装

+ 用 get 和 set 获取值。Python 并没有 Public 关键词，因此 Python 类的所有属性都是可以直接访问的，应用这个设计理念，最好把 Python 类的所有字段统一在开头加上 `_` 以示私有变量，公开的变量用 `@property` 装饰器包装。

+ 如果字段是一个集合（list，set, dict 等），谨慎对待 set 函数，需要的话，用 add，remove 会比 set 要更好。

    

9. 简化条件表达式

+ 尽管一个函数最好只有一个出口，但为了这一个出口的设计而加上多重 if else 判断并不一定划算。

+ 多重 if else 用来处理异常或者说处理完了已经对函数后半部分没有兴趣的话，可以直接 return 或者抛出异常。

+ switch case 的情况下，使用「多态」设计模式，将条件表达式的每一个分支放进一个子类内的函数实现，然后将原始函数声明为抽象函数。

10. 使用断言

+ 某些代码只有在某个条件为真的时候才能正常运行，此时与其用注释，不如使用断言来标明。

+ 不要滥用断言，只用它来检查「一定必须为真」的条件。

+ 如果断言的约束条件不满足的情况下，程序依然可以正常运行，考虑拿掉断言。

去尝试重构

Leeeyou

2017-02-26 19:51:30

所谓重构是这样一个过程在不改变代码外在行为的前提下对代码作出修改，以改进程序的内部结构。

我们并不是给你一个何时必须重构的精确衡量标准。从我们的经验看来没有任何量度规矩比得上一个见识广博者的直觉。我们只会告诉你一些迹象，他会指出这里有一个可以用重构解决的问题。你必须培养出自己的判断力，学会判断一个类里面有多少实际变量算是太大，一个函数那有多少行代码才算太长。

重构的基本技巧：小步前进，频繁测试。

代码的坏味道（摘抄）

1、重复代码

2、过长函数

3、过大的类

4、过长参数列

5、发散式变化

6、散弹式修改

7、依恋情结

8、数据泥团

9、夸夸其谈未来性

重构的手段（摘抄）：

1、重新组织函数

1.1、引入解释性变量

1.2、移除对函数的赋值

2、在对象之间搬移特性

3、重新组织数据

3.1、封装集合

3.2、以数据类取代记录

3.3、以子类取代类型码

4、简化条件表达式

4.1、以卫语句取代嵌套条件表达式

4.2、以多态取代条件表达式

4.3、引入 null 对象

4.4、引入断言

5、简化函数调用

5.1、以明确函数取代参数

5.2、保持对象完整

5.3、引入参数对象

5.4、封装向下转型

5.5、以异常取代错误码

6、处理概括关系

6.1、构造函数本体上移

6.2、塑造模板函数

6.3、以委托取代继承

6.4、以继承取代委托

上面的摘抄技术点仅仅是一个起点，是你登堂入室前的大门。如果没有这些技术，你根本无法对运行中的程序进行任何设计上的改动。有了这些技术，你仍然做不到，但起码可以开始尝试了。

不要灰心，尝试开始就不会太晚。当你冷静下来，对自己的重构技艺感到绝对的自行 ———— 不论比人留下的代码多么杂乱无章，你都可以将它变好，好到足以进行后续的开发 ———— 那时候你就知道，自己已经「得道」了。

书中提供了太多的指引，以至于我们不会在重构的途中迷失了自己，如果现在你有个清晰明确的重构目标就去实践吧，没把握的时候就停下来，学会原路还回，最好拿上你的小伙伴一起。如果某时某刻，你能自性的停止重构，那么恭喜你，「得道」了。

依法重构

颠颠 De 我

2018-02-28 14:51:57

在软件开发的各种种类的书籍中，有诸如《算法导论》、《编译原理》这种逻辑严密，证明推导较多的基础著作。也有《C++ Primer》这种内容繁多、娓娓道来的介绍性书籍。这些书都是好书，但是如果让我来评论一下写作难度的话，我认为《重构》这本书的写作难度要大于前述的作品的。主要是因为以下的原因：

1、计算机理论、架构、使用说明类书籍大多都有迹可查，一本好书只要能够用合适的措辞把事实陈述出来，配上较为生动的例子就足以让读者领会作者的意图了。而重构这项工作并没有真正意义上的谁好谁坏，也没有事实上的标准，这种经验性的东西，要写得有条理性，还要有理有据，难度不小。

2、知识性的内容，读者大多会带着消化吸收的态度去学习，而经验性的条款，有探究精神的读者就会保留一分怀疑，而因为个人项目经历的不同导致的重构思路的差异是不可避免的，那么如何求同存异，总结出普遍适用的重构规律，让读者能够接受，这又是一个难点。

令人庆幸的是《重构》的作者 Martin Fowler 写出了这一本好书。在读这本书之前我也算有一些小项目的开发经验，经常会因为类的抽象和代码段的重复问题烦心，但是这样的经验类的问题又很难通过网络得到有效的指导。于是就只能摸着石头过河，有时候灵光一闪而过能够做到 Method Abstract，减小了代码的复杂度。但是有时候脑子不好使的时候又只能看着一块块重复的代码干着急，这对于想要提升自己代码水平的我来说简直就是折磨。

这本书最令我佩服的地方就是，作者将所有的重构手法都进行了场景归类，还进行了命名。如果我们熟悉了其中的手法，就能很好的避免在重构时不知所措，或者是「冲动重构」的情况。在重构的过程中，每一步都能做到有的放矢，这样代码的质量就能稳稳地提升。这应该就是传说中的「按照基本法重构」？

关于重构的书，本来就不多，我也只打算看这一本。重构毕竟还是一个经验活，就算知道了再多的重构手法，如果在实际工作中碰不到相应的案例，很快也便会忘记了。所以我把这本书长期放在我的工作台旁边，告诉自己：这里用了 Extract Method，那里 Extract 了 Subclass。通过这样的锻炼，慢慢掌握重构的技巧。

总之，重构也是有其依据所在的，不过再好的著作都教不会不动手的人，慢慢在实践中去体会，就能够提升自己的代码质量了～

PS：最近发现了提高自己的一个有效的技巧，那就是及时总结，一味的输入和输出都不是很可取，在固定的时间停下来，总结一下最近的工作。停下来品味一下高手写出来的程序，有时候会有莫名的收获。

蓦然回首，灯火阑珊处

Optimus Prime

2019-02-25 15:53:38

        

知道这本大名鼎鼎的《重构》，是十年前。十年间，打开又关上了不知道多少次，终于在西雅图的一个夜晚，一鼓作气，完整拜读了这本神作。

看完的感觉很奇妙，第一反应是「於我心有戚戚焉」，第二反应是是「看山是山，看水是水」，第三反应是「蓦然回首，灯火阑珊处」。这本书的很多内容，现在看起来，如同 1+1=2 一样的铁律，似乎没有什么可说的，但回头想想，愈发感觉字字珠玑。

任何著作都不能脱离其时代背景，本书诞生于上个世纪的 1999 年，当时的互联网已经升起，但还处于百花齐放的年代，开发的标准都还没有完全确立，就更别提重构了。所以，回头看这本划时代书的力量，确实非同凡响（Java 11 都快正式 Release 了，书中的例子还是 Java 1 和 2）。但是 Principle 的力量，就是永远可以经受得住时间的考验。

如果回到十年前，我一定不会有「看山是山，看水是水」的感觉，但工作这么多年，已经在实际的重构中被虐千百回，蓦然回首处，灯火阑珊处，终于体会到了大师们的力量。

路漫漫其修远兮，吾将上下而求索，与君共勉。

      

重构是艺术

z 正小歪

2019-03-20 23:33:40

        

你要你在写代码你永远离不开「重构」这个话题。

如何写好代码这个也是历史难题。写好代码存在的太多客观因素，我相信每个程序员都想把代码写成逻辑清晰，利于扩展。但是现实总是显得很脆弱，需要更长的工期、产品更紧的需求、乃至更懒的你都有可能为了一场电影而放弃重构。

重构很重要，所以你一定要去做。那么，怎么做，从哪下手，就是 《重构》这本出可以告诉你的。

书中从头到尾够贯彻着「重构技术就是以微小的步伐修改程序」，每次只修改很小的一处。对自己来说心里负担很小，总是会有一种我还能掌控它的感觉。再配合完善的测试，及时发生了错误，也可以很快的定位出错的地方，让后修复它，久而久之就有有一种成就感，就是书中说的「节奏感」。

书中给我们介绍了许多种很实用的重构手法，新的《重构》虽然实用 JavaScript 作为教学语言，但本身的重构建议在大部分语言的大部分情况仍然受用。虽然在某些语言中可以有特定的重构手段，但是完全不影响从《重构》中汲取好的思想，然后加以利用。

我认为的「艺术」就是大多数人明白但是在某个点需要做到极致。重构技术恰恰也迎合这一观点，所以很多人说重构是一门艺术。新版《重构》以更现代的视角为我们阐述了这门艺术究竟是怎么回事。

那么赶快行动起来，利用书中的重构手法去看看你的代码是不是要重构。

      

非常期盼的一本书

捺横撇捺

2019-03-22 17:52:12

        

Martin Fowler 大神的经典之作的又一次升级，带来了新的观点，同时也展现了作者对目前软件研发的崭新视角，相比上一版的 JAVA 语言描述，本版本采用了 JavaScript 这种更广泛的语言，使读者阅读更加容易和流畅，特别是前端开发的小伙伴，应该会更加亲切一些～重构是一种更高的视角，与敏捷、TDD 一样，属于从流程、设计角度改善开发过程的一种思想，需要站在一定的高度，一般讲起来比较抽象。但是本书采用的方式非常好，列举了非常多的示例，能够深入浅出通过实际问题让读者更好地理解其表达的思想。相比于其他一些技术书籍，这本书更像武侠里的内功心法，需要沉下心来，多思考多体会方能为日后的精进做好铺垫。作为一本风靡全球的编程思想类图书，在很长一段时间内都不会过时，非常值得买一本来品读和收藏！

      

最好能够将设计模式的技巧与重构一起施展

zhengyangas

2019-05-19 16:36:34

        

看了下这本书的状态，在 13 年 9 月份就不知道好歹的打上了「想读」的状态，但是后来从 C 转型到 Python 觉得一本针对 Java 的书籍没啥卵用，一直搁置到最近，团队大佬在推荐书单里面加了这本书，结果开始翻阅，正好也在响应「做一个系统不去思考，后面再做十个，一百个也不会有新的收获」，开始反思自己那坨 shi 一样的代码

全书还是实用性较多，几乎都在讲各种场景的不同重构技巧，不过在 IDE 环境下，不少插件已经较好支持重构了，所以一些「手工」方式可以丢了，但是全书的思考路径还是值得借鉴。

阅读这本书还有一个点，让我想起了《代码大全》，有些异曲同工，但是从境界来说，《重构》相对高些

      

从重构中重拾编程的乐趣

何一涛

2019-07-27 00:15:53

        

这本书在五年前读了一次，当时读完觉得自己的水平上了一个台阶，然后开始在生产项目中实践。

当时的项目是一堆没人维护的遗留代码，每当要做个新功能时，我都会重构（更准确的说法是重写）下与新功能相关的逻辑，因为没有测试用例的支撑，经常会因为改出问题导致自己加班。当时我从这种修改代码的过程中找到了编程的乐趣，那是一种畅快淋漓的感觉，重构后的代码似乎也成了体现我个人编程水平的象征。

随着写的代码越来越多，维护项目中的这些代码耗费了我太多的时间，想写新的功能时发现自己无法抽身出来。我渐渐地感觉到代码成了一种负债，写的越多负债越多，我被自己的写的代码给困住了。

近期重读《重构》这本书，深感以前的我在重构方面至少犯了三个错误。

1. 重构前没写单元测试。这样的重构很容易给自己挖坑，本想改个函数名，结果却捅了个蚂蜂窝。每次重构都觉得不踏实，生怕改错了什么地方

2. 添加新特性和重构同时进行，最后一起测试。这样容易搞混原有功能与新特性。一起测试意味着没有单独对重构的代码进行小范围的测试，让代码集成测试起来复杂

3. 为了重构而重构。很多时候重构成了一种强迫症，还美其名曰说自己有代码洁癖

代码不仅仅是写完就好了，还需要维护。维护说白了就是让代容易理解，让代码易于扩展修改成本低。容易理解的代码可以很方便的交接出去给其它同事维护，难理解的代码就只能砸在自己手里。一旦有缺陷或者新功能，修改成本低易扩展的代码可以让你很快就完成需求，收获同事的佩服，早点下班。让代码易于维护就得借助重构来完成。

近些年在项目中逐渐被「剥夺」了写代码的权利，看代码和定位问题的时间超过了写代码，从工作中得到的乐趣少了很多。希望重拾重构，从编程中找回那久违的畅快淋漓。

      

实际收获没有预期大

猪头转世

2019-11-17 17:37:29

        

看完之后没有想象中那么大收获，主要原因：1. 书中很多技巧平时自己写代码已经在使用，学到的新技巧不多 2. 范例过于简单，无法准确的阐述重构手法的应用场景 3. 大部分前端项目没有机会进行重构，所以这本书最重要的价值对我来说有点鸡肋前端项目没有机会进行重构的原因：1. 前端大部分项目没有完善的自动化测试，代码一团浆糊，重构成本大于重写成本 2. 前端技术栈更新太快，一个项目往往几年之后就会重写或者没人用直接死掉，项目生命周期非常短 3. 已经上线的项目不太可能频繁进行重构，即使有完善的自动化测试，也无法保证不会改出 bug，出了问题谁背锅？

对于我来说，这本书的主要作用不是学会如何对既有代码进行重构，而是在代码编写阶段，减少有坏味道的代码。正如书中的一位推荐人「庄表伟」所说：学习《重构》是为了减少「重构」。

PS：以上观点只针对普通的前端项目，对于需要长期维护的中、大型前端项目和其他领域不一定适用

      

关于重构

prayjourney

2019-12-24 23:23:23

        

重构，为了在保持原有的代码功能的前提下，让我们的代码的逻辑更加明确，结构更加合理的一种代码重写技术，这些重写的技术，在 java 之上，与方法，类，字段紧密关联，和面向的对象的继承特性关联，我们要注意重复代码带来的问题，重复再很多情况下意味着有可以提升的空间，同时也有双倍的出错可能，我们在重构的时候，也要配合常用的设计模式来重构，这样使得我们的代码更加精良，虽然关键点在于方法，类，字段以及重复代码，这些级别，但是对于局部变量，条件分支等同样是我们可以有所发掘的地方。我们在重构的时候，一定要知道我们在做什么，我们要达到一种什么样的状态，同时也要知道，我们什么时候可以停下来。

      

很好，需要反复翻看

JiN

2009-11-23 21:26:52

《重构 -- 改善既有代码的设计》这本书半年前就买了，一直放在公司办公桌上面，一放就是半年，现在想想，真是罪过。

放了这么久才读，一方面是懒，疏忽了。另一个主要的原因是觉得这本书太理论化了，有点脱离现实。但是当我真正的读起来之后，我发现这本书并没有我想象中的那么理论化，可操作性还是很强的。

真正开始阅读的原因是工作的驱使，因为前面的工作是对一个现有项目进行重构工作，现有项目我也参与了设计开发，由于上一个项目时间紧迫，不管是设计还是编码方面都有很多的问题，正是一个很好的重构目标。现在想想还真是要感谢主管，让我有机会主持这次重构工作。

回到这本书上，这本书显然不是给刚刚编写程序的人写的，然而，这并不意味着初学者就不能从书中吸收到营养，只是会打些折扣。因为初学者不可能百分百理解所有的重构策略，但是可以学习到很多的代码准则，例如：不要使用太过长的函数，如果有将其分解；不要引入过多的临时变量等等。

如果学习过设计模式，而且有不错的项目 / 编码经验，能从这书中吸收到更多的营养，阅读起来的难度也会小很多，当然本来难度就不大，这本书很吸引人。

随着这本书的阅读以及项目中重构工作的逐渐开展，我就越体会到书中提到的：这些小的方法看起来不能使我看的更远，不能帮助我设计，但是当你按照规范进行操作之后，你就会发现，你看的更清晰了，看的更远了，设计也就随着而来了。

随着重构工作的开展，还有一个体会也随之加深，就是很多的设计并不是项目之初凭空想象出来的，而是逐渐重构，逐渐重构出来的，好像在哪里看过这样的话，对此我更加深信不疑了。

VS 中还有一个插件挺好用的，CodeRush+Refactor, 当然还有 Resharper 也不错，我用的是 CR，帮助我进行重构的。

有理论，有实践，但仍不实用

八爷

2009-12-27 17:53:32

此书总结了不少代码的问题及重构的方法，对于设计与编程的见解相当正确，但难免流于俗套 - 大道理谁都懂，但知易行难永远是硬道理，尤其其对于每种情况进行重构的极其繁冗的步骤描述，实在是相当的不高明，本人认为这是本书的一个败笔，但其后对于重构自动化工具的介绍则是黑暗中的一道阳光 - 我们需要这种工具。（目前来看 Visual Studio 的插件 VA 的重构功能最为好用，但却还是远远不够）

对于软件重构的一些想法：

http://www.debuggingnow.com/blog/2009/12/some-thoughts-on-large-scaled-software-refactoring.html

      

程序员应知 —— 也说重构

志敏荐书

2011-05-25 09:15:13

从 Martin Fowler 最早提出重构的概念开始，到现在已经有很长时间了，重构已经是深入忍心了。与其说它是一种方法，不如说是一种思想、一种习惯。我自己在工作的过程中也一直在使用它来改进自己的程序，所以在此想说说自己的两点认识。

重构不「挑食」

上面已经提到，重构不仅仅是固定的那些方法，而更是一种思想和编码时候的习惯，所以，不管你是用那种语言编程，都可以应用重构。《重构》那本书上的例子都是 Java 的，可能很多人会觉得，只有在 Java、C# 等面向对象的语言中，才能够使用重构的方法，而在面向过程和函数式的语言中，就很难应用重构了。我认为并非如此，的确，在面向对象的语言中，有很多特定的重构方法，比方说抽取接口、变量上移、变量下移等等，但还是有一些通用的重构方法，可以在各种语言中使用。

举两个最常见的例子：重命名和抽取方法。这两个方法不论在什么语言的编程下面都是非常常用的，我们也经常会做这样的重构。比方说我在使用 pl/sql 编写 procedure 和 function 的时候，就经常会做这样的操作。特别是当 pl/sql developer 的新版本中增加了重构的选项，能够帮我们更好地自动完成重构的操作。在这里，pl/sql 这门语言可是过程化的，而非面向对象的。

所以说，我们可以在编写任何代码的过程中都可以使用重构，甚至在 HTML 代码中、JavaScript 代码中等等，都可以使用，因为重构不仅仅是具体的方法，而是一种改善代码，改善系统的一种思想，它的目的就在于让我们的系统的可读性、可维护性更高，从而具有更好的质量。

重构可以随时进行

Martin Fowler 的《重构》一书还有个副标题，叫做「改善既有代码的设计」，这让我在当初产生了一点儿误会，还以为重构只能是在把代码写完了之后才能够进行的。其实不然，我们可以随时对程序进行重构，（我曾经在内部的交流中把它叫做行进中的重构，呵呵）那样会更有利于之后的编码。

比方说，在编写程序的过程中，忽然发现有一个变量的命名有些不合理，我们可以立即对其进行重构，修改名称；或者更实用的，发现自己接下来要写的代码完全是之前代码的重复，或者说可以从别处 copy，然后稍作修改就可以，那么我们就可以回头把之前的方法抽取出来，而在新的位置直接调用；或者发现想要使用某个方法，但它位于其它类中，就可以想是否可以提取父类或者接口，然后把通用的方法提取到其中，然后再对其进行继承或者实现，那样就可以方便地调用方法了。

还有很多很多的方法，都是可以在编码的过程之中就可以做的，而不需要等所有的编码完成了之后才做。那样的好处是显而易见的，在之后如果再需要实现类似的功能，就可以直接调用已有的方法，而不需要等最后再做调整了。

总之，越是使用，越是觉得在编程的过程中应该始终把「重构」的思想放在头脑中，随时拿出来使用。

你对于重构是否也有想说的话呢？

摘自：

http://blog.csdn.net/lingyun2005/archive/2010/12/08/6062149.aspx

      

精益求精

杰良

2013-07-07 03:15:15

看似都是些很简单的处理代码的方法，Fowler 一讲马上就明白了。偶尔会涉及到一些面向对象技术需要花点心思去理解，当然，这个本来就是编程的基本。还有就是用到某些设计模式，这个去参考一下四人帮的《设计模式》就好。

我想说的是，我很喜欢书本里传递出来的对于追求编写优秀代码的态度。精益求精。作者 Fowler 对重构手法的描述相当的条理清晰，而且基本都有使用范例。而且书本还有专门整理的手法列表，使用起来很方便。所以整本书，这次看完后，以后大致就会把它作为一本工具书来用了。

目前只是了解了那些方法。还需要其探索清楚的是，进行程序开发时什么时候应该开始重构，那里需要重构。再进一步就是，把重构融入程序开发过程当中，编程一个一个的习惯。就是所谓的融会贯通吧。另一方面是，面对不同的语言、IDE，去熟悉运用各种重构工具。这将大大地提高开发效率。

想起了另外一本书，《修改代码的艺术》。很相似。目的都是让既有的程序代码变得更好。重构手法对代码的修改比较保守一点，不会改变代码的外在表现。《修改代码的艺术》面对的情况要更糟糕一些，必须要进行一些较大动作的修改。为了保证修改的顺畅进行，首先需要引入完备的针对性测试。

练就那些技能，不是某一天能够做到的事情。而是一种持续的过程，秉持着精益求精的理念，对这些技术越来越纯熟。从零开始，就像一个修炼过程。更多的还是需要在实践过程中去学习。

杰良 - 2013-07-07

<<Refactoring: Improving the Design of Existing Code>>

吃西瓜放糖

2019-01-24 23:15:34

        

上次读这本书是在 2011 年，又读了一遍，做点记录。

书本主要讲如何以一种可控制且高效的方式进行重构。作者 Martin Fowler，Kent Beck 出现多次。

第二章「重构原则」和第三章「代码的坏味道」是重点，可以多读几遍。

如果你发现自己需要为程序添加一个特性，二代码结构使你无法很方便地达成目的，那就先重构程序，使添加特性更容易，然后再添加特性。

重构的第一步：为即将修改的代码构建一组可靠的单元测试。

任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。

重构是对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高可读性，降低修改成本。

重构目的：提高代码可读性，降低修改成本，改进软件设计。

两顶帽子：添加新功能和重构。任意时刻，两者不该同时进行。即，每个 commit 中只干一种事。

如果没有重构，程序的设计会逐渐腐败变质。当人们只为短期目的，或是在完全理解整体设计之前，就贸然修改代码，程序将逐渐失去自己的结构。程序员越来越难通过阅读源代码而理解原来的设计。重构很像是在整理代码，你所做的就是让所有东西回到应该处的位置。代码结构的流失是累积性的。越难看出代码所代表的设计意图，就越难保护其中设计，于是该设计就腐败得越快。经常性的重构可以帮助代码维护自己该有的形态。

重构让软件更容易理解，并理解的更深。

重构帮助找到 bug。

重构提高编程速度。

何时重构：1. 修补 bug 时。2. code review。3. 添加新功能觉得不好添加时。

重构与设计：重构可以取代预先设计，极限编程的支持者极力提倡这种办法。但这不是最有效的途径，因为极限编程的爱好者们也会进行预先设计。

重构改变了预先设计的角色。需要提前设计，但有了重构，不一定必须设计正确。后期可以通过重构修复软件设计上的问题。

重构与性能：先重构，如果有性能问题，先做性能分析，找出热点，再重构。

第三章，代码的坏味道（bad smell)

如果尿布臭了，就换掉它。

1. Duplicated Code2. Long Method: 每当感觉需要以注释来说明什么的时候，吧需要说明的东西写进一个单独函数中，并以其用途（而非实现手法）命名。3. Large Class4. Long Parameter List5. Divergent Change：保证每个对象只因一种变化需要修改 6. Shotgun Surgery7. Feature Envy: 函数对某个类的兴趣高过对自己所处类的兴趣 8. Data Clumps9. Primitive Obsession10. Switch Statements11. Parallel Inheritance Hierarchies12. Lazy Class13. Speculative Generality14. Temporary Field15. Message Chains16. Middle Man17. Inappropriate Intimacy18. Alternative Classes with Different Interfadces19. Incomplete Library Class20. Data Class21. Refused Bequest22. Comments：注释该做什么：TODO / 可能的担忧 / 为什么如此实现

至于具体如何重构，这里就不记录了。多实践，多做 Code Review。

      

很适合用于代码级的设计和技巧

LeslieGu

2006-03-13 11:52:24

好的程序应该是不段重构出来的，里面给了不少方法，部分会经常使用的，这本书我只是大概翻翻，当时看得英文版的，在这里你也会明白为什么现在开发软件都要险些测试！

经典作品重装上阵

hanson

2010-04-17 19:27:47

纸张很赞，只是排版松散，书就比较厚了。

本人对代码有洁癖，不自觉的一直会调整过去的代码，也需要对照大师总结的规律反思一下。

重构的基础能力在于能够嗅出代码中的坏味道（Bad smell），甚至反模式（Anti-pattern），因此要结合相关书籍一起阅读了。

最近在看的肖鹏一篇文章也不错：

九种不够面向对象的对象

http://www.cnblogs.com/designpatterns/archive/2009/07/04/nine-non-oo-o.html

      

感觉

舀点米

2013-01-30 00:24:17

看过之后，我才懂得要重构代码。并且学到不少方法和技巧。但是，发现看一遍是不够的，很多还是在实践时想不起来，抽空再来一次。

当时看的时候，还在用 JAVA，对程序理解还是很少的。现在改用 PYTHON 了，下次看的时候，把里面重构代码片断都用 PYTHON 实现一遍，并看看是否都能通用或需要改变的。

理论结合实践，可能才是最好的学习方法吧。

