## 01. 软件构建的核心就是管理复杂度

mijia

2006-05-19 17:55:03

啊，也不知道多少天了，终于啃完了大部头 Code Complete。经典就是经典，确实受益匪浅。

总结一下，其实让我记忆深刻的主要是两点：

首先，软件构建的核心就是管理复杂度。虽然书中有不少的篇幅来讨论变量、语句等等这些编程的基本要素，还包括代码改善和调整的策略和方法，可谓不无巨细。不过深入理解一下，这些内容都是围绕着上面这句话展开的，也就是软件构建的核心就是管理复杂度。而这一目标产生的根源就在于人脑智力同软件项目复杂程度之间的矛盾。书中常常会提到几个数字，差不多在 6、7 左右变化，因为这是人脑智力管理的极限，多了，就管不过来了，呵呵。所以，书中会有一些结论性的建议。比如构建可工作的类，内部成员应该控制在 7 (+-) 2，也就是 5 个或者 9 个左右，如果都是 Native Type 的话，9 个成员变量能管的过来，如果都是对象成员的话，5 个也能保证你的头脑始终清晰。还有，比如程序中的嵌套结构，类似于 If，循环啊什么的，要保持嵌套层次不能多于 6 层，而据实际调查，一般 3 层以上的嵌套就会使程序员非常的困惑和抓狂了；还有比如子程序的参数个数尽量保持在 7 个以下，要不然也记不住，别说 7 个了，没有现代 IDE 的帮助，我连 4 个以上的参数我都记不住，呵呵。

我想满足这些指标并不是很难的事情，而这些东西也给出了对于代码进行改善时候可以依据的标准。不过想要管理这种复杂度，从作者的书中总结一下，具体可能是以下几点：第一，分割，既然大脑管不过来，那就把系统进行分割，也就是从设计角度上抽象出若干部分，每次让大脑 focus 在一个部分上，这点我是有深刻体会，虽然我现在完全自己做的东西超不过 15000 行，不过也不能妄想自己把所有的部分都记住，如果抽象的不好的话，我就特别头疼，每天在代码中翻来翻去的，效率非常低；第二，清晰理解，其实这点跟上面一点是差不多的，只有清晰理解了抽象的含义，才能做好每个封装每个接口，这样在关注别的抽象部分的时候，其他部分需要记住和管理的更清晰也更简洁，因为不需要关注其他部分是如何实现的，只要按照接口和抽象来做就好了；第三，清晰表达，在程序中应该清晰表达逻辑和抽象含义，也就是增加程序的可读性，唉，这点太重要了，书上也围绕着这个不断的论述，上面提到那些事无巨细的部分反复的说着这一点，甚至连命名都有专门的一章来讨论。

 

第二点我觉得记忆深刻的就是：以程序员为本。可惜国内的我见过的企业做不到这些。其实以程序员为本不是说一个公司的文化，也不是说单纯就是项目管理人员的事情，其实，最底层的程序员也应当遵从这一条。代码首先是为了人而写的，不是为了机器。机器只会对机器码感兴趣，高级语言自然是留给人来看的。所以说，即便是最底层的程序员也应当奉行这一条，合作中更讲究这个。呵呵，话题又回到了上面提过的可读性的问题。当然，以程序员为本也可以延伸到企业文化或者项目组文化，毕竟在这个过程中，程序员追求的技术满足程度外行可能无法理解，不过理解起来也很容易，就像画家对于自己的油画，建筑师对于自己的建筑那种感觉。

 

「Programming is neither fully an art nor fully a science. As it's typically practiced, it's a "craft" that's somewhere between art and science. At its best, it's an engineering discipline that arises from the synergistic fusion of art and science.」现在我的理解，恰恰是这种艺术与科学相互融合的产物带给程序员无比的满足感。

## 02. 《代码大全》—— 软件开发的世界地图

庄表伟

2006-05-05 10:07:25

我有很浓厚的「地图情结」，以前我写过一篇《我的信仰地图》，最近又做了一次关于 Ajax 的演讲，名字叫做《Ajax 技术地图》。我一直以来的观点是，世界是一个整体，在这个巨大的世界之中，任何事物、任何知识，任何观点，都有其合理、自然的位置。理解这个世界的过程，就是逐步将需要了解的各种事物，在作为整体的一个世界中，找到其位置。了解这个位置的前后左右，相互关系，相互影响。这样的理解世界的学习方式，我认为是最为有效的。所以当我在 JavaEye 看到关于《代码大全》的广告时，我的第一反应就是：这不是世界地图吗？

 

看了看他的目录，竟然有 35 章之多？架构、分析、设计、编程、测试、重构、面向对象、调试、规范、管理、软件质量控制、协作、优化、开发工具、注释、甚至个性、开发艺术等等等等，只要是与软件有关的，基本上他都写到了。

 

说实话，我当时相当的不屑...... 可能吗？居然有这么一个家伙，能够像当年的托马斯·阿奎那一样，以一己之力，写出《神学大全》？CSDN 的网站上介绍这个 Steve McConnell，在 1998 年的时候，被 Software Development 杂志的读者评为软件业最具影响力的三大人物之一，与 Bill Gates、Linus Torvalds 齐名。一个写书的，能和两个写代码的天才齐名？网站上的那些推荐的话，个个都是大名鼎鼎，个个都是推崇备至。作为我这样一个有逆反心里的家伙来说，直觉上就是：「会不会呀，有这么牛吗？」

 

当然了，我也不好多说什么，毕竟没有看过书～～～

 

没想到好事居然找上门来了，博文视点的魏泉是我要写的那本 Ajax 书的责任编辑。而《代码大全》也是他们负责出版的。那天他找到我，说是让我看看这本书的书稿…… 看看能不能写一篇书评。这等美差，我很爽快的就答应下来了。

 

一看之下，果然是很喜欢，作者的思考问题的方式，与我的方式相当的接近，都是尽可能将多种、甚至矛盾的事物，放在一个整体的环境中来理解。比如对于隐喻，用于描述软件开发的特征的各种各样的隐喻，其实各有其价值，如果能够组合运用，自然能够获得一种平衡。正如作者所说：「使用隐喻又是件说不清楚的事情（fuzzy business）。你需要适当地引申它的含义，才能从其中蕴含的深刻启发中受益。但若你过分地或者在错误的方向上引申了它的含义，它也会误导你。正如人们会误用任何强大的工具一样，你也可能误用隐喻，但它的强大的功效，还是会成为你智慧工具箱中的一个宝贵部分。」

 

这样的一种看法，可以说「中正平和、深具智慧」，这是我们在大多数关于软件开发的论述中，很难看到的。

 

再比如说，作者在第三章时给出的一个表格：三种常见的软件项目种类，及其典型的良好实践。就将软件分为商业系统、性命攸关的系统以及性命攸关的嵌入式系统。然后指出对于这三类不同的应用，在开发手段、管理强度、设计、构建、测试、部署等等方面的差别化策略。这样的分类，自然就避免了将各种开发手段，简单的对立起来比较的方法，显得更加具有说服力。

 

再比如说，全书给出了相当多的 Check List，这样的表格，实在是大有益处，借用地图的隐喻来书，这样的 CheckList，就是一个一个的定位器，它能够帮助你认清自己的位置，了解问题所属的范畴，了解应该努力的大致方向。这样的「开发工具」，真是独一无二。

 

这本书我目前只看了前面的 5～6 章，实在没有太多的发言权，不过我现在已经可以肯定，这是一本非常有价值的好书，我推荐所有没有看过的朋友去看看这本名副其实的经典之作。

 

说实话，天下没有免费的午餐，我这篇书评，也是属于交差之作。人家出版社把样书给你看，请你写书评，当然希望你能说些好话幸运的是，这些好话，的确都是我自己愿意说的。

代码大全中英文要点

rocedu

2006-09-19 09:57:59

《代码大全》是一本不多见的值得多次阅读的好书，在《代码大全》一书中，每一章后面都有这一章的要点，略读这些要点中我们就可以了解到我们已经掌握了哪些知识，哪些知识还没有掌握，阅读，重读时就有重点了。下面列出这些要点，供没有购买这本书的同学（同仁）参考，或可用作决定「是否应该买这本书」的参考。

第 1 章 欢迎进入软件构建的世界

中文要点：

	软件构建是软件开发的核心活动；构建活动是每个项目中唯一一项必不可少的工作.

	软件构建的主要活动包括：详细设计，编码，调试，集成，开发者测试 (包括单元测试和集成测试).

	构建也常被称作 "编码" 和 "编程".

	构建活动的质量对软件的质量有着实质性的影响.

	最后，你对 "如何进行构建" 的理解程度，决定了你这名程序员的优秀程度.

English Key Points：

	Software construction the central activity in software development;construction is the only activity that’s guaranteed to happen on every project.

	The main activities in construction are detailed design, coding, debugging, and developer testing.

	Other common terms for construction are「coding and debugging」and「programming.」

	The quality of the construction substantially affects the quality of the software.

	In the final analysis, your understanding of how to do construction determines how good a programmer you are, and that’s the subject of the rest of the book.

第 2 章 用隐喻来更充分的理解软件开发

中文要点：

	隐喻是启示而不是算法。因此它们往往有一点随意 (sloopy).

	隐喻把软件开发过程与其他你熟悉的活动联系在一起，帮助你更好的理解.

	有些隐喻比其他一些隐喻更贴切.

	通过把软件的构建过程比作是房屋的建设过程，我们可以发现，仔细的准备是必要的，而大型项目和小型项目之间也是有差别的。

	通过把软件开发中的实践比作是智慧工具箱中的工具，我们又发现，每位程序员都有许多工具，但并不存在任何一个能适用于所有工作的工具，因地制宜的选择正确工具是成为能有效编程的程序员的关键。

	不同的隐喻彼此并不排斥，应当使用对你最有益处的某种隐喻组合。

English Key Points：

	Metaphors are heuristics, not algorithms. As such, they tend to be a little sloppy.

	Metaphors help you understand the software-development process by relating it to other activities you already know about.

	Some metaphors are better than others.

	Treating software construction as similar to building construction suggests that careful preparation is needed and illuminates the difference between large and small projects.

	Thinking of software-development practices as tools in an intellectual toolbox suggests further that every programmer has many tools and that no single tool is right for every job. Choosing the right tool for each problem is one key to being an effective programmer.

	？

第 3 章 三思而后行：前期准备

中文要点：

	构建活动的准备工作的根本目标在于降低风险。要确认你的准备活动是在降低风险，而非增加风险。

	如果你想开发高质量的软件，软件开发过程必须由始至终关注质量。在项目初期关注质量，对产品质量的正面影响比在项目末期关注质量的影响要大。

	程序员的一部分工作是教育老板和合作者，告诉他们软件开发过程，包括在开始编程之前进行充分准备的重要性。

	你所从事的软件项目的类型对构建活动的前期准备有重大影响 —— 许多项目应该是高度迭代式的，某些应该是序列式的。

	如果没有明确的问题定义，那么你可能会在构建期间解决错误的问题。

	如果没有做完良好的需求分析工作，你可能没能察觉待解决的问题的重要细节。如果需求变更发生在构建之后的阶段，其代价是「在项目早期更改需求」的 20 至 100 倍。因此在开始编程之前，你要确认「需求」已经到位了。

	如果没有做完良好的架构设计，你可能会在构建期间用错误的方法解决正确的问题。架构变更的代价随着「为错误的架构编写的代码数量」增加而增加，因此，也要确认「架构」已经到位了。

	理解项目的前期准备所采用的方法，并相应地选择构建方法。

English Key Points：

	The overarching goal of preparing for construction is risk reduction. Be sure your preparation activities are reducing risks, not increasing them.

	If you want to develop high-quality software, attention to quality must be part of the software-development process from the beginning to the end. At tention to quality at the beginning has a greater influence on product quality than attention at the end.

	Part of a programmer’s job is to educate bosses and coworkers about the software-development process, including the importance of adequate preparation before programming begins.

	The kind of project you’re working significantly affects construction prerequisites—many projects should be highly iterative, and some should be more sequential.

	If a good problem definition hasn’t been specified, you might be solving the wrong problem during construction.

	If a good requirements work hasn’t been done, you might have missed important details of the problem. Requirements changes cost 20 to 100 times as much in the stages following construction as they do earlier, so be sure the requirements are right before you start programming.

	If a good architectural design hasn’t been done, you might be solving the right problem the wrong way during construction. The cost of architectural changes increases as more code is written for the wrong architecture, so be sure the architecture is right too.

	Understand what approach has been taken to the construction prerequisites on your project and choose your construction approach accordingly.

第 4 章 关键的「构建」决策

中文要点：

	每种编程语言都有其优点和弱点。要知道你使用的语言的明确优点和弱点。

	在开始编程之前，做好一些约定（convention）。「改变代码使之符合这些约定」是近乎不可能的。

	「构建的实践方法」的种类比任何单个项目能用到的要多。有意识地选择最适合你的项目的实践方法。

	问问你自己，你采用的编程实践是对你所用的编程语言的正确响应，还是受它的控制？请记得「深入一种语言去编程」，不要仅「在一种语言上编程」。

	你在技术浪潮中的位置决定了哪种方法是有效的 —— 甚至是可能用到的。确定你在技术浪潮中的位置，并相应调整计划和预期目标。

English Key Points：

	Every programming language has strengths and weaknesses. Be aware of the specific strengths and weaknesses of the language you’re using.

	Establish programming conventions before you begin programming. It’s nearly impossible to change code to match them later.

	More construction practices exist than you can use on any single project.Consciously choose the practices that are best suited to your project.

	?

	Your position on the technology wave determines what approaches will be effective—or even possible. Identify where you are on the technology wave, and adjust your plans and expectations accordingly.

第 5 章 软件构建中的设计

中文要点：

	软件的首要技术使命就是管理复杂度。以简单性作为努力目标的设计方案对此最有帮助。

	简单性可以通过两种方式来获取：一是减少在同一时间所关注的本质性复杂度的量，二是避免生成不必要的偶然的复杂度。

	设计是一种启发式的过程。固执于某一种单一方法会损害创新能力，从而损害你的程序。

	好的设计都是迭代的。你尝试设计的可能性越多，你的最终设计方案就会变得越好。

	信息隐藏是个非常有价值的概念。通过询问「我应该隐藏些什么？」能够解决很多困难的设计问题。

	很多有用有趣的、关于设计的信息存在于本书之外。这里所给出的观点只是对这些有价值资源的一点提示而已。

English Key Points：

	Software’s Primary Technical Imperative is managing complexity. This is accomplished primarily through a design focus on simplicity.

	Simplicity is achieved in two general ways: minimizing the amount of essential complexity that anyone’s brain has to deal with at any one time and keeping accidental complexity from proliferating needlessly.

	Design is heuristic. Dogmatic adherence to any single methodology hurts creativity and hurts your programs.

	Good design is iterative; the more design possibilities you try, the better your final design will be.

	Information hiding is a particularly valuable concept. Asking,「What should I hide?」settles many difficult design issues.

	Lots of useful, interesting information on design is available outside this book. The perspectives presented here are just the tip of the iceberg.

第 6 章 可以工作的类

中文要点：

	类的接口应提供一致的抽象。很多问题都是由于违背该原则而引起的。

	类的接口应隐藏一些信息――如某个系统接口、某项设计决策、或一些实现细节。

	包含往往比继承更为可取――除非你要对「是一个 /is a」的有关系建模。

	继承是一种有用的工具，但它却会增加复杂度，这有违于软件的首要技术使命――管理复杂度。

	类是管理复杂度的首选工具。要在设计类时给予足够的关注，才能实现这一目标。

English Key Points：

	Class interfaces should provide a consistent abstraction. Many problems arise from violating this single principle.

	A class interface should hide something—a system interface, a design decision, or an implementation detail.

	Containment is usually preferable to inheritance unless you’re modeling an「is a」relationship.

	Inheritance is a useful tool, but it adds complexity, which is counter to the Primary Technical Imperative of minimizing complexity.

	Classes are your primary tool for managing complexity. Give their design as much attention as needed to accomplish that objective.

第 7 章 高质量的子程序

中文要点：

	创建子程序最主要的目的是提高程序的可管理性，当然也有其他一些好的理由。其中，节省代码空间只是一个次要原因：提高可读性、可靠性和可修改性等原因都更重要一些。

	有时候，把一些简单的操作写成独立的子程序也非常有价值。

	子程序可以按照其内聚性分为很多类，而你应该让大多数程序具有功能上的内聚性，这是最佳的一种内聚性。

	子程序的名字是它的质量的指示器。如果名字糟糕但恰如其分，那就说明这个子程序设计得很差劲。如果名字糟糕而且又不准确，那么它就反映不出程序是干什么的。不管怎样，糟糕的名字都意味着程序需要修改。

	只有在某个子程序的主要目的是返回由其名字所描述的特定结果时，才应该使用函数。

	细心的程序员会非常谨慎地使用宏，而且只在万不得已时才用。

English Key Points：

	The most important reason to create a routine is to improve the intellectual manageability of a program, and you can create a routine for many other good reasons. Saving space is a minor reason; improved readability, reliability, and modifiability are better reasons.

	Sometimes the operation that most benefits from being put into a routine of its own is a simple one.

	The name of a routine is an indication of its quality. If the name is bad and it’s accurate, the routine might be poorly designed. If the name is bad and it’s inaccurate, it’s not telling you what the program does. Either way, a bad name means that the program needs to be changed.

	Functions should be used only when the primary purpose of the function is to return the specific value described by the function’s name.

	Careful programmers use macro routines and inline routines with care, and only as a last resort.

第 8 章 防御式编程

中文要点：

	最终产品代码中对错误的处理方式要比「垃圾进，垃圾出」复杂的多。

	防御式编程技术可以让错误更容易发现、更容易修改，并减少错误对产品代码的破坏。

	断言可以帮助人尽早发现错误，尤其是在大型系统和高可靠性的系统中，以及快速变化的代码中。

	关于如何处理错误输入的决策是一项关键的错误处理决策，也是一项关键的高层设计决策。

	异常提供了一种与代码正常流程角度不同的错误处理手段。如果留心使用异常，它可以成为程序员们知识工具箱中的一项有益补充，同时也应该在异常和其他错误处理手段之间进行权衡比较。

	针对产品代码的限制并不适用于开发中的软件。你可以利用这一优势在开发中添加有助于更快地排查错误的代码。

English Key Points：

	Production code should handle errors in a more sophisticated way than「garbage in, garbage out.」

	Defensive-programming techniques make errors easier to find, easier to fix, and less damaging to production code.

	Assertions can help detect errors early, especially in large systems, high reliability systems, and fast-changing code bases.

	The decision about how to handle bad inputs is a key error-handling decision, and a key high-level design decision.

	Exceptions provide a means of handling errors that operates in a different dimension from the normal flow of the code. They are a valuable addition to the programmer’s toolkit when used with care, and should be weighed against other error-processing techniques.

	Constraints that apply to the production system do not necessarily apply to the development version. You can use that to your advantage, adding code to the development version that helps to flush out errors quickly.

第 9 章 伪代码编程过程

中文要点：

	创建类和子程序通常都是一个迭代的过程。在创建子程序的过程中获得的认识常常会反过来影响类的设计。

	编写好的伪代码需要使用易懂的英语，要避免使用特定程序语言中才有的特性，同时要在意图的层面上写伪代码（即描述该做什么，而不是要怎么去做）。

	伪代码编程过程是一个行之有效的做详细设计的工具，它同时让编码工作更容易。伪代码会直接转化为注释，从而确保了注释的准确度和实用性。

	不要只停留在你所想到的第一个设计方案上。反复使用伪代码做出多种方案，然后选出其中最佳的一种方案再开始编码。

	每一步完成后都要检查你的工作成果，还要鼓励其他人帮你来检查。这样你就会在投入精力最少的时候，用最低的成本发现错误。

English Key Points：

	Constructing classes and constructing routines tends to be an iterative process. Insights gained while constructing specific routines tend to ripple back through the class’s design.

	Writing good pseudocode calls for using understandable English, avoiding features specific to a single programming language, and writing at the level of intent—describing what the design does rather than how it will do it.

	The Pseudocode Programming Process is a useful tool for detailed design and makes coding easy. Pseudocode translates directly into comments,ensuring that the comments are accurate and useful.

	Don’t settle for the first design you think of. Iterate through multiple approaches in pseudocode and pick the best approach before you begin writing code.

	Check your work at each step and encourage others to check it too. That way, you’ll catch mistakes at the least expensive level, when you’ve invested the least amount of effort.

第 10 章 使用变量的一般事项

中文要点：

	数据初始化过程很容易出错，所以请用本章描述的初始化方法来避免由于非预期的初始值而造成的错误。

	最小化每个变量的作用域。把同一变量的引用点集中在一起。把变量限定在或类的范围之内。避免使用全局数据。

	把使用相同变量的语句尽可能集中在一起。

	早期在绑定会减低灵活性，但有助于减小复杂度。晚期绑定可以增加灵活性，同时增加复杂度。

	把每个变量用于唯一的用途。

English Key Points：

	Data initialization is prone to errors, so use the initialization techniques described in this chapter to avoid the problems caused by unexpected initial values.

	Minimize the scope of each variable. Keep references to it close together. Keep it local to a routine or class. Avoid global data.

	Keep statements that work with the same variables as close together as possible.

	Early binding tends to limit flexibility, but minimize complexity. Late binding tends to increase flexibility, but at the price of increased complexity.

	Use each variable for one and only one purpose.

第 11 章 变量名的力量

中文要点：

	好的变量名是提高程序可读性的一项关键要素。对特殊种类的变量，比如循环下标和状态变量，需要加以特殊的考虑。

	名字要尽可能地具体。那些太模糊或者太能用以致于能够用于多种目的的名字通常都是很不好的。

	命名规则应该能够区分局部数据、类数据和全局数据。它们还应当可以区分类型名、具名常量、枚举类型名字和变量名。

	无论做哪种类型项目，你都应该采用某种变量命名规则。你所采用的规则的种类取决于你的程序的规模，以及项目成员的人数。

	现代编程语言很少需要用到缩写。如果你真的要使用缩写，请使用项目缩写词典或者标准前缀来帮助理解缩写。

	代码阅读的次数远远多于编写的次数。确保你所取的名字更侧重于阅读方便而不是编写方便。

English Key Points：

	Good variable names are a key element of program readability. Specific kinds of variables such as loop indexes and status variables require specific considerations.

	Names should be as specific as possible. Names that are vague enough or general enough to be used for more than one purpose are usually bad names.

	Naming conventions distinguish among local, class, and global data. They distinguish among type names, named constants, enumerated types, and variables.

	Regardless of the kind of project you’re working on, you should adopt a variable naming convention. The kind of convention you adopt depends on the size of your program and the number of people working on it.

	Abbreviations are rarely needed with modern programming languages. If you do use abbreviations, keep track of abbreviations in a project dictionary or use the Standardized Prefixes approach.

第 12 章 基本数据类型

中文要点：

	使用特定的数据类型就意味着要记住适用于各个类型的很多独立的原则。用本章的核对表来确认你已经对觉问题做了考虑。

	如果你的语言支持，创建自定义类型会使得你的程序更容易修改，并更具有自描述性。

	当你用 typedef 或者其等价方式创建了一个简单类型的时候，考虑是否更应该创建一个新的类。

English Key Points：

	Working with specific data types means remembering many individual rules for each type. Use the checklist to make sure that you’ve considered the common problems.

	Creating your own types makes your programs easier to modify and more  self-documenting, if your language supports that capability.

	When you create a simple type using typedef or its equivalent, consider whether you should be creating a new class instead.

第 13 章 不常见的数据类型

中文要点：

	结构体可以使得程序更简单、更容易理解，以及更容易维护。

	每当你打算使用结构体的时候，考虑采用类是不是会工作的更好。

	指针很容易出错。用访问器子程序或类以及防御式编程实践来保护自己的代码。

	避免用全局变量，不只是因为它们很危险，还是因为你可以用其他更好的方法来取代它们。

	如果你不得不使用全局变量，那么就通过访问器来使用它。访问器子程序能为你带来全局变量所能带来的一切优点，还有一些额外的好处。

English Key Points：

	Structures can help make programs less complicated, easier to understand,and easier to maintain.

	Whenever you consider using a structure, consider whether a class would work better.

	Pointers are error prone. Protect yourself by using access routines or classes and defensive-programming practices.

	Avoid global variables, not just because they’re dangerous, but because you can replace them with something better.

	If you can’t avoid global variables, work with them through access routines.Access routines give you everything that global variables give you, and more.

第 14 章 组织直线型代码

中文要点：

	组织直线型代码的最主要原则是按照依赖关系进行排列。

	可以用好的子程序名、参数列表、注释，以及――如果代码足够重要――内务管理变量来让依赖关系变得更明显。

	如果代码之间没有顺序依赖关系，那就设法使相关的语句尽可以地接近。

English Key Points：

	The strongest principle for organizing straight-line code is order dependencies.

	Dependencies should be made obvious through the use of good routine names, parameter lists, comments, and—if the code is critical enough—housekeeping variables.

	If code doesn’t have order dependencies, keep related statements as close together as possible.

第 15 章 使用条件语句

中文要点：

	对于简单的 if-else 语句，请注意 if 子句和 else 子句的顺序，特别是用它来处理大量错误的时候。要确认正常的情况是清晰的。

	对于 if-then-else 语句串和 case 语句，选择一种最有利于阅读的排序。

	为了捕捉错误，可以使用 case 语句中的 default 子句 (默认子句)，或者使用 if-then-else 语句串中的最后那个 else 子句。

	各种控制结构并不是生来平等的。请为代码的每个部分选用最合适的控制结构。

English Key Points：

	For simple if-elses, pay attention to the order of the if and else clauses,especially if they process a lot of errors. Make sure the nominal case is clear.

	For if-then-else chains and case statements, choose an order that maximizes  readability.

	Use the default clause in a case statement or the last else in a chain of if then-elses to trap errors.

	All control constructs are not created equal. Choose the control construct that’s most appropriate for each section of code.

第 16 章 控制循环

中文要点：

	循环很复杂。保持循环简单将有助于别人阅读你的代码。

	操持循环简单的技巧包括：避免使用怪异的循环、减少嵌套层次、让入口和出口一目了然、把内务操作代码放在一起。

	循环下标很容易被滥用。因此命名要准确，并且要把它们各自仅用于一个用途。

	仔细地考虑循环，确认它在每一种情况下都运行正常，并且在所有可能的条件下都能退出。

English Key Points：

	Loops are complicated. Keeping them simple helps readers of your code.

	Techniques for keeping loops simple include avoiding exotic kinds of loops, minimizing nesting, making entries and exits clear, and keeping housekeeping code in one place.

	Loop indexes are subjected to a great deal of abuse. Name them clearly and use them for only one purpose.

	Think the loop through carefully to verify that it operates normally under each case and terminates under all possible conditions.

第 17 章 不常见的控制结构

中文要点：

	多个 return 可以增强子程序的可读性和可维护性，同时可以避免产生很深的嵌套逻辑。但是使用它的时候要多加小心。

	递归能够很优雅地解决一小部分问题。对它的使用也要倍加小心　。

	在少数情况下，goto 是编写可读性和可维护性代码的最佳方法。但这种情况非常罕见。除非万不得忆，不要使用 goto.

English Key Points：

	Multiple returns can enhance a routine’s readability and maintainability, and they help prevent deeply nested logic. They should, nevertheless, be used carefully.

	Recursion provides elegant solutions to a small set of problems. Use it carefully, too.

	In a few cases, gotos are the best way to write code that’s readable and maintainable. Such cases are rare. Use gotos only as a last resort.

第 18 章 表驱动法

中文要点：

	表提供了一种复杂的逻辑和继承结构的替换方案。如果你发现自己对某个应用程序的逻辑或者继承树关系感到困惑，那么问问自己它是否可以通过一个查询表来加以简化。

	使用表的一项关键决策是决定如何去访问表。你可以采取直接访问、索引访问或者阶梯访问。

	使用表的另一项关键决策是决定应该把什么内容放入表中。

English Key Points：

	Tables provide an alternative to complicated logic and inheritance structures.If you find that you’re confused by a program’s logic or inheritance tree, ask yourself whether you could simplify by using a lookup table.

	One key consideration in using a table is deciding how to access the table.You can access tables using direct access, indexed access, or stair-step access.

	Another key consideration in using a table is deciding what exactly to put into the table.

第 19 章 一般控制问题

中文要点：

	使用布尔表达式简单可读，将非常有助于提高　你的代码质量。

	深层次的嵌套使得子程序变得难以理解。所幸的是，你可以相对容易地避免这么做。

	结构化编程是一种简单并且仍然适用的思想：你可以通过把顺序、选择和循环三者组合起来而开发出任何程序。

	将复杂降低到最低水平是编写高质量代码的关键。

English Key Points：

	Making boolean expressions simple and readable contributes substantially to the quality of your code.

	Deep nesting makes a routine hard to understand. Fortunately, you can avoid it relatively easily.

	Structured programming is a simple idea that is still relevant: you can build any program out of a combination of sequences, selections, and iterations.

	Minimizing complexity is a key to writing high-quality code.

第 20 章 软件质量概述

中文要点：

	开发高质量代码最终并没有要求你付出更多，只是你需要对资源进行重新分配，以低廉的成本来防止缺陷出现，从而避免代价高昂的修正工作。

	并非所有的质量保证目标都可以全部实现。明确哪些目标是你希望达到的，并就这些目标和团队成员进行沟通。

	没有任何一种错误检测方法能够解决全部问题，测试本身并不是排队错误的最有效方法。成功的质量保证计划应该使用多种不同的技术来检查各种不同类型的错误。

	在构建期间应当使用一些有效的质量保证技术，但在这之前，一些具有同样强大功能的质量保证技术也是必不可少的。错误发现越早，它与其余代码的纠缠就越少，由此造成的损失也越少。

	软件领域的质量保证是面向过程的。软件开发与制造业不一样，在这里并不存在会影响最终产品的重复的阶断，因此，最终产品的质量受到开发软件所用的过程的控制。

English Key Points：

	Quality is free, in the end, but it requires a reallocation of resources so that defects are prevented cheaply instead of fixed expensively.

	Not all quality-assurance goals are simultaneously achievable. Explicitly decide which goals you want to achieve, and communicate the goals to other people on your team.

	No single defect-detection technique is effective by itself. Testing by itself is not effective at removing errors. Successful quality-assurance programs use several different techniques to detect different kinds of errors.

	You can apply effective techniques during construction and many equally powerful techniques before construction. The earlier you find a defect, the less damage it will cause.

	Quality assurance in the software arena is process-oriented. Software development doesn’t have a repetitive phase that affects the final product like manufacturing does, so the quality of the result is controlled by the process used to develop the software.

第 21 章 协同构建

中文要点：

	协同开发实践往往能比测试发现更多的缺陷，并且更有效率。

	协同开发实践所发现错误的类型通常跟测试所发现的不同，这意味着你需要同时使用和测试来保证你软件的质量。

	正式检查通过运用核对表、准备工作、明确定义的角色以及对方法的持续改善，将缺陷侦测的效率提升至最高。它往往能比走查发现更多的缺陷。

	通常，结对编程拥有和详查相同的成本，并能产生质量相当的代码。当需要缩短开发周期的时候，结对编程就非常有价值。相对于单独工作来说，有些开发人员更喜欢结对工作。

	正式检查可以应用在除代码之外的很多工作成果上，例如需求、设计以及测试用例等。

	走查的代码阅是详查的替代方案。代码阅读更富有弹性，能有效地利用每个人的时间。

English Key Points：

	Collaborative development practices tend to find a higher percentage of defects than testing and to find them more efficiently.

	Collaborative development practices tend to find different kinds 674 nds of errors than testing does, implying that you need to use both reviews and testing to ensure the quality of your software.

	Formal inspections use checklists, preparation, well-defined roles, and continual process improvement to maximize error-detection efficiency. They tend to find more defects than walkthroughs.

	Pair programming typically costs about the same as inspections and produces similar quality code. Pair programming is especially valuable when schedule reduction is desired. Some developers prefer working in pairs to working solo.

	Formal inspections can be used on workproducts such as requirements, designs, and test cases as well as on code.

	Walkthroughs and code reading are alternatives to inspections. Code reading offers more flexibility in using each person’s time effectively.

第 22 章 开发者测试

中文要点：

	开发人员测试是完整测试策略的一个关键部分。独立测试也很重要，但这一主题超出了本书的范围。

	同编码之后编写测试用例相比较，编码开始之前编写测试用例，工作量和花费的时间差不多，但是后者可以缩短缺陷－侦测－调试－修正这一周期。

	即使考虑到了各种可用的测试手段，测试仍然只是良好软件质量计划的一部分。高质量的开发方法至少和测试一样重要，这包括尽可能减少需求和设计阶段的缺陷。在检测错误方面，协同开发的成效至少与测试相当。这些方法所检测错误的类型也不相同。

	你可以根据各种不同的思路来产生很多测试用例，这些思路包括基础测试、数据流分析、边界分析、错误数据类型以及正确数据类型等。你可以通过猜测错误的方式得到更多的测试用例。

	错误往往集中在少数几个容易出错的类和子程序上。找出这部分代码，重新设计和编写它们。

	测试数据本身出错的密度往往比被测代码还要高。查找这种错误完全是浪费时间，又不能对代码有所改善，因此测试数据里面的错误更加让人烦恼。要像代码一样小心地开发测试用例，这样才能避免产生这种问题。

	自动化测试总体来说是很有用的，也是进行回归测试的基础。

	从长远来看，改善测试过程的最好办法就是将其规范化，并对其进行评估，然后从评估中获得的经验教训来改善这个过程。

English Key Points：

	Testing by the developer is a key part of a full testing strategy. Independent testing is also important but is outside the scope of this book.

	Writing test cases before the code takes the same amount of time and effort as writing the test cases after the code, but it shortens defect-detection debug-correction cycles.

	Even considering the numerous kinds of testing available, testing is only one part of a good software-quality program. High-quality development methods, including minimizing defects in requirements and design, are at least as important. Collaborative development practices are also at least as effective at detecting errors as testing and detect different kinds of errors.

	You can generate many test cases deterministically using basis testing, data flow analysis, boundary analysis, classes of bad data, and classes of good data. You can generate additional test cases with error guessing. 

	Errors tend to cluster in a few error-prone classes and routines. Find that error-prone code, redesign it, and rewrite it.

	Test data tends to have a higher error density than the code being tested. Because hunting for such errors wastes time without improving the code, test-data errors are more aggravating than programming errors. Avoid them by developing your tests as carefully as your code.

	Automated testing is useful in general and essential for regression testing.

	In the long run, the best way to improve your testing process is to make it regular, measure it, and use what you learn to improve it.

第 23 章 调试

中文要点：

	调试同整个软件开发的成败息息相关。最好的解决之道是使用本书中介绍的其他方法来避免缺陷的产生。然而，花点时间来提高自己的调试技能还是很划算的，因为优秀和拙劣的调试表现之间的差距至少是 10:1。

	要想成功，系统化地查找和改正错误的方法至关重要。要声浪于你的调试工作，让每一次测试都能让你朝着正确的方向前进一步。要使用科学的调试方法。

	在动手解决问题之前，要理解问题的根本。胡乱猜测错误的来源和随机修改将会让你的程序陷入比刚开始调试时更为糟糕的境地。

	将编译器警告级别设置为最严格，把警告信息所报告的错误都改正。如果你忽略了明显的错误，那么要改正那些微妙的错误就会非常麻烦。

	调试工具对软件开发而言是强有力的支持手段。找出这些工具并加以应用，当然，请记得在调试的时候开动脑筋。

English Key Points：

	Debugging is a make-or-break aspect of software development. The best approach is to use other techniques described in this book to avoid defects in the first place. It’s still worth your time to improve your debugging skills, however, because the difference between good and poor debugging performance is at least 10 to 1.

	A systematic approach to finding and fixing errors is critical to success. Focus your debugging so that each test moves you a step forward. Use the Scientific Method of Debugging. 

	Understand the root problem before you fix the program. Random guesses about the sources of errors and random corrections will leave the program in worse condition than when you started.

	Set your compiler warning to the pickiest level possible, and fix the errors it reports. It’s hard to fix subtle errors if you ignore the obvious ones. 

	Debugging tools are powerful aids to software development. Find them and use them. Remember to use your brain at the same time.

第 24 章 重构

中文要点：

	修改程序是程序一生都要面对的事情，不仅包括最初的开发阶段，还包括首次发布之后。

	在修改中软件的质量要么改进，要么恶化。软件演化的首要法则就是代码演化应当提升程序的内存质量。

	重构成功之关键在于程序员应学会关注那些标志着代码需要重构的众多的警告或「代码臭味」。

	重要成功的另一要素是程序员应当掌握大量特定的重构方法。

	重构成功的最后要点在于要有安全重构的策略。一些重构方法会比其他重构的方法要好。

	开发阶段的重构是提升程序质量的最佳时机，因为你可以立刻让刚刚产生的改变梦想变成现实。请珍惜这些开发阶段的天赐良机！

English Key Points：

	Program changes are a fact of life both during initial development and after initial release.

	Software can either improve or degrade as it’s changed. The Cardinal Rule of Software Evolution is that internal quality should improve with age.

	One key to success in refactoring is learning to pay attention to the numerous warning signs or smells that indicate a need to refactor.

	Another key to success is learning numerous specific refactorings.

	A final key to success is having a strategy for refactoring safely. Some approaches to refactoring are better than others.

	Refactoring during development is the best chance you’ll get to improve your program, to make all the changes you’ll wish you’d made the first time.Take advantage of it!

第 25 章 代码调整策略

中文要点：

	性能只是软件整体质量的一个方面，通常不是最重要的。精细的代码调整也只是实现整体性能的一种方法，通常也不是决定性的。相对于代码本身的效率而言，程序的架构、细节设计以及数据结构和算法选择对程序的运行速度和资源占用的影响通常会更大。

	定量测量是实现性能最优化的关键。定量测量需要找出能真正决定程序性能的部分，在修改之后，应当通过重复测量来明确修改是提高还是降低了软件的性能。

	绝大多数的程序都有那么一小部分代码耗费了绝大部分的运行时间。如果没有测量，你不会知道是哪一部分代码。

	代码调整需要反复尝试，这样才能获得理想的性能提高。

	为性能优化工作做好准备的最佳方式就是在最初阶段编写清晰的代码，从而使代码在后续工作中易于理解和修改。

English Key Points：

	Performance is only one aspect of overall software quality, and it’s usually not the most important. Finely tuned code is only one aspect of overall performance, and it’s usually not the most significant. Program architecture, detailed design, and data-structure and algorithm selection usually have more influence on a program’s execution speed and size than the efficiency of its code does.

	Quantitative measurement is a key to maximizing performance. It’s needed to find the areas in which performance improvements will really count, and it’s needed again to verify that optimizations improve rather than degrade the software.

	Most programs spend most of their time in a small fraction of their code. You won’t know which code that is until you measure it. 

	Multiple iterations are usually needed to achieve desired performance improvements through code tuning.

	The best way to prepare for performance work during initial coding is to write clean code that’s easy to understand and modify.

第 26 章 代码调整技术

中文要点：

	优化结果在不同的语言、编译器和环境下有很大差异。如果没有对每一次的优化进行测量，你将无法判断优化到底是帮助还是损害了这个程序　。

	第一次优化通常不会是最好的。即使找到了效果很不错的，也不要停下扩大战果的步伐。

	代码调整这一话题有点类似于核能，富于争议，甚至会让人冲动。一些人认为代码调整损害了代码可读性和可维护性，他们绝对会将其弃之不用。其他人则认为只要有适当的安全保障，代码调整对程序是有益的。如果你决定使用本章所述的调整方法，请务必谨慎行事。

English Key Points：

	Results of optimizations vary widely with different languages, compilers, and environments. Without measuring each specific optimization, you’ll have no idea whether it will help or hurt your program.

	The first optimization is often not the best. Even after you find a good one, keep looking for one that’s better. 

	Code tuning is a little like nuclear energy. It’s a controversial, emotional topic. Some people think it’s so detrimental to reliability and maintainability that they won’t do it at all. Others think that with proper safeguards, it’s beneficial. If you decide to use the techniques in this chapter, apply them with care.

第 27 章 程序规模对构建的影响

中文要点：

	随着项目规模的扩大，交流需要加以支持。大多数方法论的关键点都在于减少交流中的问题，而一项方法论的存亡关键也应取决于它能否促进交流。

	在其他条件都相等的时候，大项目的生产率会低于小项目。

	在其他条件都相等的时候，大项目的每千行代码错误率会高于小项目。

	在小项目里的一些看起来「理当如此」的活动在大项目中必须仔细地计划。随着项目规模扩大，构建活动的主导地位逐渐降低。

	放大轻量级的方法论要好于缩小重量级的方法论。最有效的办法是使用「适量级」方法论。

English Key Points：

	As project size increases, communication needs to be supported. The point of most methodologies is to reduce communications problems, and a methodology should live or die on its merits as a communication facilitator.

	All other things being equal, productivity will be lower on a large project than on a small one.

	All other things being equal, a large project will have more errors per line of code than a small one.

	 Activities that are taken for granted on small projects must be carefully planned on larger ones. Construction becomes less predominant as project size increases.

	Scaling-up a light-weight methodology tends to work better than scaling down a heavy-weight methodology. The most effective approach of all is using a「right-weight」methodology.

第 28 章 管理构建

中文要点：

	好的编码实践可以通过「贯彻标准」或者「使用更为灵活的方法」来达到。

	配置管理，如果应用得当，会使程序序员的工作变得更加轻松。特别包括为变更控制。

	好的软件评估是一项重大挑战。成功的关键包括采用多种方法、随着项目的开展而修缮评估结果，以及很好地利用数据来创建评估等。

	度量是构建管理成功的关键。你可以采取措施度量项目的任何方面，而这要比根本不度量好的多。准确的度量是制定准确的进度表、质量控制和改进开发过程的关键。

	程序员和管理人员都是人，在把他们当人看的时候工作得最好。

English Key Points：

	Good coding practices can be achieved either through enforced standards or through more light-handed approaches.

	Configuration management, when properly applied, makes programmers’jobs easier. This especially includes change control.

	Good software estimation is a significant challenge. Keys to success are using multiple approaches, tightening down your estimates as you work your way into the project, and making use of data to create the estimates.

	Measurement is a key to successful construction management. You can find ways to measure any aspect of a project that are better than not measuring it at all. Accurate measurement is a key to accurate scheduling, to quality control, and to improving your development process.

	Programmers and managers are people, and they work best when treated as such.

第 29 章 集成

中文要点：

	构建的先后次序和集成的步骤会影响设计、编码、测试各类的顺序。

	一个经过充分思考的集成顺序能减少测试的工作量，并使用调试变容易。

	增量集成有若干变型，而且――除非项目是微不足道的――任何一种形式的增量集成都比阶段式集成好。

	针对每个特定的项目，最佳的集成步骤通常是自顶向下、自底向上、风险导向及其他集成方法的某种组合。T－型集成和竖直分块集成通常都能工作得很好。

	Daily build 能减少集成的问题，提升开发人员的士气，并提供非常有用的项目管理信息。

English Key Points：

	The construction sequence and integration approach affect the order in which classes are designed, coded, and tested.

	A well-thought-out integration order reduces testing effort and eases debugging.

	Daily builds can reduce integration problems, improve developer morale, and provide useful project management information.

	Incremental integration comes in several varieties, and, unless the project is trivial, any one of them is better than phased integration.

	The best integration approach for any specific project is usually a combination of top-down, bottom-up, risk-oriented, and other integration approaches. T-shaped integration and vertical-slice integration are two approaches that often work well.

第 30 章 编程工具

中文要点：

	程序员有时会长达数年的时间里忽视某些最强大的工具，之后才发现并使用之。

	好的工具能让你的日子过的安逸得多。

	下面这些工具已经可用了：编辑、分析代码质量、重构、版本控制、除错、测试、代码调整。

	你能打造许多自己用的专用工具。

	好的工具能减少软件开发中最单调乏味的工作的量，但它不能消除对「编程」的需要，虽然它会持续地重塑（reshape）编程的含义。

English Key Points：

	Programmers sometimes overlook some of the most powerful tools for years before discovering them.

	Good tools can make your life a lot easier.

	Tools are readily available for editing, analyzing code quality, refactoring, version control, debugging, testing, and code tuning.

	You can make many of the special-purpose tools you need.

	Good tools can reduce the more tedious aspects of software development, but they can’t eliminate the need for programming, though they will continue to reshape what we mean by「programming.」

第 31 章 布局与风格

中文要点：

	可视化布局的首要任务是指明代码的逻辑组织。评估该任务是否实现的指标包括准确性、一致性、易读性和易维护性。

	外表悦目比起其他指标是最不重要的。然而，如果其他指标都达到了，代码又质量好，那么布局效果看上去也会不错。

	Visual Basic 具有纯代码块风格，而 Java 的传统做法就是使用纯块风格，所以若用这些语言编程，就请使用纯代码块风格。C＋＋中，模拟纯代码块或者 begin-end 块边界都行之有效。

	结构化代码有其自身目的。始终如一地沿用某个习惯而少来创新。不能持久的布局规范只会损害可读性。

	布局的很多方面涉及信仰问题。应试着将客观需要和主观偏好区分开来。定出明确的指标，在此基础上再讨论风格参数的选择。

English Key Points：

	The first priority of visual layout is to illuminate the logical organization of the code. Criteria used to assess whether the priority is achieved include accuracy, consistency, readability, and maintainability.

	Looking good is secondary to the other criteria—a distant second. If the other criteria are met and the underlying code is good, however, the layout will look fine.

	 Visual Basic has pure blocks and the conventional practice in Java is to use pure block style, so you can use a pure-block layout if you program in those languages. In C++, either pure-block emulation or begin-end block boundaries work well.

	Structuring code is important for its own sake. The specific convention you follow may be less important than the fact that you follow some convention consistently. A layout convention that’s followed inconsistently might actually hurt readability.

	Many aspects of layout are religious issues. Try to separate objective preferences from subjective ones. Use explicit criteria to help ground your discussions about style preferences.

第 32 章 自说明代码

中文要点：

	该不该注释是一个需要认真对待的问题。差劲的注释只会浪费时间，帮倒忙：好的注释才有价值。

	源代码应当含有程序大部分的关键信息。只要程序谷底大用，源代码比其他资料都能保持更新，故而将重要信息融入代码是很有用处的。

	好代码本身就是更好的说明。如果代码太糟，需要大量注释，应先试着改进代码，直至无须过多注释为止。

	注释应说出代码无法说出的东西――例如概述或用意等信息。

	有的注释风格需要许多重复性劳动，应舍弃之，改用易于维护的注释风格。

English Key Points：

	The question of whether to comment is a legitimate one. Done poorly, commenting is a waste of time and sometimes harmful. Done well, commenting is worthwhile.

	The source code should contain most of the critical information about the program. As long as the program is running, the source code is more likely than any other resource to be kept current, and it’s useful to have important information bundled with the code.

	Good code is its own best documentation. If the code is bad enough to require extensive comments, try first to improve the code so that it doesn’t need extensive comments.

	Comments should say things about the code that the code can’t say about itself—at the summary level or the intent level.

	Some commenting styles require a lot of tedious clerical work. Develop a style that’s easy to maintain.

第 33 章 个人性格

中文要点：

	人的个性对其编程能力有直接影响　。

	最有关系的性格为：谦虚、求知欲、诚实、创造性和纪律，以及高明的偷懒。

	程序员高手的性格与天分无关，而任何事都与个人发展相关。

	出乎意料的是，小聪明、经验、坚持和疯狂既有助也有害。

	很多程序员不愿意主要吸收新知识和技术，只依靠工作时偶尔接触新的信息。如果你能抽出少量时间阅读和学习编程知识，要不了多久就能鹤立鸡群。

	好性格与培养正确的习惯关系甚大。要成为杰出的程序员，先要养成良好习惯，其他自然水到渠成。

English Key Points：

	Your personal character directly affects your ability to write computer programs.

	The characteristics that matter most are humility, curiosity, intellectual honesty, creativity and discipline, and enlightened laziness.

	The characteristics of a superior programmer have almost nothing to do with talent and everything to do with a commitment to personal development.

	Surprisingly, raw intelligence, experience, persistence, and guts hurt as much as they help.

	Many programmers don’t actively seek new information and techniques and instead rely on accidental, on-the-job exposure to new information. If you devote a small percentage of your time to reading and learning about programming, after a few months or years you’ll dramatically distinguish yourself from the programming mainstream.

	Good character is mainly a matter of having the right habits. To be a great programmer, develop the right habits, and the rest will come naturally.

第 34 章 软件工艺的话题

中文要点：

	编程的主要主的之一是管理复杂性。

	编程过程对最终产品有深远影响　。

	合作开发要求团队成员之间进行广泛沟通，甚于同计算机的交互；而单人开发则是自我交流，其次才是计算机。

	编程规范一旦滥用，只会雪上加霜；使用得当则能为开发环境带来良好机制，有助于管理复杂性和相互沟通。

	编程应基于问题域而非解决方案，这样便于复杂性管理。

	注意警告信息，将其作为编程的疑点，因为编程几乎是纯粹的智力活动。

	开发时迭代次数越多，产品的质量越好。

	墨守成规的方法有悖于高质量的软件开发。请将编程工具箱中填满各种编程工具，不断提高自己换行合适工具的能力。

English Key Points：

	One primary goal of programming is managing complexity.

	The programming process significantly affects the final product.

	Team programming is more an exercise in communicating with people than in communicating with a computer. Individual programming is more an exercise in communicating with yourself than with a computer.

	When abused, a programming convention can be a cure that’s worse than the disease. Used thoughtfully, a convention adds valuable structure to the development environment and helps with managing complexity and communication.

	Programming in terms of the problem rather than the solution helps to manage complexity. 

	Paying attention to intellectual warning signs like the「irritation of doubt」is especially important in programming because programming is almost purely a mental activity.

	The more you iterate in each development activity, the better the product of that activity will be.

	Dogmatic methodologies and high-quality software development don’t mix. Fill your intellectual toolbox with programming alternatives and improve your skill at choosing the right tool for the job.

第 35 章 何处有更多信息

我的一些读书笔记

云风

2006-06-09 19:13:36

因为最近工作很忙，所以这本书的厚度让我迟迟没有读完.

间隙的写了点读书笔记，可以和大家分享:

http://blog.codingnow.com/cloud/CodeComplete

      

堪称经典的力作

想飞的猫

2009-11-11 15:39:48

想要学习软件开发的都应该去读这本书。书里面有很多一般很难接触到的最佳实践的东西。很多时候，这些也就是新手和高手之间的区别。当你知道了很多这些东西之后，也就很难有人再去叫你菜鸟。

我认为本书最值得去读的是中间那几章很详细的细节方面的描述，如变量命名之类。我也很讨厌死板的软件工程教条，但我不反对软件工程。其实，这些所谓的最佳实践都是软件工程的核心。这些知识不仅仅是新手需要知道的，即使是所谓高手也需要常常温故知新。

或许本书最大的败笔就在于题目。不过，这个题目也确实很难去翻译。Code Complete，译者说是「代码完成」，也就是软件工程里面有关软件生命周期的一个重要阶段。如果你要去找所谓的代码，这本书不是你要的。但是，我觉得它会给你更多。

软件构建的集大成者

草根程序员

2010-03-04 14:31:04

初见《代码大全》，还是该书的第一版，只从书名上看，还以为都是一些代码的示例。觉得还有很多的书需要读，这种实用主义的技巧书，可以先放一放，于是与之失之交臂。

及至后来，才发现原来被中文书名给骗了。

只要将目录浏览一过，就会发现，这本书基本覆盖了软件构建的全过程，从需要分析、系统架构设计到具体的编码规范、编码技巧，程序员可以在其中找到所有想找到的内容。而且每一个方面作者都进行了深入的探讨和详细的解说，同时也给出了想要更进一步学习的参考。可以说，这是一本对其出版之前的所有软件构建的知识的百科全书。

对于争论较多的方面，作者给出了较为合理、公允的折中方案，甚至在 34 章最后一节」汝当分离软件与信仰「，作者明确的阐述了这一思想。

这本书和《程序员修炼之道》一厚一薄，相映成趣，都是难得一见的好书，值得花时间和精心用心的阅读，并不时拿出来温习，可以肯定的是，每次翻开，必有收获！

看过最好的计算机书籍之一

小疯叔

2008-10-24 19:48:34

对于编程来说，借鉴成功的经验很重要，而这本书是无论新手老手都一定要读一读的佳作。

讲的比较显浅易懂，而很多宝贵的经验一一道出，很多时候看着看着都会兴奋的叫出来。

唯一有问题的就是书名的翻译，明明全书讲解的是编写良好代码的方法，却起个「大全」的名字，还以为里面是很多很多的范例代码。

时机

忘川

2009-08-10 01:45:56

这本书看的还是满早了，所谓的早是指买回来基本没放，一个月时间读完。有人说书非借不能读也，我个人是非常赞同的，一般的书我都是买回来几个月才想起来看。

这本书的内容不想多谈了，任何夸奖的形容词用在该书上都不过份。但其实我看书的时候，书上大部分的内容我都了解过了，而且已经在项目中有所实践。所以我想说说这本书读的时机。

入行 1 年，至少完整的跟过一两个商业项目的程序员应该是初读这本书的时机。然后在自己开始思考代码结构，设计，脱离代码工人层次的时候可以考虑去读第二遍。

最后，本书对设计模式，重构以及软件工程方面也有所涉猎，但是只可当作提纲，概要。对这些东西，要读的书就太多了。比如设计模式可以去读深入浅出设计模式和 Gof 的那本，重构显然应该去看福勒的重构。

本书绝对值得陪伴到你彻底脱离计算机行业为止（也许不止，咩哈哈）！

木哈哈

2009-12-16 13:29:05

这本书陪伴我已经很多年，从一个菜鸟到现在的中级菜鸟这本书已经翻了不少遍，但大多都是陆陆续续看完（工作嘛）。当时作为一个还没入门的新手来读这本书的时候，感觉有点离实际太远（自己没技术、没经验），因为这本书并没有讲具体的技术，就这样当小说看了，囫囵吞枣的翻了一遍，也就记得几个关键字：「需求」、「复杂度」…… 什么的。后来过了段时间，学编程有点迷茫了，网上充斥着学 C++、Java 还是 C# 的问题，到处有人问，有点不知所措，什么都想学，但什么又不懂。没事又来翻了翻这本书，看到「深入某种语言去编程」（估计是这个名字，有点忘了）这一节，这一节虽然短，但是对我触动很大，使我决定静下心来认真研究技术。没工作之前也翻了翻，但由于没有工作经验，很多东西感触不大。后来一直工作到现在，最近正准备继续翻一遍。每次都有不同的感受，现在来看这本书为什么牛 B，就在于它融合了许多实践经验，能给你一些指导，为你指导方向。书籍总是要陪伴实践一起来看才会更精彩，否则就只是一些浮云，这本书也一样，我个人觉得对于工作的人来说阅读起来更有收获。对于刚入门的新手来说可以看书籍的某些推荐的章节。不管怎么说好书不需要推荐，看看别人的评价就知道了。这本书绝对值得陪伴到你彻底脱离计算机行业为止（也许不止，咩哈哈）！

只是从个人性格来看

sheep

2009-08-06 15:08:06

这是一部讲软件构建的书，所以它会偏向于软件工程，而又涵盖编程技术。如果只是专注于技术细节，读完这本书中的几章可能会让你有意犹未尽的感觉，但如果你要走得更远一些的话，应该更进一步，从整体来看软件是如何构建的，这也是书名「code complete」的寓意所在。

但一下就谈软件构建对大部分人来说太庞大，太沉重。所以为了避免你对本书评看不下去，我只挑书中最个性的一章《个人性格》来说。就像书里说的：老板无法强迫你成为好的程序员，很多时候甚至无法判断你是否合格。如果你想有所成就，只能全凭自己，这涉及到你的个人性格。因为大多时候你无法提升你的聪明程度，但性格在一定程度上能够改进。

谦虚	精通编程的人是那些了解自己头脑有多大局限性的人，都很谦虚。而那些编程糟糕的人，总是拒绝接受自己脑瓜不能胜任工作的事实，自负使得他们无法成为优秀的程序员。程序是机械化的，不会和你讲人情；同时也是复杂的，不可能一目了然。但有些程序员在修改代码的时候还没有弄清楚每个变量每条语句的含义，同时又不舍得低下高傲的头颅向别人请教，然后就是问题越改越多。当然有时别人也不一定帮得上忙，那你就更要把它弄清楚了，这样以后可以帮别人了。

诚实	编程生涯成熟的标志就是发展出一种不屈不挠的诚实感。在项目需求分解下来之后对一些不明白的地方假装理解，在设计出现偏差或遗漏的时候总倾向于让别人去规避而不承认自己的错误，在项目周期或缺陷率偏离基线的时候没有准确的反映状态报告。这些都可能带来更严重的问题，所以在没有出现更大的问题前请诚实地去面对吧。

交流	编程首先是与人的交流，其次才是与计算机的交流。不要因为整个产品是你一个人完成而把代码写得犹如天书，等到天才的你再次修改自己的代码或是移交给别人的时候，天才也会忧郁的。对于团队来说，代码便于看懂是对团队成员的要求之一。

规范	在一篇文章里出现宋体隶书黑体，会让人看起来是很不舒服的；在代码里看到几种独具个性编排标注，那是让人很厌恶的。所以请自觉遵守规范和工程纪律，这不是要束缚你的创造力，在大规模的程序里，这是项目能完成的根本。

懒惰	人们容易混淆行动与进展，混淆忙碌与多产。一劳永逸的懒惰，也是你创造力的表现。程序员都是聪明的人，所以总能创造出一些工具使自己更懒惰些。

经验	在其他行业中，今天工作中的收获很可能有助于明天的工作；在软件行业中，如果不改掉使用先前编程语言时的思维模式，或者不放弃在旧机器上能用的代码性能优化技术，你的经验将还不如没有的好。对于编程，要试着养成有用的新习惯，以新习惯来代替旧习惯。

为什么要说这些呢，大多时候程序员总是在奋力追赶进度，或者满足最后期限的要求，但适当的时候应该让自己停下来思考一下。在看这书的时候，觉得很多观点技巧都很熟悉，但在真正工作的时候并没有发挥到它的效果，这只是理解得不够充分吧，那就把这本书多看几遍。

《代码大全》读后感

Perry

2011-06-08 21:12:42

昨天终于把《代码大全》这本 900 多页的大部头「啃」完了，很有成就感，所以写篇博客梳理梳理学到的知识，做下总结。

管理复杂度

软件开发是一项很复杂的工程，面对大型的项目，没有人能清楚地知道整个项目的细枝末节，一个小小的 bug 可能就要耗费你数小时甚至一整天的时间，而代码如果是别人写的，这个过程可能就会更加的漫长和痛苦。即便不是别人写的，你也很有可能不认识自己一个月前写过的代码。人的大脑是有限的，你不可能同时将五六个密切相关的类同时装进你的大脑并思考改动其中的一个会对其他几个都产生怎样的影响，如果这些类之间的关系是一团乱麻，那么改动其中任何一个都将是非常困难的。套用我同事很形象的说法，你的大脑「内存溢出」了！

所以，管理复杂度便是软件开发过程中非常重要的一个环节，这也是《代码大全》这本书中讨论得最多的一个主题。

管理复杂度是一项很艰巨的任务，大到框架的设计，子系统的划分，小到函数的内聚性，参数的个数，变量的命名，都牵涉其中。一个复杂度小的系统能让你专注于系统的某一点工作，而不用操心你的修改会对系统的其他部分产生怎样的影响。

《代码大全》这本书便从子系统的分割，类的设计和接口的定义，函数的编写，变量的作用域和命名，代码的逻辑，循环控制语句的使用等等，一层一层的讨论下来，总共花了十五章的篇幅！

提高质量

除了管理复杂度，这本书还讨论了一个主题，便是如何提高软件开发的质量。这里的质量包括几个方面，需求的质量（详细的说明），开发过程的质量（对需求变更的控制，增量集成），代码的质量（代码审察，结队编程），测试的质量（单元测试，覆盖率）等等。

作者还提到，过早的对代码进行优化对项目的进度其实是有损害的，然而偏执的程序员总是对优化上瘾，并为此感到自豪，一个好的解决办法是，profiling! 很多优化有时候是程序员想当然的，如果不能对优化前后进行客观的测量对比，那么就不要优化！

代码是写给人看的

这也是这本书中很重要的一个主题，写给机器看的代码很容易，谁都会写，你写得再难看，机器也能运行。但是写给人看的代码就难了，你写代码时要考虑到这个代码是要给你的同事来修改的，或者你自己一个月后也可能会重新维护一下。

之前讨论的管理复杂度是这个主题的一方面，除此之外，良好的注释，详细的代码规范也很重要，它降低了沟通的成本。

关于规范的制定可能会引起争执，缩进该用空格还是制表符，大括号写在末尾还是另起一行，每个人都有自己的喜好，毕竟萝卜白菜各有所爱嘛，然而这些争执其实是没有必要的，制定规范不是选美，目的是要能让你专注于代码的逻辑，减轻阅读和理解代码的负担。

check list

《代码大全》在每一章后面都有一个 check list，帮助你检查自己的工作，很适合把它放在办公室电脑旁，随时参考。

谁该来读这本书

forrest_gangp

2010-09-13 14:52:09

这是程序设计领域属内功秘籍行列的书籍，它教给你什么是好的编程实践，如何做出优雅的设计，怎样写出漂亮的代码。正如所有其他的内功武学一样，它不教给你具体的宗派招式，读过它你并不能马上就实现一个 web 浏览器或 CAD 系统；但它却能让你在涉足特定领域编程的时候，写出漂亮优雅的代码，进步神速，上升到更高的层次，从多种视角审视自己的工作，早日进化为大师。

纵观本书，我觉得作者所有的论述都围绕着两个主题：1. 怎样管理软件的复杂度；2. 程序是写给人看的，而不单是机器去执行。

第一点毋庸质疑，这是软件工程的首要任务。针对这一点，作者阐述了怎样去作架构，怎样去设计接口、类和子程序，以及怎样管理项目。针对第二点，作者阐述了怎样创建变量，怎样命名变量，怎样写控制语句，怎样注释和排版代码等等。所有这两点，都是一个优秀的程序员必须具备的编程素养。

一句话，每一个有志成为编程高手的程序员，这本书中涉及的内容都是你的必修课。

但是，并不推荐没有软件设计经验的编程新手看此书，以及有关设计模式、重构等等类似的书，因为这些书都是讲述好的编程实践方法的，属方法论范畴。所谓编程最佳实践方法，其实就是一堆经验。只有读者具备一定的实践经验，才能够对书中描述的现象以及解决策略产生共鸣，才不至于看过后没什么印象，觉得都是一些「假大空」的话并很快忘掉。所以，建议看此书的新手应该写过规模不少于三五千行的软件，并且嗅出了自己软件中的臭味，却不知如何改进是好。此时读此书正是时候。只有对什么是坏代码先有一个感性认识，才能在阅读此书时明白作者在通篇批评的就是自己，深感羞愧并痛下决心加以改正。

      

软件工程中绝对的精品

子夜风

2009-07-22 10:16:05

自从软件工程这个术语提出来以后，就有许多专家和学者去总结软件工程的概念及原理。然集成者 B.Boehm 综合百家之说，积多家之语，发表一论文。提出软件工程中的七条准则。可概括为目标，过程和原则。

在代码大全里面，把软件工程，犹如疱丁解牛一般，把其中软件工程中的问题，描述的通谷易懂。这本书不紧告诉你怎样做，还更加告诉你为什么要这样做。更是把软件工程中那环节，分析得很入理，很透彻，仿如一江清水，一清透彻浑无底。

在书上把软件构建分成不同的活动个体。1. 定义问题；2. 需求分析；3. 规划构建；4. 软件架构；5. 详细设计；6. 编码与调试；7. 单元测试；8. 集成测试；9. 集成；10. 系统测试；11. 保障维护；分别去解析，疱析，提出为什么，然后再回答怎么样，有什么好的方法。整本书的内容会觉得有似曾相识的感觉，发出感叹「我不就是有这个问题吗」，「我也这么做过」等等关于共鸣的词谓。显然此书，总结于在日常软件开发之间，然又指导我们的日常软件开发；让我们细致的整理了自己的经验.

此书中，最深有体会的是「把主要精力集中于构建活动，可以大大提高程序员的生产率」。想曾经多少次因为前期需求没做好，导致后期修改成本不断的加大，更有重则，直接导到软件的消亡。好比一个健康的生态环境中，海鸥吃新鲜的鲑鱼，鲑鱼吃新鲜的青鱼，青鱼吃新鲜的水蝽。这是一条健康的食物链。如果环境被污染了，水蝽在污染的水域游泳，那么海鸥，食物链的最后一环吃下的不仅仅是是不健康的鲑鱼体内的垃圾，还有青鱼，水蝽体内的污染物。软件开发中，架构师吃掉需求，设计师吃掉架构，程序员，软件食物链的最后一环，消化掉设计。如果一开始就被污染了，我们就不要指望程序员快乐了。整个软件都会具有放射性，周身都是缺陷，绝对导致程序员脾气暴躁、营养失调。在我们规模不大的团队里，一个人身兼数职，伤害更大。所以，项目一开始就决定了它能否成功。

那如何做好需求分析呢，书中说得相当详细，见文：「是否详细定义了系统的全部输入，包括来源、精度、取值范围、出现频率。是否详细定义了系统全部输出，包括目的，精度，取值范围、出现频率，格式？是否定义了机器内存和剩余磁盘空间的最小值？是否详细定义了系统的可维护性，包括适应特定功能的变更、操作环境的变更、与其他软件的接口的变更能力？」

因此，个人愚见，此书是软件工程中绝对的精品，质性机解，推情原意，能适其变

人类统治代码，而不是代码统治人类

久遠寺秋水

2009-07-31 12:48:09

《Write Great Code》在第一卷的 1.4 里就说到，卓越代码需要「易读并且容易维护」、「风格统一」、「涉及清晰，遵循成熟的软件工程惯例」，而《Code Complete》教给我们的，正是开启这扇卓越代码之门的第一把钥匙。

我是在初二接触到《Code Complete》一书的，而现在这本书的内容和思想，已经渗透进了我的每一行代码和每一个程序。只要我打开 IDE，我就会自然而然地把它的教诲铭刻在脑海里。我很庆幸，因为这不仅是对自己负责，也是对每一个人 —— 提高到全人类的高度也未尝不可 —— 的负责。

把这本书指出并解决了一个最关键的问题 —— 软件工程不仅是一个技术问题 —— 在这个推崇合作与开放的信息时代，它是人类统治代码而不是代码统治人类的根本保证。

金砖：）

琳琳的小狗

2009-07-28 10:07:04

超厚的一本书，堪称砖头，在我的记忆里，估计只有牛津英汉辞典能赶上他把，呵呵。也难怪，要容纳这么多的软件开发思想、经验总结，就非得那么多篇幅才可能，忍了。李维说此书始终在他的书架上，此话不假，至少，你细心看完这本书，没有几个月下来那是绝对不可能，而且，就算你看完了，能保证一股脑都吸收了精华么？所以啊，好好放在顺手能拿到的地方，闲暇就翻翻，当你可以扔掉它的时候，估计也舍不得扔了：）

所以，我将其称之为金砖……

一本可操作的软件工程书籍

breaker

2012-09-02 12:57:26

        

如果只选一本关于软件工程的书，我会选 Code Complete。

书名正确的意思是「完成编码」，是以「完成编码，更进一步地完成项目，交付产品」为宗旨的指导手册。

因为软件工程的书籍犹如「游泳教科书」，所以我不提倡「事先通晓」软件工程。但这本书算是软件工程书籍的异类，首先因为作者 Steve McConnell 是一线的软件开发者而不是学院教授，所以他的叙述比较务实，再者本书只有前几章讲述软件工程学，其它相当大部分是和 Coding 相关的，作者很好地将软件工程的要求落实到可操作的具体编程过程上。

我略读了本书有关软件工程的部分，而把重点放到 Coding 的部分。这是一个好的策略。时刻牢记远离虚无缥缈的理论。

      

《代码大全》读后的几点感想

清风乱醉

2010-01-05 12:23:21

收到一个豆邮，让我评一下读过的《代码大全》。

刚看到豆邮时，我快速回顾了一下《代码大全》，感觉让我收获最大的是：

1，给我两段代码，我可以知道哪一段代码更优秀一些。

2，我对代码的理解层次提高了，因为我不再是将程序写的复杂，而是力图将程序写的更简单。《代码大全》中对此的描述是：软件开发的最大任务是 —— 管理复杂度。

关于该书的推荐，已经有很多人写了，他们写的比我好，我就不做重复的工作了。我倒想零碎地说下感想。

首先，不要怕这本书厚。一本厚而易读的书比起薄而晦涩的书看起来要快得多。

其次，不要被书名所骗。这是一本切实写代码，很全面的书。作者在本书的开头就已经告诉读者这是一本关于「构建」的书。

再三，好的代码与坏的代码区别在哪里？很多人会说是：感觉。但感觉总是不靠谱的。促进这种感觉的，是一些具体的实践，这些实践在一起让你有了良好代码的感觉。具体的实践又是什么呢？作者都娓娓道来，小至怎么样命名一个变量，怎么样命名一个函数，类名，大到划分模块，做好信息隐藏等等。

最后，这本书提及到有关构建的方方面面。

《代码大全》与我而言更是提点，在我苦于提高编程技艺却不知道如何下手时，给了我提醒。

值得深入研究

wader

2006-04-25 15:26:16

在网上看了几页，觉得国外人写书就是风趣，把程序这么严密的问题用很亲切的口吻给你讲出来，既让你学到了丰富的知识，又加深了学习的兴趣。好书！

前进道路上的阿拉丁

risent

2009-10-05 16:50:49

这本书当初是附带在 java 编程思想一起买的，一直没看，前一阵子翻看了其中的 第 7 章 高质量的子程序设计 ，一下子给我一种豁然开朗的感觉，以前写些东西时候总感觉可以这么写可以那么写，很是纠结，我终于在这里找到了明确的答案，对没一种情况都给了清楚合理的解释。

很庆幸当初自己看完了它

Joshua

2009-11-21 21:09:25

作者的写作风格很客观很务实。

这本书可以从任何一个小章节进行阅读，而无需担心是否需要其他章节的知识。因为作者会把每个章节最吸引人的地方，用巧妙的方法展现出来。并且代码构建其实也可以变得非常具有艺术性。

还可以用这本书每个章节最后的 CheckList 来检验软件开发的每个环节。看看我自己在这些地方犯了哪些典型错误。

当初还担心书中可能会充满代码示例而放弃阅读它。现在我很庆幸当初自己看完了它。

在看这本书，还没看完，有一种很矛盾的感觉！

oolong

2013-11-17 09:21:27

代码大全这本书，说真的，实在是被这个中文译名给毁了。这样的译名实在是容易给人造成很大的误解。对于没有人推荐，没有人介绍的人来说，看到这本书的书名，多半就略过了。

这本书我现在看到了五分之一左右，这是第一遍看，突然发现一个很矛盾的地方：其实这本书应该列为每个学软件开发的学生的教科书的，书中所说的东西，可以是程序设计手册，编码规范等等，这些其实都应该是一个程序员首先应该能够掌握的技能。但问题是，一个学生，没有真实的项目经验，仅靠学校里的一些练习的项目，是根本无法体会到书中所说的内容的。

《代码大全》1 至 3 章读书笔记

蛙蛙王子

2010-04-10 14:34:18

《代码大全》1 至 3 章读书笔记

最近在看《代码大全》这本书，感觉挺有用的，对实际的设计和编码有很好的指导意义。尽管有很多高手说这本书写的没有宣传的那么好，名不副实，但我却没这感觉，各取所需吧，写了一些读书笔记和体会，和大家分享。

第一章 欢迎进入软件构建的世界

这章阐述了软件构建的重要性，软件构建大体上就是说具体程序员做的工作，而不是需求收集人员，产品设计人员，业务分析人员，架构设计人员，测试人员，运维人员等做的工作，虽然这些人的工作在整个软件开发生命周期中也非常的重要，但是一个软件开发的最主要的部分却是具体程序员做的那部分事情。一般的软件公司里具体程序员的数量应该占很大的比重，大多数的程序员也是具体程序员，只有很少的程序员经过多年的工作学习能成为项目经理，业务分析人员，架构师等高级软件从业人员。

具体程序员是我这里提出的，具体程序员做什么工作呢？理解架构师做出的架构设计，做你负责的模块的详细设计，做出自己的负责模块的开发计划，编码，单元测试，和其它模块的负责人联调，做集成测试，遇到问题后调试，解决测试人员提出的 BUG，以及软件上线后排查线上的问题等等。如果你做的是这些工作，那你就是具体程序员，你做的大多事情就是软件构建的事情。当然，还有一部分程序员，在小公司，或者做着一些不太正规的小项目，除了具体的软件构建工作，还得和客户沟通需求，设计大体架构，部署维护，解答客户问题等工作，尽管这样，软件构建还应该是你工作中最主要的一部分，应该大多数人都做过类似的项目或者在类似的公司里工作过。无论如何，只要你是个程序员，就应该系统的，好好的学习下软件构建的技能和知识，这比你学很多种语言，尝试很多种花哨的新技术要值很多，至少我看了这本书的其中几章有这个体会，第一次认真考虑软件构建中的一些基础的，细节的，基本的，通用的思维方式，编码技巧和规范。

第二章 用隐喻来更充分的理解软件开发

这章总的来说可读可不读，没啥太大的收获。我们平时把软件编码叫做写代码，让外行人听起来像是在写文章，就是把你心里的想法一点一点的有条理的写出来，在这一点上，编码和写文章确实有相似之处，但写文章一般是你自己写，编码则需要和别人合作。还有在软件设计的时候，我们经常拿盖房子来比喻，盖房子之前要先画好蓝图，整体结构，考虑好水、电的布局等，盖一个小狗窝和盖一栋大楼的过程也是不一样的，做一个小软件和一个超大型的软件的过程也是不一样的。如果你能很好把软件的开发过程想象成某些生活中具体的例子，找到他们的相似之处和不同之处，你就能更好的理解软件开发，以及利用这些隐喻来与人更好的沟通。你脑子里如果有很多这样的隐喻，在你做软件设计时就会不经意的想起来，成为你思考和权衡不同方案的工具。

第三章 三思而后行：前期准备

做任何事情都需要前期准备，在软件开发中更是如此，尽管如此，还是有很多程序员接到任务后就是想着尽快编码，很多老板不重视软件开发的前期准备。要想保证一个软件的质量，在前期准备，需求分析，架构设计，编码，测试，维护等每一个环节都要重视质量。具体程序员接到任务的时候要检查一下在你之前的那些软件活动有没有准备好，如果需求中有好多没有说明的地方，架构设计也不明确，你不知道需要和其它模块之间如何通信，基础组件啥也没有，这种情况下进行详细设计和编码会很受罪。

和同事老板达成前期准备重要性的共识之后，就是如何做前期准备以及如何判断前期准备已经做好的技巧，这些是更实用的地方。如何做前期准备基本上是需求分析人员，产品经理和架构师的关心的问题，而判断前期准备是否已准备好则是具体程序员也需要具备的能力。首先要判断你做的软件的类型和规模，如果你做的是一个长期的项目，一期一期的做，就更适合敏捷开发和迭代式开发，做一些基本的前期准备就可以开工了，先把最核心的功能实现，每隔一段时间把一些新需求加入设计和编码中来，设计和编码可以结合起来，需求也不用一下子就写的特别全面，先写出最基本的需求。如果你要做一个性命攸关的系统，如航天软件，医疗软件等，前期准备就应该更严格，需求规格说明书要尽量详细，设计也要花很长时间来做，尽量防止以后改动。根据你的项目的性质来选择更迭代化还是更瀑布式的开发。

问题定义应该是前期准备的第一个环节，用短短的几句话来说明你做的软件解决什么问题？商业意义是什么？如果这个都不明确，那你做这个软件干啥？

明确的需求在前期准备也很重要，需求要明确，全面，至少在接下来的一次开发迭代中需要的信息都要明确，而且不矛盾。没有明确的需求，测试人员就没法写测试用例，客户也没法理解如何使用系统，程序员也不知道如何设计编码。需求是不可能完全不变的，所以要针对需求变化制定一系列措施，比如每隔两周响应一次客户提出的需求变化，而不是无规律的频繁的接受用户需求变更；做一套需求管理系统；让老板，客户每个人都了解到频繁需求变化带来的后果；尽早的识别出可能的需求变化，以在架构设计的时候就提前考虑进去等。书中有一个检查需求质量的 check list，写的很具体，很有指导作用，这本书的信息量很大，很难压缩在几篇读书笔记里，具体大家看书吧。

架构设计要做到什么程度呢？架构设计包括好多个组成部分，程序如何组织，每个模块间如何通信，每个模块都负责什么？主要的类有没有定义出来，主要的数据是哪些？结构是怎样的，有哪些表？需要遵循哪些业务规则？大体的用户界面有没有设计出来？有哪些稀缺资源需要管理？如何管理？软件的安全需要什么样的级别，进行威胁建模了吗，都有可能面临哪些安全问题？哪些部分需要着重考虑性能问题？如果软件的使用者增大后，如何扩展软件满足用户需求？这个软件和其他已有软件或者系统的交互性如何？是否需要支持国际化？软件应该在哪个模块输入用户数据，哪个模块输出，在那一层检测 IO 错误？系统的错误处理策略是怎样的，检测到错误是否需要传递给调用者，还是只记录日志就可以了，是所有模块都要对数据有效性进行验证呢，还是有些模块可以假设输入的数据是干净的？系统的容错性是怎么考虑的，都需要容哪些错？系统架构的可行性如何，有没有先做出一些原型进行验证？有没有考虑过系统的健壮性，在考虑健壮性的时候是否进行了过度设计，对一些基本不会出现的情况进行了设计？有些模块或者功能是否直接买一套比自己做更划算？哪些模块可以重用，或者已经有可重用的模块？架构是否足够灵活，以很容易的面对需求的变化，是否对几乎以后肯定会有的需求进行了考虑？优秀的架构都是经过多次决策最终选定的比较靠谱的一个，在你具体进行详细设计和编码之前先针对架构师设计出来的架构问一下上面这些问题，判断一下架构是否已经准备好。

前期准备所花费的时间是不容易把握的，也没有个固定的衡量标准，但前期准备是必须要做的，前期准备的根本目的是降低风险，提高项目质量。

20 天，22 小时 20 分，我是如何干掉这本 1000 页的代码大全的

初开

2018-12-15 15:23:01

        

从 11 月 24 日到 12 月 15 日，20 天内，投入 22 个小时又 20 分钟，从头到尾通读完了这本代码大全，每一章都按同样的标准做了笔记，共 1.7w 字。

从本书本身的学到的倒是其次，最关键的是，点亮了一个新技能，

如何在一个漫长而枯燥的任务坚持下来，并保持同样的投入标准直至结束。

从此以后，我的字典里不再有坚持二字，只要我想做，就一定能做到，无所谓坚持和放弃。

先上成果。

笔记在这里：

代码大全

。

时间记录：

为了搞定它，我做了两件事，一是自我赋能，二是定标准。下面，我们来谈谈这里面的底层原理。

一、自我赋能

做一件需要持续投入事情，最大的障碍不是我们没有能力，而是没能量。

一般开始几天还好，后面我们就会慢慢动摇，用术语叫

怀疑意义

。

我们会想做这件事干嘛，又不是一定要做，去刷手机多好，搞这些有什么意义，还是算了吧。

所以，首先要防止的就是这个事情，当怀疑意义时，要有东西拿出来说服自己。

在看这本书之前，我写下了这么 7 条意义，并且把它贴在笔记的最上方。

意义

系统性复习软件开发的知识

作为会赋能，随时可以打鸡血，懂目标管理，懂时间管理，道术器用齐活，当然能通过科学手段搞定它。

老哥这本书写得这么厚，恐怕是在刁难我，我必须证明难不倒我。

我是一名终身成长者，不可能被这本破书吓到，也就是一个小障碍而已。

1000 页的专业书都看完了，以后没有看不下的书。

优化自己的阅读流程。

读完可以出去装个 x。

当我写下来后，意外发现第 7 条给我的能量最大，毕竟人是追求存在感的。

所以读完后，第一件事就去朋友圈得瑟，当然这篇文章也算。

二、定标准，结硬寨，打呆仗

很多时候，我们决定干一件事情后，总是只做好开头，后面就放飞自我，不了了之。

比如看一本书，基本都是看序一行行看，第一章一段段看，第二章一页页看，中间一章章看，后面直接翻过去完事。

这在系统思维里叫「目标侵蚀」，也就是我们对事情的标准是会随时间逐渐降低的。

比如计划了早起，然后一天比一天起得晚；安排了去跑步，后面跑着跑着就不跑了。

要防止这种情况，我们必须设定标准。如果实在不想搞，也按最低标准做下去，同时，也要设定最高投入标准，不能一开心就忘记时间的投入，这是不能长久的，要慢慢来，持续做。

如下，这是我看这本书前设定标准，标准适中，有上下限，不用严格执行，只要维持在一定范围波动就可以。

笔记标准，每章必须摘录所有标题结构、摘要和所有加粗字，有代码示例的自己写 or 摘抄一段，记录所有检查清单 。

阅读标准，顺序阅读，每天阅读量不超过两章。

时间标准，用番茄钟，每次阅读 25 分钟停下休息。

做完这两手准备，打开日期，把时间往前拨 20 天，任务就轻松完成了。

以上。

      

写代码的人

∑×pe℃t.

2014-12-06 10:05:45

最近买了几本经典编程书，有《head first 设计模式》《人月神话》《程序员修炼之道》《代码大全》，《代码大全》是第二本看完的。

看的期间不断有所悟，书中多处让我惊讶「原来是这样子」。不过由于工作之余时间有限，这本大著看了快两个月才完了，现在仅凭印象把之前悟到的写下来，算是总结。

如果要用一句话概括《代码大全》的话，我以为是「为人写代码，而不是机器」。

一：为人写代码，势必要考虑代码的扩展性。人是多变的，现实世界也是多变的，所以写代码之前需要设计，也才有设计模式，让你想变就变。

二：为人写代码，势必要考虑代码的易读性。书中无数次强调变量名的重要性，同样是代码，int i = 5 和 int beautifulGirlsCount = 5 ，虽然这两种代码都能正确编译并运行，但前者需要结合上下文连猜带蒙都不一定理解正确，后者一目了然且看得春心荡漾。

三：为人写代码，势必考虑代码的逻辑是否简单。在机器面前，人的智力显得太有限。如果代码没有遵循人类能理解的简单逻辑，如 if 、for、switch 之类，不加限制的使用 goto、递归，当代码量到达一定程度，人就没法维护这样的程序。

四：为人写代码，势必考虑异常的出现。从马士兵老师开始，就告诫我们得把你的用户当魔鬼，魔鬼是不会像我们想象中那样去使用我们的程序的。本书的防御式编程也重申了这点，人是会犯错的，毋庸置疑，重要的是犯错后你怎么抛异常、控制错误的影响范围和补救措施。

五：为人写代码，势必要将代码写的漂亮。你看印在书里的文章，所有的文字都用标点符号分隔，行与行有间隙，分段，这些文章的排版，在代码里也要有。代码里的缩进、空行、分段，不仅让代码显得有逻辑，也有美感。所以格式化很重要，即使你代码写得很有逻辑，但写得一坨一坨，你也很难让他人忍着恶心看下去。

这几点的概括显然没办法涵盖八百多页的《代码大全》，不过对于一个刚走在码农路上的我，可以让我消化好一阵子了。在现实世界中，要做到这几点，就更困难了。在看这本书的期间，每天白天在公司里看着前辈留下来那一坨坨的代码，不知何物的 mActivity，随处一点就奔溃的系统，我就知道现实跟我一样有多骨感。但是，丰满的理想跟丰满的美女一样，不会突然从天上砸到我身上。好代码是一个个敲出来的，美女也是一步步勾引过来的，这里没有捷径可言。

22.6    如何对待上司

小李飞刀

2008-04-29 11:34:52

这是第一版里的序号，新版可能不一样了

不管怎么说，印象深刻的一段话：

「    在软件开发过程中，非技术人员往往是管理者。最为例外的情况是管理者有工作经验，但是已是十年未再干过了。会技术的管理者是少见的。如果你为某一人工作，应尽力保住你的饭碗。这不是一件容易的事情。作为一个阶层，每一位雇员都想升到他并不能胜任的层次。

如果你的上司并不是一个特别的人，你将不得不学会如何面对你的上司。「控制你的上司」意味着你应告诉你的上司怎样去做，而不是用其他方法。其要决在于用这样一种方法使你的上司相信你仍是受他管理的一员。以下是一些对付你上司的方法：

·拒绝按照你上司的吩咐去做，坚持按正确方法继续你的工作。

·假装按照你上司的吩咐去做，暗地里按照正确的方法去做。

·先对自己如何做有一个全盘计划，等着上司对你的见解做评论并让人如何去做。

·告诉你上司正确的方法，这是一个中途应变方法，因为你的上司经常提升、调动或被解雇。

·寻找另一份工作。

最好的解决方法是努力说服你的上司。这并不是一件容易的事情，但是你可阅读《How to Win Friends and Influence People》（《怎样赢得朋友和影响他人》）一书以学会如何准备这件事。」

进阶程序员必读

soso

2010-04-07 10:14:50

这是区分一个刚出校园的菜鸟跟经验丰富的精英的最大区别，你可以没有很好的算法思维，没有出色的学习新语言的方法，你一定要有高质量的编程思路！

好书永远不会因为说它好的人多了而变得恶俗。

盲刺客·真的不

2008-01-18 21:27:56

书很厚实

而且内容 很丰富

我不是学编程的 但是也能看得懂

里面很多基础的知识 不是教你怎么用 而是教你如何注意会犯的错误

里面讲到和我有关系的部分 很清晰的思路 让你一看就明白平时应该注意什么

书的导航性很好 很容易找到自己所需要的知识 和相关的知识

而且里面知识结构很合理 循序渐进又不失去让人触类旁通的机会

交叉参考会提到一些具体要学习的某些知识 所用到比较权威的书

而国内有些作家再推荐的时候往往只会推荐自己的书 (*^__^*)

这书一天看几页 多思考 估计用不了多少时间 就会发现自己的某些理念清晰很多 不像是系统的学习那么累 且记忆不深刻。

这是一本值得反复看的好书

不过也太厚了。。放在手里沉甸甸的 真像是圣经了

唯一美中不足的是名字叫《代码大全》 其实若叫「编码完成」呵呵

中文版译得不错 不过也有些小纰漏吧。。因为有些句子看得别扭

以后有时间要收英文影印本看看。。好书永远不会因为说它好的人多了而变得恶俗。

好厚一本 <<葵花宝典>>

自强不吸

2008-05-29 15:35:28

半年内读完了 <<代码大全>>. 如今恕小弟无能，套用」八股文模式」写这篇书评 (脑子已经被作者搅晕了，哪里还有空去照顾」文风」)

<<代码大全>> 给我留下两大印象:

首先，它让我看到了代码之外的世界

(笔墨虽然不多，但作者介绍了上游工程). 眼睛盯住程序却不理解问题何在时，在上游工程中或许能找到答案。这世界上没有爸爸哪能有儿子，没有昨天哪有今日？儿子为什么长得那么丑或者那么俊？-> 调查一下他的家族就能找到原因.

其次，它让我在造代码时游刃有余.

(1) 我必须对得起自己写的代码.(这是作者反复暗示和明示的一个观点).

」盖大楼」和」写代码」常被拿来对比。我认为，二者之间有一明显的区别：前者的材料不透明，若不利用仪器测量则难以分析某块砖头的优劣。而」代码」里的材料基本上是」透明」的，明眼人一看便知某段代码写的好坏，稍有不慎它就会变成我的」罪证」. 对得起自己写的代码，意味着降低自己的随意度，以换取团队的整体效率.(与人方便，自己方便？)

(2) 当别人对不起他的代码时，我该怎么改写它？

书中诸如优化，重构等章节为我们提供了现成的」改造方案」. 家里卧室造得太小，我想把它扩大一些，那么势必要遵守某些规则，以免改造了局部，破坏了整体. <<代码大全>> 指明了代码的改造规则，使改造软件时有章可循.

总之，<<代码大全>> 对于我，就象 <<葵花宝典>> 对于 <<笑傲江湖>> 一样重要。没有葵花宝典，七尺男儿又怎能修炼成」东方不败」, 更何谈称霸武林，何谈对着江湖笑傲？

OOM 时代更珍贵了

Qian Xin

2010-01-17 10:05:28

code complete 这书写在 OOM 流行以前，现在类似 field 的书肯定都是 oo,design patern 为主了；但是真正写的时候发现，函数名字怎么取啊，这种问题还是在啊，但是现在讲软件设计的书已经不讲这些了；code complete 却是着重在这些现在 oo 的书已经不怎么讲了，但是仍然每天困扰我们这些人的问题上。

实践经验

Jeao&Leon

2009-11-12 19:27:14

的确是一本大部头的书，足足花了 1 个多月才看完。书写的还算活跃，不那么死板，经常举出风趣可爱的例子，再配上搞笑的插图，常常会吸引我不停的读下去。一路读下来，发现都是似曾相识的，因为在工作中，这些本来都是基础的要求，只是我知道应该怎么做，但是作者却知道如何把怎么做总结起来，并且论述为什么要这么做。总体而言，认真的跟随书中绝大多数说法有助于让一个新手快速成长为一个合格的程序员。不过另外一些地方还是得加上自己的判断，其实作者自己也提到，很多东西不是死的，写代码，做构建，其目的还是为了软件工程，还是为了把事情做好.

有真正项目经验后收获更多

zaohe

2010-01-20 17:39:18

之前非常忽视代码层次的书，看的都是一些设计、计算机原理方面的书籍。看完这本书后，自己的代码质量有了本质的提升，同时也对另外的一些描述代码的经典书籍发生了兴趣。发现自己原来连程序员一直都没入门。啥也不说了，努力学习吧，书看了肯定有收获的。

Code Complete

速速

2009-12-21 07:36:25

        not language specific, code standard including variables, statements, debugging and etc.      

关于《代码大全 2e》

Charles Tang

2012-11-18 13:53:54

最近几天，微博上有一个戏谑的帖子，把程序员按照等第分为了几档，从「死掉的程序员」开始，有「成功程序员」，「著名程序员」，「普通程序员」，「无名程序员」，「烂程序员」，等等几个档次。按照描述，我对号入座，觉得自己现在算得上是「无名程序员」这个级别，在中国，处于我这个级别的程序员有千千万万，也就是人们常说的「码农」。《代码大全》这书，依我看，其面向读者群，就是「码农」。

我推己及人一下，我觉得每个下决心买这本书的人，都是有一定的原因的，反正我不会因为看到封面四个字「代码大全」而去买这个砖头书，这四个字，看起来要么像是以前初学编程时候，那种「js 特效一千例」，找到你要用的例子，拷贝，粘贴，就能极大程度提高你的生产力的那种「食粮」；要么就像「成语大全」，「歇后语大全」一样的字典一类的东西。如果你联想到了上面两种东西，那要产生花几乎 100 块钱而去买这么一本书动力，就很困难了。我回忆了一下，我自己买这书的原因，大体是因为「著名程序员」和「成功程序员」的推荐，我是码农，整天扑在代码生产的一线，日子重复，枯燥，最最让人感到不能忍受的是迷茫，不知道自己将去向何方，应该去向何方。所以这个时候，一般都是看看「著名程序员」，「成功程序员」的道路，以期望照亮自己的道路。于是，就有了买这本书的理由。

我看了下扉页的签名，购买于 10 年 6 月 17 日，迄今超过 2 年了，仍旧没有看完。如果正态分布是真理的话，那我猜测，购买了此书的，极少人完整阅读过此书，也极少人一页都没看。你们会在书的前言部分，看到各种「成功程序员」，「著名程序员」，「普通程序员」的推荐辞，但是你们大约没法看到像我这样的一个「码农」，聊聊这本书。这是我第一次聊这本书，以后应该还会聊一次，我想是在我看完了之后。

前面说了我被什么蛊惑而买了这本书，被什么蛊惑下决心去看。接下来说说为什么这本书这么「难看」。

「难看」点一，始于枯燥。McConnell，作者被称为是软件工程的专家，当然，我不熟悉他，就像不熟悉每个老外一样。这本书，把软件工程的一般管理过程放到全书的第一个部分，虽然，流程之类的东西很重要，但是如果丢给一个「码农」一大摞文档，只为了说明某流程多么重要，可以想见这个东西有多不受欢迎。这本书，就这么开始了。花了几乎 30 页讲两个问题，一个是「为什么码农写代码（软件构建）很重要」，另一个是「用什么样的比喻（隐喻）描述码农写代码（软件构建）这件事情比较合适」。如果我猜测没错，大部分中国读者都会觉得，这两个问题，真的很那什么。30 页，足够消磨一个程序员阅读的兴趣了。如果拿做爱来比喻，前戏大概有 125 页，这还是中译本，考虑到汉语比英语精炼，原著的前戏大概要有 200 页了。对比下，《Learning Ruby》影印版一共才 200 多页。

「难看」点二，太合乎常识。程序＝算法＋数据结构；程序包含顺序、分支和循环；编写代码最重要的是管理复杂性；类应该有良好的抽象、封装和接口…… 这些东西，都是每个一线码农或多或少知道的东西，内心有认识的东西，未必能说出来，或者这么有条理的写出来，但是多少都知道一点。于是乎，你看这书，就好像，不断的意料之中嘛。

这本书到底该不该看呢？问出这个问题后，我很纠结要怎么回答。我觉得这本书里说到的很多东西，都是很基础的实践要求，也是有远见的做法，但是就像我上面说的，很多都没有超出常识太多。但是从我实际从工作中看到的各种人的代码来看，很多人都没有坚持用比较好的方案去做事情，但是你要问及他们，他们总是有各种选用比较差的方法的理由。对于这种人，最应该看这书，但是他们看完了还是依然故我，那不是浪费时间么？对于另一部分人，他们有类似这样的常识，也确实会应用到实践中去，这样的人，看书，估计就是有共鸣，不断有共鸣，但是我已经是这样做的了。看完又觉得收获不大。仿佛也没有什么看的必要。

如果说，我自己要看的理由，第一个就是我花了快 100 块，不应该浪费（追加沉没成本投资，不理智）；第二是，以后你吹嘘这书有多牛逼，或者批判这书有多傻逼，你最最起码，应该通读过一遍吧（码农的可悲自尊）；第三，这书其实还是有一点营养的，至少把敲代码这件事情，讲得这么系统，还是绝无仅有的一本书。但是，如果要我像「李维」，「潘爱民」之流，写出那么肉麻而虚伪地推荐辞，我是万万办不到的。这本书，应该就是那种你通读一遍之后，觉得「我知道了」的书，或许会想起来再翻下，但是你绝不会想翻纸质版，你更愿意 google，很难成为「书架上占据重要地位，不曾移开」的书，《鹿鼎记》还更有可能一点。「在众多编程书籍中，如果只能挑一本」，我也绝不会挑这本书，又厚，又重的，说不定挑《设计模式》还更好一点。

原文：

http://sexywp.com/about-code-complete-2e.htm

      

软件开发人员请读《代码大全》

I 泼侯

2008-12-21 21:24:32

《代码大全》是软件构建领域最重要的一本书。

我们阅读经典文学作品时需要树立一种观念，伟大作家的伟大作品的每一个词都有它独特的含义。作为一个对自己代码负责任的软件开发人员也需要树立一个类似的信念，每一行代码都有它存在的理由。而《代码大全》就是对所有编码实践背后理由的汇集，你可以找到大量的惯用法以及他背后的理由。

此书对我启发最大的是它的论述软件设计部分，它以最直接的方式表达出软件设计的本质，复杂度是软件开发的首要技术难题。设计不存在最佳的方法，设计是尝试的过程。

此书巨细靡遗涵盖了编码实现阶段的大量主题，各种层次的开发人员都可以一读，可以学到新的方法，也可以与自己的领悟互相印证。

      

公司发了一本

Hago

2006-08-10 14:37:44

软件开发的方方面面几乎无所不包，一本软件开发的百科全书。实在是太厚了，不知道读才好。就像是辞海辞源般的大家伙，谁要是能完全读下来融会贯通，绝对能成为大师；就是能全部记下来，怎么也能成为一代巨匠。

很喜欢这本书

大川

2006-08-18 13:38:00

我没读过软件工程的相关课程，但是看了前 4 张，感觉这本书正如序言里面说的，这本书也非常适合自学编程的人。在看这本书的过程中也负责了一个项目，虽然中途接手，而且需求做的比较差，验收项目的人也在上千公里之外，但是按照书上的做法，时间和质量都控制的不错。

陪伴大半年的 <Code Complete>

泰山

2015-02-18 17:38:06

Code Complete 是一本难得的可以在 kindle 上看的技术类经典书籍。

去年项目比较忙，基本上每天就是吃饭睡觉写代码。每日仅剩一点点看书的机会，是在地铁上、等人时、候车时，利用这些碎片时间掏出 kindle 看上几页。

但这半年时间，每天读这几页却实实在在地帮助我编写更好的代码。

譬如吧，书中有章节专门讲 debug，其中一段讲道，当你发现自己钻进一个问题太久，就意味着你需要休息了，让你的潜意识在你休息的时候帮你解决。于是，我在解决不了一个问题的时候，我就试试，下楼买杯咖啡晒晒太阳，放松一下；或者换一个事情做，回头再解决这个难题。这招别说还真有效，有几个我遇到的问题，看下去很难解决，其实换个思路，就豁然开朗了。

再举一例，书中讨论 comment 的部分。作者说道，仅仅重复代码内容的 comment，是不值得写的。值得写的 comment 是总结性的 comment 和说明意图的 comment。这样，你的代码就会像一本书被分为章节、段落，维护代码的人，能定位到需要关注的代码片段。

这本书中涉及的内容相当庞大，但都围绕同一个主题，就是『如何提高代码质量』。

对于我这种半路出家的人来说，很幸运能读到这本书。它就像一幅巨大的地图。

读几页书，在代码中实践，思考，每次提高一点点代码质量，这大概是一条比较好的修行路径。

必看的编程基础书籍

[已注销]

2016-01-06 15:53:36

1. 翻译总体质量很好，但也有些翻译的不是很贴切，或者和当前惯例译法不一样的地方，可能会对理解造成障碍，但是译者会适时加上原本的单词，影响不是很大

2. 书中的一些建议可能有些过时，读者应作多方参考，做独立思考.

3. 不得不吐槽的一点是，书的封面设计真心很丑，就这出版人感言还特意指出封面设计的 "美术功底" 不错，也是醉了.

4. 以上三点虽然全是负面的，但也都是些小瑕疵，依然动摇不了该书 (包括翻译) 对于程序员在技术上给出的这么多建议的实用性和作者语言风格的趣味性。任何买这本书的人都不会感到后悔，任何读完这本书的程序员都会上一个档次.

只是笔记

子龙

2016-04-02 01:57:49

详细的笔记也同时放在了我的博客里：

《代码大全（第 2 版）》笔记

---

title: 《代码大全（第 2 版）》笔记

date: 2016-08-28 21:05:43

tags: 

- 代码大全

- 读书笔记

---

### 记

按照阅读顺序来记录吧。并没有按照书页顺序来读，而是听从了译序里的「这本书适合谁看，该怎么看」的建议。先看了 18 章（初级程序员）、11 章（低年级学生）、第 8 章（防御式编程）、第 7 章（自学

编程的人）、第 13 章（喜欢参与网上争论的人）。看完这几章之后，就开始顺序看了。

总体感觉，这本书是属于「软件工程」范畴的。译序里提到：「这本书讲的正是为了到达‘编码完成’这一重要里程碑所必需的软件构件技术，确切地说，就是如何编写高质量的代码。作者认为，应该首先为人编写代码，其次才是为机器」。这差不多就总结了这本书的主旨。

这个笔记最初是在豆瓣上面一点点记录的，顺便还发现豆瓣上面这本书的一个特点：目前其书评大概是隔 2 个月会有人写一篇；本书出版 10 年，共计 90 篇书评，平均每年 9 篇。相对于那些畅销书，这样的评论增幅的确较慢，估计也是因为本书非常厚重、比较偏技术类的缘故了。

即使那么多年过去了，程序员在工作时的常见心理表现似乎没什么大变化。程序员普遍自负，例如 23.4 节说的，「就算是已经看到了一个缺陷，你的自负还是会让你觉得自己的代码完美无缺」。~~

<!-- more -->

### 第 3 章 三思而后行：前期准备

> 【49 页】

> 错误处理已被证实为现代计算机科学中最棘手的问题之一，你不能武断地处理它。有人估计程序中高达 90% 的代码是用来处理异常情况、进行错误处理、或做簿记工作，意味着只有 10% 的代码是用来处理常规的情况。

> …… 最好在架构层次上对待它。

### 第 4 章 关键的「构建」决策

> 一套好的符号系统能把大脑从所有非必要的工作中解放出来，集中精力去对付更高级的问题，从功效上看，能够有效地提高人类的智力。

以及：

>【4.3】

> 在我的职业生涯中，我看到了 PC 之星的升起和大型机之星的陨落，我看到图形用户界面程序代替了字符界面程序，我还看到了 Web 的崛起和 Windows 的衰落。（2004 年）

### 第 5 章 软件构建中的设计

这一章提到了本书的核心理念：

> 管理复杂度是软件开发中最为重要的技术话题。在我看来，软件的首要技术使命便是管理复杂度，它实在是太重要了。

以及，程序员的基本职业操守就是：

> 要写出既让自己容易理解，也能让别人容易看懂，而且很少有错误的程序代码。

>【第 90 页】：

> 封装帮助你管理复杂度的方法是不让你看到那些复杂度。

### 第 11 章 变量名的力量

> 临时变量，这个名词很奇怪，因为真的是「无论从那种角度看，你程序中的大多数变量都是临时性的。把其中几个称为临时的，可能表明你还没有弄清它们的实际用途。

【275 页】给出了 CPP/Java 的非正式变量命命名规则。然而似乎没有见过针对 JavaScript 的呢。。。（待调研）

为变量命名这个事情，也挺考验程序员的英语词汇量的。

### 第 12 章 基本数据类型

>【第 292 页】

> 避免使用「神秘数值」神秘数值是在程序中出现的、没有经过解释的数值文字量。如果你编程用的语言支持具名常量，那么就用它来代替神秘数值。

> 即使你确信某个数值在代码中永远也不会改变，使用具名常量也会有助于提高可读性。

> 一条很好的经验法则是，程序主体中仅能出现的（数字）字面量就是 0 和 1 。

### 第 15 章 使用条件语句

> 【第 363 页】

> 利用 default 子句来检测错误

> 如果一条 case 语句中默认子句既没有用来做其他的处理，按照正常执行顺序也不太可能会发生，那么就向里面加入一条诊断消息。

的确，很多时候编辑器的 Lint 工具会提示我们一定要加上一个 default 子句，然而有时候真的不知道该在里面写什么。上面的建议很不错。

### 第 16 章 控制循环

> 【第 382 页】

> 在嵌套循环中使用有意义的变量名来提高其可读性

### 第 18 章 表驱动法

表驱动法就讲了三类方法：① 直接访问；② 索引访问；③ 阶梯访问。

### 第 20 章

> 虽然开发一个高质量产品的最好方法似乎就是专注于产品本身，但就软件质量保证而言，你还需要关注软件开发的过程。

要尽可能多地找出缺陷，靠一种技术肯定是远远不够的，需要多种技术联合使用。例如，进行功能检查，单元测试，代码阅读。这三个就是最基本的了。而我目前的措施，顶多只有功能检查和代码阅读。非常缺少单元测试。

### 第 21 章 协同构建

对于协同构建技术的一个相关思想比较有趣而且也非常符合在实践中的感受：

> …… 那就是在工作中，开发人员总会对某些错误点视而不见，而其他人不会有相同的盲点，所以开发人员让其他人来检查自己的工作是很有好处的…… 攻击这些盲点就成为了有效构建的关键。

> 正如 Karl Wiegers 所指出的那样：「由人进行的复查能够发现不明显的错误信息、不恰当的注释、硬编码的变量值，以及重复出现的需要进行统一的代码模式，这些是测试发现不了的。」

想到一个话题，「经验丰富的程序员的价值究竟体现在哪里」，窃以为，其人工执行代码检查从而发现潜在问题、漏洞、缺陷的能力，可以弥补测试的不足、减少上线后的 BUG 率，从而为整个项目节约成本。这便是其价值体现之一。

> 【第 482 页】

> 一个采用正式检查的团队报告称，复查可以快速地讲所有开发者的水平提升到最优秀的开发者的高度（Tackett and Van Doren 1999）。

### 第 22 章 开发者测试

> 有些程序员会将术语「测试（testing）」和「调试（debugging）」混用，但是严谨的程序员会区分这两种活动。测试是一种检查错误的方法，而调试意味着错误已经被发现，要做的是诊断错误并消灭造成这些错误的根本原因。

在最近的开发体验中（说白了，就是指工作啦），深感开发者如果能够进行充分的自测，那么其交付的软件质量，将会更高，对代码质量（可维护性、可靠性、容错能力等）也都会有相应的（以及间接的）帮助。然而：

> 测试对于绝大多数开发人员来说都是一种煎熬……

> 

> 开发者测试应该占整个项目时间的 8%~25%

519 页有一条很有趣，而且自己也遇到这样的事情：

> 让人惊奇的是，笔误（拼写错误）是一个常见的问题根源…… 我的一位同事仅仅借助一个拼写检查工具对可执行文件中的所有字符串进行检查，就在我写的一个程序里发现了许多的错误。

说真的，编码过程中，还是应该尽量使用拼写正确的英文单词～

** 测试数据生成器（test-data generators）** 是用于产生对自己的代码进行测试用的数据的类或工具，作者在【524 页】提到了自己的一个经历，总结认为：

> 比起手工构造测试数据，随机数据生成器可以更加彻底地对程序进行测试。

这个概念目前我们也正在试用，对于线下无数据的情形比较有帮助。

### 第 23 章 调试

程序员背锅誓言：

> ** 要知道，如果你写的程序出了问题，那就是你的原因，不是计算机的，也不是编译器的。程序不会每次都产生不同的结果。它不是自己写出来的，是你写的，所以，请对它负责。**

有种编程方式叫做迷信式编程（programming by superstition），迷信式编程的同学大概是这样子的：

> 每个团队里也许都有这样一个程序员，他总会遇到无穷的问题：不听话的机器，奇怪的编译器错误，月圆时才会出现的编程语言的隐藏缺陷，失效的数据，忘记做的重要改动，一个不能正常保存程序的疯狂的编辑器……

以及新手程序员常犯错误：

> 因此，如果你从一开始就假设错误是你引发的，就能避免陷入这样的尴尬境地：在公众面前先指责别人犯了错，最终却发现错误其实由你而生。

550 页：

> 当你的编译器输出了一大堆的错误信息时，如果无法迅速找出第二条或第三条错误信息的源头，不要担心。先把第一条处理了，再重新编译。

### 第 33 章 个人性格

这一章的主题，像是对程序员的职业发展、学习方法给出合理中肯的建议。

要保持谦逊的品质。

> 在成长为高手的过程中，对技术事物的求知欲具有压倒一切的重要性。

> 技术环境的特定特征每 5 到 10 年就变化一番，如果没有足够的求知欲来跟上这些变化，你就面临落伍的威胁。

> 学习编程的一个特别好的途径是研究高手的程序。

> 如果每两月能看一本计算机好书，大约每周 35 页，过不了多久，你就能把握本行业的脉搏，并脱颖而出。（824 页）

> 当初学者或中级程序员不是错，当熟练级程序员而非技术带头人也无可厚非。但如果知道自己该如何改进后，还总是在初学者或者中级程序员阶段徘徊，就是你的不对了。

> 比尔·盖茨说，任何日后出色的程序员前几年就做得很好。从那以后，程序员好坏就定型了（Lammers，1986）。

好好学习

广所在

2016-06-23 08:37:09

想要学习软件开发的都应该去读这本书。书里面有很多一般很难接触到的最佳实践的东西。很多时候，这些也就是新手和高手之间的区别。当你知道了很多这些东西之后，也就很难有人再去叫你菜鸟。我认为本书最值得去读的是中间那几章很详细的细节方面的描述，如变量命名之类。我也很讨厌死板的软件工程教条，但我不反对软件工程。其实，这些所谓的最佳实践都是软件工程的核心。这些知识不仅仅是新手需要知道的，即使是所谓高手也需要常......

软件设计与开发的核心就在于：控制复杂度

Daniel

2016-08-05 16:16:09

最近在 《代码大全》这本书，包括的内容非常多，从软件设计到代码开发，团队管理都有，更像是一个软件编程领域的百科全书.

但是，对于书中提到的一点印象最为深刻，其实在 《人月神话》和《卓有成效的程序员》这两本书都有提到，那就是:

软件设计与开发的核心就在于 控制复杂度

这句话的核心其实包括几个问题:

软件开发的本质问题性难题是 复杂度 ？

如何可以一定程序的降低复杂度 ？

杂耍抛球

其中，书中对于软件设计必须控制复杂度的解释原因是:

没有谁的大脑能容得下一个现代计算机程序，也就是说，作为软件开发人员，我们不应该试着在同一时间把整个程序都塞进自己的大脑，而应该试着以某种方式去组织程序，以便能在同一个时刻可以专注于一个地方。这么做的目的是尽量减少同一时间所要考虑的程序量。你可以把它想做是一种心理上的杂耍 (边抛边接：通过轮流抛接使两个或者两个以上的物体同时保持于空中)- 程序要求你在空中保持的 (精神上的) 球越多，你就越可能漏掉其中的某一个，从而导致设计或者编码上的错误

—- 代码大全

当我读到这一段的时候，感觉这本书的作者真是说出了软件开发者心中的痛点，我也认为这段话可以说真本书的一个核心，其实代码大全的所有部分都是在围绕『如何降低软件开发中的复杂度』. 作者用这种，杂耍抛球的方式非常形象的比喻了，我们的大脑（生物结构上）本质的局限性导致的。曾经美国人有一个非常有名的调查，人类的大脑短期记忆能够容纳最多的不连续信息数就是 7, 加而或减二

具体可以参考心理学上被引用最多的一篇论文之一：魔数七，加二或者减二：人类处理能力的局限性.

而现实问题域中，我们要处理的变量何止是 7!

所以我们根本不可能同时让这么多变量一起出现在我们大脑中.

没有银弹

从哲学的角度来说，柏拉图认为，任何事物都有 两个属性：本质属性 与 偶然属性。通过此我们可以将软件行业

遇到的问题也分为两类，那么软件开发过程中 本质性的 难题是什么？

《人月神话》的作者认为，软件行业中遇到的非根本问题 (偶然属性) 都会随着时间发展，技术的提升，会逐步解决。但是 开发中的根本性问题 - 对于现实复杂世界本质的概念的复杂性是无法降低的.

一个软件系统有大量的状态，存在大量不同元素的相互叠加。这使得软件系统的复杂性以指数的形式增长。而且，这些复杂度是软件系统的根本属性，而不像数学和物理中那样可以建立简化的模型而忽略复杂的次要因素。

《人月神话》中对于本质的复杂性无法避免，起了一个名词，日后基本成了这个行业的标志：木有银弹.

不要期望通过一种 万能药能解决软件行业中所有的复杂性问题。所以 当每次一种新的技术 / 语言 / 框架 等出现的时候，当有些人大喊可以颠覆以前软件开发中的所有问题的时候，这时候你就要小心了。心理默默的告诉自己，没有银弹！

降熵

其实，软件的复杂度从某种意义上，用物理学第二定律来理解和加强。物理学第二定律又叫做，熵定律:

自然过程中，一个孤立系统的总混乱度（即「熵」）不会减小。

换成是软件行业的背景就是，用《程序员修炼之道》里面的解释就是:

软件的熵总是倾向于最大化的，程序员们称之为「软件腐烂」。

程序员只有在开发过程中，不断的通过 外部做功 (思考，主动性的思考和改代码), 不断进行代码重构与整理，通过外部系统注入能量，来降低整个软件系统的熵，是整个软件达到有序的状态.

为此软件开发行业提出了一些列的原则和指导方法，重构 / 单元测试 / 模块化设计 / KISS 原则 / 面向接口编程 / 模式设计 / 分布式系统… 等等如此，其实你都会发现，这些方法和指导原则，都是 告诉程序员，在软件开发的过程中，通过这些方法降低软件系统整体的复杂度，以便后期更好的维护与开发。当软件复杂度可以得到很好的控制，而不是让软件的熵无限的增长，那么这个软件系统的寿命也就会很长，得到更好的维护性.

所以，最后，我们知道：软件开发中的本质难题是 复杂度，那么我们在之后开发中 应该时刻的主动思考和做功：如何通过不断的代码重构降低整体的复杂度。保持我们的代码熵的最小化.

让我们的代码 永垂不朽！😊

更多内容:

www.razorer.com

      

我把它像圣经一样捧在手里...

Hong

2007-12-26 21:16:13

还能说什么呢，赞美的话语都快被说光了。我才看完第五章，但我已经确信，这本书绝对是个里程碑式的著作。我把它像圣经一样捧在手里...

信息量很大的一本书，需要认认真真的去读

☆守护魔鬼★

2012-07-12 23:02:12

每天读 6 页，读了三四个月，中间有时候偷了一下懒，终于读完了。回想过来，有些东西是可以一下子就明白的，例如关于具名常量、格式等等。有一些需要慢慢在以后的实践中慢慢推敲。

而且这本书信息量超乎寻常的大，不仅仅指书本身还有每个章节中的引用和书本后面的引用。还有最后一章，专门有一章的推荐读物，全部展开，可能穷尽一生都未必能够读完。所以需要好好的细读，慢慢的斟酌。

关于代码的工程实践参考

David

2006-10-31 13:54:46

是时候了，把你的代码建立在坚实的理论之上...

是时候了，读译本关于代码的工程实践参考全书...

力荐《代码大全》

集合还是分散

艾姆·凯丁

2013-06-16 13:15:01

之前看过一些其它书，《unix 编程艺术》《程序员修炼之道》之类的，这些书大同小异，《代码大全》很早就听过了，主观感觉这名字实在不吸引人，而且太厚了一直没买。

前段时间公司送大家每人一本，那就翻翻吧。

这就是彻彻底底的经验之书，没有研究的介绍，作者像是个博学的学者，语言平实，但字字珠玑。或许叫做「针针见血」反而更贴切。

对其中的每一句话的仔细推敲都能让你畅游其中。

毕加索的一句话印象很深，「艺术评论家聚在一起时讨论的是艺术的形式、意蕴、手法，而真正的艺术家只会讨论在哪里能买到便宜的松节油」

一本大杂烩

M_piaobo

2013-06-19 01:05:52

很多人问我，学计算机哪些书是必看的。当初我也问过这个问题，也在网上查了计算机的经典书籍，有什么《代码大全》、《算法导论》、

《计算机程序的构造与解释》、《深入理解计算机系统》等。先说《计算机程序的构造与解释》这本书吧，耐着头皮看完前三章，

感觉《Lisp 程序设计》这个书名更适合它，lisp 这种语言有一个特点就是可以把函数当做参数来传递。这本书是在一年以前看的，似乎没有学习到

什么建设性的知识。也许是笔者才疏学浅。上个月看了《代码大全》，给笔者的感觉这本书就是一本关于软件构建的大杂烩。前面 5 章，

大多阐述的比较抽象，书中讲的抽象、封装等和面向对象里讲的差不多，缺乏亮点，书中讲的，其他书中也有讲。也许有人会问，你要什么亮点啊？

举个例子，应该面向抽象编程，这没有错，但程序员也要避免陷入过度分层的倾向。过多的层次破坏了透明性，导致很难看清这些层次，无法在头脑中

理清代码到底是怎样运行的。从第 7 章到第 17 章，讲的很琐碎，每一个主题几乎讲到了所有的细节，我并不是说这不好，我只是说这部分是关于代码构建的。

或许你会说那么第 18 章应该是个亮点吧。恩，表驱动法，这个名字确实不错。但只讲了方法，没有讲原理。表驱动法背后的原理就是数据驱动编程，尽可能把

设计的复杂度从程序代码转移到数据中，因为数据比程序逻辑更易驾驭。总之，对《代码大全》这本书蛮失望的，可能是期望太高的了吧。

如何做到优秀？

一步一个脚印

2013-07-06 20:02:16

代码大全几乎包含了软件生命周期的方方面面，从多方面讨论了软件分析设计实现工作的原则、目标、方法，重点在实际开发实现层面，代码大全告诉了我什么才是规范化，如何做到人与代码最顺畅的沟通，我理解的代码大全的主题是：「优秀的软件设计实现是什么样子？如何做到优秀？做到优秀需要考虑哪些要素？」

设计优秀在于问题分解和抽象

实现优秀在于找寻适合自身团队组织的要素共同执行和遵守

整理的一些书中设计主题的笔记 >

http://blog.csdn.net/ybygjy/article/details/9260065

      

提高程序员的综合素质

mendynew

2009-09-23 22:03:05

这是一个大而全的软件开发书，但不是一本能使你成为高手的圣经，它只能提高你从事软件开发的综合素质。综合素质比精通其中的某一项更重要。

被人要求写书评...

xmq120

2009-11-12 14:57:59

虽然没全部看完，不过就看完的部分评价下吧。基本里面描述的问题在实际开发中都是会遇到，感觉很贴近实际，当然都是从思想角度和系统架构角度而言。不推荐新手看，起码有 3 年左右开发经验的人比较合适了。

软件工程管理参考手册

云水

2009-07-07 20:40:23

从软件的需求，构建，设计，测试，重构

软件开发的每个过程的每个细节，巨细无遗，软件工程案头必备。

让编程的方方面面更加有道理

WilliamCheung

2009-02-17 21:01:44

我一直认为，大多数事情，只要懂得了里面的章法，那么它会越来越有趣。读完这本大全级的书，定会饱学到编程方方面面的规则与规律，此时心中是满的，写程序将会是件有章法的有趣的脑力活动，整个过程便是愉悦的。

很棒的好书

流星

2017-07-12 21:15:35

        

作为一个小公司的程序员，所写的代码基本都是「只要能运行就行」。当项目变大时，这些可读性差的代码便变得很难维护。由于没有经验，重构的过程很慢。不知道什么是好的，什么是差的，只能根据自己的想法一点一点改。看完《代码大全 2》，发现书中的很多方法都很有用。比如有意义的变量名、函数名，避免全局变量，避免神秘字符、数字。创建高质量的代码、变量、语句，三个部分讲了如何创建高可读性的代码。系统考虑、软件工艺部分，又介绍了系统集成、测试、项目管理、个人发展等方面。看完了此书，对创建高可读性的代码有了一定的方向。并且其他如测试，集成等有一定的概念。力荐！

思维导图

http://processon.com/mindmap/59573c80e4b0a77c5ae87a07

，欢迎克隆

      

一次失败的技术学习组织经历

appleleaf

2011-04-11 20:43:42

《代码大全》是在学生的时候就读过的书，确实是五星级图书。于是我提出来作为小组内部每周技术讨论的学习资料。本来以为会有很好的学习效果，一定是大家热烈讨论，而事实恰好相反。在尝试了五六次之后，大家一直要求 stop。对我的热情是一个不大不小的打击。

下来反思了一下失败的原因：

首先，《代码大全》最为一本巨著，正面的评价，我们可以说他是巨细靡遗；而负面一点则是鱼龙混杂或者泥沙俱下。作者的一个写作意图就是试图覆盖软件开发之中，软件制作过程的方方面面。于是很多内容对于有经验的开发人员有些显而易见。我觉得，对于有 5,6 年工作经验的工程师，基本上砍掉一半的内容将会更加合适。

其次，本书描述的很多是一些准则，对于我这种喜欢名言警句的人或者需要准备 check list 的，当然读起来比较舒服。而也有很大一部分人反感这类的总结。

那么，什么样的话题适合小组学习或者大家讨论的更热烈呢？据我观察，应该符合下面的特点：

1. 两三个实际的小难题或者小 trick。例如，解决的困难的 bug 分析。

2. 稍微偏门一点，不要大家都了解的泛泛资料。

例如 BGP 的新扩展，多核开发的小问题，MIPS 上面的 Coredump 分析等等。

由手工作坊到现代工业的必由之路

ontheway

2009-08-27 11:40:50

Fortran 这名字来源于 Formular Translator。确实，大多数时候编程对于非计算机科班出身做数值计算的人来说，就是把推导好的公式翻译成计算机认得的语言。但当源代码长度数以 k 记，变量上百，函数几十个，而研究的问题又在不停地变化时，整个程序就很容易变成一团乱麻：每一行抽出来都知道是什么意思，放在一起就完全没有头绪了。最直接的解决办法自然是面向对象编程，把问题模块化成比较独立的结构来处理。但最根本的解决办法还是从更专业的角度来看待编程。这本书从前期需求分析，架构设计，到系统分层，模块化不同功能，中期调试，架构调整，后期优化与系统整合都有涉及。不仅谈到了概念与思路，也给出了具体的例子以及容易犯的错误。整个读下来编程就不仅仅是公式翻译，它本身也是一个需要统筹考虑的系统工程。当然，其中有些东西对于不以程序员为目标的人来说是有点杀鸡用牛刀了，但能以一种更系统全面的方式看问题也是很有帮助的。

这本书语言比较简单，逻辑思路很清晰，对于习惯看文献的人来说应该会很轻松。没给五星是因为不是专门针对科研背景的人（废话，本来就不是写给你看的）。我想这本书对于接触过面向对象编程，刚开始写大一点程序的人应该会更有助益的。

经典之作，翻译不行

Mongo

2012-02-03 09:43:10

书名翻译成《代码大全》是一种误导。如果直译，最好译作《关于编写程序代码的一切》。

可惜目前英文不到家，读读应用类的还行，无法读这种较抽象的专业书籍。如果能读通原版的，对提高编码能力绝对有实质性的帮助。

如果能读完这本书，对书中的代码示例有自己的切身体会的话，恭喜你，你已经成为一个合格的程序员了。我尚在合格的路上。

我买了一本，慧通面试的时候推荐给我的

softtrain

2006-05-10 14:28:08

当初推荐了两本 <<代码大全>> 和 <<代码精粹>>.

看到有 <<代码大全>> 出新版了，激动的不得了，就买了.

我是个刚要毕业的学生，很多东西会看不懂，但是慢慢来咯：)

多多交流呢，有机会的话

经验的总结

gleaners

2006-04-19 16:32:14

显然这是作者经验的总结。我想对任何软件开发人员来说，也是一张测试水平的试纸.

就是名字起得不好，第二版应该坚持用英文原名作为中文名: Code Complete.

写代码本就是写人性

流云阳光

2008-12-01 23:40:08

从没想过一本关于如何写代码的书会写得如此散文化。

　　 

以至于第一次读的 10 年后依然记得它。

　　 

更可笑的是记得的不是软件的种种开发方法及优劣，

　　 

也不是代码的布局，亦不是调试或测试。

　　 

而是通俗易懂的比喻。

　　 

你想像写文章一样写代码，还是像老福特工厂装备线上的员工呢？

      

都 TMD 说这本书好，什么意思？

渣叔叔。

2013-03-15 22:48:23

        

翻了翻目录，兴趣已经不大。

东翻西翻了下，勒个去，烂书一本。

好你妹！杂七杂八的拼盘，厚厚一本貌似每句话都重要，结果是尼玛没有一句话重要。我哪有兴致把这玩意翻完？艹，看了评论觉得这书简直是非买不可，结果，被坑了吧你，活该了吧你。这书就是本人列入「声名远扬，浪得虚名」名单中第一本！

不对我胃口。仍旁边废书堆去，爱咋咋。

少给 LZ 来什么低端的废话。LZ 就尼玛低端了不行？LZ 就是要给这本烂书一个差评！不给不舒服斯基！浪费 LZ Money 和心情！

      

不建议高手看

魏理布赫

2008-07-11 19:42:54

新手和中等水平的程序员可以看一下，对你养成良好的编程素养非常有益。

如果是高手的话，书中讲的，大家基本上都经历过了。有时间不如研究下算法、接触一下新技术。

代码大全

涅瓦纳

2011-07-30 20:13:54

我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了

Code Complete, Second Edition

涅瓦纳

2011-07-30 20:22:54

我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了 我看过了

开发做了两年多，看这个用处不大了。

death

2010-08-18 20:37:35

推荐刚毕业的看看，之后的就算了。

不亏是大全，从项目开始到结束，面面俱到，但对我来讲有用的东西就不多了。什么都涵盖，难免不够深入。

就像老妈的唠叨

流星

2010-10-12 19:20:57

之前看到一半了，但都忘了。

现在准备 Cover2Cover，挤点时间读完。

刚开始，感觉就像听老妈的唠叨。

有用的工具书

小东

2006-06-10 13:58:09

这本书，绝对不能跟读小说一样来读，因为里面涉及了很多实践方面的东西，如果你从来不写文章，可能用不到字典或者辞海，但我们写文章，觉不会去读这个字典或辞海；

这本书就是这样，我们开发软件，里面很多东西需要查找，但我们不必把这本书全都囫囵吞枣的读完。

呵呵，不知道我对本书评论的这个隐喻是否恰当。

推荐软件开发人员特别初学人员多看几遍

糊糊

2006-12-20 16:07:20

代码大全（第二版）是一本不错的书，特别对初级软件开发人员提了很多较好的建议，同时也对有一定编程经验的人有很好的指导意义。

比较全面的入门书籍

2sin18°

2008-03-04 19:46:33

code complete 2 看完了 和第一版相比 去掉了很多过时技术的介绍 加入一些比较新的技术介绍 不过大多都保留了意见

介绍的知识比较基础 在最后一章里 Steve 也把自己这本书定位在入门一级 但整体感很强 可以说是面面俱到 看完之后对一个完整的构建过程可以有一个全景式的了解

这本书最大的特点之一是「学术味」很浓，坚持用数字说话，对各种技术的评价比较中立。在做一些决策的时候，书中的数据会有比较大的说服力。另外，书中引用的资料也都是某个领域的经典之作。总之，这本书很像是一本大几百页的软件开发综述。

作者对「伪代码」技术的非常推崇，不过语言的抽象级本身比较高，本身的表达力就很强的时候，看不出由伪代码转为注释比普通的意图注释有什么明显优势～

里面比较新的参考文献很多都读过了，所以读得比较快，估计有些囫囵吞枣，等下次有机会再读吧。

      

china-pub 近期免费赠书活动大汇总

互动出版网

2011-06-17 11:43:11

        

http://www.china-pub.com/STATIC07/1106/jsj_zengshu_110616.asp

1、china-pub 新浪微博免费赠书（5 本）

#china-pub 赠书 #共 5 册，

《云计算核心技术剖析》

《云计算 (第二版)》

《Linux 内核设计与实现 (原书第 3 版)》

《黑客与画家：硅谷创业之父 Paul Graham 文集》

《MongoDB 权威指南》

关注本人转发本微博，即有机会获得赠书 1 册，随机抽取 5 名幸运者。

活动时间：06.10—06.20 日。

china-pub 新浪微博:@china-pub 网上书店

 

2、china-pub 豆瓣免费赠书（20 本）

活动地址：

http://www.douban.com/group/topic/20425927/

谁说天下没有免费的午餐？！您尽情的侃，china-pub 尽情的送！

不需其他，只要您侃的精彩，即有超值畅销书赠送。

【好书推荐】总有那么一些书，您想谈谈评评……

【职场杂谈】钱不是问题，问题是……（总有一些经验，您觉得值得分享）

【神侃战场】关于 IT 行业、人生、爱情……（总有一些话，如鲠在喉不吐不快）

【关于 china-pub】您对十年老网站 china-pub 有什么建议与意见呢？

活动规则

1、关注本豆瓣 china-pub (

http://www.douban.com/people/chinapub/

)，加入本小组 china-pub 网上书店（

http://www.douban.com/group/chinapub/

）；

2、在本小组对应的上述 4 个板块（好书推荐、职场杂谈、神侃战场、关于 china-pub）中任一板块发言，参与讨论的人，侃的精彩（侃的精彩就行哦）即有机会获得超值赠书 1 册；

3、赠书数量 20 册，最终获得赠书的 20 名幸运者（侃的最精彩的 20 人）可以在 china-pub 网站上任选 1 册赠书，每人限 1 册（原版书、按需印刷、套装书、缺货书除外）。（共 20 册赠书）；

4、活动时间：2011.06.13—2011.07.10 日；

5、本活动最终解释权归 china-pub 所有。

不错的书！

BRUCE

2007-03-11 21:31:19

我先看了中文版，后来看英文版，感觉里面的东西真的对工作有所帮助，如果你做程序员，你就能发现「我也犯过类似的错误！」，作者很强，能在工作中总结出如此之多的经验，不得不佩服啊！！

初读的时候并不觉得这本书能对得起它的盛名

netawater

2007-10-09 10:35:26

但我慢慢的读下去，了解到作者肯定花了很多精力在总结程序实现方面的经验，这些条理清楚的经验很有价值。

看你如何看待了

[已注销]

2008-05-01 00:34:47

        

最深刻的一个单词是「一致抽象」，这是我见过的最精确的用词。

这本书需要读过很多书作为底子，否则，会看得很吃力；或者只能看到表面的有趣。

很好很强大

cunsheng

2008-05-03 21:44:45

从软件工程、到编码规范和细节、再到效率优化，在构建的范围内，阐述了很多实用的理论，有些章节都读了三遍了，感觉还是回味无穷，项目管理那些章节尤其甚是，有了这本书，我就可以不用拿我的饭碗去摸索那些宝贵的经验，作者在各个领域都有很深的功力，我是佩服得五体投地，名字有些让人莫名其妙，看到博文如此强力的推荐是我当初购买的主要原因

这个大全不太冷

marryme

2008-06-04 09:51:11

最近代码写得.... 老大已经不能忍受了，让我自己看这本大部头... 看了一半，都是些经验的集合，要是没有机会运用的话，看了很快就忘了...

细微之处见真谛

老匡

2009-06-30 10:08:24

很早买了这本书，却在一次心浮时随便翻了二下。感觉整本书都在罗列条文，于是觉得没啥意思。

可前些日子细读下来，感受作者的细致、精湛。

代码大全提升了我整个开发的思维与修养。

软件开发，一门技术与艺术的结合。

代码

qhors 苗广飞

2010-01-10 11:29:30

人的代码由他的行为决定，因此没有自由。真是可悲，我们呢？可悲吗？也许吧！？人为了生活而付出自己的一切，但是死亡之后呢？怎么办？这本书已经把人的代码写出来了，只是没有点明。真是一本好书。其他呢？其他的事物岂不是没有位置了吗？怎么办呢？规则呢？她在哪呢？真是可惜。唉，真没办法！还好，还有真情存在于人们之间。

写得很仔细，平时总结得多

Kevin

2010-07-03 12:40:19

作者平时总结了很多，许多细节能体现出作者平时的严谨和细致。

体现了《程序员修炼之道》里的一句话：Think about your work.

相当合格的程序员，一点都不简单，得关注的方面太多太多！

蚂蚁

2010-09-10 18:25:33

看了此书，才知道原来当程序员还要关注很多很多方面。

或许，程序员也应该是有心人、有责任的人中的一种！

大学教材

JAVAMAN

2010-09-17 23:23:32

这是我大学的教材，买的时候感觉太贵了，毕业的时候觉得太重了，现在没事的时候翻翻，还没体会到经典的地方！

代码大全这本书绝对要看

smartbird

2010-10-21 11:31:29

1，无论你是新手还是老手，看后都能收获极多的知识。

2，代码大全既关乎代码，又关乎的是软件构建。

半程体会

嘉

2010-10-22 13:13:28

一条一条按书中所述的来做，可以养成好的编程习惯，写出赏心悦目的程序。

但读的过程感觉非常平淡，很少有让我心头一震的地方。

估计大头在后。

代码大全的一点读书感悟

水星 cici

2010-10-29 23:39:31

1. 软件构建的首要技术使命就是「管理复杂度」。这同时也符合简单哲学。书中常常会提到 7 这个数字，因为这是人脑智力管理的极限，多了就管不过来了。

关键词：抽象、封装、层次、消息隐藏、高扇入、低扇出，本篇不再具体阐述，有时间再专门讨论。

2. 以程序员为本。代码首先是为了人而写的，不是为了机器。机器只会对机器码感兴趣，高级语言自然是留给人来看的。

编程是艺术还是科学？"Programming is neither fully an art nor fully a science. As it's typically practiced, it's a"craft" that's somewhere between art and science. At its best, it's an engineering discipline that arises from the synergistic fusion of art and science.」我想正是这种艺术与科学相互融合的产物带给程序员无比的满足感。

一本值得你付一个月薪水的书

dlmu2001

2010-12-29 09:45:56

这是一本软件业的辟邪剑谱，关键是，你根本不需要挥刀自宫。拥有不同的功力，看书的时候就会有不同的收获，就如武林高手每天需要内家心法打坐一样，你应该每隔一段时间阅读这本书。再反省一下，是不是哪里还可以有所改进。

初学者可以从这本书里面学到很多经验，这些经验会让你在工作中少流很多血汗。

有一定工作经验的同志可以从这本书里面找到很多共鸣，然后，发现更多，激发更多思索。

技术带头人则适合以这本书来培养团队战斗力，组织代码构建活动，提高生产效率。

喜欢这本书的写作方式和翻译方式，书中列出了很多相关的读物，就相当于指一条路，让你可以继续前行。翻译的时候，对小标题保留英文术语，这点对我来说很好。

对编程生涯很好的总结。。

暮晨

2011-02-13 19:05:55

这是一本接近百科全书式的软件开发大全，里面涉及到了方方面面的开发知识，主要的侧重点放在了程序员编程这一偏微观的方向上。

从编写代码的最基础知识，优化方案，到软件架构，软件工艺，作者是烂熟于胸，信手拈来，整本书通读下来，非常的顺滑，惬意，仿佛在看自己这么多年来的软件开发回忆录，很过瘾。时常发出「哦，原来这样」，「啊，一直这么做原来是这个原因」。。。再看看作者随处列出的参考书目和文章引用，就知道作者是何等功力了。

窃以为这本书可以作为软件开发新手熟悉这个行业的扫盲指南，快速醍醐灌顶，也适合软件老鸟们作为梳理自己多年编程感悟和心得的一杯成年佳酿，至于像我等介于菜鸟和老鸟之间的「愤怒的小鸟」，更是给自己快要生锈的编程发动机上上油的绝佳激情催化剂。

我的编程 Bible

学游泳的鱼

2011-03-29 10:53:40

历时两个月的工作闲暇时间终于把这本大块头 800 + 页的书读完了，真的是大师的手笔，作者从软件构建的方方面面讲述了软件开发的核心内容。不愧为 Jolt Award 震撼大奖得主，对程序员最具影响力的书籍第一名。

http://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read

      

内容实在丰富

花之溪

2011-04-01 11:55:17

作者说:

创建一个软件的最彻底的办法并不是创建 —— 而是去购买一个软件，，你可以购买数据库管理系统、屏幕生成程序、报告生成程序和图形环境。在苹果公司 Macintosh 或者微软公司.Windows 环境下编程的一个主要优点是你可以自动获得许多功能；图形程序，对话框管理程序，键盘输入与处理程序，可以自动与任何打印机或者显示器工作的代码，等等....

那能写出这么一大本书的人不知道蚊子部分有参考别人的呢，因为这本书的内容实在是太丰富了，而且几乎面面俱到，太神奇了

相见恨晚的经典之作

leiux

2011-05-05 11:36:23

又一本相见恨晚的牛书，曾经因为蹩脚的书名没引起我注意，但是如果可以随意接触到其中任意一章内容的话，你就会觉得此书乃程序员必读的经典之作。如果你觉得你编码能力不行，建议你看看此书；如果你觉得你编码能力很牛，也建议你看看此书。

为编码人员写的一本书

泥土

2012-01-31 15:43:41

适合有一定编码经历的程序员阅读。如果大部分章节涉及的问题你都没有感触，说明或者读者没一定编码经历，或者已经跨过了这个层次。对于后一种，就没有必要看了。但对于前一种读者，建议还是看看。看的方法上，不需要字斟句酌，关注其思想和方法就可以了。

强化思想的好书

刘毅乐

2012-02-17 19:47:24

一本能提高编程思想的书，讲得粗浅却又细腻，全面又不乏细节的书，大到设计思想，小到编码风格，调试技巧。好多地方给我上了生动的一课，指引我在今后的编程生涯中应该怎么做，不该怎么做。能让我在应对问题的时候更加冷静，更加安心的适应编程过程中得各种变化，以及做出应对这些变化的决策。

很好的书

KCWU

2012-05-20 09:50:13

最近一直在看，感觉对于做过若干项目的程序员有很大的帮助，侧重说明对代码的整体设计，构建，直到编程规范的优化。对于提升代码的质量有很大帮助，的确是软件工程领域的一本既好读，又非常具有指导价值的好书，非常值得一读。

软件构建之实践指南

Wuqifu

2012-06-10 10:00:54

本书原版名为《Code Complete》，第二版出版于 2004 年。国内直接翻译成《代码大全》确实有些误导初读者，本书实质上是囊括了所有与编码相关软件开发活动。与某些高谈阔论、纸上谈兵方法论的书籍不同，作者有丰富的软件开发经验，书中的大量建议、Check List 都有实战价值，本书当之无愧是一本「软件构建之实践指南」。如果你是一名软件工程师，请不要错过这本《代码大全》！

在我看来如果一个团队中的开发人员都认真阅读过《代码大全》，那么在之后的开发过程中团队成员之间在理解、沟通方面会顺畅很多，《代码大全》为他们提供了一套标准、优秀的开发规范。正如 Coding Standard 对一个公司很重要一样，开发规范对一个团队的重要作用也是一样的。从这点上说，《代码大全》很适合作为公司员工培训书籍，貌似有不少公司也正是这么做的。

每个程序猿桌上必备的经典

Larry2012

2012-08-06 21:51:42

《代码大全》里很多观点对我的想法起了一个印证的作用，其中讲到用 goto 来编写错误处理一段完全重现了我之前开发时得出来的同样的经验。关于具体的编程的一些内容和现在的编程语言已经有一定差距了，不用怎么管，但此外的，讲项目的，讲心态的相当重要。一本牛 X 的书却起了一个烂的中文名字，这点很可惜。这本书应当买 一本放在手头，在开发的过程中遇到相关问题了，就翻下说不定能获得一些灵感。下面是引起我共鸣的一些内容的摘录。

* 设计是一个险恶的过程：需要先解决一遍才能认清问题。7.5.4 很有趣，值得多看几次。

* 关于变量名：理想的变量名长度为 9 到 15 个字符，函数名更长一点。在书中多次提到变量名，好的变量名能对代码的作用起到解释的作用，使得注释成为多余。

* 注释并不是必须的，只是在需要的时候才注释。更多的时候应当依靠代码本身来说明代码的作用。代码的易读性很重要，一方面是是使用好的变量名，另一方面是使用函数包装具体的单一功能使得程序结构清晰。

* 子程序长度是 100~150 行时，错误率最低。

* 结构化设计是把程序分解为子程序，强调的是操作。面向对象是把程序分解为对象，强调的是数据。面向对象的 4 类要素是：问题域要素、用户接口要素、任务管理要素、数据管理要素。这也是面向对象要考虑的 4 类对象。我认为类应当是以数据为核心的一系列操作。若操作不是对同样的数据做操作，就只能算作在一个名字空间下，或静态方法。

* 输入垃圾，输出不能是垃圾。

* 面向领域编程：定义类型的命名要用问题域中的类型，而不是编程语言自身的类型。程序的结构应当能体现问题域，整个思路也应该是按照问题域来编写，而不是仍停留在函数库的接口层面上。

* 单元测试、功能测试、部分测试、联合测试。

* 该用全局变量时就用。

* 使用逻辑变量。

* goto 用来释放资源的例子和我自己开发时想到的方法是完全一致的。只不过我自己后来用了更好的方法。

* 不要用递归计算阶乘。

* 项目越大，开发的效率越低。

* how to win friends and influnce people

* 软件质量保证最好的方法是控制软件的开发过程。

* 制造错误并不是罪过，不能从中学习才是罪过。

* 书上同样讲到在解决问题时不要钻牛角尖，不要过于坚持，在解决问题时设定一个时限，发现自己仍解决不也时，考虑一下别的思路，或是给别人讲述一下。当感到焦虑时，就要走一走，让心情平复下来。

还有一些残余的问题：

* 代码检查、普查、阅读有什么区别？评审比测试能发现更多错误。

       

程序员都应该读这本书

_Wise

2012-11-22 13:17:35

已经读过 2 遍了，非常受用。不管编程语言（范式）如何的发展，这里边提到的编程的方式和习惯都是非常实用的。比如，里边提到的变量的命名规格，函数设计的技巧，都是我们在实际的编码工作中能用到的，能极大的提高我们代码的质量。

照搬一句话，没看这本书你还是能写代码，但是看过之后你能写出更好的代码。

可以作为工程实践中 review 的 checklist

zchflyer

2013-01-27 10:30:59

书名解释其实就很好地诠释了这本书的主要内容，A practical handbook of software construction，软件构建之实践指南，列出了在具体的工程实践中需要注意的各个方面。

从一个项目的前期准备，真正理清软件的类型及问题描述，再到决定关键的「构建」决策，选择语言、选择主要的构建实践方法等，接着就是代码构建的各个方面，架构设计、类、子程序等，同时提出了一种实用的编程方式，即伪代码编程过程。

伪代码编程过程是通过书写伪代码贰高效地创建程序代码的专门方法，使用伪代码的指导原则是：1）用类似英语的语句来精确描述特定的操作，2）避免使用目标编程语言中的语法元素，3）在本意的层面上编程，4）在一个足够低的层次上编写伪代码，以便可以近乎自动地从它生成代码。就个人来讲，以前编程过程基本上处于用特定的编程语言写伪代码的过程，伪代码和特定语言的思维方式是不同的，这就导致代码构建的效率不高，其实完全依照伪代码编程方式进行实践，很多时候通过实践才能够理解一种方法和思想，进而改进，招到真正适合自己的方式。

变量和语句是代码构建过程中最主要的两个基本要素，从这两方面基本上可以区别程序员水平的高低。本书在这两方面不惜浓墨重彩，很多东西其实也是平时能够想到但做不到的，通过文字列出，同时总结了 checklist，可以在实际工程实践中时刻 check，养成良好的编程习惯并坚持。

真正的代码构建一般不超过 30% 的项目实践，更多的实际消耗在测试、调试和重构过程中，其实也就是书中所讲的代码改善过程。这部分经常在大型软件架构中才会足够重视，但是在小团队开发过程中，这其实也是需要重新重点考虑并有效实践的。

最后针对编程素养进行了讨论，从代码的布局与风格、字说明代码，再到个人性格，最终提出了软件工艺的话题，将工程化的软件构建过程上升到艺术的层面，的确如此，誰不愿意自己的成果看起来更像是工艺品！

内容丰富

第三方

2013-06-13 10:41:22

看了看他的目录，竟然有 35 章之多？架构、分析、设计、编程、测试、重构、面向对象、调试、规范、管理、软件质量控制、协作、优化、开发工具、注释、甚至个性、开发艺术等等等等，只要是与软件有关的，基本上他都写到了。

不愧为新老鸟的读物

zhengyangas

2013-09-22 21:19:56

很适合作为床头读物，全文可以一气呵成，也可以细细品味，毕竟扯了较多编程思想，编程哲学层面的东西。

无论新老鸟，品读该大作都会有不少收获。从设计思想到编程规范都让自己有了新的认识。全文通读下来，也思考了自己的项目经历，发现本书作者的观点的确能够指导自己接下来的工作，非常推荐大家阅读

当概念与实践之间有很长的路要走，这本书可以指导你

清逸

2014-09-01 11:27:57

我学的是软件工程专业，也知道好多概念，项目管理，项目过程，代码规范等等，代码写得还行，可是还是很困惑，它们的联系，为什么这样做，还相信一些传说。我一直在试图弄明白这些问题。

在等待通知而又无所事事的那段日子，我便买了这本书。本是想着边读书，边等待消磨时间。只是没想到，越读越让人感兴趣，以前似是而非的理解在看书的过程中豁然开朗。

像整个软件开发过程的隐喻，让人倍感亲切，不似以前看的书中尽是死板，条条列列。像防御性编程的讲解让人感觉软件的健壮性是天经地义的，这时候就会不禁想起那些国内讲语言编程的教材真是有待进步。像代码规范的部分看着真是让人赏心悦目，效果远胜于有人苦口婆心教导你要遵循 XX 语言编程规范。还有讲调试，优化性能的既有例子又有分析。最后软件工艺的部分真的很贴心，从人的角度看待整个工程，而不是伤感情地说 XX 人月。

我感觉读这本书的方式是，有困惑的时候去读，不读不足以解惑。过段时间回过头再读，因为这是一本百科式的全书。

其实这本书应该叫《编码大全》

Alanmars

2014-12-06 22:46:43

这本书读到一半之后，就发现这本书的书名翻译得并不贴切。因为发现作者从头到尾在告诉读者如何写出易读，鲁棒和可扩展性的代码。

现在的软件开发已经告别过去个人英雄主义的时代了，协作变得越来越重要，如何让自己写的代码让别人易于理解，是每一个软件工程师都必备的技能。

《代码大全》这本书基本上涵盖了编码过程中的方方面面，作者所讲到的每一个部分，软件工程师们都应该根据自身情况消化吸收。

书名翻译的不怎么对

砖块工

2015-01-31 23:23:00

这本书读到一半之后，就发现这本书的书名翻译得并不贴切。因为发现作者从头到尾在告诉读者如何写出易读，鲁棒和可扩展性的代码。

　　 

现在的软件开发已经告别过去个人英雄主义的时代了，协作变得越来越重要，如何让自己写的代码让别人易于理解，是每一个软件工程师都必备的技能。

　　 

《代码大全》这本书基本上涵盖了编码过程中的方方面面，作者所讲到的每一个部分，软件工程师们都应该根据自身情况消化吸收。

好厚好全好难深入

ansondeng

2015-03-01 15:17:20

这真是一本很厚很全面的书，话说参考文献就几百本，这还怎么好好的看下去嘛。不过，好在有点年头了，所以也不是什么都要仔细看。但我好想好多书都没有很认真仔细地研读过，都是等着以后重读时再说。anyway，要看的书浏览的信息实在太多，至少我大部分看下来了。

下面正式记录下印象深刻的点：

本书是关于构建 construction 的，包括  设计、编码、调试、测试；

前期准备必须必要，用来定义问题、确定需求、选择软件架构；

软件设计最主要任务、方法就是 控制、降低复杂度，把问题搞得越简单越好；

好多关于  类、子程序、异常、变量、语句  的细节；

协同构建包括 结对编程、正式检查等等，正式审查和走查、review 不一样；

什么时候能完完全全实践 开发者测试、TDD；

不要盲目地、随机地为了调试而调试，动手解决问题先理解问题的根本；

觉得代码有坏味道时实时重构；

根据项目规模适用不同的开发方法和过程，分清程序和产品；

度量、评估工作量和时间虽然不准切但却很重要；

     。。。     

程序员的「交规」

Odysseus_110

2015-03-27 10:32:55

这本书几乎占据所有「大神」推荐书单的前三甲，最主要的原因是这本书不是针对某一种语言，而更像是所有程序员应该遵守的「交规」。就像你可以在驾校开着车子绕圈，但是在驾校学会开车以后，在上路之前你还得把交规背熟，不然你就是「马路杀手」。写程序也一样，你如果不遵守写程序的「交规」，就会在你写的程序里横冲直撞，把零件散落到程序的所有地方，并且影响到团队的其他人的工作。

这本书不用太费脑子，但是在写程序之前最好能过一遍。

摘录一些小例子：

1 把变量的引用点靠在一起的时候，也就使得代码的阅读者能每次只关注于一部分代码。而如果这些引用点之间的距离非常远，那你就要迫使阅读者的目光在程序里跳来跳去。因此，把变量的引用点集中起来的主要好处是提高程序的可读性。

2 警惕」临时「变量

临时变量用于存储计算的中间结果，他们常被赋予 temp，x 或者其他一些模糊且缺乏描述性的名字。通常，临时变量是一个信号，表明程序员还没有完全把问题弄清楚。增加了出错的可能性。

3 使用肯定的布尔变量名  否定的名字如 notFound, notdone 以及 notSuccessful 等较难阅读，特别是如果它们被求范：

If not notFound

这样的名字应该替换为 found, done 或者 processingComplete，然后再用适当的运算符求反。

[Code] code 的阴阳生两仪

KeepRunner

2015-08-03 00:51:12

本书涉及内容很广，800 + 的书籍，仍旧无法深入每个细节，但是给出了深入学习的参考书籍和资料。

涉及的技术不需要刻意的会某种语言，基本上涉及到代码构建的方方面面，第一遍几乎是一星期就浏览完成，感觉很有意思，比起学校的编程语言教学，这本书涉及到的才是真正的 code 技术。

本书不涉及数据结构、算法、或者是设计模式、编程语言的语法，数据库等问题，而是在一个宏观的解读上解读如何编写高质量的代码，如果管理自己的代码的复杂度，不同数量级的代码编写起来是非常不一样的，写的不错，值得在深入读一遍。是修炼内功、让自己写出优雅和可控复杂度代码的一本好书。

《代码大全 2》读书笔记

JH_Gao

2015-12-13 19:09:26

读了两遍，第一遍概览，第二遍仔细地读，并做了笔记。这本书涉及到大量的细节，核心思想是：1. 管理软件项目的核心是管理复杂性；2. 代码更多的是人与人之间的交流。

# 第一部分 打好基础

## 第 2 章 隐喻

重要的研发成果常常产自类比（analogy）。通过把你不太理解的东西和一些你较为理解、且十分类似的东西做比较，你可以对这些不太理解的东西产生深刻的理解。这种使用隐喻的方法叫做「建模」。

目前最合适隐喻：建造软件（Building Software）

## 第 3 章 前期准备（ Measure Twice, Cut Once）

测试只是完整的质量保证策略的一部分，而且不是最有影响的部分。

迭代开发往往能够减少「前期准备不足」造成的负面影响，但它不能完全消除此影响。

如果需求变更过于频繁，就建立一套变更控制程序（流程）。

** 错误处理 **

架构中应该清楚地说明一种「一致地处理错误」的策略。监测到一个错误时，应该「说」出来。

** 过度工程 **

在软件中，链条的强度不是取决于最薄弱的一环，而是等于所有薄弱环节的乘积。

** 变更策略 **

架构应当清楚地描述处理变更的策略。架构应该列出已经考虑过的有可能会有所增强的功能，并说明「最有可能增强的功能同样也是最容易实现的」。

** 质量 **

你不应该担心架构的任何部分。架构不应该包含任何仅仅为了取悦老板的东西。它不应该包含任何对你而言很难理解的东西。你就是那个实现架构的人；如果自己都弄不懂，那怎么实现它？

# 第 2 部分 创建高质量的代码

## 第 5 章 软件构建中的设计（Design in Construction）

好的高层次设计能提供一个可以稳妥容纳多个较低层次设计的结构。

设计是一个「Wicked Problem」-- 你必须把这个问题「解决」一遍以便能够明确地定义它，然后再次解决该问题，从而形成一个可行的方案。

软件设计的最重要目的是管理复杂度（Managing Complexity）。有两类复杂度：

* 本质的（essential）：一件事物必须具备，不具备就不再是该事物的属性。比如业务逻辑。

* 偶然的（accidental）：碰巧具有的属性。比如集成环境，编程工具等等。

大脑没法装下整个程序。好的设计，让人在一个时刻可以只专注于一个特定的部分。

> 你可以把它想做是一种心理上的杂耍（边抛边接：通过轮流抛接，使两个或两个以上的物体同时保持在空中） -- 程序要求你在空中（精神上）保持的球越多，你就越可能漏掉其中的某一个，从而导致设计或编码的错误。

理想的设计特征（Desirable Characteristics of a Design）

* 最小的复杂度（Minimal Complexity）。要避免做出「聪明的」设计。因为「聪明的」设计往往都是难以理解的。如果你设计的方案不能让你在专注于程序的一部分时安心地忽视其他部分的话，这一设计就没什么作用了。

* 易于维护（Ease of maintenance）

* 松散耦合（loose coupling）

* 可扩展性（extensibility）

* 可重用性（reusability）

* 高扇入（high fan-in）。高扇入就是说让大量的类使用某个给定的类。这意味着设计出的系统很好地利用了在较低层次上的工具类。

* 低扇出（low fan-out）。低扇出就是说让一个类里少量或适中（小于 7 个）地使用其他的类。

* 可移植性（portability）

* 精简性（leanness）。伏尔泰曾说，一本书的完成，不在它不能加入任何内容的时候，而在不能删去任何内容的时候。

* 层次性（stratification）。假设你正在编写一个新系统，其中用到很多设计不佳的旧代码，这时你就应该为新系统编写一个负责同老代码交互的层。在设计这一层时，要让它能隐藏旧代码的低劣质量，同时为新的层次提供一组一致的服务。

* 标准技术（Standard techniques）

优秀设计师的一项重要特质就是对变化的预期能力。好的程序把变化所带来的影响限制在一个子程序、类或者包的内部。

测试友好的设计，往往是好的设计。

「你在应用某种设计方法时越教条化，你所能解决的现实问题就越少」。请把设计看成是一个险恶的、杂乱的和启发式的过程，不要停留于你所想到的第一套解决方案，而是去寻找合作，探求简洁性，在需要的时候做出原型，迭代，并进一步迭代。你将对自己的设计成果感到满意。

## 第 6 章 可以工作的类（Working Classes）

警惕有超过约 7 个数据成员的类。

优先使用「深层副本（deep copies）」，除非论证可行，才采用「浅层副本（shallow copies）。

## 第 7 章 高质量的子程序（High-Quality Routinges）

复杂的布尔判断，应该使用子程序来实现。

人类很难同时记住超过 7 个单位的信息。

子程序的名字是它的质量的指示器。如果名字糟糕但恰如其分，那说明这个子程序设计得很差劲。如果名字糟糕而且又不准确，那么它就反映不出程序是干什么的。不管怎样，糟糕的名字都意味着程序需要修改。

## 第 8 章 防御式编程（Defensive Programming）

保护程序免遭非法输入数据的破坏。检查所有来源于外部的数据的值。

用错误处理代码来处理预期会发生的状况，用断言来处理绝不应该发生的状况。

可以让软件的某些部分（某个抽象层，公用方法等）处理「不干净的」数据，而让另一些部分处理「干净的」数据，即可让大部分代码无须再担负检查错误数据的职责。

** 异常 **

用异常通知程序的其他部分，发生了不可忽略的错误。在恰当的抽象层次抛出恰当的异常，比如底层异常不应该在高层抽象中被抛出。

# 第 3 部分 变量

## 第 10 章 使用变量的一般事项（General Issues in Using Avriables）

** 初始化 **

在声明变量的时候初始化。

理想情况下，在靠近第一次使用变量的位置声明和定义改变量。

在可能的情况下使用 final 或者 const。

** 作用域 **

使变量的引用局部化，减小变量的作用域：

* 在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序的开始处初始化这些变量。

* 直到变量即将被使用时再为其赋值。

* 把相关语句放在一起，可能的情况下提取成单独的子程序。

* 开始时采用最严格的可见性（比如设为 private），然后根据需要扩展变量的作用域。

「方便性」和「智力可管理性」两种理念之间的区别，归根结底来源于侧重写程序还是读程序之间的区别。

每个变量只应该用于单一用途，且不应该有隐藏含义（比如当 x 大于 5000 时代表什么）。

## 第 11 章 变量名的力量（The Power of Variable Names）

通常，对变量的描述就是最好的变量名。名字对于代码读者的意义要比对作者更重要。

一个好名字通常表达的是「what」而不是「how」。一般而言，如果一个名字反映了计算的某些方面而不是问题本身，那么它反映的就是「how」而不是「what」了。

较长的名字适用于较长的作用域，较短的名字适用于短的作用域（循环、小的方法等）。

计算限定词，如 Total、Sum、Average、Min、Max、String、Pointer 等等，应该放在名字的最后。

典型的布尔变量名：done, error, found, success, ok 等。布尔变量应该是那些隐含了「真 / 假」含义的名字，如 done 和 success 等。应该使用肯定的布尔变量命名，而不是 notFound，notDone 等。

枚举类型要有统一的组前缀。

避免使用具有相似含义的名字。如果你能够交换两个变量的名字而不会妨碍对程序的理解，那么你就需要为这两个变量重新命名了。

命名规则应该能够区分局部数据、类的数据和全局数据。

## 第 12 章 基本数据类型（Fundamental Data Types）

Tips：

* 避免使用 Magic Number。

* 每次遇到除法时都要检查预防除零错误。

* 显式地使用类型转换。

* 避免混合类型的比较。

* 整数：小心溢出。

* 浮点数：避免「相等」判断，避免数量级相差巨大的数之间的加减运算。

* 字符和字符串：尽早决定是否使用 Unicode

* C 语言中的字符串：

* 警惕任何包含字符串和等号的表达式

* 字符串的长度声明为「CONSTANT+1」

* 用 null 初始化字符串以避免没有结束符的字符串，使用 `calloc ()` 而不是 `malloc ()`

* 布尔变量：使用布尔变量来简化复杂的判断

* 数组：

* 任何情况下，确认所有的数组下标都没有超出数组的边界

* 尽量使用容器来取代数组，或者将数组作为顺序化结构来处理

* 自定义类型

* 使用自定义类型（通过 typedef 等方法）实现更好的抽象

* 给所创建的类型取功能导向的名字，避免使用那些代表了计算机数据类的类型名（如 BigIngeger

, LongString 等）。

## 第 13 章 不常见的数据类型（Unusual Data Types）

* 指针：

* 把指针的操作限制在子程序或类里面。比如通过 `NextLink ()`，`PreviousLink ()` 等方法代替直接操作指针。

* 指针的声明和定义放在一起（一行）。

* 在与「指针分配」相同的作用域中删除指针。

* 在使用指针之前检查指针。

* 用额外的指针变量来提高代码清晰度，避免类似 `pointer->next->last->next` 等使用指针的方法

* 在删除或者释放指针之后把它们设为空值（null）

* 全局数据：

* 仅在确实需要的使用使用全局数据（首先把每一个变量设置为局部的，仅当需要是再设置为全局的）

* 全局数据应该让人一看便知，如果使用了全局数据，就公开地使用

* 用访问器子程序（Access Routines）来取代全局数据

* 根据全局数据的功能，把全局数据分为不同的模块（包、类）

* 用 `static` 关键字或者它的等价物来声明该数据，确保该数据只有单一实例

* 确保对一项数据的所有访问都发生在同一个抽象层上

## 第 14 章 组织直线型代码（Organizing Straight-Line Code）

依赖关系必须清晰明显。通子程序名、程序参数等实现。

## 第 15 章 使用条件语句（Using Conditionals）

If-ElseIf-Else 结构中，最后一个 Else 确保所有的情况都考虑到了。

Case 语句的顺序：首先按照频率从高到低，频率一样按照字母排列。

## 第 16 章 控制循环（Controlling Loops）

使用带退出的循环，类似：

```python

while True:

    # do something

    if some_condition:

        break

    # do something

```

把初始化代码紧放在循环前面。

在循环的开始处用 continue 进行判断。

一个循环只做一件事。如果用两个循环会导致效率地下，而使用一个循环很合适，那么就把代码写成两个循环，并注明可以把它们合并起来以提高效率，然后等测量数据显示程序的这一部分性能低下的时候再去合并它们。

避免出现依赖循环下标最终取值的代码。

小心那些有很多 break 散布其中的循环。一个循环包含很多的 break，有可能意味着程序员对该循环的结构或者对循环本身的角色缺乏清晰的认识。在大量使用 break 的场合中，用一系列的循环而非一个含有多个出口的循环可能会使表达更清晰。

循环要尽可能短，嵌套限制在 3 层内。

## 第 17 章 不常见的控制结构（Unusual Control Structures）

子程序中的多处返回（Multiple Returns）：如果能增强可读性，那么就使用 return。

小心谨慎地使用递归。

## 第 18 章 表驱动法（Table-Driven Methods）

使用一目了然的表来代替复杂的逻辑判断。

## 第 19 章 一般控制问题（General Control Issues）

Tips：

* 编写肯定形式的布尔表达式

* 按照数轴的顺序编写数值表达式，例如 `MIN_ELEMENTS <= i and i <= MAX_ELEMENTS`

* 与 0 比较的指导原则：

* 隐式地比较逻辑变量

* 把数和 0 相比较，使用 `while (balance != 0) ...` 而不要使用 `while (balance) ...`

* 在 C 语言中显式地比较字符和 `\0`

* 把指针与 NULL 相比较，使用 `while (p != NULL) ...` 而不要用 `while (p)`

控制结构域复杂度密切相关。人类大脑很难处理好超过 5 到 9 个的智力实体。

# 第 5 部分 代码改善（Code Improvement）

## 第 20 章 软件质量概述（The Software-Quality Lanscape）

质量不应该被认为是次要目标。组织本身必须向程序员们说明，质量应当放在第一位。

实现软件质量目标的拦路虎之一就是失控的变更。

阅读代码是最有效率的找出缺陷的方法。

没有任何一种错误检测方法能够解决全部问题，测试本身并不是排除错误的最有效方法。成功的质量保证计划应该使用多种不同的技术来检查各种不同类型的错误。

缺陷可能在任何阶段渗透到软件中。因此，你需要在早期阶段就开始强调质量保证工作，并且将其贯彻到项目的余下部分中。质量保证工作应该作为技术脉络的一部分，以及项目的结束点。

提高生产效率和改善质量的最佳途径就是减少花在这种代码返工上的时间，无论返工的代码是由需求，设计改变还是调试引起的。

更多的质量保证工作能降低错误率，但不会增加开发的总成本。编写无缺陷软件并不一定会比编写富含缺陷的软件花更多的时间。开发高质量代码最终并没有要求你付出更多，只是你需要对资源进行重新分配，以低廉的成本来防止缺陷的出现，从而避免代驾高昂的修正工作。

## 第 21 章 协同构建（Collaborative Construction）

协同开发实践往往能比测试发现更多的缺陷，并且更有效。

协同开发实践所发现的错误的类型通常跟测试所发现的不同，这意味着你需要同时使用详查和测试来保证你软件的质量。

对代码进行详细检查是减少缺陷的高效方法。

代码详查的记过不应当作为员工表现的评估，因为详查中的代码任然属于开发阶段，评估的依据应该是最终产品而非尚未完成的工作。

进行详查的目的是发现设计或代码总的缺陷，而不是探索替代方案，或者争论谁对谁错，其目的绝不应该是批评作者的设计或者代码。对所有人来说，这一过程都应该是正面的：程序得到了明显改善，参与者都学到了一些东西。

对代码的非正式检查（走查）效果并不好。

软件质量的普遍原理：在减少软件中的缺陷数量的同时，开发周期也能得到缩短。

结对编程的关键（Keys to Success with Pair Programming）

* 统一编码规范

* 不要让结对编程变成旁观

* 不要强迫在简单的问题上使用结对编程

* 有规律地对结对人员和分配的工作任务进行轮换

* 鼓励双方跟上对方的步伐

* 避免新手组合

* 指定一个组长

## 第 22 章 开发者测试（Developer Testing）

* 错误并非平均地分布在所有的子程序里面，二是集中在少数几个子程序里面。

* 大多数错误的影响范围是相当有限的（不超过一个子程序）。

* 大多数的构建期的错误是编人员的失误造成的。

* 笔误（拼写错误）是一个常见的问题根源

* 很多错误是由于没有彻底地理解设计

软件质量的普遍原则：开发高质量的软件，比开发低质量软件然后修正的成本要低廉。

## 第 24 章 重构（Refactoring）

重构策略：

* 在增加子程序、类时进行重构

* 在修补缺陷时进行重构

* 关注容易出错的模块

* 关注高度复杂的模块

* 如果在维护一个系统，改善你手中正在处理的代码。确保代码在离开你的时候比来之前更健康。

* 定义清楚干净代码和拙劣代码之间的边界，然后尝试把代码移过这条边界。

# 第 6 部分 系统考虑（System Considerations）

## 第 27 章 程序规模对构建的影响（How Program Size Affects Construction）

随着项目规模的增大，更大一部分错误要归咎于需求和设计。

随着项目规模的增长，构建活动将只占项目总工作量的一小部分。

对于大项目来说，如果不有意识地去选择方法论，就将无法完成任务。

项目越正规，你不得不写的文件的数量也越来越多，用于确认你已经完成了自己的工作。

随着项目规模的扩大，交流需要加以支持。大多数方法论的关键点都在于减少交流中的问题，而一项方法论的存亡关键也应取决于它能否促进交流。

在其他条件都相等的时候，大项目的生产率会低于小项目。而大项目的每千行代码错误会高于小项目。

在小项目里的一些看起来「理当如此」的活动在大项目中必须仔细地计划。随着项目规模扩大，构建活动的主导地位逐渐降低。

放大轻量级方法论要好于缩小重量级方法论。最有效的办法是使用「适量级」方法论。

第 28 章 管理构建（Managing Construction）

鼓励良好编码实践的一些技术：

* 给项目每一部分分派两个人。

* 逐行复查代码。

* 要求代码签名。

* 安排一些好的代码示例供人参考。

* 强调代码是共有财产。

一个简单而有效的衡量标准是：「我必须能阅读并理解这个项目里的所有代码」。

需求变更和设计变更：

* 遵循某种系统化的变更控制手续。

* 成组地处理变更请求。记下所有的想法和建议，不管它实现起来有多容易。把它记录下来，直到你有时间取处理它们。到那时，把它当做整体来看待，从中选中最有益的一些变更来加以实施。

进度落后时，增加时间通常并不可行。

任何一种项目特征都是可以用某种方法来度量的，而且总会比根本不度量好得多。度量结果也许不会完全精确，度量也许很难做，而且也需要持续不断地改善结果，但是它能使你对软件开发过程进行控制，而如果不度量就根本不可能控制。

程序员之间有着数量级的差异。即时个体程序员都一样，不同编程团队在软件质量和生产率上也有着相当大的差异。

# 第 29 章 集成（Integration）

要点：

* 构建的先后顺序和集成的步骤会影响涉及、编码、测试各类的顺序。

* 一个经过充分思考的集成顺序能减少测试的工作量，并使调试变容易。

* 增量集成有若干变型，而且 -- 除非项目是微不足道的 -- 任何一种形式的增量集成都比阶段式集成好。

* 针对每个特定的项目，最佳的集成步骤通常是自顶向下、自底向上、风险导向以及其他集成方法的某种组合。T 型集成和竖直分块集成通常都能工作得很好。

* Daily Build 能减少集成的问题，提升开发人员的士气，并提供非常有用的项目管理信息。

# 第 7 部分 软件工艺（Software Craftsmanship）

## 第 32 章 自说明代码（Self-Documenting Code）

好代码本身就是最好的说明。如果代码太糟，需要大量注释，应先试着改进代码，直至无须过多注释为止。

注释应说出代码无法说出的东西 -- 例如概述或用意等信息。

## 第 33 章 个人性格（Personal Character）

编程工作本质上是项无法监督的工作，因为没人真正清楚你正在做什么。

高智商与优秀的程序员之间并无太密切的联系。

编程首先是与人交流，其次才是与计算机交流。

人的个性对其编程能力有直接影响。

最有关系的性格为：谦虚、求知欲、诚实、创造性、纪律，以及高明的偷懒。

小聪明、经验、坚持和疯狂既有助也有害。

好性格与培养正确的习惯关系甚大。要成为杰出的程序员，先要养成良好习惯、其他自然水到渠成。

      

这是少有的常看常新的书

城北大洋桃有毛

2016-10-16 19:59:20

在能力不同的阶段，有不同的收获，很多程序员界的纷争都有答案。

物超所值的一本书

既有深度，又有广度

康康

2017-01-05 22:33:34

        

虽然以前翻阅过十来章，没有系统的阅读过，最近买了一本书，读完以后收货非常大。

可以说自己从多个视角去阅读，都是收货满满。从程序员角度，明白了基础的编码方法和要求，还有一些注意事项。从架构师角度，再一次理解如何设计，以及软件的本质在于解决现实世界的复杂度。从项目经理角度，温顾了迭代、持续集成、冒烟…… 正想不到在很多年前以及有人将这些我们还在发挥关键作用的工程方法总结的非常透彻。从部门经理角度，理解一个团队软件开发过程最重要是什么，如何做好团队成员的合作以及方法，个人的成长。

虽然只花了 11 天就阅读完成了，主要还是很多经验和道理已经在平时的工作和学习获知了，但是这本书给我带来的震撼和感悟还是非常深刻的。

      

经典不会过时

无聊叮当猫

2017-08-28 19:56:13

过了 5 年，再次翻开这本已经出版了十多年的经典书籍，仍是感受颇多。

尽管没有什么银弹，但 Manage the complexity，管理复杂度，是软件项目成功与否的重要因素。McConnell 在近千页，三十余章的篇幅里，不遗余力地向我们阐述如何去管理软件项目中的复杂度。和人月神话里 Brooks 说的一样，软件有 domain 里复杂度，那是不可避免的；但非必要的复杂度，是我们需要着力去解决，去简化的。

不知 AI 的发展，会不会在对问题领域中的复杂度的处理发生天翻地覆的改变呢？

代码完成

读万卷书

2017-12-03 13:46:10

        

几年前入手此书，即被此书的篇幅震撼到。以致于刚开始阅读时，每每拿起都有一种无法驾驭，想就此放弃的想法。不过在断断续续看过第一遍后，对此书大纲及具体内容有了初步了解，竟不自觉的开始了第二遍、第三遍、第四遍的阅读。说实话这是一本需要多次阅读的书，因为每次翻看同一章节，或查看同样内容，都会使自身阅历增加，尤其是 coding 经验的增长而得到不同理解和收获。 如果你是既得利益者，带着明确的目的来寻求答案代码，请果断放弃，本书不会有你想要的东西。但如果你想在程序员的路上走的更远、段位更高，在架构层面理解的更深，建议你仔细品读。 此书名为 <Code Complete>，译版名为《代码大全》。但是当你阅读过后，反而觉得 <Code Complete>（代码完成）的书名更适合此书。代码完成这一软件开发过程中的重要里程碑的概念是什么？标准是什么？阅读此书后答案自然揭晓。此书并没有任何功能实现类的代码，但却涵盖了编写代码到构建代码的各个领域的知识。我认为初级程序员需要读它，因为它会让你自律；高级程序员更需要读它，因为它会让你自省。 作为一个十几年的 coder，此书让我更加透彻的领悟到，如何使得团队编码的质量和效率更高？那就是团队中要达到标准统一、认识统一、概念统一。软件的质量需要靠每一个 coder 去保障，而团队中的每一个人所编写的每一段代码，无论简单还是复杂都需要遵循统一的质量标准、统一的测试标准、统一的构建标准等等，真正做到产品演进、知识传承。

      

关于前期工作重要性部分体会深刻

jason

2018-09-30 15:02:21

        

个人经历过两家创业公司产品迟迟不能量产而导致资金链断裂倒闭，导致产品一直无法量产的问题都在于没有把前期工作做足，或者说完全没有前期工作，什么需求分析和架构设计都不存在的，结果就是随意搭建了一个维护和开发成本很高的框架，并且性能也受到限制。需求方面也是时时刻刻在变，这方面用书中建筑隐喻可以很恰当的理解，需求稳定就是装修一次到位，需求一直变的结果就是我需要反复地把已装修好的结构拆掉、再装修，这个结果的成本明显多出几倍，而这个过程确会被执行多次。

      

内容上乘，翻译优秀

valleygtc

2019-01-10 16:36:59

        

很早就有听知乎上不少大神提到过《代码大全》这本书，说是有追求的程序员都应该读一读。但我因个人的学习计划安排，从大二到今天一直没读。

最近实习期间工作比较少，加之并未在学校上过专讲软件工程的课程，故买来阅读补充一下知识。

每天阅读几章，约十几天的时间读完，收获颇丰。

本书主讲开发中的软件构建（代码完成）这一部分，但是内容上也覆盖了完成一个软件的整体流程：需求分析，高层设计，架构，代码构建，集成，系统测试，调试。甚至在最后还有一章讲「个人性格」。非常全面，令我对软件工程之所以称之为工程有了理解。

且书中有很多思想发人深省如：编程是个启发式过程，深入一门语言编程而非浮于表面（programming into a language），程序员的智慧工具箱，隐喻的妙用等等。

作者也十分体贴，在每内容块后都有 checklist，每章后都有知识点总结。

翻译质量绝对没话说，这是唯一一本我没有借助英文电子版对照着就顺利读下来的书。读起来真的很舒服，没有遇到歧义和坑点。还有特别值得一提的是，为了之后看英文文档方便，我读中译本一般习惯在遇到术语后查一下其英文原词是什么，记下来。而在读本书过程中，当我发现译者在每章的题目和重要的关键词汇旁都有附英文原文，简直感动到哭。

总而言之，对于每一个有追求的程序员来说，此书绝对值得一读。

      

还不错

li

2019-03-05 23:59:01

        

内容很实用，对于有一定工程实践量的程序员会比较管用。

但是行文过于啰嗦，概念介绍有时相当混乱。一本书不但要有丰富详实的内容，还要有良好的叙事条理，才能方便初学者阅读。

凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！凑字数！

      

小白读代码大全的收获

白衣

2019-12-16 12:29:15

        

作为一个初入职场还没毕业的实习生，觉得这本书给我带来的收益是很大的，目前能够感受到的对我影响较为深刻的也是对我的帮助比较大的：

1、编程中更注重的应该是人而不是计算机，代码不止要计算机能够理解，最重要的是能够让别人能够读懂我们写的代码，因此需要注意变量名、子程序的编写和注释之类的事情。

2、防范式编程，之前看代码的时候经常看到子程序里面判断参数，如果参数不合法就断言（公司的断言是自己实现的）。之前一直以为这些事情是没有多大意义的事情，读了之后才知道这么做的初心。

3、子程序的编写，在学校当中写课设的时候一个 main 函数几百行，几乎没有子程序。看到公司的代码中子程序很多，而且参数的格式很整齐，一个文件放某一个模块的子程序，需要实现某个功能直接去找对应的文件或者对应的负责人去问问相关的接口即可，节省了很多的时间。

4、变量命名，书中举了一些反例，以 i、j、k 命名的变量，仿佛就是在说我大学写的代码，也就是当时能够看的懂，换了个人或者让我现在看懂那些垃圾会花费很大的精力和很长的时间。

5、不过分迷信某一种编程方法，不要有编程信仰，要综合多种方式，取一个折中的方法。没有一种放在四海之内皆准的方法，针对当前的情况做出最大化收益的选择才是明智的。

6、提升了测试在我心中的低位，在构建中针对自己写的代码选择对应的方式进行相应的测试，书中也列出了一些测试的技巧，不过我目前的情况还用不到。

其它的一些事物对现阶段的我影响还不是太大，比如集成，我现阶段的工作只是添加一点需求，维护一下以前的代码，无法体验集成的过程；比如项目规模，我现在刚开始接触项目，对不同规模的项目没有一个具体的认知。总而言之，这本书的价值远比我目前从书中获得的价值要高，要完全的发掘书中的价值需要在将来的挑战中不断的回顾这本书，以后会常翻这本书的。

      

初级读物

元创

2006-05-19 14:18:37

说了很多很基本的东西，虽然是给初级程序看的，但高级程序员也可以看一看.

从名字就可知道书的内容，大全，大而全者，不会深而精.

不过这本书的合适的读者不太好找：初级的，可能看不懂；高级的，可能觉太繁.

说啥好呢

阿丹

2008-03-26 14:08:16

一句话：没读过的赶紧找过来读，读过的有空翻一翻。如果儿子还当程序员的话，如果那时候还没第三版，这本书可以当程序员传家宝。

其实 N 段时间之后还是需要重新翻阅的

邻家の低端码农

2010-08-27 13:55:50

好书，无需解释

估计 N 天之后还是要重新翻翻，毕竟还没真正接触项目开发，偶的大学生涯才将将开始╮(╯▽╰)╭

好书！

自由的柠檬

2014-01-02 20:15:52

很遗憾最近才读完这本书，但是很好！写了篇笔记记录一下阅读成果：

http://hongbinzuo.github.io/2014/01/02/reading-note-on-code-complete-2/

      

记下一些需要反复阅读的点

forsee

2015-12-03 15:45:11

每天读一点，随手记下些东西，权当索引，懒得打字，直接从英文电子版复制了。页码对应中文第 2 版

P146 如果派生后覆写了某方法，但在其中没做任何事，应该参考以下内容

Be suspicious of classes that override a routine and do nothing inside the  derived routine

…

The place to fix this problem is not in the base class, but in the original Cat class.  Create a Claws class and contain that within the Cats class, or build a constructor for the class that includes whether the cat scratches. The root problem was the  assumption that all cats scratch, so fix that problem at the source, rather than just  bandaging it at the destination. 

P149 关于使用继承还是包含的建议

If multiple classes share common data but not behavior, then create a  common object that those classes can contain. 

●  If multiple classes share common behavior but not data, then derive them  from a common base class that defines the common routines. 

●  If multiple classes share common data and behavior, then inherit from a  common base class that defines the common data and routines. 

●  Inherit when you want the base class to control your interface; contain when  you want to control your interface.  

P170 逻辑上的内聚性

P171 好的子程序名字

P305 把枚举类型的第一个元素留做非法值

P505 想知道测试用例是否覆盖了所有代码，要使用一个覆盖率监视器

Too Thick To Read

心如印

2007-06-18 11:22:50

        Now I don't want to spend much of time on technology. This book sounds good, but not as important as some more special books such as 'regular-expression', 'design-pagttern' etc. 

It teaches programming conveniences, but in China who is willing coding in all life now?

So although this book is full of public praise, it is useless.      

看这本书是一种享受

yolanda

2010-04-02 10:34:25

转一位读者评论：

这是我看完这本书以后的感受：

我可以感受到作者的客观务实的写作风格。

我意识到代码构建其实也可以变得非常具有艺术性。

我可以从任何一个小章节进行阅读，而无需担心是否需要其他章节的知识。因为作者会把每个章节最吸引人的地方，用巧妙的方法展现出来。

我也可以用这本书每个章节最后的 CheckList 来检验软件开发的每个环节。看看我自己在这些地方犯了哪些典型错误。

看这本书就像看金庸的武侠小说那样惬意。我当初还担心书中可能会充满代码示例而放弃阅读它。现在我很庆幸当初自己看完了它。

来自当当读者：battlearea

