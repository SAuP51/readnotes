第 10 章　序列的修改、散列和切片

不要检查它是不是鸭子、它的叫声像不像鸭子、它的走路姿势像不像鸭子，等等。具体检查什么取决于你想使用语言的哪些行为。（comp.lang.python，2000 年 7 月 26 日）

——Alex Martelli

本章将以第 9 章定义的二维向量 Vector2d 类为基础，向前迈出一大步，定义表示多维向量的 Vector 类。这个类的行为与 Python 中标准的不可变扁平序列一样。Vector 实例中的元素是浮点数，本章结束后 Vector 类将支持下述功能：

基本的序列协议 —— __len__ 和 __getitem__

正确表述拥有很多元素的实例

适当的切片支持，用于生成新的 Vector 实例

综合各个元素的值计算散列值

自定义的格式语言扩展

此外，我们还将通过 __getattr__ 方法实现属性的动态存取，以此取代 Vector2d 使用的只读特性 —— 不过，序列类型通常不会这么做。

在大量代码之间，我们将穿插讨论一个概念：把协议当作正式接口。我们将说明协议和鸭子类型之间的关系，以及对自定义类型的实际影响。

我们开始吧！

三维以上向量的应用

谁需要 1000 维向量呢？提示：不是 3D 艺术家！不过，信息检索领域经常使用 n 维向量（n 是很大的数），查询的文档和文本使用向量表示，一个单词一个维度。这叫向量空间模型。在这个模型中，一个关键的相关指标是余弦相关性（即查询向量与文档向量夹角的余弦）。夹角越小，余弦值越趋近于 1，文档与查询的相关性就越大。

不过，本章定义的 Vector 类是为了教学而举的例子，不会涉及很多数学原理。我们的目的是以序列类型为背景说明 Python 的几个特殊方法。

如果在实际使用中需要做向量运算，应该使用 NumPy 和 SciPy。Radim Rehurek 开发的 PyPI 包 gensim 使用 NumPy 和 SciPy 实现了用于处理自然语言和检索信息的向量空间模型。

10.1　Vector 类：用户定义的序列类型

我们将使用组合模式实现 Vector 类，而不使用继承。向量的分量存储在浮点数数组中，而且还将实现不可变扁平序列所需的方法。

不过，在实现序列方法之前，我们要确保 Vector 类与前一章定义的 Vector2d 类兼容，除非有些地方让二者兼容没有什么意义。

10.2　Vector 类第 1 版：与 Vector2d 类兼容

Vector 类的第 1 版要尽量与前一章定义的 Vector2d 类兼容。

然而我们会故意不让 Vector 的构造方法与 Vector2d 的构造方法兼容。为了编写 Vector (3, 4) 和 Vector (3, 4, 5) 这样的代码，我们可以让 __init__ 方法接受任意个参数（通过 *args）；但是，序列类型的构造方法最好接受可迭代的对象为参数，因为所有内置的序列类型都是这样做的。示例 10-1 展示了 Vector 类的几种实例化方式。

示例 10-1　测试 Vector.__init__ 和 Vector.__repr__ 方法

>>> Vector([3.1, 4.2]) Vector([3.1, 4.2]) >>> Vector((3, 4, 5)) Vector([3.0, 4.0, 5.0]) >>> Vector(range(10)) Vector([0.0, 1.0, 2.0, 3.0, 4.0, ...])

除了新构造方法的签名外，我还确保了传入两个分量（如 Vector ([3, 4])）时，Vector2d 类（如 Vector2d (3, 4)）的每个测试都能通过，而且得到相同的结果。

如果 Vector 实例的分量超过 6 个，repr () 生成的字符串就会使用 ... 省略一部分，如示例 10-1 中的最后一行所示。包含大量元素的集合类型一定要这么做，因为字符串表示形式是用于调试的（因此不想让大型对象在控制台或日志中输出几千行内容）。使用 reprlib 模块可以生成长度有限的表示形式，如示例 10-2 所示。

在 Python 2 中，reprlib 模块的名字是 repr。2to3 工具能自动重写 repr 导入的内容。

示例 10-2 是第 1 版 Vector 类的实现代码（以示例 9-2 和示例 9-3 中的代码为基础）。

示例 10-2　vector_v1.py：从 vector2d_v1.py 衍生而来

from array import array import reprlib import math class Vector: typecode = 'd' def __init__(self, components): self._components = array(self.typecode, components) ➊ def __iter__(self): return iter(self._components) ➋ def __repr__(self): components = reprlib.repr(self._components) ➌ components = components[components.find('['):-1] ➍ return 'Vector({})'.format(components) def __str__(self): return str(tuple(self)) def __bytes__(self): return (bytes([ord(self.typecode)]) + bytes(self._components)) ➎ def __eq__(self, other): return tuple(self) == tuple(other) def __abs__(self): return math.sqrt(sum(x * x for x in self)) ➏ def __bool__(self): return bool(abs(self)) @classmethod def frombytes(cls, octets): typecode = chr(octets[0]) memv = memoryview(octets[1:]).cast(typecode) return cls(memv) ➐

❶ self._components 是「受保护的」实例属性，把 Vector 的分量保存在一个数组中。

❷ 为了迭代，我们使用 self._components 构建一个迭代器。1

1iter () 函数和 __iter__ 方法在第 14 章讨论。

❸ 使用 reprlib.repr () 函数获取 self._components 的有限长度表示形式（如 array ('d', [0.0, 1.0, 2.0, 3.0, 4.0, ...])）。

❹ 把字符串插入 Vector 的构造方法调用之前，去掉前面的 array ('d' 和后面的)。

❺ 直接使用 self._components 构建 bytes 对象。

❻ 不能使用 hypot 方法了，因此我们先计算各分量的平方之和，然后再使用 sqrt 方法开平方。

❼ 我们只需在 Vector2d.frombytes 方法的基础上改动最后一行：直接把 memoryview 传给构造方法，不用像前面那样使用 * 拆包。

我使用 reprlib.repr 的方式需要做些说明。这个函数用于生成大型结构或递归结构的安全表示形式，它会限制输出字符串的长度，用 '...' 表示截断的部分。我希望 Vector 实例的表示形式是 Vector ([3.0, 4.0, 5.0]) 这样，而不是 Vector (array ('d', [3.0, 4.0, 5.0]))，因为 Vector 实例中的数组是实现细节。因为这两种构造方法的调用方式所构建的 Vector 对象是一样的，所以我选择使用更简单的句法，即传入列表参数。

编写 __repr__ 方法时，本可以使用这个表达式生成简化的 components 显示形式：reprlib.repr (list (self._components))。然而，这么做有点浪费，因为要把 self._components 中的每个元素复制到一个列表中，然后使用列表的表示形式。我没有这么做，而是直接把 self._components 传给 reprlib.repr 函数，然后去掉 [] 外面的字符，如示例 10-2 中 __repr__ 方法的第二行所示。

调用 repr () 函数的目的是调试，因此绝对不能抛出异常。如果 __repr__ 方法的实现有问题，那么必须处理，尽量输出有用的内容，让用户能够识别目标对象。

注意，__str__、__eq__ 和 __bool__ 方法与 Vector2d 类中的一样，而 frombytes 方法也只变了一个字符（最后一行把 * 去掉了）。这是 Vector2d 可迭代的好处之一。

顺便说一下，我们本可以让 Vector 继承 Vector2d，但是我没这么做，原因有二。其一，两个构造方法不兼容，因此不建议继承。这一点可以通过适当处理 __init__ 方法的参数解决，不过第二个原因更重要：我想把 Vector 类当作单独的示例，以此实现序列协议。接下来，我们先讨论协议这个术语，然后实现序列协议。

10.3　协议和鸭子类型

在第 1 章我们就说过，在 Python 中创建功能完善的序列类型无需使用继承，只需实现符合序列协议的方法。不过，这里说的协议是什么呢？

在面向对象编程中，协议是非正式的接口，只在文档中定义，在代码中不定义。例如，Python 的序列协议只需要 __len__ 和 __getitem__ 两个方法。任何类（如 Spam），只要使用标准的签名和语义实现了这两个方法，就能用在任何期待序列的地方。Spam 是不是哪个类的子类无关紧要，只要提供了所需的方法即可。示例 1-1 中见过一例，这里再次给出代码，

如示例 10-3 所示。

示例 10-3　示例 1-1 的代码，为了方便，再次给出

import collections Card = collections.namedtuple('Card', ['rank', 'suit']) class FrenchDeck: ranks = [str(n) for n in range(2, 11)] + list('JQKA') suits = 'spades diamonds clubs hearts'.split() def __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks] def __len__(self): return len(self._cards) def __getitem__(self, position): return self._cards[position]

示例 10-3 中的 FrenchDeck 类能充分利用 Python 的很多功能，因为它实现了序列协议，不过代码中并没有声明这一点。任何有经验的 Python 程序员只要看一眼就知道它是序列，即便它是 object 的子类也无妨。我们说它是序列，因为它的行为像序列，这才是重点。

根据本章开头引用的 Alex Martelli 的帖子，人们称其为鸭子类型（duck typing）。

协议是非正式的，没有强制力，因此如果你知道类的具体使用场景，通常只需要实现一个协议的部分。例如，为了支持迭代，只需实现 __getitem__ 方法，没必要提供 __len__ 方法。

下面，我们将在 Vector 类中实现序列协议。我们先不支持完美的切片，稍后再完善。

10.4　Vector 类第 2 版：可切片的序列

如 FrenchDeck 类所示，如果能委托给对象中的序列属性（如 self._components 数组），支持序列协议特别简单。下述只有一行代码的 __len__ 和 __getitem__ 方法是个好的开始：

class Vector: # 省略了很多行 # ... def __len__(self): return len (self._components) def __getitem__(self, index): return self._components [index]

添加这两个方法之后，就能执行下述操作了：

>>> v1 = Vector([3, 4, 5]) >>> len(v1) 3 >>> v1[0], v1[-1] (3.0, 5.0) >>> v7 = Vector(range(7)) >>> v7[1:4] array('d', [1.0, 2.0, 3.0])

可以看到，现在连切片都支持了，不过尚不完美。如果 Vector 实例的切片也是 Vector 实例，而不是数组，那就更好了。前面那个 FrenchDeck 类也有类似的问题：切片得到的是列表。对 Vector 来说，如果切片生成普通的数组，将会缺失大量功能。

想想内置的序列类型，切片得到的都是各自类型的新实例，而不是其他类型。

为了把 Vector 实例的切片也变成 Vector 实例，我们不能简单地委托给数组切片。我们要分析传给 __getitem__ 方法的参数，做适当的处理。

下面来看 Python 如何把 my_seq [1:3] 句法变成传给 my_seq.__getitem__(...) 的参数。

10.4.1　切片原理

一例胜千言，我们来看看示例 10-4。

示例 10-4　了解 __getitem__ 和切片的行为

>>> class MySeq: ... def __getitem__(self, index): ... return index # ➊ ... >>> s = MySeq() >>> s[1] # ➋ 1 >>> s[1:4] # ➌ slice(1, 4, None) >>> s[1:4:2] # ➍ slice(1, 4, 2) >>> s[1:4:2, 9] # ➎ (slice(1, 4, 2), 9) >>> s[1:4:2, 7:9] # ➏ (slice(1, 4, 2), slice(7, 9, None))

❶ 在这个示例中，__getitem__ 直接返回传给它的值。

❷ 单个索引，没什么新奇的。

❸ 1:4 表示法变成了 slice (1, 4, None)。

❹ slice (1, 4, 2) 的意思是从 1 开始，到 4 结束，步幅为 2。

❺ 神奇的事发生了：如果 [] 中有逗号，那么 __getitem__ 收到的是元组。

❻ 元组中甚至可以有多个切片对象。

现在，我们来仔细看看 slice 本身，如示例 10-5 所示。

示例 10-5　查看 slice 类的属性

>>> slice # ➊ <class 'slice'> >>> dir(slice) # ➋ ['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'indices', 'start', 'step', 'stop']

❶ slice 是内置的类型（2.4.2 节首次出现）。

❷ 通过审查 slice，发现它有 start、stop 和 step 数据属性，以及 indices 方法。

在示例 10-5 中，调用 dir (slice) 得到的结果中有个 indices 属性，这个方法有很大的作用，但是鲜为人知。help (slice.indices) 给出的信息如下。

S.indices(len) -> (start, stop, stride)

给定长度为 len 的序列，计算 S 表示的扩展切片的起始（start）和结尾（stop）索引，以及步幅（stride）。超出边界的索引会被截掉，这与常规切片的处理方式一样。

换句话说，indices 方法开放了内置序列实现的棘手逻辑，用于优雅地处理缺失索引和负数索引，以及长度超过目标序列的切片。这个方法会「整顿」元组，把 start、stop 和 stride 都变成非负数，而且都落在指定长度序列的边界内。

下面举几个例子。假设有个长度为 5 的序列，例如 'ABCDE'：

>>> slice(None, 10, 2).indices(5) # ➊ (0, 5, 2) >>> slice(-3, None, None).indices(5) # ➋ (2, 5, 1)

❶ 'ABCDE'[:10:2] 等同于 'ABCDE'[0:5:2]

❷ 'ABCDE'[-3:] 等同于 'ABCDE'[2:5:1]

写作本书时，在线版 Python 库参考好像还没有 slice.indices 方法的文档。2Python Python/C API 参考手册中有类似的 C 语言函数的文档，PySlice_GetIndicesEx。研究切片对象时，我在 Python 控制台中执行了 dir () 和 help ()，这才发现 slice.indices () 方法。这也表明交互式控制台是个有价值的工具，能发现新事物。

2 现在已经有了，参见：https://docs.python.org/3/reference/datamodel.html?highlight=indices#slice.indices。—— 编者注

在 Vector 类中无需使用 slice.indices () 方法，因为收到切片参数时，我们会委托 _components 数组处理。但是，如果你没有底层序列类型作为依靠，那么使用这个方法能节省大量时间。

现在我们知道如何处理切片了，下面来看 Vector.__getitem__ 方法改进后的实现。

10.4.2　能处理切片的__getitem__方法

示例 10-6 列出了让 Vector 表现为序列所需的两个方法：__len__ 和 __getitem__ （后者现在能正确地处理切片了）。

示例 10-6　vector_v2.py 的部分代码：为 vector_v1.py 中的 Vector 类（见示例 10-2）添加 __len__ 和__getitem__ 方法

def __len__(self): return len(self._components) def __getitem__(self, index): cls = type(self) ➊ if isinstance(index, slice): ➋ return cls(self._components[index]) ➌ elif isinstance(index, numbers.Integral): ➍ return self._components[index] ➎ else: msg = '{cls.__name__} indices must be integers' raise TypeError(msg.format(cls=cls)) ➏

❶ 获取实例所属的类（即 Vector），供后面使用。

❷ 如果 index 参数的值是 slice 对象……

❸ …… 调用类的构造方法，使用 _components 数组的切片构建一个新 Vector 实例。

❹ 如果 index 是 int 或其他整数类型……3

3 必须在 vector_v2.py 的开头加上 import numbers。—— 编者注

❺ …… 那就返回 _components 中相应的元素。

❻ 否则，抛出异常。

大量使用 isinstance 可能表明面向对象设计得不好，不过在 __getitem__ 方法中使用它处理切片是合理的。注意，示例 10-6 中测试时用的是 numbers.Integral，这是一个抽象基类（Abstract Base Class，ABC）。在 isinstance 中使用抽象基类做测试能让 API 更灵活且更容易更新，原因参见第 11 章。可惜，Python 3.4 的标准库中没有 slice 的抽象基类。

为了确定在 __getitem__ 的 else 子句中会抛出哪个异常，我在交互式控制台中查看了 'ABC'[1, 2] 的结果。我发现，Python 抛出的是 TypeError；我还从错误消息中复制了表述方式，「indices must be integers」。为了创建符合 Python 风格的对象，我们要模仿 Python 内置的对象。

把示例 10-6 中的代码添加到 Vector 类中之后，切片行为就正确了，如示例 10-7 所示。

示例 10-7　测试示例 10-6 中改进的 Vector.__getitem__ 方法

>>> v7 = Vector(range(7)) >>> v7[-1] ➊ 6.0 >>> v7[1:4] ➋ Vector([1.0, 2.0, 3.0]) >>> v7[-1:] ➌ Vector([6.0]) >>> v7[1,2] ➍ Traceback (most recent call last): ... TypeError: Vector indices must be integers

❶ 单个整数索引只获取一个分量，值为浮点数。

❷ 切片索引创建一个新 Vector 实例。

❸ 长度为 1 的切片也创建一个 Vector 实例。

❹ Vector 不支持多维索引，因此索引元组或多个切片会抛出错误。

10.5　Vector 类第 3 版：动态存取属性

Vector2d 变成 Vector 之后，就没办法通过名称访问向量的分量了（如 v.x 和 v.y）。现在我们处理的向量可能有大量分量。不过，若能通过单个字母访问前几个分量的话会比较方便。比如，用 x、y 和 z 代替 v [0]、v [1] 和 v [2]。

我们想额外提供下述句法，用于读取向量的前四个分量：

>>> v = Vector(range(10)) >>> v.x 0.0 >>> v.y, v.z, v.t (1.0, 2.0, 3.0)

在 Vector2d 中，我们使用 @property 装饰器把 x 和 y 标记为只读特性（见示例 9-7）。我们可以在 Vector 中编写四个特性，但这样太麻烦。特殊方法 __getattr__ 提供了更好的方式。

属性查找失败后，解释器会调用 __getattr__ 方法。简单来说，对 my_obj.x 表达式，Python 会检查 my_obj 实例有没有名为 x 的属性；如果没有，到类（my_obj.__class__）中查找；如果还没有，顺着继承树继续查找。4 如果依旧找不到，调用 my_obj 所属类中定义的 __getattr__ 方法，传入 self 和属性名称的字符串形式（如 'x'）。

4 属性查找机制比这复杂得多，复杂的细节在第六部分讲解。目前知道这种简单的说明即可。

示例 10-8 中列出的是我们为 Vector 类定义的 __getattr__ 方法。这个方法的作用很简单，它检查所查找的属性是不是 xyzt 中的某个字母，如果是，那么返回对应的分量。

示例 10-8　vector_v3.py 的部分代码：在 vector_v2.py 中定义的 Vector 类里添加 __getattr__ 方法

shortcut_names = 'xyzt' def __getattr__(self, name): cls = type(self) ➊ if len(name) == 1: ➋ pos = cls.shortcut_names.find(name) ➌ if 0 <= pos < len(self._components): ➍ return self._components[pos] msg = '{.__name__!r} object has no attribute {!r}' ➎ raise AttributeError(msg.format(cls, name))

❶ 获取 Vector，后面待用。

❷ 如果属性名只有一个字母，可能是 shortcut_names 中的一个。

❸ 查找那个字母的位置；str.find 还会定位 'yz'，但是我们不需要，因此在前一行做了测试。

❹ 如果位置落在范围内，返回数组中对应的元素。

❺ 如果测试都失败了，抛出 AttributeError，并指明标准的消息文本。

__getattr__ 方法的实现不难，但是这样实现还不够。看看示例 10-9 中古怪的交互行为。

示例 10-9　不恰当的行为：为 v.x 赋值没有抛出错误，但是前后矛盾

>>> v = Vector(range(5)) >>> v Vector([0.0, 1.0, 2.0, 3.0, 4.0]) >>> v.x # ➊ 0.0 >>> v.x = 10 # ➋ >>> v.x # ➌ 10 >>> v Vector([0.0, 1.0, 2.0, 3.0, 4.0]) # ➍

❶ 使用 v.x 获取第一个元素（v [0]）。

❷ 为 v.x 赋新值。这个操作应该抛出异常。

❸ 读取 v.x，得到的是新值，10。

❹ 可是，向量的分量没变。

你能解释为什么会这样吗？具体而言，如果向量的分量数组中没有新值，为什么 v.x 返回 10 ？如果你不能立即给出解释，再看看示例 10-8 前面对 __getattr__ 方法的说明。原因不是很明显，但却是理解本书后面内容的重要基础。

示例 10-9 之所以前后矛盾，是 __getattr__ 的运作方式导致的：仅当对象没有指定名称的属性时，Python 才会调用那个方法，这是一种后备机制。可是，像 v.x = 10 这样赋值之后，v 对象有 x 属性了，因此使用 v.x 获取 x 属性的值时不会调用 __getattr__ 方法了，解释器直接返回绑定到 v.x 上的值，即 10。另一方面，__getattr__ 方法的实现没有考虑到 self._components 之外的实例属性，而是从这个属性中获取 shortcut_names 中所列的「虚拟属性」。

为了避免这种前后矛盾的现象，我们要改写 Vector 类中设置属性的逻辑。

回想第 9 章的最后一个 Vector2d 示例中，如果为 .x 或 .y 实例属性赋值，会抛出 AttributeError。为了避免歧义，在 Vector 类中，如果为名称是单个小写字母的属性赋值，我们也想抛出那个异常。为此，我们要实现 __setattr__ 方法，如示例 10-10 所示。

示例 10-10　vector_v3.py 的部分代码：在 Vector 类中实现 __setattr__ 方法

def __setattr__(self, name, value): cls = type(self) if len(name) == 1: ➊ if name in cls.shortcut_names: ➋ error = 'readonly attribute {attr_name!r}' elif name.islower(): ➌ error = "can't set attributes 'a' to 'z' in {cls_name!r}" else: error = '' ➍ if error: ➎ msg = error.format(cls_name=cls.__name__, attr_name=name) raise AttributeError(msg) super().__setattr__(name, value) ➏

❶ 特别处理名称是单个字符的属性。

❷ 如果 name 是 xyzt 中的一个，设置特殊的错误消息。

❸ 如果 name 是小写字母，为所有小写字母设置一个错误消息。

❹ 否则，把错误消息设为空字符串。

❺ 如果有错误消息，抛出 AttributeError。

❻ 默认情况：在超类上调用 __setattr__ 方法，提供标准行为。

super () 函数用于动态访问超类的方法，对 Python 这样支持多重继承的动态语言来说，必须能这么做。程序员经常使用这个函数把子类方法的某些任务委托给超类中适当的方法，如示例 10-10 所示。12.2 节会进一步探讨 super () 函数。

为了给 AttributeError 选择错误消息，我查看了内置的 complex 类型的行为，因为 complex 对象是不可变的，而且有一对数据属性：real 和 imag。如果试图修改任何一个属性，complex 实例会抛出 AttributeError，而且把错误消息设为 "can't set attribute"。而如果尝试为受特性保护的只读属性赋值（像 9.6 节那样做），得到的错误消息是 "readonly attribute"。在 __setattr__ 方法中为 error 字符串选词时，我参考了这两个错误消息，而且更为明确地指出了禁止赋值的属性。

注意，我们没有禁止为全部属性赋值，只是禁止为单个小写字母属性赋值，以防与只读属性 x、y、z 和 t 混淆。

我们知道，在类中声明 __slots__ 属性可以防止设置新实例属性；因此，你可能想使用这个功能，而不像这里所做的，实现 __setattr__ 方法。可是，正如 9.8.1 节所指出的，不建议只为了避免创建实例属性而使用 __slots__ 属性。__slots__ 属性只应该用于节省内存，而且仅当内存严重不足时才应该这么做。

虽然这个示例不支持为 Vector 分量赋值，但是有一个问题要特别注意：多数时候，如果实现了 __getattr__ 方法，那么也要定义 __setattr__ 方法，以防对象的行为不一致。

如果想允许修改分量，可以使用 __setitem__ 方法，支持 v [0] = 1.1 这样的赋值，以及（或者）实现 __setattr__ 方法，支持 v.x = 1.1 这样的赋值。不过，我们要保持 Vector 是不可变的，因为在下一节中，我们将把它变成可散列的。

10.6　Vector 类第 4 版：散列和快速等值测试

我们要再次实现 __hash__ 方法。加上现有的 __eq__ 方法，这会把 Vector 实例变成可散列的对象。

示例 9-8 中的 __hash__ 方法简单地计算 hash (self.x) ^ hash (self.y)。这一次，我们要使用 ^（异或）运算符依次计算各个分量的散列值，像这样：v [0] ^ v [1] ^ v [2]...。这正是 functools.reduce 函数的作用。之前我说 reduce 没有以往那么常用，5 但是计算向量所有分量的散列值非常适合使用这个函数。reduce 函数的整体思路如图 10-1 所示。

5sum、any 和 all 涵盖了 reduce 的大部分用途。参见 5.2.1 节的讨论。

图 10-1：归约函数（reduce、sum、any、all）把序列或有限的可迭代对象变成一个聚合结果

我们已经知道 functools.reduce () 可以替换成 sum ()，下面说说它的原理。它的关键思想是，把一系列值归约成单个值。reduce () 函数的第一个参数是接受两个参数的函数，第二个参数是一个可迭代的对象。假如有个接受两个参数的 fn 函数和一个 lst 列表。调用 reduce (fn, lst) 时，fn 会应用到第一对元素上，即 fn (lst [0], lst [1])，生成第一个结果 r1。然后，fn 会应用到 r1 和下一个元素上，即 fn (r1, lst [2])，生成第二个结果 r2。接着，调用 fn (r2, lst [3])，生成 r3…… 直到最后一个元素，返回最后得到的结果 rN。

使用 reduce 函数可以计算 5!（5 的阶乘）：

>>> 2 * 3 * 4 * 5 # 想要的结果是：5! == 120 120 >>> import functools >>> functools.reduce (lambda a,b: a*b, range (1, 6)) 120

回到散列问题上。示例 10-11 展示了计算聚合异或的 3 种方式：一种使用 for 循环，两种使用 reduce 函数。

示例 10-11　计算整数 0~5 的累计异或的 3 种方式

>>> n = 0 >>> for i in range(1, 6): # ➊ ... n ^= i ... >>> n 1 >>> import functools >>> functools.reduce(lambda a, b: a^b, range(6)) # ➋ 1 >>> import operator >>> functools.reduce(operator.xor, range(6)) # ➌ 1

❶ 使用 for 循环和累加器变量计算聚合异或。

❷ 使用 functools.reduce 函数，传入匿名函数。

❸ 使用 functools.reduce 函数，把 lambda 表达式换成 operator.xor。

示例 10-11 中的 3 种方式里，我最喜欢最后一种，其次是 for 循环。你呢？

5.10.1 节讲过，operator 模块以函数的形式提供了 Python 的全部中缀运算符，从而减少使用 lambda 表达式。

为了使用我喜欢的方式编写 Vector.__hash__ 方法，我们要导入 functools 和 operator 模块。Vector 类的相关变化如示例 10-12 所示。

示例 10-12　 vector_v4.py 的部分代码：在 vector_v3.py 中 Vector 类的基础上导入两个模块，添加 __hash__ 方法

from array import array import reprlib import math import functools # ➊ import operator # ➋ class Vector: typecode = 'd' # 排版需要，省略了很多行... def __eq__(self, other): # ➌ return tuple (self) == tuple (other) def __hash__(self): hashes = (hash (x) for x in self._components) # ➍ return functools.reduce (operator.xor, hashes, 0) # ➎ # 省略了很多行...

❶ 为了使用 reduce 函数，导入 functools 模块。

❷ 为了使用 xor 函数，导入 operator 模块。

❸ __eq__ 方法没变；我把它列出来是为了把它和 __hash__ 方法放在一起，因为它们要结合在一起使用。

❹ 创建一个生成器表达式，惰性计算各个分量的散列值。

❺ 把 hashes 提供给 reduce 函数，使用 xor 函数计算聚合的散列值；第三个参数，0 是初始值（参见下面的警告框）。

使用 reduce 函数时最好提供第三个参数，reduce (function, iterable, initializer)，这样能避免这个异常：TypeError: reduce () of empty sequence with no initial value（这个错误消息很棒，说明了问题，还提供了解决方法）。如果序列为空，initializer 是返回的结果；否则，在归约中使用它作为第一个参数，因此应该使用恒等值。比如，对 +、| 和 ^ 来说，initializer 应该是 0；而对 * 和 & 来说，应该是 1。

示例 10-12 中实现的 __hash__ 方法是一种映射归约计算（见图 10-2）。

图 10-2：映射归约：把函数应用到各个元素上，生成一个新序列（映射，map），然后计算聚合值（归约，reduce）

映射过程计算各个分量的散列值，归约过程则使用 xor 运算符聚合所有散列值。把生成器表达式替换成 map 方法，映射过程更明显：

def __hash__(self): hashes = map(hash, self._components) return functools.reduce(operator.xor, hashes)

在 Python 2 中使用 map 函数效率低些，因为 map 函数要使用结果构建一个列表。但是在 Python 3 中，map 函数是惰性的，它会创建一个生成器，按需产出结果，因此能节省内存 —— 这与示例 10-12 中使用生成器表达式定义 __hash__ 方法的原理一样。

既然讲到了归约函数，那就把前面草草实现的 __eq__ 方法修改一下，减少处理时间和内存用量 —— 至少对大型向量来说是这样。如示例 9-2 所示，__eq__ 方法的实现可以非常简洁：

def __eq__(self, other): return tuple(self) == tuple(other)

Vector2d 和 Vector 都可以这样做，它甚至还会认为 Vector ([1, 2]) 和 (1, 2) 相等。这或许是个问题，不过我们暂且忽略。6 可是，这样做对有几千个分量的 Vector 实例来说，效率十分低下。上述实现方式要完整复制两个操作数，构建两个元组，而这么做只是为了使用 tuple 类型的 __eq__ 方法。对 Vector2d（只有两个分量）来说，这是个捷径，但是对维数很多的向量来说情况就不同了。示例 10-13 中比较两个 Vector 实例（或者比较一个 Vector 实例与一个可迭代对象）的方式更好。

613.1 节会认真对待 Vector ([1, 2]) == (1, 2) 这个问题。

示例 10-13　为了提高比较的效率，Vector.__eq__ 方法在 for 循环中使用 zip 函数

def __eq__(self, other): if len(self) != len(other): # ➊ return False for a, b in zip(self, other): # ➋ if a != b: # ➌ return False return True # ➍

❶ 如果两个对象的长度不一样，那么它们不相等。

❷ zip 函数生成一个由元组构成的生成器，元组中的元素来自参数传入的各个可迭代对象。如果不熟悉 zip 函数，请阅读「出色的 zip 函数」附注栏。前面比较长度的测试是有必要的，因为一旦有一个输入耗尽，zip 函数会立即停止生成值，而且不发出警告。

❸ 只要有两个分量不同，返回 False，退出。

❹ 否则，对象是相等的。

示例 10-13 的效率很好，不过用于计算聚合值的整个 for 循环可以替换成一行 all 函数调用：如果所有分量对的比较结果都是 True，那么结果就是 True。只要有一次比较的结果是 False，all 函数就返回 False。使用 all 函数实现 __eq__ 方法的方式如示例 10-14 所示。

示例 10-14　使用 zip 和 all 函数实现 Vector.__eq__ 方法，逻辑与示例 10-13 一样

def __eq__(self, other): return len(self) == len(other) and all(a == b for a, b in zip(self, other))

注意，首先要检查两个操作数的长度是否相同，因为 zip 函数会在最短的那个操作数耗尽时停止。

我们选择在 vector_v4.py 中采用示例 10-14 中实现的 __eq__ 方法。

本章最后要像 Vector2d 类那样，为 Vector 类实现 __format__ 方法。

出色的 zip 函数

使用 for 循环迭代元素不用处理索引变量，还能避免很多缺陷，但是需要一些特殊的实用函数协助。其中一个是内置的 zip 函数。使用 zip 函数能轻松地并行迭代两个或更多可迭代对象，它返回的元组可以拆包成变量，分别对应各个并行输入中的一个元素。如示例 10-15 所示。

zip 函数的名字取自拉链系结物（zipper fastener），因为这个物品用于把两个拉链边的链牙咬合在一起，这形象地说明了 zip (left, right) 的作用。zip 函数与文件压缩没有关系。

示例 10-15　zip 内置函数的使用示例

>>> zip(range(3), 'ABC') # ➊ <zip object at 0x10063ae48> >>> list(zip(range(3), 'ABC')) # ➋ [(0, 'A'), (1, 'B'), (2, 'C')] >>> list(zip(range(3), 'ABC', [0.0, 1.1, 2.2, 3.3])) # ➌ [(0, 'A', 0.0), (1, 'B', 1.1), (2, 'C', 2.2)] >>> from itertools import zip_longest # ➍ >>> list(zip_longest(range(3), 'ABC', [0.0, 1.1, 2.2, 3.3], fillvalue=-1)) [(0, 'A', 0.0), (1, 'B', 1.1), (2, 'C', 2.2), (-1, -1, 3.3)]

❶ zip 函数返回一个生成器，按需生成元组。

❷ 为了输出，构建一个列表；通常，我们会迭代生成器。

❸ zip 有个奇怪的特性：当一个可迭代对象耗尽后，它不发出警告就停止。7

❹ itertools.zip_longest 函数的行为有所不同：使用可选的 fillvalue（默认值为 None）填充缺失的值，因此可以继续产出，直到最长的可迭代对象耗尽。

为了避免在 for 循环中手动处理索引变量，还经常使用内置的 enumerate 生成器函数。如果你不熟悉 enumerate 函数，一定要阅读「Build-in Functions」文档。内置的 zip 和 enumerate 函数，以及标准库中其他几个生成器函数在 14.9 节讨论。

7 至少对我来说，这是奇怪的。我认为，当组合不同长度的可迭代对象时，zip 应该抛出 ValueError。

10.7　Vector 类第 5 版：格式化

Vector 类的 __format__ 方法与 Vector2d 类的相似，但是不使用极坐标，而使用球面坐标（也叫超球面坐标），因为 Vector 类支持 n 个维度，而超过四维后，球体变成了「超球体」。8 因此，我们会把自定义的格式后缀由 'p' 变成 'h'。

8Wolfram Mathworld 网站中有一篇介绍超球体的文章；维基百科会把「超球体」词条重定向到「n 维球体」词条。

9.5 节说过，扩展格式规范微语言时，最好避免重用内置类型支持的格式代码。这里对微语言的扩展还会用到浮点数的格式代码 'eEfFgGn%'，而且保持原意，因此绝对要避免重用代码。整数使用的格式代码有 'bcdoxXn'，字符串使用的是's'。在 Vector2d 类中，我选择使用 'p' 表示极坐标。使用 'h' 表示超球面坐标（hyperspherical coordinate）是个不错的选择。

例如，对四维空间（len (v) == 4）中的 Vector 对象来说，'h' 代码得到的结果是这样：<r, Φ1, Φ2, Φ3>。其中，r 是模（abs (v)），余下三个数是角坐标 Φ1、Φ2 和 Φ3。下面几个示例摘自 vector_v5.py 的 doctest（参见示例 10-16），是四维球面坐标格式：

>>> format(Vector([-1, -1, -1, -1]), 'h') '<2.0, 2.0943951023931957, 2.186276035465284, 3.9269908169872414>' >>> format(Vector([2, 2, 2, 2]), '.3eh') '<4.000e+00, 1.047e+00, 9.553e-01, 7.854e-01>' >>> format(Vector([0, 1, 0, 0]), '0.5fh') '<1.00000, 1.57080, 0.00000, 0.00000>'

在小幅改动 __format__ 方法之前，我们要定义两个辅助方法：一个是 angle (n)，用于计算某个角坐标（如 Φ1）；另一个是 angles ()，返回由所有角坐标构成的可迭代对象。我们不会讲解其中涉及的数学原理，如果你好奇的话，可以查看维基百科中的「n 维球体」词条，那里有几个公式，我就是使用它们把 Vector 实例分量数组内的笛卡儿坐标转换成球面坐标的。

示例 10-16 是 vector_v5.py 脚本的完整代码，包含自 10.2 节以来实现的所有代码和本节实现的自定义格式。

示例 10-16　 vector_v5.py：Vector 类最终版的 doctest 和全部代码；带标号的那几行是为了支持 __format__ 方法而添加的代码

"""A multidimensional``Vector``class, take 5 A``Vector``is built from an iterable of numbers:: >>> Vector ([3.1, 4.2]) Vector ([3.1, 4.2]) >>> Vector ((3, 4, 5)) Vector ([3.0, 4.0, 5.0]) >>> Vector (range (10)) Vector ([0.0, 1.0, 2.0, 3.0, 4.0, ...]) Tests with two dimensions (same results as``vector2d_v1.py``):: >>> v1 = Vector ([3, 4]) >>> x, y = v1 >>> x, y (3.0, 4.0) >>> v1 Vector ([3.0, 4.0]) >>> v1_clone = eval (repr (v1)) >>> v1 == v1_clone True >>> print (v1) (3.0, 4.0) >>> octets = bytes (v1) >>> octets b'd\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@' >>> abs (v1) 5.0 >>> bool (v1), bool (Vector ([0, 0])) (True, False) Test of``.frombytes ()``class method:>>> v1_clone = Vector.frombytes (bytes (v1)) >>> v1_clone Vector ([3.0, 4.0]) >>> v1 == v1_clone True Tests with three dimensions:: >>> v1 = Vector ([3, 4, 5]) >>> x, y, z = v1 >>> x, y, z (3.0, 4.0, 5.0) >>> v1 Vector ([3.0, 4.0, 5.0]) >>> v1_clone = eval (repr (v1)) >>> v1 == v1_clone True >>> print (v1) (3.0, 4.0, 5.0) >>> abs (v1) # doctest:+ELLIPSIS 7.071067811... >>> bool (v1), bool (Vector ([0, 0, 0])) (True, False) Tests with many dimensions:: >>> v7 = Vector (range (7)) >>> v7 Vector ([0.0, 1.0, 2.0, 3.0, 4.0, ...]) >>> abs (v7) # doctest:+ELLIPSIS 9.53939201... Test of``.__bytes__``and``.frombytes ()``methods::>>> v1 = Vector ([3, 4, 5]) >>> v1_clone = Vector.frombytes (bytes (v1)) >>> v1_clone Vector ([3.0, 4.0, 5.0]) >>> v1 == v1_clone True Tests of sequence behavior:: >>> v1 = Vector ([3, 4, 5]) >>> len (v1) 3 >>> v1 [0], v1 [len (v1)-1], v1 [-1] (3.0, 5.0, 5.0) Test of slicing:: >>> v7 = Vector (range (7)) >>> v7 [-1] 6.0 >>> v7 [1:4] Vector ([1.0, 2.0, 3.0]) >>> v7 [-1:] Vector ([6.0]) >>> v7 [1,2] Traceback (most recent call last): ... TypeError: Vector indices must be integers Tests of dynamic attribute access:: >>> v7 = Vector (range (10)) >>> v7.x 0.0 >>> v7.y, v7.z, v7.t (1.0, 2.0, 3.0) Dynamic attribute lookup failures:: >>> v7.k Traceback (most recent call last): ... AttributeError: 'Vector' object has no attribute 'k' >>> v3 = Vector (range (3)) >>> v3.t Traceback (most recent call last): ... AttributeError: 'Vector' object has no attribute 't' >>> v3.spam Traceback (most recent call last): ... AttributeError: 'Vector' object has no attribute'spam' Tests of hashing:: >>> v1 = Vector ([3, 4]) >>> v2 = Vector ([3.1, 4.2]) >>> v3 = Vector ([3, 4, 5]) >>> v6 = Vector (range (6)) >>> hash (v1), hash (v3), hash (v6) (7, 2, 1) Most hash values of non-integers vary from a 32-bit to 64-bit CPython build:: >>> import sys >>> hash (v2) == (384307168202284039 if sys.maxsize> 2**32 else 357915986) True Tests of``format ()``with Cartesian coordinates in 2D::>>> v1 = Vector ([3, 4]) >>> format (v1) '(3.0, 4.0)' >>> format (v1, '.2f') '(3.00, 4.00)' >>> format (v1, '.3e') '(3.000e+00, 4.000e+00)' Tests of``format ()``with Cartesian coordinates in 3D and 7D::>>> v3 = Vector ([3, 4, 5]) >>> format (v3) '(3.0, 4.0, 5.0)' >>> format (Vector (range (7))) '(0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0)' Tests of``format ()``with spherical coordinates in 2D, 3D and 4D::>>> format (Vector ([1, 1]), 'h') # doctest:+ELLIPSIS '<1.414213..., 0.785398...>' >>> format (Vector ([1, 1]), '.3eh') '<1.414e+00, 7.854e-01>' >>> format (Vector ([1, 1]), '0.5fh') '<1.41421, 0.78540>' >>> format (Vector ([1, 1, 1]), 'h') # doctest:+ELLIPSIS '<1.73205..., 0.95531..., 0.78539...>' >>> format (Vector ([2, 2, 2]), '.3eh') '<3.464e+00, 9.553e-01, 7.854e-01>' >>> format (Vector ([0, 0, 0]), '0.5fh') '<0.00000, 0.00000, 0.00000>' >>> format (Vector ([-1, -1, -1, -1]), 'h') # doctest:+ELLIPSIS '<2.0, 2.09439..., 2.18627..., 3.92699...>' >>> format (Vector ([2, 2, 2, 2]), '.3eh') '<4.000e+00, 1.047e+00, 9.553e-01, 7.854e-01>' >>> format (Vector ([0, 1, 0, 0]), '0.5fh') '<1.00000, 1.57080, 0.00000, 0.00000>'""" from array import array import reprlib import math import numbers import functools import operator import itertools ➊ class Vector: typecode = 'd' def __init__(self, components): self._components = array (self.typecode, components) def __iter__(self): return iter (self._components) def __repr__(self): components = reprlib.repr (self._components) components = components [components.find ('['):-1] return 'Vector ({})'.format (components) def __str__(self): return str (tuple (self)) def __bytes__(self): return (bytes ([ord (self.typecode)]) + bytes (self._components)) def __eq__(self, other): return (len (self) == len (other) and all (a == b for a, b in zip (self, other))) def __hash__(self): hashes = (hash (x) for x in self) return functools.reduce (operator.xor, hashes, 0) def __abs__(self): return math.sqrt (sum (x * x for x in self)) def __bool__(self): return bool (abs (self)) def __len__(self): return len (self._components) def __getitem__(self, index): cls = type (self) if isinstance (index, slice): return cls (self._components [index]) elif isinstance (index, numbers.Integral): return self._components [index] else: msg = '{.__name__} indices must be integers' raise TypeError (msg.format (cls)) shortcut_names = 'xyzt' def __getattr__(self, name): cls = type (self) if len (name) == 1: pos = cls.shortcut_names.find (name) if 0 <= pos < len (self._components): return self._components [pos] msg = '{.__name__!r} object has no attribute {!r}' raise AttributeError (msg.format (cls, name)) def angle (self, n): ➋ r = math.sqrt (sum (x * x for x in self [n:])) a = math.atan2 (r, self [n-1]) if (n == len (self) - 1) and (self [-1] <0): return math.pi * 2 - a else: return a def angles (self): ➌ return (self.angle (n) for n in range (1, len (self))) def __format__(self, fmt_spec=''): if fmt_spec.endswith ('h'): # 超球面坐标 fmt_spec = fmt_spec [:-1] coords = itertools.chain ([abs (self)], self.angles ()) ➍ outer_fmt = '<{}>' ➎ else: coords = self outer_fmt = '({})' ➏ components = (format (c, fmt_spec) for c in coords) ➐ return outer_fmt.format (', '.join (components)) ➑ @classmethod def frombytes (cls, octets): typecode = chr (octets [0]) memv = memoryview (octets [1:]).cast (typecode) return cls (memv)

❶ 为了在 __format__ 方法中使用 chain 函数，导入 itertools 模块。

❷ 使用「n 维球体」词条中的公式计算某个角坐标。

❸ 创建生成器表达式，按需计算所有角坐标。

❹ 使用 itertools.chain 函数生成生成器表达式，无缝迭代向量的模和各个角坐标。

❺ 配置使用尖括号显示球面坐标。

❻ 配置使用圆括号显示笛卡儿坐标。

❼ 创建生成器表达式，按需格式化各个坐标元素。

❽ 把以逗号分隔的格式化分量插入尖括号或圆括号。

我们在 __format__、angle 和 angles 中大量使用了生成器表达式，不过我们的目的是让 Vector 类的 __format__ 方法与 Vector2d 类处在同一水平上。第 14 章讨论生成器时会使用 Vector 类中的部分代码举例，然后详细说明生成器的技巧。

本章的任务到此结束。第 13 章会改进 Vector 类，让它支持中缀运算符。本章的目的是探讨如何编写集合类广泛使用的几个特殊方法。

10.8　本章小结

本章所举的 Vector 示例故意与 Vector2d 兼容，不过二者的构造方法签名不同，Vector 类的构造方法接受一个可迭代的对象，这与内置的序列类型一样。Vector 的行为之所以像序列，是因为它实现了 __getitem__ 和 __len__ 方法；借此，我们讨论了协议，这是鸭子类型语言使用的非正式接口。

然后，我们说明了 my_seq [a:b:c] 句法背后的工作原理：创建 slice (a, b, c) 对象，交给 __getitem__ 方法处理。了解这一点之后，我们让 Vector 正确处理切片，像符合 Python 风格的序列那样返回新的 Vector 实例。

接下来，我们为 Vector 实例的头几个分量提供了只读访问功能，使用 my_vec.x 这样的表示法。这一点通过 __getattr__ 方法实现。实现这一功能之后，用户会想通过 my_vec.x = 7 这样的写法为头几个分量赋值 —— 这是一个潜在的缺陷。为了解决这个问题，我们又实现了 __setattr__ 方法，通过它禁止为单字母属性赋值。大多数时候，如果定义了 __getattr__ 方法，那么也要定义 __setattr__ 方法，这样才能避免行为不一致。

实现 __hash__ 方法特别适合使用 functools.reduce 函数，因为我们要把异或运算符 ^ 依次应用到各个分量的散列值上，生成整个向量的聚合散列值。在 __hash__ 方法中使用 reduce 函数之后，我们又使用内置的归约函数 all 实现了效率更高的 __eq__ 方法。

Vector 类的最后一项改进是在 Vector2d 的基础上重新实现 __format__ 方法，这一次，除了支持笛卡儿坐标，我们还支持了球面坐标。为了定义 __format__ 方法及其辅助方法，我们用到了很多数学知识和几个生成器，但这些是实现细节。第 14 章会再次讨论生成器。最后一节的目的是支持自定义格式，从而兑现承诺，让 Vector 与 Vector2d 兼容，此外还能做更多的事情。

与第 9 章一样，我们经常分析 Python 标准对象的行为，然后进行模仿，让 Vector 的行为符合 Python 风格。

第 13 章将为 Vector 实现几个中缀运算符。第 13 章使用的数学知识比 angle () 方法用到的简单多了，但是通过了解 Python 中缀运算符的工作方式，我们对面向对象设计的认识将更进一步。讨论运算符重载之前，我们将先定义一个类，说明如何使用接口和继承组织多个类 —— 这是第 11 章和第 12 章的话题。

10.9　延伸阅读

Vector 类中的大多数特殊方法在第 9 章定义的 Vector2d 类中也有，因此前一章给出的延伸阅读材料同样适合本章。

强大的高阶函数 reduce 也叫合拢、累计、聚合、压缩和注入。更多信息参见维基百科中的「Fold (higher-order function)」词条。这篇文章展示了高阶函数的用途，着重说明了具有递归数据结构的函数式语言。这篇文章中还有一个表格，列出了很多编程语言中起合拢作用的函数。

杂谈

把协议当作非正式的接口

协议不是 Python 发明的。Smalltalk 团队，也就是「面向对象」的发明者，使用「协议」这个词表示现在我们称之为接口的特性。某些 Smalltalk 编程环境允许程序员把一组方法标记为协议，但这只不过是一种文档，用于辅助导航，语言不对其施加特定措施。因此，向熟悉正式（而且编译器会施加措施）接口的人解释「协议」时，我会简单地说它是「非正式的接口」。

动态类型语言中的既定协议会自然进化。所谓动态类型是指在运行时检查类型，因为方法签名和变量没有静态类型信息。Ruby 是一门重要的面向对象动态类型语言，它也使用协议。

在 Python 文档中，如果看到「文件类对象」这样的表述，通常说的就是协议。这是一种简短的说法，意思是：「行为基本与文件一致，实现了部分文件接口，满足上下文相关需求的东西。」

你可能觉得只实现协议的一部分不够严谨，但是这样做的优点是简单。「Data Model」一章的 3.3 节建议：

模仿内置类型实现类时，记住一点：模仿的程度对建模的对象来说合理即可。例如，有些序列可能只需要获取单个元素，而不必提取切片。

——Python 语言参考手册中「Data Model」一章

不要为了满足过度设计的接口契约和让编译器开心，而去实现不需要的方法，我们要遵守 KISS 原则。

第 11 章还会讨论协议和接口，这正是那一章的主要话题。

鸭子类型的起源

我相信 Ruby 社区在「鸭子类型」这个术语的推广过程中起了主要作用，因为他们向大量 Java 使用者宣扬了这个说法。但是，在 Ruby 或 Python 流行起来之前，Python 就使用这个术语了。根据维基百科，在面向对象编程中较早使用鸭子作比喻的人是 Alex Martelli，在他于 2000 年 7 月 26 日发到 Python-list 中的一篇文章里：「polymorphism (was Re: Type checking in python?)」。本章开头引用的那句话就出自那篇文章。如果你想知道「鸭子类型」这个术语的真正起源，以及很多编程语言对这个面向对象概念的运用，请阅读维基百科中的「Duck typing」词条。

安全的 __format__ 方法，增强可用性

实现 __format__ 方法时，我们没有采取措施防范 Vector 实例拥有大量分量，不过在 __repr__ 方法中我们使用 reprlib 做了预防。这是因为 repr () 函数用于调试和记录日志，所以必须生成可用的输出；而 __format__ 方法用于向最终用户显示输出，他们大概想看到整个 Vector。如果你觉得这样做危险，可以再为格式规范微语言实现一个扩展。

如果是我，我会这么做：默认情况下，格式化的 Vector 实例显示有限个分量，比如说 30 个。如果元素数量超过上限，默认的行为是像 reprlib 那样，截断超出的部分，使用 ... 表示。然而，如果格式说明符后面有特殊的 * 代码（意思是「全部」），那么就不限制显示的元素数量。因此，用户在不知情的情况下不会被特别长的输出吓到。如果默认的上限碍事，那么 ... 的存在对用户是个提醒，用户研究文档后会发现 * 格式代码。

如果你实现了，请向本书的 GitHub 仓库发一个拉取请求。

寻找符合 Python 风格的求和方式

就像「什么是美」没有确切的答案一样，「什么是 Python 风格」也没有标准答案。如果回答「地道的 Python」（我通常会这样说），不能让人 100% 满意，因为对你来说是「地道的」，在我看来却可能不是。但我可以肯定的是，「地道」并不是指使用最鲜为人知的语言特性。

Python-list 中有一篇发表于 2003 年 4 月的话题，题为「Pythonic Way to Sum n-th List Element?」。这个话题与本章讨论的 reduce 函数有关。

该话题的发起人 Guy Middleton 说他不喜欢使用 lambda 表达式，问下面这个方案有没有办法改进：9

>>> my_list = [[1, 2, 3], [40, 50, 60], [9, 8, 7]] >>> import functools >>> functools.reduce(lambda a, b: a+b, [sub[1] for sub in my_list]) 60

这段代码有很多习惯用法：lambda、reduce 和列表推导。最终，这可能会变成人气竞赛，因为它冒犯了讨厌 lambda 的人和看不上列表推导的人 —— 这两种人都很多。

如果使用 lambda，或许就不应该使用列表推导 —— 过滤除外，但这不是过滤。

下面是我给出的方案，这能讨得 lambda 拥护者的欢心：

>>> functools.reduce(lambda a, b: a + b[1], my_list, 0) 60

我没有参与那个话题，而且我不会在真实的代码中使用上述方案，因为我非常不喜欢 lambda 表达式。这里只是为了举例说明不使用列表推导怎么做。

第一个答案是 Fernando Perez 给出的，他是 IPython 的创建者，他的答案强调了 NumPy 支持 n 维数组和 n 维切片：

>>> import numpy as np >>> my_array = np.array(my_list) >>> np.sum(my_array[:, 1]) 60

我觉得 Perez 的方案很棒，不过 Guy Middleton 推崇 Paul Rubin 和 Skip Montanaro 给出的下述方案：

>>> import operator >>> functools.reduce(operator.add, [sub[1] for sub in my_list], 0) 60

随后，Evan Simpson 问道：「这样做有什么错？」

>>> total = 0 >>> for sub in my_list: ... total += sub[1] >>> total 60

许多人都觉得这也很符合 Python 风格。Alex Martelli 甚至说，Guido 或许就会这么做。

我喜欢 Evan Simpson 的代码，不过也喜欢 David Eppstein 对此给出的评论：

如果你想计算列表中各个元素的和，写出的代码应该看起来像是在「计算元素之和」，而不是「迭代元素，维护一个变量 t，再执行一系列求和操作」。如果不能站在一定高度上表明意图，让语言去关注低层操作，那么要高级语言干嘛？

之后 Alex Martelli 又建议：

求和操作经常需要，我不介意 Python 提供一个这样的内置函数。但是，在我看来，「reduce (operator.add, ...」不是好方法（作为一名 APL 老程序员和 FP 语言的爱好者，我应该喜欢，但是我并不喜欢）。

随后，Alex 建议提供并实现了 sum () 函数。这次讨论之后三个月，Python 2.3 就内置了这个函数。因此，Alex 喜欢的句法变成了标准：

>>> sum([sub[1] for sub in my_list]) 60

下一年年末（2004 年 11 月），Python 2.4 发布了，这一版引入了生成器表达式。因此，在我看来，Guy Middleton 那个问题目前最符合 Python 风格的答案是：

>>> sum(sub[1] for sub in my_list) 60

这样写不仅比使用 reduce 函数更易阅读，而且还能避免空序列导致的陷阱：sum ([]) 的结果是 0，就这么简单。

在这次讨论中，Alex Martelli 指出，Python 2 内置的 reduce 函数成事不足败事有余，因为它推荐的地道编程方式难以理解。他的观点最有说服力：Python 3 把 reduce 函数移到 functools 模块中了。

当然，functools.reduce 函数仍有它的作用。实现 Vector.__hash__ 方法时我就用了它，我觉得我的实现方式算得上符合 Python 风格。

9 为了在此展示，我稍微修改了这段代码，因为在 2003 年，reduce 是内置函数，而在 Python 3 中要导入。此外，我把 x 和 y 换成了 my_list 和 sub（表示子串）。

第 11 章　接口：从协议到抽象基类

抽象类表示接口。1

——Bjarne Stroustrup

C++ 之父

1Bjarne Stroustrup, The Design and Evolution of C++ (Addison-Wesley, 1994), p. 278.

本章讨论的话题是接口：从鸭子类型的代表特征动态协议，到使接口更明确、能验证实现是否符合规定的抽象基类（Abstract Base Class，ABC）。

如果用过 Java、C# 或类似的语言，你会觉得鸭子类型的非正式协议很新奇。但是对长时间使用 Python 或 Ruby 的程序员来说，这是接口的「常规」方式，新知识是抽象基类的严格规定和类型检查。Python 语言诞生 15 年后，Python 2.6 才引入抽象基类。

本章先说明 Python 社区以往对接口的不严谨理解：部分实现接口通常被认为是可接受的。我们将通过几个示例强调鸭子类型的动态本性，从而澄清这一点。

接着，我邀请 Alex Martelli 写了一篇短文，对抽象基类做了介绍，还为 Python 编程的一个新趋势下了定义。本章余下的内容专门讲解抽象基类。首先，本章说明抽象基类的常见用途：实现接口时作为超类使用。然后，说明抽象基类如何检查具体子类是否符合接口定义，以及如何使用注册机制声明一个类实现了某个接口，而不进行子类化操作。最后，说明如何让抽象基类自动「识别」任何符合接口的类 —— 不进行子类化或注册。

我们将实现一个新抽象基类，看看它的运作方式。但是，我和 Alex Martelli 都不建议你自己编写抽象基类，因为很容易过度设计。

抽象基类与描述符和元类一样，是用于构建框架的工具。因此，只有少数 Python 开发者编写的抽象基类不会对用户施加不必要的限制，让他们做无用功。

下面我们从 Python 风格的角度探讨接口。

11.1　Python 文化中的接口和协议

引入抽象基类之前，Python 就已经非常成功了，即便现在也很少有代码使用抽象基类。第 1 章就已经讨论了鸭子类型和协议。在 10.3 节，我们把协议定义为非正式的接口，是让 Python 这种动态类型语言实现多态的方式。

接口在动态类型语言中是怎么运作的呢？首先，基本的事实是，Python 语言没有 interface 关键字，而且除了抽象基类，每个类都有接口：类实现或继承的公开属性（方法或数据属性），包括特殊方法，如 __getitem__ 或 __add__。

按照定义，受保护的属性和私有属性不在接口中：即便「受保护的」属性也只是采用命名约定实现的（单个前导下划线）；私有属性可以轻松地访问（参见 9.7 节），原因也是如此。不要违背这些约定。

另一方面，不要觉得把公开数据属性放入对象的接口中不妥，因为如果需要，总能实现读值方法和设值方法，把数据属性变成特性，使用 obj.attr 句法的客户代码不会受到影响。Vector2d 类就是这么做的，示例 11-1 是 Vector2d 类的第一版，x 和 y 是公开属性。

示例 11-1　vector2d_v0.py：x 和 y 是公开数据属性（代码与示例 9-2 相同）

class Vector2d: typecode = 'd' def __init__(self, x, y): self.x = float (x) self.y = float (y) def __iter__(self): return (i for i in (self.x, self.y)) # 下面是其他方法（这个代码清单将其省略了）

在示例 9-7 中，我们把 x 和 y 变成了只读特性（见示例 11-2）。这是一项重大重构，但是 Vector2d 的接口基本没变：用户仍能读取 my_vector.x 和 my_vector.y。

示例 11-2　vector2d_v3.py：使用特性实现 x 和 y（完整的代码清单参见示例 9-9）

class Vector2d: typecode = 'd' def __init__(self, x, y): self.__x = float (x) self.__y = float (y) @property def x (self): return self.__x @property def y (self): return self.__y def __iter__(self): return (i for i in (self.x, self.y)) # 下面是其他方法（这个代码清单将其省略了）

关于接口，这里有个实用的补充定义：对象公开方法的子集，让对象在系统中扮演特定的角色。Python 文档中的「文件类对象」或「可迭代对象」就是这个意思，这种说法指的不是特定的类。接口是实现特定角色的方法集合，这样理解正是 Smalltalk 程序员所说的协议，其他动态语言社区都借鉴了这个术语。协议与继承没有关系。一个类可能会实现多个接口，从而让实例扮演多个角色。

协议是接口，但不是正式的（只由文档和约定定义），因此协议不能像正式接口那样施加限制（本章后面会说明抽象基类对接口一致性的强制）。一个类可能只实现部分接口，这是允许的。有时，某些 API 只要求「文件类对象」返回字节序列的 .read () 方法。在特定的上下文中可能需要其他文件操作方法，也可能不需要。

写作本书时，Python 3 中 memoryview 的文档说，它能处理「支持缓冲协议的对象」，不过缓冲协议的文档是针对 C API 的。bytearray（https://docs.python.org/3/library/functions.html#bytearray） 的构造方法接受「一个符合缓冲接口的对象」。如今，文档正在改变用词，使用「字节序列类对象」这样更加友好的表述。2 我指出这一点是为了强调，对 Python 程序员来说，「X 类对象」「X 协议」和「X 接口」都是一个意思。

2 其实，Issue 16518:「add buffer protocol to glossary」做的就是这种修改，把很多「支持缓冲协议 / 接口 /API 的对象」改成了「字节序列类对象」；「Other mentions of the buffer protocol」也是如此。

序列协议是 Python 最基础的协议之一。即便对象只实现了那个协议最基本的一部分，解释器也会负责任地处理，如下一节所示。

11.2　Python 喜欢序列

Python 数据模型的哲学是尽量支持基本协议。对序列来说，即便是最简单的实现，Python 也会力求做到最好。

图 11-1 展示了定义为抽象基类的 Sequence 正式接口。

图 11-1：Sequence 抽象基类和 collections.abc 中相关抽象类的 UML 类图，箭头由子类指向超类，以斜体显示的是抽象方法

现在，看看示例 11-3 中的 Foo 类。它没有继承 abc.Sequence，而且只实现了序列协议的一个方法： __getitem__ （没有实现 __len__ 方法）。

示例 11-3　定义 __getitem__ 方法，只实现序列协议的一部分，这样足够访问元素、迭代和使用 in 运算符了

>>> class Foo: ... def __getitem__(self, pos): ... return range(0, 30, 10)[pos] ... >>> f = Foo() >>> f[1] 10 >>> for i in f: print(i) ... 0 10 20 >>> 20 in f True >>> 15 in f False

虽然没有 __iter__ 方法，但是 Foo 实例是可迭代的对象，因为发现有 __getitem__ 方法时，Python 会调用它，传入从 0 开始的整数索引，尝试迭代对象（这是一种后备机制）。尽管没有实现 __contains__ 方法，但是 Python 足够智能，能迭代 Foo 实例，因此也能使用 in 运算符：Python 会做全面检查，看看有没有指定的元素。

综上，鉴于序列协议的重要性，如果没有 __iter__ 和 __contains__ 方法，Python 会调用 __getitem__ 方法，设法让迭代和 in 运算符可用。

第 1 章定义的 FrenchDeck 类也没有继承 abc.Sequence，但是实现了序列协议的两个方法：__getitem__ 和 __len__。如示例 11-4 所示。

示例 11-4　实现序列协议的 FrenchDeck 类（代码与示例 1-1 相同）

import collections Card = collections.namedtuple('Card', ['rank', 'suit']) class FrenchDeck: ranks = [str(n) for n in range(2, 11)] + list('JQKA') suits = 'spades diamonds clubs hearts'.split() def __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks] def __len__(self): return len(self._cards) def __getitem__(self, position): return self._cards[position]

第 1 章那些示例之所以能用，大部分是由于 Python 会特殊对待看起来像是序列的对象。Python 中的迭代是鸭子类型的一种极端形式：为了迭代对象，解释器会尝试调用两个不同的方法。

下面再分析一个示例，着重强调协议的动态本性。

11.3　使用猴子补丁在运行时实现协议

示例 11-4 中的 FrenchDeck 类有个重大缺陷：无法洗牌。几年前，第一次编写 FrenchDeck 示例时，我实现了 shuffle 方法。后来，我对 Python 风格有了深刻理解，我发现如果 FrenchDeck 实例的行为像序列，那么它就不需要 shuffle 方法，因为已经有 random.shuffle 函数可用，文档中说它的作用是「就地打乱序列 x」。

如果遵守既定协议，很有可能增加利用现有的标准库和第三方代码的可能性，这得益于鸭子类型。

标准库中的 random.shuffle 函数用法如下：

>>> from random import shuffle >>> l = list(range(10)) >>> shuffle(l) >>> l [5, 2, 9, 7, 8, 3, 1, 4, 0, 6]

然而，如果尝试打乱 FrenchDeck 实例，会出现异常，如示例 11-5 所示。

示例 11-5　random.shuffle 函数不能打乱 FrenchDeck 实例

>>> from random import shuffle >>> from frenchdeck import FrenchDeck >>> deck = FrenchDeck() >>> shuffle(deck) Traceback (most recent call last): File "<stdin>", line 1, in <module> File ".../python3.3/random.py", line 265, in shuffle x[i], x[j] = x[j], x[i] TypeError: 'FrenchDeck' object does not support item assignment

错误消息相当明确，「'FrenchDeck' object does not support item assignment」（'FrenchDeck' 对象不支持为元素赋值）。这个问题的原因是，shuffle 函数要调换集合中元素的位置，而 FrenchDeck 只实现了不可变的序列协议。可变的序列还必须提供 __setitem__ 方法。

Python 是动态语言，因此我们可以在运行时修正这个问题，甚至还可以在交互式控制台中，修正方法如示例 11-6 所示。

示例 11-6　为 FrenchDeck 打猴子补丁，把它变成可变的，让 random.shuffle 函数能处理（接续示例 11-5）

>>> def set_card(deck, position, card): ➊ ... deck._cards[position] = card ... >>> FrenchDeck.__setitem__ = set_card ➋ >>> shuffle(deck) ➌ >>> deck[:5] [Card(rank='3', suit='hearts'), Card(rank='4', suit='diamonds'), Card(rank='4', suit='clubs'), Card(rank='7', suit='hearts'), Card(rank='9', suit='spades')]

❶ 定义一个函数，它的参数为 deck、position 和 card。

❷ 把那个函数赋值给 FrenchDeck 类的 __setitem__ 属性。

❸ 现在可以打乱 deck 了，因为 FrenchDeck 实现了可变序列协议所需的方法。

特殊方法 __setitem__ 的签名在 Python 语言参考手册的「3.3.6. Emulating container types」中定义。语言参考中使用的参数是 self、key 和 value，而这里使用的是 deck、position 和 card。这么做是为了告诉你，每个 Python 方法说到底都是普通函数，把第一个参数命名为 self 只是一种约定。在控制台会话中使用那几个参数没问题，不过在 Python 源码文件中最好按照文档那样使用 self、key 和 value。

这里的关键是，set_card 函数要知道 deck 对象有一个名为 _cards 的属性，而且 _cards 的值必须是可变序列。然后，我们把 set_card 函数赋值给特殊方法 __setitem__，从而把它依附到 FrenchDeck 类上。这种技术叫猴子补丁：在运行时修改类或模块，而不改动源码。猴子补丁很强大，但是打补丁的代码与要打补丁的程序耦合十分紧密，而且往往要处理隐藏和没有文档的部分。

除了举例说明猴子补丁之外，示例 11-6 还强调了协议是动态的：random.shuffle 函数不关心参数的类型，只要那个对象实现了部分可变序列协议即可。即便对象一开始没有所需的方法也没关系，后来再提供也行。

目前，本章讨论的主题是「鸭子类型」：对象的类型无关紧要，只要实现了特定的协议即可。

前面给出的抽象基类图表是为了展示协议与抽象基类的文档中所说的接口之间的关系，但是目前为止还没有真正继承抽象基类。

在接下来的几节中，我们将直接使用抽象基类，而不只将其当作文档。

11.4　Alex Martelli 的水禽

介绍完 Python 常规的协议风格接口后，下面讨论抽象基类。不过在分析示例和细节之前，我们要看 Alex Martelli 写的一篇短文。这篇短文说明了 Python 为什么引入抽象基类。

非常感谢 Alex Martelli。本书引用最多的就是他说的话，后来他变成了本书的技术编辑之一。他的见解已经非常宝贵了，现在又愿意撰写这篇短文。Python 社区有他的存在真是幸运。接下来交给你了，Alex ！

水禽和抽象基类

Alex Martelli 撰

维基百科说是我协助传播了「鸭子类型」这种言简意赅的说法（即忽略对象的真正类型，转而关注对象有没有实现所需的方法、签名和语义）。

对 Python 来说，这基本上是指避免使用 isinstance 检查对象的类型（更别提 type (foo) is bar 这种更糟的检查方式了，这样做没有任何好处，甚至禁止最简单的继承方式）。

总的来说，鸭子类型在很多情况下十分有用；但是在其他情况下，随着发展，通常有更好的方式。事情是这样的……

近代，属和种（包括但不限于水禽所属的鸭科）基本上是根据表型系统学（phenetics）分类的。表征学关注的是形态和举止的相似性…… 主要是表型系统学特征。因此使用「鸭子类型」比喻是贴切的。

然而，平行进化往往会导致不相关的种产生相似的特征，形态和举止方面都是如此，但是生态位的相似性是偶然的，不同的种仍属不同的生态位。编程语言中也有这种「偶然的相似性」，比如说下述经典的面向对象编程示例：

class Artist: def draw(self): ... 　 class Gunslinger: def draw(self): ... 　 class Lottery: def draw(self): ...

显然，只因为 x 和 y 两个对象刚好都有一个名为 draw 的方法，而且调用时不用传入参数，即 x.draw () 和 y.draw ()，远远不能确保二者可以相互调用，或者具有相同的抽象。也就是说，从这样的调用中不能推导出语义相似性。相反，我们需要一位渊博的程序员主动把这种等价维持在一定层次上。

生物（和其他学科）遇到的这个问题，迫切需要（从很多方面来说，是催生）表征学之外的分类方式解决，即支序系统学（cladistics）。这种分类学主要根据从共同祖先那里继承的特征分类，而不是单独进化的特征。（近些年，DNA 测序变得便宜又快，这使支序学的实用地位变得更高。）

例如，草雁（以前认为与其他鹅类比较相似）和麻鸭（以前认为与其他鸭类比较相似）现在被分到 Tadornidae 亚科（表明二者的相似性比鸭科中其他动物高，因为它们的共同祖先比较接近）。此外，DNA 分析表明，白翅木鸭与美洲家鸭（属于麻鸭）不是很像，至少没有形态和举止看起来那么像，因此把木鸭单独分成了一属，完全不在 Tadornidae 亚科中。

知道这些有什么用呢？视情况而定！比如，逮到一只水禽后，决定如何烹制才最美味时，显著的特征（不是全部，例如一身羽毛并不重要）主要是口感和风味（过时的表征学），这比支序学重要得多。但在其他方面，如对不同病原体的抗性（圈养水禽还是放养），DNA 接近性的作用就大多了……

因此，参照水禽的分类学演化，我建议在鸭子类型的基础上增加白鹅类型（goose typing）。

白鹅类型指，只要 cls 是抽象基类，即 cls 的元类是 abc.ABCMeta，就可以使用 isinstance (obj, cls)。

collections.abc 中有很多有用的抽象类（Python 标准库的 numbers 模块中还有一些）。3

与具体类相比，抽象基类有很多理论上的优点（例如，参阅 Scott Meyer 写的《More Effective C++：35 个改善编程与设计的有效方法（中文版）》的「条款 33：将非尾端类设计为抽象类」，英文版见 http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html），Python 的抽象基类还有一个重要的实用优势：可以使用 register 类方法在终端用户的代码中把某个类「声明」为一个抽象基类的「虚拟」子类（为此，被注册的类必须满足抽象基类对方法名称和签名的要求，最重要的是要满足底层语义契约；但是，开发那个类时不用了解抽象基类，更不用继承抽象基类）。这大大地打破了严格的强耦合，与面向对象编程人员掌握的知识有很大出入，因此使用继承时要小心。

有时，为了让抽象基类识别子类，甚至不用注册。

其实，抽象基类的本质就是几个特殊方法。例如：

>>> class Struggle: ... def __len__(self): return 23 ... >>> from collections import abc >>> isinstance(Struggle(), abc.Sized) True

可以看出，无需注册，abc.Sized 也能把 Struggle 识别为自己的子类，只要实现了特殊方法 __len__ 即可（要使用正确的句法和语义实现，前者要求没有参数，后者要求返回一个非负整数，指明对象的长度；如果不使用规定的句法和语义实现特殊方法，如 __len__，会导致非常严重的问题）。

最后我想说的是：如果实现的类体现了 numbers、collections.abc 或其他框架中抽象基类的概念，要么继承相应的抽象基类（必要时），要么把类注册到相应的抽象基类中。开始开发程序时，不要使用提供注册功能的库或框架，要自己动手注册；如果必须检查参数的类型（这是最常见的），例如检查是不是「序列」，那就这样做：

isinstance(the_arg, collections.abc.Sequence)

此外，不要在生产代码中定义抽象基类（或元类）…… 如果你很想这样做，我打赌可能是因为你想「找茬」，刚拿到新工具的人都有大干一场的冲动。如果你能避开这些深奥的概念，你（以及未来的代码维护者）的生活将更愉快，因为代码会变得简洁明了。再会！

3 当然，你还可以自己定义抽象基类，但是我不建议高级 Python 程序员之外的人这么做；同样，我也不建议你自己定义元类…… 我说的「高级 Python 程序员」是指对 Python 语言的一招一式都了如指掌，即便对这类人来说，抽象基类和元类也不是常用工具。如此「深层次的元编程」，如果可以这么讲的话，适合框架的作者使用，这样便于众多不同的开发团队独立扩展框架…… 真正需要这么做的「高级 Python 程序员」不超过 1%。——Alex Martelli

除了提出「白鹅类型」之外，Alex 还指出，继承抽象基类很简单，只需要实现所需的方法，这样也能明确表明开发者的意图。这一意图还能通过注册虚拟子类来实现。

此外，使用 isinstance 和 issubclass 测试抽象基类更为人接受。过去，这两个函数用来测试鸭子类型，但用于抽象基类会更灵活。毕竟，如果某个组件没有继承抽象基类，事后还可以注册，让显式类型检查通过。

然而，即便是抽象基类，也不能滥用 isinstance 检查，用得多了可能导致代码异味，即表明面向对象设计得不好。在一连串 if/elif/elif 中使用 isinstance 做检查，然后根据对象的类型执行不同的操作，通常是不好的做法；此时应该使用多态，即采用一定的方式定义类，让解释器把调用分派给正确的方法，而不使用 if/elif/elif 块硬编码分派逻辑。

具体使用时，上述建议有一个常见的例外：有些 Python API 接受一个字符串或字符串序列；如果只有一个字符串，可以把它放到列表中，从而简化处理。因为字符串是序列类型，所以为了把它和其他不可变序列区分开，最简单的方式是使用 isinstance (x, str) 检查。4

4 可惜，在 Python 3.4 中没有能把字符串和元组或其他不可变序列区分开的抽象基类，因此必须测试 str。在 Python 2 中，basestr 类型可以协助这样的测试。basestr 不是抽象基类，但它是 str 和 unicode 的超类；然而，Python 3 把 basestr 去掉了。奇怪的是，Python 3 中有个 collections.abc.ByteString 类型，但是它只能检测 bytes 和 bytearray 类型。

另一方面，如果必须强制执行 API 契约，通常可以使用 isinstance 检查抽象基类。「老兄，如果你想调用我，必须实现这个」，正如本书技术审校 Lennart Regebro 所说的。这对采用插入式架构的系统来说特别有用。在框架之外，鸭子类型通常比类型检查更简单，也更灵活。

例如，本书有几个示例要使用序列，把它当成列表处理。我没有检查参数的类型是不是 list，而是直接接受参数，立即使用它构建一个列表。这样，我就可以接受任何可迭代对象；如果参数不是可迭代对象，调用立即失败，并且提供非常清晰的错误消息。本章后面示例 11-13 中的代码就是这么做的。当然，如果序列太长或者需要就地修改序列而导致无法复制参数，就不能采用这种方式；此时，使用 isinstance (x, abc.MutableSequence) 更好。如果可以接受任何可迭代对象，也可以调用 iter (x) 函数获得一个迭代器，详情参见 14.1.1 节。

模仿 collections.namedtuple（https://docs.python.org/3/library/collections.html#collections.namedtuple） 处理 field_names 参数的方式也是一例：field_names 的值可以是单个字符串，以空格或逗号分隔标识符，也可以是一个标识符序列。此时可能想使用 isinstance，但我会使用鸭子类型，如示例 11-7 所示。5

5 这段代码摘自示例 21-2。

示例 11-7　使用鸭子类型处理单个字符串或由字符串组成的可迭代对象

try: ➊ field_names = field_names.replace(',', ' ').split() ➋ except AttributeError: ➌ pass ➍ field_names = tuple(field_names) ➎

❶ 假设是单个字符串（EAFP 风格，即「取得原谅比获得许可容易」）。

❷ 把逗号替换成空格，然后拆分成名称列表。

❸ 抱歉，field_names 看起来不像是字符串…… 没有 .replace 方法，或者返回值不能使用 .split 方法拆分。

❹ 假设已经是由名称组成的可迭代对象了。

❺ 为了确保的确是可迭代对象，也为了保存一份副本，使用所得值创建一个元组。

在那篇短文的最后，Alex 多次强调，要抑制住创建抽象基类的冲动。滥用抽象基类会造成灾难性后果，表明语言太注重表面形式，这对以实用和务实著称的 Python 可不是好事。在审阅本书的过程中，Alex 写道：

抽象基类是用于封装框架引入的一般性概念和抽象的，例如「一个序列」和「一个确切的数」。（读者）基本上不需要自己编写新的抽象基类，只要正确使用现有的抽象基类，就能获得 99.9% 的好处，而不用冒着设计不当导致的巨大风险。

下面通过实例讲解白鹅类型。

11.5　定义抽象基类的子类

我们将遵循 Martelli 的建议，先利用现有的抽象基类（collections.MutableSequence），然后再斗胆自己定义。在示例 11-8 中，我们明确把 FrenchDeck2 声明为 collections.MutableSequence 的子类。

示例 11-8　frenchdeck2.py：FrenchDeck2，collections.MutableSequence 的子类

import collections Card = collections.namedtuple('Card', ['rank', 'suit']) class FrenchDeck2(collections.MutableSequence): ranks = [str(n) for n in range(2, 11)] + list('JQKA') suits = 'spades diamonds clubs hearts'.split() def __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks] def __len__(self): return len(self._cards) def __getitem__(self, position): return self._cards[position] def __setitem__(self, position, value): # ➊ self._cards[position] = value def __delitem__(self, position): # ➋ del self._cards[position] def insert(self, position, value): # ➌ self._cards.insert(position, value)

❶ 为了支持洗牌，只需实现 __setitem__ 方法。

❷ 但是继承 MutableSequence 的类必须实现 __delitem__ 方法，这是 MutableSequence 类的一个抽象方法。

❸ 此外，还要实现 insert 方法，这是 MutableSequence 类的第三个抽象方法。

导入时（加载并编译 frenchdeck2.py 模块时），Python 不会检查抽象方法的实现，在运行时实例化 FrenchDeck2 类时才会真正检查。因此，如果没有正确实现某个抽象方法，Python 会抛出 TypeError 异常，并把错误消息设为 "Can't instantiate abstract class FrenchDeck2 with abstract methods __delitem__, insert"。正是这个原因，即便 FrenchDeck2 类不需要 __delitem__ 和 insert 提供的行为，也要实现，因为 MutableSequence 抽象基类需要它们。

如图 11-2 所示，Sequence 和 MutableSequence 抽象基类的方法不全是抽象的。

图 11-2：MutableSequence 抽象基类和 collections.abc 中它的超类的 UML 类图（箭头由子类指向祖先；以斜体显示的名称是抽象类和抽象方法）

FrenchDeck2 从 Sequence 继承了几个拿来即用的具体方法：__contains__、__iter__、__reversed__、index 和 count。FrenchDeck2 从 MutableSequence 继承了 append、extend、pop、remove 和__iadd__。

在 collections.abc 中，每个抽象基类的具体方法都是作为类的公开接口实现的，因此不用知道实例的内部结构。

要想实现子类，我们可以覆盖从抽象基类中继承的方法，以更高效的方式重新实现。例如，__contains__ 方法会全面扫描序列，可是，如果你定义的序列按顺序保存元素，那就可以重新定义 __contains__ 方法，使用 bisect 函数做二分查找（参见 2.8 节），从而提升搜索速度。

为了充分使用抽象基类，我们要知道有哪些抽象基类可用。接下来介绍集合抽象基类。

11.6　标准库中的抽象基类

从 Python 2.6 开始，标准库提供了抽象基类。大多数抽象基类在 collections.abc 模块中定义，不过其他地方也有。例如，numbers 和 io 包中有一些抽象基类。但是，collections.abc 中的抽象基类最常用。我们来看看这个模块中有哪些抽象基类。

11.6.1　collections.abc 模块中的抽象基类

标准库中有两个名为 abc 的模块，这里说的是 collections.abc。为了减少加载时间，Python 3.4 在 collections 包之外实现这个模块（在 Lib/_collections_abc.py 中），因此要与 collections 分开导入。另一个 abc 模块就是 abc（即 Lib/abc.py），这里定义的是 abc.ABC 类。每个抽象基类都依赖这个类，但是不用导入它，除非定义新抽象基类。

Python 3.4 在 collections.abc 模块中定义了 16 个抽象基类，简要的 UML 类图（没有属性名称）如图 11-3 所示。collections.abc 的官方文档中有个不错的表格，对各个抽象基类做了总结，说明了相互之间的关系，以及各个基类提供的抽象方法和具体方法（称为「混入方法」）。图 11-3 中有很多多重继承。我们将在第 12 章着重说明多重继承，讨论抽象基类时通常不用考虑多重继承。6

6Java 认为多重继承有危害，因此没有提供支持，但是提供了接口：Java 的接口可以扩展多个接口，而且 Java 的类可以实现多个接口。

图 11-3：collections.abc 模块中各个抽象基类的 UML 类图

下面详述图 11-3 中那一群基类。

Iterable、Container 和 Sized

各个集合应该继承这三个抽象基类，或者至少实现兼容的协议。Iterable 通过 __iter__ 方法支持迭代，Container 通过 __contains__ 方法支持 in 运算符，Sized 通过 __len__ 方法支持 len () 函数。

Sequence、Mapping 和 Set

这三个是主要的不可变集合类型，而且各自都有可变的子类。MutableSequence 的详细类图见图 11-2；MutableMapping 和 MutableSet 的类图在第 3 章中（见图 3-1 和图 3-2）。

MappingView

在 Python 3 中，映射方法 .items ()、.keys () 和 .values () 返回的对象分别是 ItemsView、KeysView 和 ValuesView 的实例。前两个类还从 Set 类继承了丰富的接口，包含 3.8.3 节所述的全部运算符。

Callable 和 Hashable

这两个抽象基类与集合没有太大的关系，只不过因为 collections.abc 是标准库中定义抽象基类的第一个模块，而它们又太重要了，因此才把它们放到 collections.abc 模块中。我从未见过 Callable 或 Hashable 的子类。这两个抽象基类的主要作用是为内置函数 isinstance 提供支持，以一种安全的方式判断对象能不能调用或散列。7

7 若想检查是否能调用，可以使用内置的 callable () 函数；但是没有类似的 hashable () 函数，因此测试对象是否可散列，最好使用 isinstance (my_obj, Hashable)。

Iterator

注意它是 Iterable 的子类。我们将在第 14 章详细讨论。

继 collections.abc 之后，标准库中最有用的抽象基类包是 numbers。下面就来介绍。

11.6.2　抽象基类的数字塔

numbers 包定义的是「数字塔」（即各个抽象基类的层次结构是线性的），其中 Number 是位于最顶端的超类，随后是 Complex 子类，依次往下，最底端是 Integral 类：

Number

Complex

Real

Rational

Integral

因此，如果想检查一个数是不是整数，可以使用 isinstance (x, numbers.Integral)，这样代码就能接受 int、bool（int 的子类），或者外部库使用 numbers 抽象基类注册的其他类型。为了满足检查的需要，你或者你的 API 的用户始终可以把兼容的类型注册为 numbers.Integral 的虚拟子类。

与之类似，如果一个值可能是浮点数类型，可以使用 isinstance (x, numbers.Real) 检查。这样代码就能接受 bool、int、float、fractions.Fraction，或者外部库（如 NumPy，它做了相应的注册）提供的非复数类型。

decimal.Decimal 没有注册为 numbers.Real 的虚拟子类，这有点奇怪。没注册的原因是，如果你的程序需要 Decimal 的精度，要防止与其他低精度数字类型混淆，尤其是浮点数。

了解一些现有的抽象基类之后，我们将从零开始实现一个抽象基类，然后实际使用，以此实践白鹅类型。这么做的目的不是鼓励每个人都立即开始定义抽象基类，而是教你怎么阅读标准库和其他包中的抽象基类源码。

11.7　定义并使用一个抽象基类

为了证明有必要定义抽象基类，我们要在框架中找到使用它的场景。想象一下这个场景：你要在网站或移动应用中显示随机广告，但是在整个广告清单轮转一遍之前，不重复显示广告。假设我们在构建一个广告管理框架，名为 ADAM。它的职责之一是，支持用户提供随机挑选的无重复类。8 为了让 ADAM 的用户明确理解「随机挑选的无重复」组件是什么意思，我们将定义一个抽象基类。

8 客户可能要审查随机发生器，或者代理想作弊…… 谁知道呢！

受到「栈」和「队列」（以物体的排放方式说明抽象接口）启发，我将使用现实世界中的物品命名这个抽象基类：宾果机和彩票机是随机从有限的集合中挑选物品的机器，选出的物品没有重复，直到选完为止。

我们把这个抽象基类命名为 Tombola，这是宾果机和打乱数字的滚动容器的意大利名。9

9 牛津英语词典对 tombola 的定义是「像对号游戏（lotto）那样的彩票（lottery）」。

Tombola 抽象基类有四个方法，其中两个是抽象方法。

.load (...)：把元素放入容器。

.pick ()：从容器中随机拿出一个元素，返回选中的元素。

另外两个是具体方法。

.loaded ()：如果容器中至少有一个元素，返回 True。

.inspect ()：返回一个有序元组，由容器中的现有元素构成，不会修改容器的内容（内部的顺序不保留）。

图 11-4 展示了 Tombola 抽象基类和三个具体实现。

图 11-4：一个抽象基类和三个子类的 UML 类图。根据 UML 的约定，Tombola 抽象基类和它的抽象方法使用斜体。虚线箭头用于表示接口实现，这里它表示 TomboList 是 Tombola 的虚拟子类，因为 TomboList 是注册的，本章后面会说明这一点 10

10«registered» 和 «virtual subclass» 不是标准的 UML 词汇。我们使用二者表示 Python 类之间的关系。

Tombola 抽象基类的定义如示例 11-9 所示。

示例 11-9　tombola.py：Tombola 是抽象基类，有两个抽象方法和两个具体方法

import abc class Tombola (abc.ABC): ➊ @abc.abstractmethod def load (self, iterable): ➋ """从可迭代对象中添加元素。""" @abc.abstractmethod def pick (self): ➌ """随机删除元素，然后将其返回。如果实例为空，这个方法应该抛出`LookupError`。""" def loaded (self): ➍ """如果至少有一个元素，返回`True`，否则返回`False`。""" return bool (self.inspect ()) ➎ def inspect (self): """返回一个有序元组，由当前元素构成。""" items = [] while True: ➏ try: items.append (self.pick ()) except LookupError: break self.load (items) ➐ return tuple (sorted (items))

❶ 自己定义的抽象基类要继承 abc.ABC。

❷ 抽象方法使用 @abstractmethod 装饰器标记，而且定义体中通常只有文档字符串。11

11 在抽象基类出现之前，抽象方法使用 raise NotImplementedError 语句表明由子类负责实现。

❸ 根据文档字符串，如果没有元素可选，应该抛出 LookupError。

❹ 抽象基类可以包含具体方法。

❺ 抽象基类中的具体方法只能依赖抽象基类定义的接口（即只能使用抽象基类中的其他具体方法、抽象方法或特性）。

❻ 我们不知道具体子类如何存储元素，不过为了得到 inspect 的结果，我们可以不断调用 .pick () 方法，把 Tombola 清空……

❼ …… 然后再使用 .load (...) 把所有元素放回去。

其实，抽象方法可以有实现代码。即便实现了，子类也必须覆盖抽象方法，但是在子类中可以使用 super () 函数调用抽象方法，为它添加功能，而不是从头开始实现。@abstractmethod 装饰器的用法参见 abc 模块的文档。

示例 11-9 中的 .inspect () 方法实现的方式有些笨拙，不过却表明，有了 .pick () 和 .load (…) 方法，若想查看 Tombola 中的内容，可以先把所有元素挑出，然后再放回去。这个示例的目的是强调抽象基类可以提供具体方法，只要依赖接口中的其他方法就行。Tombola 的具体子类知晓内部数据结构，可以覆盖 .inspect () 方法，使用更聪明的方式实现，但这不是强制要求。

示例 11-9 中的 .loaded () 方法没有那么笨拙，但是耗时：调用 .inspect () 方法构建有序元组的目的仅仅是在其上调用 bool () 函数。这样做是可以的，但是具体子类可以做得更好，后文见分晓。

注意，实现 .inspect () 方法采用的迂回方式要求捕获 self.pick () 抛出的 LookupError。self.pick () 抛出 LookupError 这一事实也是接口的一部分，但是在 Python 中没办法声明，只能在文档中说明（参见示例 11-9 中抽象方法 pick 的文档字符串）。

我选择使用 LookupError 异常的原因是，在 Python 的异常层次关系中，它与 IndexError 和 KeyError 有关，这两个是具体实现 Tombola 所用的数据结构最有可能抛出的异常。据此，实现代码可能会抛出 LookupError、IndexError 或 KeyError 异常。异常的部分层次结构如示例 11-10 所示（完整的层次结构参见 Python 标准库文档中的「5.4. Exception hierarchy」一节。12）

12 见 https://docs.python.org/dev/library/exceptions.html#exception-hierarchy。—— 编者注

示例 11-10　异常类的部分层次结构

BaseException ├── SystemExit ├── KeyboardInterrupt ├── GeneratorExit └── Exception ├── StopIteration ├── ArithmeticError │ ├── FloatingPointError │ ├── OverflowError │ └── ZeroDivisionError ├── AssertionError ├── AttributeError ├── BufferError ├── EOFError ├── ImportError ├── LookupError ➊ │ ├── IndexError ➋ │ └── KeyError ➌ ├── MemoryError ... etc.

❶ 我们在 Tombola.inspect 方法中处理的是 LookupError 异常。

❷ IndexError 是 LookupError 的子类，尝试从序列中获取索引超过最后位置的元素时抛出。

❸ 使用不存在的键从映射中获取元素时，抛出 KeyError 异常。

我们自己定义的 Tombola 抽象基类完成了。为了一睹抽象基类对接口所做的检查，下面我们尝试使用一个有缺陷的实现来糊弄 Tombola，如示例 11-11 所示。

示例 11-11　不符合 Tombola 要求的子类无法蒙混过关

>>> from tombola import Tombola >>> class Fake(Tombola): # ➊ ... def pick(self): ... return 13 ... >>> Fake # ➋ <class '__main__.Fake'> >>> f = Fake() # ➌ Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: Can't instantiate abstract class Fake with abstract methods load

❶ 把 Fake 声明为 Tombola 的子类。

❷ 创建了 Fake 类，目前没有错误。

❸ 尝试实例化 Fake 时抛出了 TypeError。错误消息十分明确：Python 认为 Fake 是抽象类，因为它没有实现 load 方法，这是 Tombola 抽象基类声明的抽象方法之一。

我们的第一个抽象基类定义好了，而且还用它实际验证了一个类。稍后我们将定义 Tombola 抽象基类的子类，在此之前必须说明抽象基类的一些编程规则。

11.7.1　抽象基类句法详解

声明抽象基类最简单的方式是继承 abc.ABC 或其他抽象基类。

然而，abc.ABC 是 Python 3.4 新增的类，因此如果你使用的是旧版 Python，那么无法继承现有的抽象基类。此时，必须在 class 语句中使用 metaclass= 关键字，把值设为 abc.ABCMeta（不是 abc.ABC）。在示例 11-9 中，可以写成：

class Tombola(metaclass=abc.ABCMeta): # ...

metaclass= 关键字参数是 Python 3 引入的。在 Python 2 中必须使用 __metaclass__ 类属性：

class Tombola (object): # 这是 Python 2！！！ __metaclass__ = abc.ABCMeta # ...

元类将在第 21 章讲解。现在，我们暂且把元类理解为一种特殊的类，同样也把抽象基类理解为一种特殊的类。例如，「常规的」类不会检查子类，因此这是抽象基类的特殊行为。

除了 @abstractmethod 之外，abc 模块还定义了 @abstractclassmethod、@abstractstaticmethod 和 @abstractproperty 三个装饰器。然而，后三个装饰器从 Python 3.3 起废弃了，因为装饰器可以在 @abstractmethod 上堆叠，那三个就显得多余了。例如，声明抽象类方法的推荐方式是：

class MyABC(abc.ABC): @classmethod @abc.abstractmethod def an_abstract_classmethod(cls, ...): pass

在函数上堆叠装饰器的顺序通常很重要，@abstractmethod 的文档就特别指出：

与其他方法描述符一起使用时，abstractmethod () 应该放在最里层，……13

也就是说，在 @abstractmethod 和 def 语句之间不能有其他装饰器。

13 出自 abc 模块文档中的 @abc.abstractmethod 词条。

说明抽象基类的句法之后，我们要通过实现几个功能完善的具体子代来使用 Tombola。

11.7.2　定义 Tombola 抽象基类的子类

定义好 Tombola 抽象基类之后，我们要开发两个具体子类，满足 Tombola 规定的接口。这两个子类的类图如图 11-4 所示，图中还有将在下一节讨论的虚拟子类。

示例 11-12 中的 BingoCage 类是在示例 5-8 的基础上修改的，使用了更好的随机发生器。BingoCage 实现了所需的抽象方法 load 和 pick，从 Tombola 中继承了 loaded 方法，覆盖了 inspect 方法，还增加了 __call__ 方法。

示例 11-12　bingo.py：BingoCage 是 Tombola 的具体子类

import random from tombola import Tombola class BingoCage(Tombola): ➊ def __init__(self, items): self._randomizer = random.SystemRandom() ➋ self._items = [] self.load(items) ➌ def load(self, items): self._items.extend(items) self._randomizer.shuffle(self._items) ➍ def pick(self): ➎ try: return self._items.pop() except IndexError: raise LookupError('pick from empty BingoCage') def __call__(self): ➏ self.pick()

❶ 明确指定 BingoCage 类扩展 Tombola 类。

❷ 假设我们将在线上游戏中使用这个。random.SystemRandom 使用 os.urandom (...) 函数实现 random API。根据 os 模块的文档，os.urandom (...) 函数生成「适合用于加密」的随机字节序列。

❸ 委托 .load (...) 方法实现初始加载。

❹ 没有使用 random.shuffle () 函数，而是使用 SystemRandom 实例的 .shuffle () 方法。

❺ pick 方法的实现方式与示例 5-8 一样。

❻ __call__ 也跟示例 5-8 中的一样。它没必要满足 Tombola 接口，添加额外的方法没有问题。

BingoCage 从 Tombola 中继承了耗时的 loaded 方法和笨拙的 inspect 方法。这两个方法都可以覆盖，变成示例 11-13 中速度更快的一行代码。这里想表达的观点是：我们可以偷懒，直接从抽象基类中继承不是那么理想的具体方法。从 Tombola 中继承的方法没有 BingoCage 自己定义的那么快，不过只要 Tombola 的子类正确实现 pick 和 load 方法，就能提供正确的结果。

示例 11-13 是 Tombola 接口的另一种实现，虽然与之前不同，但完全有效。LotteryBlower 打乱「数字球」后没有取出最后一个，而是取出一个随机位置上的球。

示例 11-13　lotto.py：LotteryBlower 是 Tombola 的具体子类，覆盖了继承的 inspect 和 loaded 方法

import random from tombola import Tombola class LotteryBlower(Tombola): def __init__(self, iterable): self._balls = list(iterable) ➊ def load(self, iterable): self._balls.extend(iterable) def pick(self): try: position = random.randrange(len(self._balls)) ➋ except ValueError: raise LookupError('pick from empty LotteryBlower') return self._balls.pop(position) ➌ def loaded(self): ➍ return bool(self._balls) def inspect(self): ➎ return tuple(sorted(self._balls))

❶ 初始化方法接受任何可迭代对象：把参数构建成列表。

❷ 如果范围为空，random.randrange (...) 函数抛出 ValueError，为了兼容 Tombola，我们捕获它，抛出 LookupError。

❸ 否则，从 self._balls 中取出随机选中的元素。

❹ 覆盖 loaded 方法，避免调用 inspect 方法（示例 11-9 中的 Tombola.loaded 方法是这么做的）。我们可以直接处理 self._balls 而不必构建整个有序元组，从而提升速度。

❺ 使用一行代码覆盖 inspect 方法。

示例 11-13 中有个习惯做法值得指出：在 __init__ 方法中，self._balls 保存的是 list (iterable)，而不是 iterable 的引用（即没有直接把 iterable 赋值给 self._balls）。前面说过，14 这样做使得 LotteryBlower 更灵活，因为 iterable 参数可以是任何可迭代的类型。把元素存入列表中还确保能取出元素。就算 iterable 参数始终传入列表，list (iterable) 会创建参数的副本，这依然是好的做法，因为我们要从中删除元素，而客户可能不希望自己提供的列表被修改。15

14 我在 Martelli 写的「水禽和抽象基类」短文之后以此为例说明鸭子类型。

15.4.2 节专门讨论了这种防止混淆别名的问题。

接下来要讲白鹅类型的重要动态特性了：使用 register 方法声明虚拟子类。

11.7.3　Tombola 的虚拟子类

白鹅类型的一个基本特性（也是值得用水禽来命名的原因）：即便不继承，也有办法把一个类注册为抽象基类的虚拟子类。这样做时，我们保证注册的类忠实地实现了抽象基类定义的接口，而 Python 会相信我们，从而不做检查。如果我们说谎了，那么常规的运行时异常会把我们捕获。

注册虚拟子类的方式是在抽象基类上调用 register 方法。这么做之后，注册的类会变成抽象基类的虚拟子类，而且 issubclass 和 isinstance 等函数都能识别，但是注册的类不会从抽象基类中继承任何方法或属性。

虚拟子类不会继承注册的抽象基类，而且任何时候都不会检查它是否符合抽象基类的接口，即便在实例化时也不会检查。为了避免运行时错误，虚拟子类要实现所需的全部方法。

register 方法通常作为普通的函数调用（参见 11.9 节），不过也可以作为装饰器使用。在示例 11-14 中，我们使用装饰器句法实现了 TomboList 类，这是 Tombola 的一个虚拟子类，如图 11-5 所示。

图 11-5：TomboList 的 UML 类图，它是 list 的真实子类和 Tombola 的虚拟子类

TomboList 能像它宣称的那样使用，doctest 能证明这一点，详情参见 11.8 节。

示例 11-14　tombolist.py：TomboList 是 Tombola 的虚拟子类

from random import randrange from tombola import Tombola @Tombola.register # ➊ class TomboList(list): # ➋ def pick(self): if self: # ➌ position = randrange(len(self)) return self.pop(position) # ➍ else: raise LookupError('pop from empty TomboList') load = list.extend # ➎ def loaded(self): return bool(self) # ➏ def inspect(self): return tuple(sorted(self)) # Tombola.register(TomboList) # ➐

❶ 把 Tombolist 注册为 Tombola 的虚拟子类。

❷ Tombolist 扩展 list。

❸ Tombolist 从 list 中继承 __bool__ 方法，列表不为空时返回 True。

❹ pick 调用继承自 list 的 self.pop 方法，传入一个随机的元素索引。

❺ Tombolist.load 与 list.extend 一样。

❻ loaded 方法委托 bool 函数。16

16loaded 方法不能采用 load 方法的那种方式，因为 list 类型没有实现 loaded 方法所需的 __bool__ 方法。而内置的 bool 函数不需要 __bool__ 方法，因为它还可以使用 __len__ 方法。参见 Python 文档中「Built-in Types」一章中的「4.1. Truth Value Testing」。

❼ 如果是 Python 3.3 或之前的版本，不能把 .register 当作类装饰器使用，必须使用标准的调用句法。

注册之后，可以使用 issubclass 和 isinstance 函数判断 TomboList 是不是 Tombola 的子类：

>>> from tombola import Tombola >>> from tombolist import TomboList >>> issubclass(TomboList, Tombola) True >>> t = TomboList(range(100)) >>> isinstance(t, Tombola) True

然而，类的继承关系在一个特殊的类属性中指定 —— __mro__，即方法解析顺序（Method Resolution Order）。这个属性的作用很简单，按顺序列出类及其超类，Python 会按照这个顺序搜索方法。17 查看 TomboList 类的 __mro__ 属性，你会发现它只列出了「真实的」超类，即 list 和 object：

1712.2 节会专门讲解 __mro__ 类属性，现在知道这个简单的解释就行了。

>>> TomboList.__mro__ (<class 'tombolist.TomboList'>, <class 'list'>, <class 'object'>)

Tombolist.__mro__ 中没有 Tombola，因此 Tombolist 没有从 Tombola 中继承任何方法。

我编写了几个类，实现了相同的接口，现在我需要一种编写 doctest 的方式来涵盖不同的实现。下一节说明如何利用常规类和抽象基类的 API 编写 doctest。

11.8　Tombola 子类的测试方法

我编写的 Tombola 示例测试脚本用到两个类属性，用它们内省类的继承关系。

__subclasses__()

这个方法返回类的直接子类列表，不含虚拟子类。

_abc_registry

只有抽象基类有这个数据属性，其值是一个 WeakSet 对象，即抽象类注册的虚拟子类的弱引用。

为了测试 Tombola 的所有子类，我编写的脚本迭代 Tombola.__subclasses__() 和 Tombola._abc_registry 得到的列表，然后把各个类赋值给在 doctest 中使用的 ConcreteTombola。

这个测试脚本成功运行时输出的结果如下：

$ python3 tombola_runner.py BingoCage 24 tests, 0 failed - OK LotteryBlower 24 tests, 0 failed - OK TumblingDrum 24 tests, 0 failed - OK TomboList 24 tests, 0 failed - OK

测试脚本的代码在示例 11-15 中，doctest 在示例 11-16 中。

示例 11-15　tombola_runner.py：Tombola 子类的测试运行程序

import doctest from tombola import Tombola # 要测试的模块 import bingo, lotto, tombolist, drum ➊ TEST_FILE = 'tombola_tests.rst' TEST_MSG = '{0:16} {1.attempted:2} tests, {1.failed:2} failed - {2}' def main (argv): verbose = '-v' in argv real_subclasses = Tombola.__subclasses__() ➋ virtual_subclasses = list (Tombola._abc_registry) ➌ for cls in real_subclasses + virtual_subclasses: ➍ test (cls, verbose) def test (cls, verbose=False): res = doctest.testfile (TEST_FILE, globs={'ConcreteTombola': cls}, ➎ verbose=verbose, optionflags=doctest.REPORT_ONLY_FIRST_FAILURE) tag = 'FAIL' if res.failed else 'OK' print (TEST_MSG.format (cls.__name__, res, tag)) ➏ if __name__ == '__main__': import sys main (sys.argv)

❶ 导入包含 Tombola 真实子类和虚拟子类的模块，用于测试。

❷ __subclasses__() 返回的列表是内存中存在的直接子代。即便源码中用不到想测试的模块，也要将其导入，因为要把那些类载入内存。

❸ 把 _abc_registry（WeakSet 对象）转换成列表，这样方能与 __subclasses__() 的结果拼接起来。

❹ 迭代找到的各个子类，分别传给 test 函数。

❺ 把 cls 参数（要测试的类）绑定到全局命名空间里的 ConcreteTombola 名称上，供 doctest 使用。

❻ 输出测试结果，包含类的名称、尝试运行的测试数量、失败的测试数量，以及 'OK' 或 'FAIL' 标记。

doctest 文件如示例 11-16 所示。

示例 11-16　tombola_tests.rst：Tombola 子类的 doctest

============== Tombola tests ============== Every concrete subclass of Tombola should pass these tests. Create and load instance from iterable:: >>> balls = list(range(3)) >>> globe = ConcreteTombola(balls) >>> globe.loaded() True >>> globe.inspect() (0, 1, 2) Pick and collect balls:: >>> picks = [] >>> picks.append(globe.pick()) >>> picks.append(globe.pick()) >>> picks.append(globe.pick()) Check state and results:: >>> globe.loaded() False >>> sorted(picks) == balls True Reload:: >>> globe.load(balls) >>> globe.loaded() True >>> picks = [globe.pick() for i in balls] >>> globe.loaded() False Check that `LookupError` (or a subclass) is the exception thrown when the device is empty:: >>> globe = ConcreteTombola([]) >>> try: ... globe.pick() ... except LookupError as exc: ... print('OK') OK Load and pick 100 balls to verify that they all come out:: >>> balls = list(range(100)) >>> globe = ConcreteTombola(balls) >>> picks = [] >>> while globe.inspect(): ... picks.append(globe.pick()) >>> len(picks) == len(balls) True >>> set(picks) == set(balls) True Check that the order has changed and is not simply reversed:: >>> picks != balls True >>> picks[::-1] != balls True Note: the previous 2 tests have a *very* small chance of failing even if the implementation is OK. The probability of the 100 balls coming out, by chance, in the order they were inspect is 1/100!, or approximately 1.07e-158. It's much easier to win the Lotto or to become a billionaire working as a programmer. THE END

我们对 Tombola 抽象基类的分析到此结束。下一节说明 Python 如何使用抽象基类的 register 函数。

11.9　Python 使用 register 的方式

示例 11-14 把 Tombola.register 当作类装饰器使用。在 Python 3.3 之前的版本中不能这样使用 register，必须在定义类之后像普通函数那样调用，如示例 11-14 中最后那行注释所述。

虽然现在可以把 register 当作装饰器使用了，但更常见的做法还是把它当作函数使用，用于注册其他地方定义的类。例如，在 collections.abc 模块的源码中，是这样把内置类型 tuple、str、range 和 memoryview 注册为 Sequence 的虚拟子类的：

Sequence.register(tuple) Sequence.register(str) Sequence.register(range) Sequence.register(memoryview)

其他几个内置类型在 _collections_abc.py 文件中注册为抽象基类的虚拟子类。这些类型在导入模块时注册，这样做是可以的，因为必须导入才能使用抽象基类：能访问 MutableMapping 才能编写 isinstance (my_dict, MutableMapping)。

结束本章之前，还要解释一下 Alex Martelli 在「水禽和抽象基类」中施展的魔法。

11.10　鹅的行为有可能像鸭子

Alex 在他写的「水禽和抽象基类」一文中指出，即便不注册，抽象基类也能把一个类识别为虚拟子类。下面是他举的例子，我添加了一些代码，使用 issubclass 做测试：

>>> class Struggle: ... def __len__(self): return 23 ... >>> from collections import abc >>> isinstance(Struggle(), abc.Sized) True >>> issubclass(Struggle, abc.Sized) True

经 issubclass 函数确认（isinstance 函数也会得出相同的结论），Struggle 是 abc.Sized 的子类，这是因为 abc.Sized 实现了一个特殊的类方法，名为 __subclasshook__。参见示例 11-17。

示例 11-17　Sized 类的源码，摘自 Lib/_collections_abc.py（Python 3.4）

class Sized(metaclass=ABCMeta): __slots__ = () @abstractmethod def __len__(self): return 0 @classmethod def __subclasshook__(cls, C): if cls is Sized: if any("__len__" in B.__dict__ for B in C.__mro__): # ➊ return True # ➋ return NotImplemented # ➌

❶ 对 C.__mro__ （即 C 及其超类）中所列的类来说，如果类的 __dict__ 属性中有名为 __len__ 的属性……

❷ …… 返回 True，表明 C 是 Sized 的虚拟子类。

❸ 否则，返回 NotImplemented，让子类检查。

如果你对子类检查的细节感兴趣，可以阅读 Lib/abc.py 文件中 ABCMeta.__subclasscheck__ 方法的源码。提醒：源码中有很多 if 语句和两个递归调用。

__subclasshook__ 在白鹅类型中添加了一些鸭子类型的踪迹。我们可以使用抽象基类定义正式接口，可以始终使用 isinstance 检查，也可以完全使用不相关的类，只要实现特定的方法即可（或者做些事情让 __subclasshook__ 信服）。当然，只有提供 __subclasshook__ 方法的抽象基类才能这么做。

在自己定义的抽象基类中要不要实现 __subclasshook__ 方法呢？可能不需要。我在 Python 源码中只见到 Sized 这一个抽象基类实现了 __subclasshook__ 方法，而 Sized 只声明了一个特殊方法，因此只用检查这么一个特殊方法。鉴于 __len__ 方法的「特殊性」，我们基本可以确定它能做到该做的事。但是对其他特殊方法和基本的抽象基类来说，很难这么肯定。例如，虽然映射实现了 __len__、__getitem__ 和 __iter__，但是不应该把它们视作 Sequence 的子类型，因为不能使用整数偏移值获取元素，也不能保证元素的顺序。当然，OrderedDict 除外，它保留了插入元素的顺序，但是不支持通过偏移获取元素。

在你我自己编写的抽象基类中实现 __subclasshook__ 方法，可靠性很低。我可不相信随便一个实现或继承了 load、pick、inspect 和 loaded 的类（如 Spam）的行为一定像 Tombola。程序员最好让 Spam 继承 Tombola，至少也要注册（Tombola.register (Spam)），从而确保这一点。当然，自己实现的 __subclasshook__ 方法还可以检查方法签名和其他特性，但我觉得不值得这么做。

11.11　本章小结

本章首先介绍了非正式接口（称为协议）的高度动态本性，然后讲解了抽象基类的静态接口声明，最后指出了抽象基类的动态特性：虚拟子类，以及使用 __subclasshook__ 方法动态识别子类。

我们首先回顾了 Python 社区对接口的惯常理解。在 Python 的历史中常常出现接口的身影，但它是非正式的，类似于 Smalltalk 的协议，而且在官方文档中，「foo 协议」「foo 接口」和「foo 类对象」这三种措辞是同一个意思。协议风格的接口与继承完全没有关系，实现同一个协议的各个类是相互独立的。在鸭子类型中，接口就是这样的。

通过示例 11-3，我们发现 Python 对序列协议的支持十分深入。如果一个类实现了 __getitem__ 方法，此外什么也没做，那么 Python 会设法迭代它，而且 in 运算符也随之可以使用。随后，我们继续编写第 1 章中的 FrenchDeck 示例，还动态添加了一个方法，从而让它支持洗牌。这里用到的是猴子补丁，突出了协议的动态本性。我们再一次见识到，部分实现协议也是有用的：添加可变序列协议中的 __setitem__ 方法之后，立即就能使用标准库中的 random.shuffle 函数。了解现有的协议能让我们充分利用 Python 丰富的标准库。

接下来，Alex Martelli 介绍了「白鹅类型」这个术语，18 以此描述一种新的 Python 编程风格。借助「白鹅类型」，可以使用抽象基类明确声明接口，而且类可以子类化抽象基类或使用抽象基类注册（无需在继承关系中确立静态的强链接），宣称它实现了某个接口。

18「白鹅类型」这种说法是 Alex 发明的，这是它第一次出现在书中。

FrenchDeck2 示例清楚地展示了显式继承抽象基类的优缺点。继承 abc.MutableSequence 后，必须实现 insert 和 __delitem__ 方法，而我们并不需要这两个方法。不过，即便是 Python 新手，只要查看 FrenchDeck2 类的源码，就能看出它是可变序列。此外，我们还得到一个额外好处，从 abc.MutableSequence 中继承了 11 个方法（其中五个间接继承自 abc.Sequence），而且拿来即用。

全面介绍图 11-3 中 collections.abc 模块里的各个抽象基类后，我们自己动手从头开始编写了一个抽象基类。PyMOTW.com（Python Module of the Week）网站的创建者 Doug Hellmann 道出了这么做的目的：

定义抽象基类之后，各个子类可以实现通用的 API。如果有人不熟悉应用程序的运作方式，却又想使用插件扩展，就可以利用这一功能……19

19PyMOTW 网站介绍 abc 模块的页面，「Why use Abstract Base Classes?」一节。

定义好 Tombola 抽象基类之后，我们创建了三个具体子类，两个继承 Tombola，另一个注册为虚拟子类 —— 它们都能通过同一个测试组件。

本章结束之前，我们提到了几个内置类型是如何注册到 collections.abc 模块中的抽象基类的。这样，虽然 memoryview 没有继承 abc.Sequence，isinstance (memoryview, abc. Sequence) 的结果也是 True。最后，我们探究了 __subclasshook__ 魔法。这个方法的作用是让抽象基类识别没有注册为子类的类，你可以根据需要做简单的或者复杂的测试 —— 标准库的做法只是检查方法名称。

最后的最后，我要重申 Alex Martelli 的警告：不要自己定义抽象基类，除非你要构建允许用户扩展的框架 —— 然而大多数情况下并非如此。日常使用中，我们与抽象基类的联系应该是创建现有抽象基类的子类，或者使用现有的抽象基类注册。此外，我们可能还会在 isinstance 检查中使用抽象基类，但这比继承或注册更少见。需要自己从头编写新抽象基类的情况少之又少。

我使用 Python 15 年了，除了教学示例以外，我只在 Pingo 项目中编写过一个抽象类，即 Board（https://github.com/garoa/pingo/blob/master/pingo/board.py） 类。支持单板机和控制器的驱动是 Board 的子类，共用相同的接口。就算我把 pingo.Board 打造成抽象类，它也并没有继承 abc.ABC。20 我本打算把 Board 定义为抽象基类，但是 Pingo 项目有更重要的事情要做。

20ython 标准库也有这样做的，有些类虽然是抽象的，但是并没有显式地继承 abc.ABC。

本章适合使用下面这段话结尾：

尽管抽象基类使得类型检查变得更容易了，但不应该在程序中过度使用它。Python 的核心在于它是一门动态语言，它带来了极大的灵活性。如果处处都强制实行类型约束，那么会使代码变得更加复杂，而本不应该如此。我们应该拥抱 Python 的灵活性。21

——David Beazley 和 Brian Jones

《Python Cookbook（第 3 版）中文版》

21《Python Cookbook（第 3 版）中文版》第 281 页。

或者，像本书技术审校 Leonardo Rochael 所写的：「如果觉得自己想创建新的抽象基类，先试着通过常规的鸭子类型来解决问题。」

11.12　延伸阅读

Beazley 与 Jones 的《Python Cookbook（第 3 版）中文版》有一节（8.12）定义了一个抽象基类。这本书在 Python 3.4 之前撰写，因此他们没有使用现在推荐的句法，即通过继承 abc.ABC 声明抽象基类，而是使用 metaclass 关键字。除了这个小细节之外，那个秘笈很好地涵盖了抽象基类的主要功能，而且最后还给出了宝贵的意见，即前一节末尾引用的那段话。

Doug Hellmann 写的《Python 标准库》一书中有一章是关于 abc 模块的。Doug 创建的 PyMOTW（Python Module of the Week）网站中也有那一章。这本书和 PyMOTW 网站都针对 Python 2，因此如果你使用 Python 3 的话，必须做些调整。22 记住，在 Python 3.4 中，唯一推荐使用的抽象基类方法装饰器是 @abstractmethod，其他装饰器已经废弃了。本章小结中引用的关于抽象基类的另一句话出自 Doug 的网站和这本书。

22PyMOTW 网站现在已经是面向 Python 3 了。—— 编者注

使用抽象基类时，经常会遇到多重继承，而且是不可避免的，因为基本的集合抽象基类（Sequence、Mapping 和 Set）都扩展多个抽象基类（如图 11-3 所示）。第 12 章接着讨论这个话题，那是重要的一章。

「PEP 3119—Introducing Abstract Base Classes」讲解了抽象基类的基本原理，「PEP 3141—A Type Hierarchy for Numbers」提出了 numbers 模块中的抽象基类。

Bill Venners 对 Guido van Rossum 的采访「Contracts in Python: A Conversation with Guido van Rossum, Part IV」讨论了动态类型的优缺点。

zope.interface 包提供了一种声明接口的方式：检查对象是否实现了接口，注册提供方，然后查询指定接口的提供方。一开始，这个包是 Zope 3 核心的一部分，不过它可以在 Zope 外部使用，而且已经有人这么做了。这个包为大型 Python 项目（如 Twisted、Pyramid 和 Plone）的组件式架构提供了灵活的基础。Lennart Regebro 写的「A Python Component Architecture」一文对 zope.interface 包做了介绍，Baiju M 还写了一本相关的书 ——A Comprehensive Guide to Zope Component Architecture。

杂谈

类型提示

2014 年，Python 世界最大的新闻应该是 Guido van Rossum 同意实现可选的静态类型检查，这与检查程序 Mypy 的做法类似，即使用函数注解实现。这一消息出自 8 月 15 日发表在 Python-ideas 邮件列表中的一个话题，题为「Optional static typing —the crossroads」。一个月后，「PEP 484—Type Hints」草案发布了，发起人是 Guido。

这个功能的目的是让程序员在函数定义中使用注解声明参数和返回值的类型，但这是可选的。关键在于「可选」二字。仅当你想得到注解的好处和限制时才需要添加注解，而且可以在一些函数中添加，在另一些函数中不添加。

从表面上看，这与 Microsoft 对 TypeScript（JavaScript 的超集）采取的方式类似，不过 TypeScript 做得更进一步：TypeScript 添加了新的语言结构（如模块、类、显式接口，等等），允许声明变量类型，而且最终编译成常规的 JavaScript。目前来看，Python 的可选静态类型没这么大的雄心。

为了理解这个提案的动机，不能忽略 Guido 在 2014 年 8 月 15 日发送的那封重要邮件中的这段话：

我还得做个假设：这个功能主要供 lint 程序、IDE 和文档生成工具使用。这些工具有个共同点：即使类型检查失败了，程序仍能运行。此外，程序中添加的类型不能降低性能（也不能提升性能 :-)）。

因此，这一举动并不像乍一看那么激进。「PEP 484—Type Hints」提到了「PEP 482—Literature Overview for Type Hints」，后者概述了第三方 Python 工具和其他语言实现类型提示的方式。

不管激进不激进，类型提示都将到来：支持 PEP 484 的 typing 模块好像已经纳入 Python 3.5。23 根据这个提案的表述和实现方式，可以肯定的是，现有代码不会因为缺少类型提示（或相关的附加物）而无法运行。

最后，PEP 484 明确指出：

还要强调一点，Python 依旧是一门动态类型语言，作者从未打算强制要求使用类型提示，甚至不会把它变成约定。

Python 是弱类型语言吗

由于缺少统一的术语，讨论语言类型方面的话题时有时会让人不明其意。有些人（例如扩展阅读中提到的 Bill Venners 对 Guido 的访谈）说 Python 是弱类型语言，把 Python 与 JavaScript 和 PHP 归为一类。讨论类型时，最好考虑两条不同的坐标线。

强类型和弱类型

如果一门语言很少隐式转换类型，说明它是强类型语言；如果经常这么做，说明它是弱类型语言。Java、C++ 和 Python 是强类型语言。PHP、JavaScript 和 Perl 是弱类型语言。

静态类型和动态类型

在编译时检查类型的语言是静态类型语言，在运行时检查类型的语言是动态类型语言。静态类型需要声明类型（有些现代语言使用类型推导避免部分类型声明）。Fortran 和 Lisp 是最早的两门语言，现在仍在使用，它们分别是静态类型语言和动态类型语言。

强类型能及早发现缺陷。

下面几例体现了弱类型的不足：24

// 这些是 JavaScript 代码（在 Node.js v0.10.33 中做了测试） '' == '0' //false 0 == '' //true 0 == '0' //true '' < 0 //false '' < '0' //true

因为 Python 不会自动在字符串和数字之间强制转换，所以在 Python 3 中，上述 == 表达式的结果都是 False（保留了 == 的意思），而 < 比较会抛出 TypeError。

静态类型使得一些工具（编译器和 IDE）便于分析代码、找出错误和提供其他服务（优化、重构，等等）。动态类型便于代码重用，代码行数更少，而且能让接口自然成为协议而不提早实行。

综上，Python 是动态强类型语言。「PEP 484—Type Hints」无法改变这一点，但是 API 作者能够添加可选的类型注解，执行某种静态类型检查。

猴子补丁

猴子补丁的名声不太好。如果滥用，会导致系统难以理解和维护。补丁通常与目标紧密耦合，因此很脆弱。另一个问题是，打了猴子补丁的两个库可能相互牵绊，因为第二个库可能撤销了第一个库的补丁。

不过猴子补丁也有它的作用，例如可以在运行时让类实现协议。适配器设计模式通过实现全新的类解决这种问题。

为 Python 打猴子补丁不难，但是有些局限。与 Ruby 和 JavaScript 不同，Python 不允许为内置类型打猴子补丁。其实我觉得这是优点，因为这样可以确保 str 对象的方法始终是那些。这一局限能减少外部库打的补丁有冲突的概率。

Java、Go 和 Ruby 的接口

从 C++ 2.0（1989 年发布）起，这门语言开始使用抽象类指定接口。Java 的设计者选择不支持类的多重继承，这排除了使用抽象类作为接口规范的可能性，因为一个类通常会实现多个接口。但是，Java 的设计者添加了 interface 这个语言结构，而且允许一个类实现多个接口 —— 这是一种多重继承。以更为明确的方式定义接口是 Java 的一大贡献。在 Java 8 中，接口可以提供方法实现，这叫默认方法。有了这个功能，Java 的接口与 C++ 和 Python 中的抽象类更像了。

Go 语言采用的方式完全不同。首先，Go 不支持继承。我们可以定义接口，但是无需（其实也不能）明确地指出某个类型实现了某个接口。编译器能自动判断。因此，考虑到接口在编译时检查，但是真正重要的是实现了什么类型，Go 语言可以说是具有「静态鸭子类型」。

与 Python 相比，对 Go 来说就好像每个抽象基类都实现了 __subclasshook__ 方法，它会检查函数的名称和签名，而我们自己从不需要继承或注册抽象基类。如果想让 Python 更像 Go，可以对所有函数参数做类型检查。Python 提供了部分基础设施（参见 5.9 节）。Guido 说过，他不介意使用注解做类型检查，至少在辅助工具中可以这么做。详情参阅第 5 章的「杂谈」。

Ruby 程序员是鸭子类型的坚定拥护者，而且 Ruby 没有声明接口或抽象类的正式方式，只能像 Python 2.6 之前的版本那样做，即在方法的定义体中抛出 NotImplementedError，以此表明方法是抽象的，用户必须在子类中实现。

不过，2014 年 9 月，Ruby 之父松本行弘在日本举办的 Ruby Kaigi（最重要的 Ruby 大会之一，每年举办）中做了一场主题演讲，他透露说，Ruby 未来可能会支持静态类型。目前我还没看到相关报道，但是根据 Godfrey Chan 的博客文章「Ruby Kaigi 2014: Day 2」，松本行弘关注的似乎是函数注解。他甚至还提到了 Python 的函数注解。

在没有抽象基类向类型系统添加结构，以及不丧失灵活性的情况下，我不知道函数注解有什么用。因此，Ruby 未来可能还会支持正式接口。

我相信，Python 的抽象基类在 register 函数和 __subclasshook__ 方法的协助下能把正式接口带入这门语言，而且不失去动态类型的优势。

或许，鹅正在赶超鸭子。

接口中的隐喻和习惯用法

隐喻能打破壁垒，让人更易于理解。使用「栈」和「队列」描述基本的数据类型就有这样的功效：这两个词清楚地道出了添加或删除元素的方式。另一方面，Alan Cooper 在《交互设计精髓（第 4 版）》中写道：

严格奉行隐喻设计毫无必要，却把界面死死地与物理世界的运行机制捆绑在一起。

他说的是用户界面，但对 API 同样适用。不过 Cooper 同意，当「真正合适的」隐喻「正中下怀」时，可以使用隐喻（他用的词是「正中下怀」，因为合适的隐喻可遇不可求）。我觉得本章用宾果机作比喻是合适的，我相信自己。

我读过不少 UI 设计方面的书，《交互设计精髓》是最好的。我从 Cooper 的书中学到的最宝贵的知识是，不把隐喻当作设计范式，而代之以「习惯用法的界面」。前面说过，Cooper 说的不是 API，但是我越深入思考他的观点，越觉得可以将之运用到 Python 中。Python 语言的基本协议就是 Cooper 所说的「习惯用法」。知道「序列」是什么之后，可以把这些知识应用到不同的场合。这正是本书的主要目的：着重讲解这门语言的基本惯用法，让你的代码简洁、高效且可读，把你打造成熟练的 Python 程序员。

23 现在，typing 模块已经纳入 Python 3.5。—— 编者注

24 改编自 JavaScript: The Good Parts（Douglas Crockford 著）附录 B 第 109 页给出的示例。

第 12 章　继承的优缺点

（我们）推出继承的初衷是让新手顺利使用只有专家才能设计出来的框架。1

——Alan Kay

「The Early History of Smalltalk」

