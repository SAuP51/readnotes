第 20 章　属性描述符

学会描述符之后，不仅有更多的工具集可用，还会对 Python 的运作方式有更深入的理解，并由衷赞叹 Python 设计的优雅。1

——Raymond Hettinger

Python 核心开发者和专家

1 摘自 Raymond Hettinger 写的「Descriptor HowTo Guide」。

描述符是对多个属性运用相同存取逻辑的一种方式。例如，Django ORM 和 SQL Alchemy 等 ORM 中的字段类型是描述符，把数据库记录中字段里的数据与 Python 对象的属性对应起来。

描述符是实现了特定协议的类，这个协议包括 __get__、__set__ 和 __delete__ 方法。property 类实现了完整的描述符协议。通常，可以只实现部分协议。其实，我们在真实的代码中见到的大多数描述符只实现了 __get__ 和 __set__ 方法，还有很多只实现了其中的一个。

描述符是 Python 的独有特征，不仅在应用层中使用，在语言的基础设施中也有用到。除了特性之外，使用描述符的 Python 功能还有方法及 classmethod 和 staticmethod 装饰器。理解描述符是精通 Python 的关键。本章的话题就是描述符。

20.1　描述符示例：验证属性

如 19.4 节所示，特性工厂函数借助函数式编程模式避免重复编写读值方法和设值方法。特性工厂函数是高阶函数，在闭包中存储 storage_name 等设置，由参数决定创建哪些存取函数，再使用存取函数构建一个特性实例。解决这种问题的面向对象方式是描述符类。

这里继续 19.4 节的 LineItem 系列示例，把 quantity 特性工厂函数重构成 Quantity 描述符类。

20.1.1　LineItem 类第 3 版：一个简单的描述符

实现了 __get__、__set__ 或 __delete__ 方法的类是描述符。描述符的用法是，创建一个实例，作为另一个类的类属性。

我们将定义一个 Quantity 描述符，LineItem 类会用到两个 Quantity 实例：一个用于管理 weight 属性，另一个用于管理 price 属性。示意图有助于理解，如图 20-1 所示。

图 20-1：LineItem 类的 UML 示意图，用到了名为 Quantity 的描述符类。UML 示意图中带下划线的属性是类属性。注意，weight 和 price 是依附在 LineItem 类上的 Quantity 类的实例，不过 LineItem 实例也有自己的 weight 和 price 属性，存储着相应的值

注意，在图 20-1 中，「weight」这个词出现了两次，因为其实有两个不同的属性都叫 weight：一个是 LineItem 的类属性，另一个是各个 LineItem 对象的实例属性。price 也是如此。

从现在开始，我会使用下述定义。

描述符类

实现描述符协议的类。在图 20-1 中，是 Quantity 类。

托管类

把描述符实例声明为类属性的类 —— 图 20-1 中的 LineItem 类。

描述符实例

描述符类的各个实例，声明为托管类的类属性。在图 20-1 中，各个描述符实例使用箭头和带下划线的名称表示（在 UML 中，下划线表示类属性）。与黑色菱形接触的 LineItem 类包含描述符实例。

托管实例

托管类的实例。在这个示例中，LineItem 实例是托管实例（没在类图中展示）。

储存属性

托管实例中存储自身托管属性的属性。在图 20-1 中，LineItem 实例的 weight 和 price 属性是储存属性。这种属性与描述符实例不同，描述符属性都是类属性。

托管属性

托管类中由描述符实例处理的公开属性，值存储在储存属性中。也就是说，描述符实例和储存属性为托管属性建立了基础。

Quantity 实例是 LineItem 类的类属性，这一点一定要理解。图 20-2 中的机器和小怪兽强调了这个关键点。

图 20-2：带有 MGN（Mills & Gizmos Notation，机器和小怪兽图示法）注解的 UML 类图：类是机器，用于生产小怪兽（实例）。Quantity 机器生产了两个圆头的小怪兽，依附到 LineItem 机器上，即 weight 和 price。LineItem 机器生产方头的小怪兽，有自己的 weight 和 price 属性，存储着相应的值

机器和小怪兽图示法介绍

我以前经常使用 UML 解说描述符，但是后来发现 UML 无法很好地展现类与实例之间的关系，例如托管类与描述符实例之间的关系。2 所以，我自己发明了一门「语言」—— 机器和小怪兽图示法（Mills & Gizmos Notation，MGN），使用它注解 UML 示意图。

MGN 的目的是明确区分类和实例。如图 20-3 所示。在 MGN 中，类画成「机器」，这是一种复杂的设备，用于生产小怪兽。类（机器）都是有操控杆和刻度盘的设备。小怪兽是实例，外观更简洁。小怪兽与生产它的机器具有相同的颜色。

图 20-3：MGN 简图表示，LineItem 类生产了三个实例，Quantity 类生产了两个实例。其中一个 Quantity 实例从一个 LineItem 实例中获取存储的值

在这个示例中，我把 LineItem 实例画成表格中的行，各有三个单元格，表示三个属性（description、weight 和 price）。Quantity 实例是描述符，因此有个放大镜，用于获取值（__get__），以及一个手抓，用于设置值（__set__）。讲到元类时，你会感谢我画了这些涂鸦。

2 在 UML 类图中，类和实例都画成方框。虽然视觉上有区别，但是因为类图中很少出现实例，所以开发者可能认不出。

先把涂鸦放在一边，来看代码：示例 20-1 是 Quantity 描述符类和新版 LineItem 类，用到两个 Quantity 实例。

示例 20-1　bulkfood_v3.py：使用 Quantity 描述符管理 LineItem 的属性

class Quantity: ➊ def __init__(self, storage_name): self.storage_name = storage_name ➋ def __set__(self, instance, value): ➌ if value > 0: instance.__dict__[self.storage_name] = value ➍ else: raise ValueError('value must be > 0') class LineItem: weight = Quantity('weight') ➎ price = Quantity('price') ➏ def __init__(self, description, weight, price): ➐ self.description = description self.weight = weight self.price = price def subtotal(self): return self.weight * self.price

❶ 描述符基于协议实现，无需创建子类。

❷ Quantity 实例有个 storage_name 属性，这是托管实例中存储值的属性的名称。

❸ 尝试为托管属性赋值时，会调用 __set__ 方法。这里，self 是描述符实例（即 LineItem.weight 或 LineItem.price），instance 是托管实例（LineItem 实例），value 是要设定的值。

❹ 这里，必须直接处理托管实例的 __dict__ 属性；如果使用内置的 setattr 函数，会再次触发 __set__ 方法，导致无限递归。

❺ 第一个描述符实例绑定给 weight 属性。

❻ 第二个描述符实例绑定给 price 属性。

❼ 类定义体中余下的代码与 bulkfood_v1.py 脚本（见示例 19-15）中的代码一样简洁。

在示例 20-1 中，各个托管属性的名称与储存属性一样，而且读值方法不需要特殊的逻辑，所以 Quantity 类不需要定义 __get__ 方法。

示例 20-1 中的代码会像预期那样运作，禁止以 0 美元销售松露：3

3 一磅白松露价值几千美元。留个练习给有进取心的读者：不准以 0.01 美元的价格销售松露。我认识一个人，他以 18 美元买到了价值 1800 美元的统计学百科全书，因为那个网店（不是亚马逊）有漏洞。

>>> truffle = LineItem('White truffle', 100, 0) Traceback (most recent call last): ... ValueError: value must be > 0

编写 __set__ 方法时，要记住 self 和 instance 参数的意思：self 是描述符实例，instance 是托管实例。管理实例属性的描述符应该把值存储在托管实例中。因此，Python 才为描述符中的那个方法提供了 instance 参数。

你可能想把各个托管属性的值直接存在描述符实例中，但是这种做法是错误的。也就是说，在 __set__ 方法中，应该像下面这样写：

instance.__dict__[self.storage_name] = value

而不能试图使用下面这种错误的写法：

self.__dict__[self.storage_name] = value

为了理解错误的原因，可以想想 __set__ 方法前两个参数（self 和 instance）的意思。这里，self 是描述符实例，它其实是托管类的类属性。同一时刻，内存中可能有几千个 LineItem 实例，不过只会有两个描述符实例：LineItem.weight 和 LineItem.price。因此，存储在描述符实例中的数据，其实会变成 LineItem 类的类属性，从而由全部 LineItem 实例共享。

示例 20-1 有个缺点，在托管类的定义体中实例化描述符时要重复输入属性的名称。如果 LineItem 类能像下面这样声明就好了：

class LineItem: weight = Quantity () price = Quantity () # 余下的方法与之前一样

可问题是，正如第 8 章说过的，赋值语句右手边的表达式先执行，而此时变量还不存在。Quantity () 表达式计算的结果是创建描述符实例，而此时 Quantity 类中的代码无法猜出要把描述符绑定给哪个变量（例如 weight 或 price）。

因此，示例 20-1 必须明确指明各个 Quantity 实例的名称。这样不仅麻烦，还很危险：如果程序员直接复制粘贴代码而忘了编辑名称，比如写成 price = Quantity ('weight')，那么程序的行为会大错特错，设置 price 的值时会覆盖 weight 的值。

下一节会介绍一个不太优雅但是可行的方案，解决这个重复输入名称的问题。更好的解决方案是使用类装饰器或元类，等到第 21 章再介绍。

20.1.2　LineItem 类第 4 版：自动获取储存属性的名称

为了避免在描述符声明语句中重复输入属性名，我们将为每个 Quantity 实例的 storage_name 属性生成一个独一无二的字符串。图 20-4 是更新后的 Quantity 和 LineItem 类的 UML 类图。

图 20-4：示例 20-2 的 UML 类图。现在，Quantity 类既有 __get__ 方法，也有 __set__ 方法；LineItem 实例中储存属性的名称是生成的，_Quantity#0 和 _Quantity#1

为了生成 storage_name，我们以 '_Quantity#' 为前缀，然后在后面拼接一个整数： Quantity.__counter 类属性的当前值，每次把一个新的 Quantity 描述符实例依附到类上，都会递增这个值。在前缀中使用井号能避免 storage_name 与用户使用点号创建的属性冲突，因为 nutmeg._Quantity#0 是无效的 Python 句法。但是，内置的 getattr 和 setattr 函数可以使用这种「无效的」标识符获取和设置属性，此外也可以直接处理实例属性 __dict__。示例 20-2 是新的实现。

示例 20-2　bulkfood_v4.py：每个 Quantity 描述符都有独一无二的 storage_name

class Quantity: __counter = 0 ➊ def __init__(self): cls = self.__class__ ➋ prefix = cls.__name__ index = cls.__counter self.storage_name = '_{}#{}'.format(prefix, index) ➌ cls.__counter += 1 ➍ def __get__(self, instance, owner): ➎ return getattr(instance, self.storage_name) ➏ def __set__(self, instance, value): if value > 0: setattr(instance, self.storage_name, value) ➐ else: raise ValueError('value must be > 0') class LineItem: weight = Quantity() ➑ price = Quantity() def __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price def subtotal(self): return self.weight * self.price

❶ __counter 是 Quantity 类的类属性，统计 Quantity 实例的数量。

❷ cls 是 Quantity 类的引用。

❸ 每个描述符实例的 storage_name 属性都是独一无二的，因为其值由描述符类的名称和 __counter 属性的当前值构成（例如，_Quantity#0）。

❹ 递增 __counter 属性的值。

❺ 我们要实现 __get__ 方法，因为托管属性的名称与 storage_name 不同。稍后会说明 owner 参数。

❻ 使用内置的 getattr 函数从 instance 中获取储存属性的值。

❼ 使用内置的 setattr 函数把值存储在 instance 中。

❽ 现在，不用把托管属性的名称传给 Quantity 构造方法。这是这一版的目标。

这里可以使用内置的高阶函数 getattr 和 setattr 存取值，无需使用 instance.__dict__，因为托管属性和储存属性的名称不同，所以把储存属性传给 getattr 函数不会触发描述符，不会像示例 20-1 那样出现无限递归。

测试 bulkfood_v4.py 脚本之后你会发现，weight 和 price 描述符能按预期使用，而且储存属性也能直接读取 —— 这对调试有帮助：

>>> from bulkfood_v4 import LineItem >>> coconuts = LineItem('Brazilian coconut', 20, 17.95) >>> coconuts.weight, coconuts.price (20, 17.95) >>> getattr(coconuts, '_Quantity#0'), getattr(coconuts, '_Quantity#1') (20, 17.95)

如果想使用 Python 矫正名称的约定方式（例如 _LineItem__quantity0），要知道托管类（即 LineItem）的名称，可是，解释器要先运行类的定义体才能构建类，因此创建描述符实例时得不到那个信息。不过，对这个示例来说，为了防止不小心被子类覆盖，不用包含托管类的名称，因为每次实例化新的描述符，描述符类的 __counter 属性都会递增，从而确保每个托管类的每个储存属性的名称都是独一无二的。

注意，__get__ 方法有三个参数：self、instance 和 owner。owner 参数是托管类（如 LineItem）的引用，通过描述符从托管类中获取属性时用得到。如果使用 LineItem.weight 从类中获取托管属性（以 weight 为例），描述符的 __get__ 方法接收到的 instance 参数值是 None。因此，下述控制台会话才会抛出 AttributeError 异常：

>>> from bulkfood_v4 import LineItem >>> LineItem.weight Traceback (most recent call last): ... File ".../descriptors/bulkfood_v4.py", line 54, in __get__ return getattr(instance, self.storage_name) AttributeError: 'NoneType' object has no attribute '_Quantity#0'

抛出 AttributeError 异常是实现 __get__ 方法的方式之一，如果选择这么做，应该修改错误消息，去掉令人困惑的 NoneType 和 _Quantity#0，这是实现细节。把错误消息改成 "'LineItem' class has no such attribute" 更好。最好能给出缺少的属性名，但是在这个示例中，描述符不知道托管属性的名称，因此目前只能做到这样。

此外，为了给用户提供内省和其他元编程技术支持，通过类访问托管属性时，最好让 __get__ 方法返回描述符实例。示例 20-3 对示例 20-2 做了小幅改动，为 Quantity.__get__ 方法添加了一些逻辑。

示例 20-3　bulkfood_v4b.py（只列出部分代码）：通过托管类调用时，__get__ 方法返回描述符的引用

class Quantity: __counter = 0 def __init__(self): cls = self.__class__ prefix = cls.__name__ index = cls.__counter self.storage_name = '_{}#{}'.format(prefix, index) cls.__counter += 1 def __get__(self, instance, owner): if instance is None: return self ➊ else: return getattr(instance, self.storage_name) ➋ def __set__(self, instance, value): if value > 0: setattr(instance, self.storage_name, value) else: raise ValueError('value must be > 0')

➊ 如果不是通过实例调用，返回描述符自身。

➋ 否则，像之前一样，返回托管属性的值。

测试示例 20-3，会看到如下结果：

>>> from bulkfood_v4b import LineItem >>> LineItem.price <bulkfood_v4b.Quantity object at 0x100721be0> >>> br_nuts = LineItem('Brazil nuts', 10, 34.95) >>> br_nuts.price 34.95

看着示例 20-2，你可能觉得就为了管理几个属性而编写这么多代码不值得，但是要知道，描述符逻辑现在被抽象到单独的代码单元（Quantity 类）中了。通常，我们不会在使用描述符的模块中定义描述符，而是在一个单独的实用工具模块中定义，以便在整个应用中使用 —— 如果开发的是框架，甚至会在多个应用中使用。

了解这一点之后就可推知，示例 20-4 是描述符的常规用法。

示例 20-4　bulkfood_v4c.py：整洁的 LineItem 类；Quantity 描述符类现在位于导入的 model_v4c 模块中

import model_v4c as model ➊ class LineItem: weight = model.Quantity() ➋ price = model.Quantity() def __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price def subtotal(self): return self.weight * self.price

❶ 导入 model_v4c 模块，指定一个更友好的名称。

❷ 使用 model.Quantity 描述符。

Django 用户会发现，示例 20-4 非常像模型定义。这不是巧合：Django 模型的字段就是描述符。

就目前的实现来说，Quantity 描述符能出色地完成任务。它唯一的缺点是，储存属性的名称是生成的（如 _Quantity#0），导致用户难以调试。但这是不得已而为之，如果想自动把储存属性的名称设成与托管属性的名称类似，需要用到类装饰器或元类，而这两个话题到第 21 章才会讨论。

描述符在类中定义，因此可以利用继承重用部分代码来创建新描述符。下一节会这么做。

特性工厂函数与描述符类比较

特性工厂函数若想实现示例 20-2 中增强的描述符类并不难，只需在示例 19-24 的基础上添加几行代码。__counter 变量的实现方式是个难点，不过我们可以把它定义成工厂函数对象的属性，以便在多次调用之间持续存在，如示例 20-5 所示。

示例 20-5　bulkfood_v4prop.py：使用特性工厂函数实现与示例 20-2 中的描述符类相同的功能

def quantity(): ➊ try: quantity.counter += 1 ➋ except AttributeError: quantity.counter = 0 ➌ 　 storage_name = '_{}:{}'.format('quantity', quantity.counter) ➍ 　 def qty_getter(instance): ➎ return getattr(instance, storage_name) def qty_setter(instance, value): if value > 0: setattr(instance, storage_name, value) else: raise ValueError('value must be > 0') 　 return property(qty_getter, qty_setter)

❶ 没有 storage_name 参数。

❷ 不能依靠类属性在多次调用之间共享 counter，因此把它定义为 quantity 函数自身的属性。

❸ 如果 quantity.counter 属性未定义，把值设为 0。

❹ 我们也没有实例变量，因此创建一个局部变量 storage_name，借助闭包保持它的值，供后面的 qty_getter 和 qty_setter 函数使用。

❺ 余下的代码与示例 19-24 一样，不过这里可以使用内置的 getattr 和 setattr 函数，而不用处理 instance.__dict__ 属性。

那么，你喜欢哪个？示例 20-2 还是示例 20-5 ？

我喜欢描述符类那种方式，主要有下列两个原因。

描述符类可以使用子类扩展；若想重用工厂函数中的代码，除了复制粘贴，很难有其他方法。

与示例 20-5 中使用函数属性和闭包保持状态相比，在类属性和实例属性中保持状态更易于理解。

此外，解说示例 20-5 时，我没有画机器和小怪兽的动力。特性工厂函数的代码不依赖奇怪的对象关系，而描述符的方法中有名为 self 和 instance 的参数，表明里面涉及奇怪的对象关系。

总之，从某种程度上来讲，特性工厂函数模式较简单，可是描述符类方式更易扩展，而且应用也更广泛。

20.1.3　LineItem 类第 5 版：一种新型描述符

我们虚构的有机食物网店遇到一个问题：不知怎么回事儿，有个商品的描述信息为空，导致无法下订单。为了避免出现这个问题，我们要再创建一个描述符，NonBlank。在设计 NonBlank 的过程中，我们发现，它与 Quantity 描述符很像，只是验证逻辑不同。

回想 Quantity 的功能，我们注意到它做了两件不同的事：管理托管实例中的储存属性，以及验证用于设置那两个属性的值。由此可知，我们可以重构，并创建两个基类。

AutoStorage

自动管理储存属性的描述符类。

Validated

扩展 AutoStorage 类的抽象子类，覆盖 __set__ 方法，调用必须由子类实现的 validate 方法。

我们稍后会重写 Quantity 类，并实现 NonBlank，让它继承 Validated 类，只编写 validate 方法。类之间的关系见图 20-5。

图 20-5：几个描述符类的层次结构。AutoStorage 基类负责自动存储属性；Validated 类做验证，把职责委托给抽象方法 validate；Quantity 和 NonBlank 是 Validated 的具体子类

Validated、Quantity 和 NonBlank 三个类之间的关系体现了模板方法设计模式。具体而言，Validated.__set__ 方法正是 Gamma 等四人所描述的模板方法的例证：

一个模板方法用一些抽象的操作定义一个算法，而子类将重定义这些操作以提供具体的行为。4

4《设计模式：可复用面向对象软件的基础》第 215 页。

这里，抽象的操作是验证。示例 20-6 列出图 20-5 中各个类的实现。

示例 20-6　model_v5.py：重构后的描述符类 5

5 因为 20.5 节有文档字符串的截图，为了保持一致，所以这里的文档字符串不翻译。—— 译者注

import abc class AutoStorage: ➊ __counter = 0 def __init__(self): cls = self.__class__ prefix = cls.__name__ index = cls.__counter self.storage_name = '_{}#{}'.format(prefix, index) cls.__counter += 1 def __get__(self, instance, owner): if instance is None: return self else: return getattr(instance, self.storage_name) def __set__(self, instance, value): setattr(instance, self.storage_name, value) ➋ class Validated(abc.ABC, AutoStorage): ➌ def __set__(self, instance, value): value = self.validate(instance, value) ➍ super().__set__(instance, value) ➎ @abc.abstractmethod def validate(self, instance, value): ➏ """return validated value or raise ValueError""" class Quantity(Validated): ➐ """a number greater than zero""" def validate(self, instance, value): if value <= 0: raise ValueError('value must be > 0') return value class NonBlank(Validated): """a string with at least one non-space character""" def validate(self, instance, value): value = value.strip() if len(value) == 0: raise ValueError('value cannot be empty or blank') return value ➑

❶ AutoStorage 类提供了之前 Quantity 描述符的大部分功能……

❷ …… 验证除外。

❸ Validated 是抽象类，不过也继承自 AutoStorage 类。

❹ __set__ 方法把验证操作委托给 validate 方法……

❺ …… 然后把返回的 value 传给超类的 __set__ 方法，存储值。

❻ 在这个类中，validate 是抽象方法。

❼ Quantity 和 NonBlank 都继承自 Validated 类。

❽ 要求具体的 validate 方法返回验证后的值，借机可以清理、转换或规范化接收的数据。这里，我们把 value 首尾的空白去掉，然后将其返回。

model_v5.py 脚本的用户不需要知道全部细节。用户只需知道，他们可以使用 Quantity 和 NonBlank 自动验证实例属性。参见示例 20-7 中的最新版 LineItem 类。

示例 20-7　bulkfood_v5.py：使用 Quantity 和 NonBlank 描述符的 LineItem 类

import model_v5 as model ➊ class LineItem: description = model.NonBlank() ➋ weight = model.Quantity() price = model.Quantity() def __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price def subtotal(self): return self.weight * self.price

❶ 导入 model_v5 模块，指定一个更友好的名称。

❷ 使用 model.NonBlank 描述符。其余的代码没变。

本章所举的几个 LineItem 示例演示了描述符的典型用途 —— 管理数据属性。这种描述符也叫覆盖型描述符，因为描述符的 __set__ 方法使用托管实例中的同名属性覆盖（即插手接管）了要设置的属性。不过，也有非覆盖型描述符。下一节会详述这两种描述符之间的区别。

20.2　覆盖型与非覆盖型描述符对比

如前所述，Python 存取属性的方式特别不对等。通过实例读取属性时，通常返回的是实例中定义的属性；但是，如果实例中没有指定的属性，那么会获取类属性。而为实例中的属性赋值时，通常会在实例中创建属性，根本不影响类。

这种不对等的处理方式对描述符也有影响。其实，根据是否定义 __set__ 方法，描述符可分为两大类。若想观察这两类描述符的行为差异，则需要使用几个类。我们将使用示例 20-8 中的代码作为接下来几节的试验台。

在示例 20-8 中，每个 __get__ 和 __set__ 方法都调用了 print_args 函数，使调用方式易于阅读。没必要深入理解 print_args 函数及辅助函数 cls_name 和 display，因此不要花心思研究它们。

示例 20-8　descriptorkinds.py：几个简单的类，用于研究描述符的覆盖行为

### 辅助函数，仅用于显示 ### def cls_name (obj_or_cls): cls = type (obj_or_cls) if cls is type: cls = obj_or_cls return cls.__name__.split ('.')[-1] def display (obj): cls = type (obj) if cls is type: return '<class {}>'.format (obj.__name__) elif cls in [type (None), int]: return repr (obj) else: return '<{} object>'.format (cls_name (obj)) def print_args (name, *args): pseudo_args = ', '.join (display (x) for x in args) print ('-> {}.__{}__({})'.format (cls_name (args [0]), name, pseudo_args)) ### 对这个示例重要的类 ### class Overriding: ➊ """也称数据描述符或强制描述符""" def __get__(self, instance, owner): print_args ('get', self, instance, owner) ➋ def __set__(self, instance, value): print_args ('set', self, instance, value) class OverridingNoGet: ➌ """没有``__get__``方法的覆盖型描述符""" def __set__(self, instance, value): print_args ('set', self, instance, value) class NonOverriding: ➍ """也称非数据描述符或遮盖型描述符""" def __get__(self, instance, owner): print_args ('get', self, instance, owner) class Managed: ➎ over = Overriding () over_no_get = OverridingNoGet () non_over = NonOverriding () def spam (self): ➏ print ('-> Managed.spam ({})'.format (display (self)))

❶ 有 __get__ 和 __set__ 方法的典型覆盖型描述符。

❷ 在这个示例中，各个描述符的每个方法都调用了 print_args 函数。

❸ 没有 __get__ 方法的覆盖型描述符。

❹ 没有 __set__ 方法，所以这是非覆盖型描述符。

❺ 托管类，使用各个描述符类的一个实例。

❻ spam 方法放在这里是为了对比，因为方法也是描述符。

在接下来的几节中，我们要分析对 Managed 类及其实例做属性读写时的行为，还会讨论所定义的各个描述符。

20.2.1　覆盖型描述符

实现 __set__ 方法的描述符属于覆盖型描述符，因为虽然描述符是类属性，但是实现 __set__ 方法的话，会覆盖对实例属性的赋值操作。示例 20-2 就是这样实现的。特性也是覆盖型描述符：如果没提供设值函数，property 类中的 __set__ 方法会抛出 AttributeError 异常，指明那个属性是只读的。我们可以使用示例 20-8 中的代码测试覆盖型描述符的行为，如示例 20-9 所示。

示例 20-9　覆盖型描述符的行为，其中 obj.over 是 Overriding 类（见示例 20-8）的实例

>>> obj = Managed() ➊ >>> obj.over ➋ -> Overriding.__get__(<Overriding object>, <Managed object>, <class Managed>) >>> Managed.over ➌ -> Overriding.__get__(<Overriding object>, None, <class Managed>) >>> obj.over = 7 ➍ -> Overriding.__set__(<Overriding object>, <Managed object>, 7) >>> obj.over ➎ -> Overriding.__get__(<Overriding object>, <Managed object>, <class Managed>) >>> obj.__dict__['over'] = 8 ➏ >>> vars(obj) ➐ {'over': 8} >>> obj.over ➑ -> Overriding.__get__(<Overriding object>, <Managed object>, <class Managed>)

❶ 创建供测试使用的 Managed 对象。

❷ obj.over 触发描述符的 __get__ 方法，第二个参数的值是托管实例 obj。

❸ Managed.over 触发描述符的 __get__ 方法，第二个参数（instance）的值是 None。

❹ 为 obj.over 赋值，触发描述符的 __set__ 方法，最后一个参数的值是 7。

❺ 读取 obj.over，仍会触发描述符的 __get__ 方法。

❻ 跳过描述符，直接通过 obj.__dict__ 属性设值。

❼ 确认值在 obj.__dict__ 属性中，在 over 键名下。

❽ 然而，即使是名为 over 的实例属性，Managed.over 描述符仍会覆盖读取 obj.over 这个操作。

20.2.2　没有 __get__ 方法的覆盖型描述符

通常，覆盖型描述符既会实现 __set__ 方法，也会实现 __get__ 方法，不过也可以只实现 __set__ 方法，如示例 20-1 所示。此时，只有写操作由描述符处理。通过实例读取描述符会返回描述符对象本身，因为没有处理读操作的 __get__ 方法。如果直接通过实例的 __dict__ 属性创建同名实例属性，以后再设置那个属性时，仍会由 __set__ 方法插手接管，但是读取那个属性的话，就会直接从实例中返回新赋予的值，而不会返回描述符对象。也就是说，实例属性会遮盖描述符，不过只有读操作是如此。参见示例 20-10。

示例 20-10　没有 __get__ 方法的覆盖型描述符，其中 obj.over_no_get 是 OverridingNoGet 类（见示例 20-8）的实例

>>> obj.over_no_get ➊ <__main__.OverridingNoGet object at 0x665bcc> >>> Managed.over_no_get ➋ <__main__.OverridingNoGet object at 0x665bcc> >>> obj.over_no_get = 7 ➌ -> OverridingNoGet.__set__(<OverridingNoGet object>, <Managed object>, 7) >>> obj.over_no_get ➍ <__main__.OverridingNoGet object at 0x665bcc> >>> obj.__dict__['over_no_get'] = 9 ➎ >>> obj.over_no_get ➏ 9 >>> obj.over_no_get = 7 ➐ -> OverridingNoGet.__set__(<OverridingNoGet object>, <Managed object>, 7) >>> obj.over_no_get ➑ 9

❶ 这个覆盖型描述符没有 __get__ 方法，因此，obj.over_no_get 从类中获取描述符实例。

❷ 直接从托管类中读取描述符实例也是如此。

❸ 为 obj.over_no_get 赋值会触发描述符的 __set__ 方法。

❹ 因为 __set__ 方法没有修改属性，所以在此读取 obj.over_no_get 获取的仍是托管类中的描述符实例。

❺ 通过实例的 __dict__ 属性设置名为 over_no_get 的实例属性。

❻ 现在，over_no_get 实例属性会遮盖描述符，但是只有读操作是如此。

❼ 为 obj.over_no_get 赋值，仍然经过描述符的 __set__ 方法处理。

❽ 但是读取时，只要有同名的实例属性，描述符就会被遮盖。

20.2.3　非覆盖型描述符

没有实现 __set__ 方法的描述符是非覆盖型描述符。如果设置了同名的实例属性，描述符会被遮盖，致使描述符无法处理那个实例的那个属性。方法是以非覆盖型描述符实现的。示例 20-11 展示了对一个非覆盖型描述符的操作。

示例 20-11　非覆盖型描述符的行为，其中 obj.non_over 是 NonOverriding 类（见示例 20-8）的实例

>>> obj = Managed() >>> obj.non_over ➊ -> NonOverriding.__get__(<NonOverriding object>, <Managed object>, <class Managed>) >>> obj.non_over = 7 ➋ >>> obj.non_over ➌ 7 >>> Managed.non_over ➍ -> NonOverriding.__get__(<NonOverriding object>, None, <class Managed>) >>> del obj.non_over ➎ >>> obj.non_over ➏ -> NonOverriding.__get__(<NonOverriding object>, <Managed object>, <class Managed>)

❶ obj.non_over 触发描述符的 __get__ 方法，第二个参数的值是 obj。

❷ Managed.non_over 是非覆盖型描述符，因此没有干涉赋值操作的 __set__ 方法。

❸ 现在，obj 有个名为 non_over 的实例属性，把 Managed 类的同名描述符属性遮盖掉。

❹ Managed.non_over 描述符依然存在，会通过类截获这次访问。

❺ 如果把 non_over 实例属性删除了……

❻ 那么，读取 obj.non_over 时，会触发类中描述符的 __get__ 方法；但要注意，第二个参数的值是托管实例。

Python 贡献者和作者讨论这些概念时会使用不同的术语。覆盖型描述符也叫数据描述符或强制描述符。非覆盖型描述符也叫非数据描述符或遮盖型描述符。

在上述几个示例中，我们为几个与描述符同名的实例属性赋了值，结果依描述符中是否有 __set__ 方法而有所不同。

依附在类上的描述符无法控制为类属性赋值的操作。其实，这意味着为类属性赋值能覆盖描述符属性，正如下一节所述的。

20.2.4　在类中覆盖描述符

不管描述符是不是覆盖型，为类属性赋值都能覆盖描述符。这是一种猴子补丁技术，不过在示例 20-12 中，我们把描述符替换成了整数，这其实会导致依赖描述符的类不能正确地执行操作。

示例 20-12　通过类可以覆盖任何描述符

>>> obj = Managed() ➊ >>> Managed.over = 1 ➋ >>> Managed.over_no_get = 2 >>> Managed.non_over = 3 >>> obj.over, obj.over_no_get, obj.non_over ➌ (1, 2, 3)

❶ 为后面的测试新建一个实例。

❷ 覆盖类中的描述符属性。

❸ 描述符真的不见了。

示例 20-12 揭示了读写属性的另一种不对等：读类属性的操作可以由依附在托管类上定义有 __get__ 方法的描述符处理，但是写类属性的操作不会由依附在托管类上定义有 __set__ 方法的描述符处理。

若想控制设置类属性的操作，要把描述符依附在类的类上，即依附在元类上。默认情况下，对用户定义的类来说，其元类是 type，而我们不能为 type 添加属性。不过在第 21 章，我们会自己创建元类。

下面我们调转话题，分析 Python 是如何使用描述符实现方法的。

20.3　方法是描述符

在类中定义的函数属于绑定方法（bound method），因为用户定义的函数都有 __get__ 方法，所以依附到类上时，就相当于描述符。示例 20-13 演示了从示例 20-8 里定义的 Managed 类中读取 spam 方法。

示例 20-13　方法是非覆盖型描述符

>>> obj = Managed() >>> obj.spam ➊ <bound method Managed.spam of <descriptorkinds.Managed object at 0x74c80c>> >>> Managed.spam ➋ <function Managed.spam at 0x734734> >>> obj.spam = 7 ➌ >>> obj.spam 7

❶ obj.spam 获取的是绑定方法对象。

❷ 但是 Managed.spam 获取的是函数。

❸ 如果为 obj.spam 赋值，会遮盖类属性，导致无法通过 obj 实例访问 spam 方法。

函数没有实现 __set__ 方法，因此是非覆盖型描述符，如示例 20-13 中的最后一行所示。

从示例 20-13 中还可以看出一个重要信息：obj.spam 和 Managed.spam 获取的是不同的对象。与描述符一样，通过托管类访问时，函数的 __get__ 方法会返回自身的引用。但是，通过实例访问时，函数的 __get__ 方法返回的是绑定方法对象：一种可调用的对象，里面包装着函数，并把托管实例（例如 obj）绑定给函数的第一个参数（即 self），这与 functools.partial 函数的行为一致（参见 5.10.2 节）。

为了深入理解这种机制，请看示例 20-14。

示例 20-14　method_is_descriptor.py：Text 类，继承自 UserString 类

import collections class Text(collections.UserString): def __repr__(self): return 'Text({!r})'.format(self.data) def reverse(self): return self[::-1]

下面来分析 Text.reverse 方法，如示例 20-15 所示。

示例 20-15　测试一个方法

>>> word = Text('forward') >>> word ➊ Text('forward') >>> word.reverse() ➋ Text('drawrof') >>> Text.reverse(Text('backward')) ➌ Text('drawkcab') >>> type(Text.reverse), type(word.reverse) ➍ (<class 'function'>, <class 'method'>) >>> list(map(Text.reverse, ['repaid', (10, 20, 30), Text('stressed')])) ➎ ['diaper', (30, 20, 10), Text('desserts')] >>> Text.reverse.__get__(word) ➏ <bound method Text.reverse of Text('forward')> >>> Text.reverse.__get__(None, Text) ➐ <function Text.reverse at 0x101244e18> >>> word.reverse ➑ <bound method Text.reverse of Text('forward')> >>> word.reverse.__self__ ➒ Text('forward') >>> word.reverse.__func__ is Text.reverse ➓ True

❶ Text 实例的 repr 方法返回一个类似 Text 构造方法调用的字符串，可用于创建相同的实例。

❷ reverse 方法返回反向拼写的单词。

❸ 在类上调用方法相当于调用函数。

❹ 注意类型是不同的，一个是 function，一个是 method。

❺ Text.reverse 相当于函数，甚至可以处理 Text 实例之外的其他对象。

❻ 函数都是非覆盖型描述符。在函数上调用 __get__ 方法时传入实例，得到的是绑定到那个实例上的方法。

❼ 调用函数的 __get__ 方法时，如果 instance 参数的值是 None，那么得到的是函数本身。

❽ word.reverse 表达式其实会调用 Text.reverse.__get__(word)，返回对应的绑定方法。

❾ 绑定方法对象有个 __self__ 属性，其值是调用这个方法的实例引用。

❿ 绑定方法的 __func__ 属性是依附在托管类上那个原始函数的引用。

绑定方法对象还有个 __call__ 方法，用于处理真正的调用过程。这个方法会调用 __func__ 属性引用的原始函数，把函数的第一个参数设为绑定方法的 __self__ 属性。这就是形参 self 的隐式绑定方式。

函数会变成绑定方法，这是 Python 语言底层使用描述符的最好例证。

深入了解描述符和方法的运作方式之后，下面讨论用法方面的一些实用建议。

20.4　描述符用法建议

下面根据刚刚论述的描述符特征给出一些实用的结论。

使用特性以保持简单

内置的 property 类创建的其实是覆盖型描述符，__set__ 方法和 __get__ 方法都实现了，即便不定义设值方法也是如此。特性的 __set__ 方法默认抛出 AttributeError: can't set attribute，因此创建只读属性最简单的方式是使用特性，这能避免下一条所述的问题。

只读描述符必须有 __set__ 方法

如果使用描述符类实现只读属性，要记住，__get__ 和 __set__ 两个方法必须都定义，否则，实例的同名属性会遮盖描述符。只读属性的 __set__ 方法只需抛出 AttributeError 异常，并提供合适的错误消息。6

6Python 为此类异常提供的错误消息不一致。如果试图修改 complex 的 c.real 属性，那么得到的错误消息是 AttributeError: read-only attribute；但是，如果试图修改 c.conjugat（e complex 对象的方法），那么得到的错误消息是 AttributeError: 'complex' object attribute 'conjugate' is read-only。

用于验证的描述符可以只有 __set__ 方法

对仅用于验证的描述符来说，__set__ 方法应该检查 value 参数获得的值，如果有效，使用描述符实例的名称为键，直接在实例的 __dict__ 属性中设置。这样，从实例中读取同名属性的速度很快，因为不用经过 __get__ 方法处理。参见示例 20-1 中的代码。

仅有 __get__ 方法的描述符可以实现高效缓存

如果只编写了 __get__ 方法，那么创建的是非覆盖型描述符。这种描述符可用于执行某些耗费资源的计算，然后为实例设置同名属性，缓存结果。同名实例属性会遮盖描述符，因此后续访问会直接从实例的 __dict__ 属性中获取值，而不会再触发描述符的 __get__ 方法。

非特殊的方法可以被实例属性遮盖

由于函数和方法只实现了 __get__ 方法，它们不会处理同名实例属性的赋值操作。因此，像 my_obj.the_method = 7 这样简单赋值之后，后续通过该实例访问 the_method 得到的是数字 7—— 但是不影响类或其他实例。然而，特殊方法不受这个问题的影响。解释器只会在类中寻找特殊的方法，也就是说，repr (x) 执行的其实是 x.__class__.__repr__(x)，因此 x 的 __repr__ 属性对 repr (x) 方法调用没有影响。出于同样的原因，实例的 __getattr__ 属性不会破坏常规的属性访问规则。

实例的非特殊方法可以被轻松地覆盖，这听起来不可靠且容易出错，可是在我使用 Python 的 15 年中从未受此困扰。然而，如果要创建大量动态属性，属性名称从不受自己控制的数据中获取（像本章前面那样），那么你应该知道这种行为；或许你还可以实现某种机制，过滤或转义动态属性的名称，以维持数据的健全性。

示例 19-6 中的 FrozenJSON 类不会出现实例属性遮盖方法的问题，因为那个类只有几个特殊方法和一个 build 类方法。只要通过类访问，类方法就是安全的，在示例 19-6 中我就是这么调用 FrozenJSON.build 方法的 —— 在示例 19-7 中替换成 __new__ 方法了。Record 类（见示例 19-9 和示例 19-11）及其子类也是安全的，因为只用到了特殊的方法、类方法、静态方法和特性。特性是数据描述符，因此不能被实例属性覆盖。

讨论特性时讲了两个功能，这里讨论的描述符还未涉及，结束本章之前我们来讲讲：文档和对删除托管属性的处理。

20.5　描述符的文档字符串和覆盖删除操作

描述符类的文档字符串用于注解托管类中的各个描述符实例。图 20-6 中的截图是 LineItem 类（见示例 20-7）及 Quantity 和 NonBlank 描述符（见示例 20-6）的帮助界面。

提供的信息有点不足。对 LineItem 类来说，如果能说明 weight 必须以千克为单位就好了。这对特性来说是小菜一碟，因为各个特性只处理特定的托管属性。可是对描述符来说，weight 和 price 使用的都是 Quantity 描述符类。7

7 定制各个描述符实例的帮助文本特别难。有一种方法是为各个描述符实例动态构建包装类。

讨论特性时还讲了一个细节，而这里讨论的描述符没有涉及，那就是对删除托管属性的处理。在描述符类中，实现常规的 __get__ 和（或）__set__ 方法之外，可以实现 __delete__ 方法，或者只实现 __delete__ 方法做到这一点。时间充足的读者可以编写一个没有实际作用的描述符类实现 __delete__ 方法，就当作练习。

图 20-6：在 Python 控制台中执行 help (LineItem.weight) 和 help (LineItem) 命令时的截图

20.6　本章小结

本章的第一个示例接续第 19 章的 LineItem 系列示例。在示例 20-1 中，我们把特性替换成了描述符。我们知道，描述符类的实例能用作托管类的属性。为了讨论这个机制，我们引入了几个特殊的术语，例如托管实例和储存属性。

在 20.1.2 节，我们把声明 Quantity 描述符所需的 storage_name 参数去掉了，那个参数多余且容易出错，因为实例化描述符时指定的名称始终与赋值语句左边的属性名一样。我们采用的方法是，结合描述符类的名称和类中的计数器，生成独一无二的 storage_name（例如 '_Quantity#1'）。

接下来，本章对比了描述符类与使用函数式编程方式构建的特性工厂函数，分析了二者的代码量和优缺点。有时后者更合适也更简单，但是前者更灵活，而且是标准方案。20.1.3 节利用了描述符类的关键优势：通过子类共享代码，构建具有部分相同功能的专用描述符。

然后，我们分析了有或没有 __set__ 方法时，描述符的行为有什么不同，了解了覆盖型描述符和非覆盖型描述符之间的重要差异。通过详细的测试，我们揭示了描述符何时接管，以及何时被遮盖、被跳过或被覆盖。

本章随后分析了非覆盖型描述符的一种具体类型：方法。通过控制台中的测试可知，通过实例访问依附在类上的函数时，经由描述符协议的处理，就会变成方法。

最后，我们对描述符的用法给出了一些建议，还简要说明了如何删除描述符和添加文档。

这一章我们遇到了几个只有类元编程能解决的问题，这些问题留到第 21 章解决。

20.7　延伸阅读

除了语言参考手册中必读的「Data model」一章，Raymond Hettinger 写的「Descriptor HowTo Guide」也值得一读 —— 这是 Python 官方文档 HowTo 合集中的一篇。

对 Python 对象模型相关的话题来说，Alex Martelli 写的《Python 技术手册（第 2 版）》一书虽然有点过时，但仍然提供了权威且客观的论述：本章讨论的关键机制在 Python 2.2 中引入，远在那本书涵盖的 2.5 版之前。Martelli 还做了一次题为「Python's Object Model」的演讲，深入探讨了特性和描述符 [幻灯片，视频]，强烈推荐观看。

至于针对 Python 3 的实例，David Beazley 与 Brian K. Jones 的《Python Cookbook（第 3 版）中文版》一书中有很多说明描述符的诀窍，推荐阅读的有「6.12 读取嵌套型和大小可变的二进制结构」「8.10 让属性具有惰性求值的能力」「8.13 实现一种数据模型或类型系统」和「9.9 把装饰器定义成类」。最后一个诀窍解决了函数装饰器、描述符和方法之间相互作用的深层次问题，说明了如何使用有 __call__ 方法的类实现函数装饰器；如果既想装饰方法又想装饰函数，还要实现 __get__ 方法。

杂谈

self 的问题

「变糟更好」（「Worse is Better」）是 Richard P. Gabriel 在「The Rise of Worse is Better」一文中提出的设计思想。这个思想的第一要义是「简单」；对此，Gabriel 说道：

设计方式必须简单，对实现和接口来说都应如此。简单的实现比简单的接口更重要。简单是设计过程中最重要的考虑因素。

我认为，Python 要求明确把方法的第一个参数声明为 self 是「变糟更好」思想的体现。这样，实现是简单了（甚至也优雅了），但却牺牲了用户接口：方法的签名 —— 例如 def zfill (self, width):—— 在外观上与 pobox.zfill (8) 调用不匹配。

这种做法（以及使用 self 这个标识符）由 Modula-3 语言创造，但是与 Python 有差异：在 Modula-3 中，接口的声明与实现是分开的，而且在接口声明中会省略 self 参数，因此对用户来说，接口声明中的方法显示的参数数量与真正接受的参数数量完全一致。

在这方面，Python 有一项改进 —— 错误消息。对于用户定义的单参数（除 self 之外）方法来说，如果用户调用 obj.meth ()，Python 2.7 会抛出异常，显示 TypeError: meth () takes exactly 2 arguments (1 given)；不过在 Python 3.4 中，错误消息没那么难以理解了，解决了参数数量问题，还指出了缺失的参数：meth () missing 1 required positional argument: 'x'。

除了要明确把 self 作为参数之外，限制必须使用 self 访问实例属性也备受批评。8 我自己并不介意输入 self 限定符，这样便于把局部变量和属性区分开。我介意的是在 def 语句中使用 self。但是我已经习惯了。

如果讨厌 Python 要求显式使用 self，可以想想 JavaScript 中隐式的 this 那变幻莫测的语义，这样感觉就会好多了。像这样使用 self 有一些合理之处，Guido 在他的博客 The History of Python 中写了一篇文章，题为「Adding Support for User-defined Classes」，说明了这些原因。

8 例如，A. M. Kuchling 发表的著名文章「Python Warts」（存档）。Kuchling 自己并不讨厌 self 限定符，但是他提到了这一点 —— 可能是为了呼应 comp.lang.python 邮件列表中的观点。

第 21 章　类元编程

（元类）是深奥的知识，99% 的用户都无需关注。如果你想知道是否需要使用元类，我告诉你，不需要（真正需要使用元类的人确信他们需要，无需解释原因）。1

——Tim Peters

Timsort 算法的发明者，活跃的 Python 贡献者

1 摘自 comp.lang.python 邮件列表中对「Acrimony in c.l.p.」话题的回复。前言中引述的那句话也是出自这篇发布于 2002 年 12 月 23 日的消息。TimBot 在那天获得了灵感。

类元编程是指在运行时创建或定制类的技艺。在 Python 中，类是一等对象，因此任何时候都可以使用函数新建类，而无需使用 class 关键字。类装饰器也是函数，不过能够审查、修改，甚至把被装饰的类替换成其他类。最后，元类是类元编程最高级的工具：使用元类可以创建具有某种特质的全新类种，例如我们见过的抽象基类。

元类功能强大，但是难以掌握。类装饰器能使用更简单的方式解决很多问题。其实，Python 2.6 引入类装饰器之后，元类很难使用真实的代码说明，因此我不会像前面的章节那样再举引导示例。

本章还会谈及导入时和运行时的区别 —— 这是有效使用 Python 元编程的重要基础。

这是一个令人兴奋的话题，很容易让人忘乎所以。因此，进入本章的正文之前，我必须告诫你：

除非开发框架，否则不要编写元类 —— 然而，为了寻找乐趣，或者练习相关的概念，可以这么做。

首先，本章探讨如何在运行时创建类。

21.1　类工厂函数

本书多次提到标准库中的一个类工厂函数 ——collections.namedtuple。我们把一个类名和几个属性名传给这个函数，它会创建一个 tuple 的子类，其中的元素通过名称获取，还为调试提供了友好的字符串表示形式（__repr__）。

有时，我觉得应该有类似的工厂函数，用于创建可变对象。假设我在编写一个宠物店应用程序，我想把狗的数据当作简单的记录处理。编写下面的样板代码让人厌烦：

class Dog: def __init__(self, name, weight, owner): self.name = name self.weight = weight self.owner = owner

无趣…… 各个字段名称出现了三次。写了这么多样板代码，甚至字符串表示形式都不友好：

>>> rex = Dog('Rex', 30, 'Bob') >>> rex <__main__.Dog object at 0x2865bac>

参考 collections.namedtuple，下面我们创建一个 record_factory 函数，即时创建简单的类（如 Dog）。这个函数的用法如示例 21-1。

示例 21-1　测试 record_factory 函数，一个简单的类工厂函数

>>> Dog = record_factory('Dog', 'name weight owner') ➊ >>> rex = Dog('Rex', 30, 'Bob') >>> rex ➋ Dog(name='Rex', weight=30, owner='Bob') >>> name, weight, _ = rex ➌ >>> name, weight ('Rex', 30) >>> "{2}'s dog weighs {1}kg".format(*rex) ➍ "Bob's dog weighs 30kg" >>> rex.weight = 32 ➎ >>> rex Dog(name='Rex', weight=32, owner='Bob') >>> Dog.__mro__ ➏ (<class 'factories.Dog'>, <class 'object'>)

❶ 这个工厂函数的签名与 namedtuple 类似：先写类名，后面跟着写在一个字符串里的多个属性名，使用空格或逗号分开。

❷ 友好的字符串表示形式。

❸ 实例是可迭代的对象，因此赋值时可以便利地拆包。

❹ 传给 format 等函数时也可以拆包。

❺ 记录实例是可变的对象。

❻ 新建的类继承自 object，与我们的工厂函数没有关系。

record_factory 函数的代码在示例 21-2 中。2

2 感谢我的朋友 J.S. Bueno 的建议。

示例 21-2　record_factory.py：一个简单的类工厂函数

def record_factory (cls_name, field_names): try: field_names = field_names.replace (',', ' ').split () ➊ except AttributeError: # 不能调用.replace 或.split 方法 pass # 假定 field_names 本就是标识符组成的序列 field_names = tuple (field_names) ➋ def __init__(self, *args, **kwargs): ➌ attrs = dict (zip (self.__slots__, args)) attrs.update (kwargs) for name, value in attrs.items (): setattr (self, name, value) def __iter__(self): ➍ for name in self.__slots__: yield getattr (self, name) def __repr__(self): ➎ values = ', '.join ('{}={!r}'.format (*i) for i in zip (self.__slots__, self)) return '{}({})'.format (self.__class__.__name__, values) cls_attrs = dict (__slots__ = field_names, ➏ __init__ = __init__, __iter__ = __iter__, __repr__ = __repr__) return type (cls_name, (object,), cls_attrs) ➐

❶ 这里体现了鸭子类型：尝试在逗号或空格处拆分 field_names；如果失败，那么假定 field_names 本就是可迭代的对象，一个元素对应一个属性名。

❷ 使用属性名构建元组，这将成为新建类的 __slots__ 属性；此外，这么做还设定了拆包和字符串表示形式中各字段的顺序。

❸ 这个函数将成为新建类的 __init__ 方法。参数有位置参数和（或）关键字参数。

❹ 实现 __iter__ 函数，把类的实例变成可迭代的对象；按照 __slots__ 设定的顺序产出字段值。

❺ 迭代 __slots__ 和 self，生成友好的字符串表示形式。

❻ 组建类属性字典。

❼ 调用 type 构造方法，构建新类，然后将其返回。

通常，我们把 type 视作函数，因为我们像函数那样使用它，例如，调用 type (my_object) 获取对象所属的类 —— 作用与 my_object.__class__ 相同。然而，type 是一个类。当成类使用时，传入三个参数可以新建一个类：

MyClass = type('MyClass', (MySuperClass, MyMixin), {'x': 42, 'x2': lambda self: self.x * 2})

type 的三个参数分别是 name、bases 和 dict。最后一个参数是一个映射，指定新类的属性名和值。上述代码的作用与下述代码相同：

class MyClass(MySuperClass, MyMixin): x = 42 def x2(self): return self.x * 2

让人觉得新奇的是，type 的实例是类，例如这里的 MyClass 类或示例 21-1 中的 Dog 类。

总之，示例 21-2 中 record_factory 函数的最后一行会构建一个类，类的名称是 cls_name 参数的值，唯一的直接超类是 object，有 __slots__、__init__、__iter__ 和 __repr__ 四个类属性，其中后三个是实例方法。

我们本可以把 __slots__ 类属性的名称改成其他值，不过要是那样的话，就要实现 __setattr__ 方法，为属性赋值时验证属性的名称，因为对于记录这样的类，我们希望属性始终是固定的那几个，而且顺序相同。然而 9.8 节说过，__slots__ 属性的主要特色是节省内存，能处理数百万个实例，不过也有一些缺点。

把三个参数传给 type 是动态创建类的常用方式。如果查看 collections.namedtuple 函数的源码，你会发现另一种方式：先声明一个 _class_template 变量，其值是字符串形式的源码模板；然后在 namedtuple 函数中调用 _class_template.format (...) 方法，填充模板里的空白；最后，使用内置的 exec 函数计算得到的源码字符串。

在 Python 中做元编程时，最好不用 exec 和 eval 函数。如果接收的字符串（或片段）来自不可信的源，那么这两个函数会带来严重的安全风险。Python 提供了充足的内省工具，大多数时候都不需要使用 exec 和 eval 函数。然而，Python 核心开发者实现 namedtuple 函数时选择了使用 exec 函数，这样做是为了让生成的类代码能通过 ._source 属性获取。

record_factory 函数创建的类，其实例有个局限 —— 不能序列化，即不能使用 pickle 模块里的 dump/load 函数处理。这个示例是为了说明如何使用 type 类满足简单的需求，因此不会解决这个问题。如果想了解完整的方案，请分析 collections.nameduple 函数的源码，搜索「pickling」这个词。

21.2　定制描述符的类装饰器

20.1.3 节中的 LineItem 示例还有个问题没有解决：储存属性的名称不具有描述性，即属性（如 weight）的值存储在名为 _Quantity#0 的实例属性中，这样的名称有点不便于调试。我们可以使用下述代码从示例 20-7 定义的描述符中获取储存属性的名称：

>>> LineItem.weight.storage_name '_Quantity#0'

可是，如果储存属性的名称中包含托管属性的名称更好，如下所示：

>>> LineItem.weight.storage_name '_Quantity#weight'

20.1.2 节说过，我们不能使用描述性的储存属性名称，因为实例化描述符时无法得知托管属性（即绑定到描述符上的类属性，例如前述示例中的 weight）的名称。可是，一旦组建好整个类，而且把描述符绑定到类属性上之后，我们就可以审查类，并为描述符设置合理的储存属性名称。LineItem 类的 __new__ 方法可以做到这一点，因此，在 __init__ 方法中使用描述符时，储存属性已经设置了正确的名称。为了解决这个问题而使用 __new__ 方法纯属白费力气：每次新建 LineItem 实例时都会运行 __new__ 方法中的逻辑，可是，一旦 LineItem 类构建好了，描述符与托管属性之间的绑定就不会变了。因此，我们要在创建类时设置储存属性的名称。使用类装饰器或元类可以做到这一点。我们首先使用较简单的方式。

类装饰器与函数装饰器非常类似，是参数为类对象的函数，返回原来的类或修改后的类。

在示例 21-3 中，解释器会计算 LineItem 类，把返回的类对象传给 model.entity 函数。Python 会把 LineItem 这个全局名称绑定给 model.entity 函数返回的对象。在这个示例中，model.entity 函数会返回原先的 LineItem 类，但是会修改各个描述符实例的 storage_name 属性。

示例 21-3　bulkfood_v6.py：使用 Quantity 和 NonBlank 描述符的 LineItem 类

import model_v6 as model @model.entity ➊ class LineItem: description = model.NonBlank() weight = model.Quantity() price = model.Quantity() def __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price def subtotal(self): return self.weight * self.price

➊ 这个类唯一的变化是添加了装饰器。

示例 21-4 是那个装饰器的实现。这里只列出了 model_v6.py 脚本底部添加的新代码，其余的代码与 model_v5.py 脚本（见示例 20-6）一样。

示例 21-4　model_v6.py：一个类装饰器

def entity(cls): ➊ for key, attr in cls.__dict__.items(): ➋ if isinstance(attr, Validated): ➌ type_name = type(attr).__name__ attr.storage_name = '_{}#{}'.format(type_name, key) ➍ return cls ➎

❶ 装饰器的参数是一个类。

❷ 迭代存储类属性的字典。

❸ 如果属性是 Validated 描述符的实例……

❹ …… 使用描述符类的名称和托管属性的名称命名 storage_name（例如 _NonBlank#description）。

❺ 返回修改后的类。

bulkfood_v6.py 脚本中的 doctest 证明，改动是成功的。例如，示例 21-5 展示了一个 LineItem 实例中的储存属性名称。

示例 21-5　bulkfood_v6.py：描述符中新 storage_name 属性的 doctest

>>> raisins = LineItem('Golden raisins', 10, 6.95) >>> dir(raisins)[:3] ['_NonBlank#description', '_Quantity#price', '_Quantity#weight'] >>> LineItem.description.storage_name '_NonBlank#description' >>> raisins.description 'Golden raisins' >>> getattr(raisins, '_NonBlank#description') 'Golden raisins'

可以看出，这并不复杂。类装饰器能以较简单的方式做到以前需要使用元类去做的事情 —— 创建类时定制类。

类装饰器有个重大缺点：只对直接依附的类有效。这意味着，被装饰的类的子类可能继承也可能不继承装饰器所做的改动，具体情况视改动的方式而定。接下来的几节会探讨这个问题，并给出解决方案。

21.3　导入时和运行时比较

为了正确地做元编程，你必须知道 Python 解释器什么时候计算各个代码块。Python 程序员会区分「导入时」和「运行时」，不过这两个术语没有严格的定义，而且二者之间存在着灰色地带。在导入时，解释器会从上到下一次性解析完 .py 模块的源码，然后生成用于执行的字节码。如果句法有错误，就在此时报告。如果本地的 __pycache__ 文件夹中有最新的 .pyc 文件，解释器会跳过上述步骤，因为已经有运行所需的字节码了。

编译肯定是导入时的活动，不过那个时期还会做些其他事，因为 Python 中的语句几乎都是可执行的，也就是说语句可能会运行用户代码，修改用户程序的状态。尤其是 import 语句，它不只是声明 3，在进程中首次导入模块时，还会运行所导入模块中的全部顶层代码 —— 以后导入相同的模块则使用缓存，只做名称绑定。那些顶层代码可以做任何事，包括通常在「运行时」做的事，例如连接数据库。4 因此，「导入时」与「运行时」之间的界线是模糊的：import 语句可以触发任何「运行时」行为。

3Java 中的 import 语句则只是声明，用于告知编译器需要特定的包。

4 我不是说导入模块时应该连接数据库，只是指出来可以做到。

在前一段中我写道，导入时会「运行全部顶层代码」，但是「顶层代码」会经过一些加工。导入模块时，解释器会执行顶层的 def 语句，可是这么做有什么作用呢？解释器会编译函数的定义体（首次导入模块时），把函数对象绑定到对应的全局名称上，但是显然解释器不会执行函数的定义体。通常这意味着解释器在导入时定义顶层函数，但是仅当在运行时调用函数时才会执行函数的定义体。

对类来说，情况就不同了：在导入时，解释器会执行每个类的定义体，甚至会执行嵌套类的定义体。执行类定义体的结果是，定义了类的属性和方法，并构建了类对象。从这个意义上理解，类的定义体属于「顶层代码」，因为它在导入时运行。

上述说明模糊又抽象，下面通过练习理解各个时期所做的事情。

理解计算时间的练习

假设在 evaltime.py 脚本中导入了 evalsupport.py 模块。这两个模块调用了几次 print 函数，打印 <[N]> 格式的标记，其中 N 是数字。下述两个练习的目标是，确定各个调用在何时执行。

据我的学生说，这两个练习有助于更好地理解 Python 计算源码的方式。在查看场景 1 的解答之前，请一定要拿出纸和笔，花点时间作答。

那两个模块的代码在示例 21-6 和示例 21-7 中。先别运行代码，拿出纸和笔，按顺序写出下述两个场景输出的标记。

场景 1

在 Python 控制台中以交互的方式导入 evaltime.py 模块：

>> import evaltime

场景 2

在命令行中运行 evaltime.py 模块：

$ python3 evaltime.py

示例 21-6　evaltime.py：按顺序写出输出的序号标记 <[N]>

from evalsupport import deco_alpha print('<[1]> evaltime module start') class ClassOne(): print('<[2]> ClassOne body') def __init__(self): print('<[3]> ClassOne.__init__') def __del__(self): print('<[4]> ClassOne.__del__') def method_x(self): print('<[5]> ClassOne.method_x') class ClassTwo(object): print('<[6]> ClassTwo body') @deco_alpha class ClassThree(): print('<[7]> ClassThree body') def method_y(self): print('<[8]> ClassThree.method_y') class ClassFour(ClassThree): print('<[9]> ClassFour body') def method_y(self): print('<[10]> ClassFour.method_y') if __name__ == '__main__': print('<[11]> ClassOne tests', 30 * '.') one = ClassOne() one.method_x() print('<[12]> ClassThree tests', 30 * '.') three = ClassThree() three.method_y() print('<[13]> ClassFour tests', 30 * '.') four = ClassFour() four.method_y() print('<[14]> evaltime module end')

示例 21-7　evalsupport.py：evaltime.py 导入的模块

print('<[100]> evalsupport module start') def deco_alpha(cls): print('<[200]> deco_alpha') def inner_1(self): print('<[300]> deco_alpha:inner_1') cls.method_y = inner_1 return cls class MetaAleph(type): print('<[400]> MetaAleph body') def __init__(cls, name, bases, dic): print('<[500]> MetaAleph.__init__') def inner_2(self): print('<[600]> MetaAleph.__init__:inner_2') cls.method_z = inner_2 print('<[700]> evalsupport module end')

场景 1 的解答

在 Python 控制台中导入 evaltime.py 模块后得到的输出如示例 21-8 所示。

示例 21-8　场景 1：在 Python 控制台中导入 evaltime 模块

>>> import evaltime <[100]> evalsupport module start ➊ <[400]> MetaAleph body ➋ <[700]> evalsupport module end <[1]> evaltime module start <[2]> ClassOne body ➌ <[6]> ClassTwo body ➍ <[7]> ClassThree body <[200]> deco_alpha ➎ <[9]> ClassFour body <[14]> evaltime module end ➏

❶ evalsupport 模块中的所有顶层代码在导入模块时运行；解释器会编译 deco_alpha 函数，但是不会执行定义体。

❷ MetaAleph 类的定义体运行了。

❸ 每个类的定义体都执行了……

❹ …… 包括嵌套的类。

❺ 先计算被装饰的类 ClassThree 的定义体，然后运行装饰器函数。

❻ 在这个场景中，evaltime 模块是导入的，因此不会运行 if __name__ == '__main__': 块。

对于场景 1，要注意以下几点。

(1) 这个场景由简单的 import evaltime 语句触发。

(2) 解释器会执行所导入模块及其依赖（evalsupport）中的每个类定义体。

(3) 解释器先计算类的定义体，然后调用依附在类上的装饰器函数，这是合理的行为，因为必须先构建类对象，装饰器才有类对象可处理。

(4) 在这个场景中，只运行了一个用户定义的函数或方法 ——deco_alpha 装饰器。

下面来看场景 2。

场景 2 的解答

运行 python3 evaltime.py 命令后得到的输出如示例 21-9 所示。

示例 21-9　场景 2：在 shell 中运行 evaltime.py

$ python3 evaltime.py <[100]> evalsupport module start <[400]> MetaAleph body <[700]> evalsupport module end <[1]> evaltime module start <[2]> ClassOne body <[6]> ClassTwo body <[7]> ClassThree body <[200]> deco_alpha <[9]> ClassFour body ➊ <[11]> ClassOne tests .............................. <[3]> ClassOne.__init__ ➋ <[5]> ClassOne.method_x <[12]> ClassThree tests .............................. <[300]> deco_alpha:inner_1 ➌ <[13]> ClassFour tests .............................. <[10]> ClassFour.method_y <[14]> evaltime module end <[4]> ClassOne.__del__ ➍

❶ 目前为止，输出与示例 21-8 相同。

❷ 类的标准行为。

❸ deco_alpha 装饰器修改了 ClassThree.method_y 方法，因此调用 three.method_y () 时会运行 inner_1 函数的定义体。

❹ 只有程序结束时，绑定在全局变量 one 上的 ClassOne 实例才会被垃圾回收程序回收。

场景 2 主要想说明的是，类装饰器可能对子类没有影响。在示例 21-6 中，我们把 ClassFour 定义为 ClassThree 的子类。ClassThree 类上依附的 @deco_alpha 装饰器把 method_y 方法替换掉了，但是这对 ClassFour 类根本没有影响。当然，如果 ClassFour.method_y 方法使用 super (...) 调用 ClassThree.method_y 方法，我们便会看到装饰器起作用，执行 inner_1 函数。

与此不同的是，如果想定制整个类层次结构，而不是一次只定制一个类，使用下一节介绍的元类更高效。

21.4　元类基础知识

元类是制造类的工厂，不过不是函数（如示例 21-2 中的 record_factory），而是类。图 21-1 使用机器和小怪兽图示法描述元类，可以看出，元类是生产机器的机器。

图 21-1：元类是用于构建类的类

根据 Python 对象模型，类是对象，因此类肯定是另外某个类的实例。默认情况下，Python 中的类是 type 类的实例。也就是说，type 是大多数内置的类和用户定义的类的元类：

>>> 'spam'.__class__ <class 'str'> >>> str.__class__ <class 'type'> >>> from bulkfood_v6 import LineItem >>> LineItem.__class__ <class 'type'> >>> type.__class__ <class 'type'>

为了避免无限回溯，type 是其自身的实例，如最后一行所示。

注意，我没有说 str 或 LineItem 继承自 type。我的意思是，str 和 LineItem 是 type 的实例。这两个类是 object 的子类。图 21-2 可能有助于你理清这个奇怪的现象。

图 21-2：两个示意图都是正确的。左边的示意图强调 str、type 和 LineItem 是 object 的子类。右边的示意图则清楚地表明 str、object 和 LineItem 是 type 的实例，因为它们都是类

object 类和 type 类之间的关系很独特：object 是 type 的实例，而 type 是 object 的子类。这种关系很「神奇」，无法使用 Python 代码表述，因为定义其中一个之前另一个必须存在。type 是自身的实例这一点也很神奇。

除了 type，标准库中还有一些别的元类，例如 ABCMeta 和 Enum。如下述代码片段所示，collections.Iterable 所属的类是 abc.ABCMeta。Iterable 是抽象类，而 ABCMeta 不是 —— 不管怎样，Iterable 是 ABCMeta 的实例：

>>> import collections >>> collections.Iterable.__class__ <class 'abc.ABCMeta'> >>> import abc >>> abc.ABCMeta.__class__ <class 'type'> >>> abc.ABCMeta.__mro__ (<class 'abc.ABCMeta'>, <class 'type'>, <class 'object'>)

向上追溯，ABCMeta 最终所属的类也是 type。所有类都直接或间接地是 type 的实例，不过只有元类同时也是 type 的子类。若想理解元类，一定要知道这种关系：元类（如 ABCMeta）从 type 类继承了构建类的能力。图 21-3 对这种至关重要的关系做了图解。

图 21-3：Iterable 是 object 的子类，是 ABCMeta 的实例。object 和 ABCMeta 都是 type 的实例，但是这里的重要关系是，ABCMeta 还是 type 的子类，因为 ABCMeta 是元类。示意图中只有 Iterable 是抽象类

我们要抓住的重点是，所有类都是 type 的实例，但是元类还是 type 的子类，因此可以作为制造类的工厂。具体来说，元类可以通过实现 __init__ 方法定制实例。元类的 __init__ 方法可以做到类装饰器能做的任何事情，但是作用更大，如接下来的练习所示。

理解元类计算时间的练习

我们对 21.3 节的练习做些改动，evalsupport.py 模块与示例 21-7 一样，不过现在主脚本变成 evaltime_meta.py 了，如示例 21-10 所示。

示例 21-10　evaltime_meta.py：ClassFive 是 MetaAleph 元类的实例

from evalsupport import deco_alpha from evalsupport import MetaAleph print('<[1]> evaltime_meta module start') @deco_alpha class ClassThree(): print('<[2]> ClassThree body') def method_y(self): print('<[3]> ClassThree.method_y') class ClassFour(ClassThree): print('<[4]> ClassFour body') def method_y(self): print('<[5]> ClassFour.method_y') class ClassFive(metaclass=MetaAleph): print('<[6]> ClassFive body') def __init__(self): print('<[7]> ClassFive.__init__') def method_z(self): print('<[8]> ClassFive.method_z') class ClassSix(ClassFive): print('<[9]> ClassSix body') def method_z(self): print('<[10]> ClassSix.method_z') if __name__ == '__main__': print('<[11]> ClassThree tests', 30 * '.') three = ClassThree() three.method_y() print('<[12]> ClassFour tests', 30 * '.') four = ClassFour() four.method_y() print('<[13]> ClassFive tests', 30 * '.') five = ClassFive() five.method_z() print('<[14]> ClassSix tests', 30 * '.') six = ClassSix() six.method_z() print('<[15]> evaltime_meta module end')

同样，请拿出纸和笔，按顺序写出下述两个场景中输出的序号标记 <[N]>。

场景 3

在 Python 控制台中以交互的方式导入 evaltime_meta.py 模块。

场景 4

在命令行中运行 evaltime_meta.py 模块。

解答和分析如下。

场景 3 的解答

在 Python 控制台中导入 evaltime_meta.py 模块后得到的输出如示例 21-11 所示。

示例 21-11　场景 3：在 Python 控制台中导入 evaltime_meta 模块

>>> import evaltime_meta <[100]> evalsupport module start <[400]> MetaAleph body <[700]> evalsupport module end <[1]> evaltime_meta module start <[2]> ClassThree body <[200]> deco_alpha <[4]> ClassFour body <[6]> ClassFive body <[500]> MetaAleph.__init__ ➊ <[9]> ClassSix body <[500]> MetaAleph.__init__ ➋ <[15]> evaltime_meta module end

➊ 与场景 1 的关键区别是，创建 ClassFive 时调用了 MetaAleph.__init__ 方法。

➋ 创建 ClassFive 的子类 ClassSix 时也调用了 MetaAleph.__init__ 方法。

Python 解释器计算 ClassFive 类的定义体时没有调用 type 构建具体的类定义体，而是调用 MetaAleph 类。看一下示例 21-12 中定义的 MetaAleph 类，你会发现 __init__ 方法有四个参数。

self

这是要初始化的类对象（例如 ClassFive）。

name、bases、dic

与构建类时传给 type 的参数一样。

示例 21-12　evalsupport.py：定义 MetaAleph 元类，摘自示例 21-7

class MetaAleph(type): print('<[400]> MetaAleph body') 　 def __init__(cls, name, bases, dic): print('<[500]> MetaAleph.__init__') 　 def inner_2(self): print('<[600]> MetaAleph.__init__:inner_2') 　 cls.method_z = inner_2

编写元类时，通常会把 self 参数改成 cls。例如，在上述元类的 __init__ 方法中，把第一个参数命名为 cls 能清楚地表明要构建的实例是类。

__init__ 方法的定义体中定义了 inner_2 函数，然后将其绑定给 cls.method_z。MetaAleph.__init__ 方法签名中的 cls 指代要创建的类（例如 ClassFive）。而 inner_2 函数签名中的 self 最终是指代我们在创建的类的实例（例如 ClassFive 类的实例）。

场景 4 的解答

在命令行中运行 python3 evaltime_meta.py 命令后得到的输出如示例 21-13 所示。

示例 21-13　场景 4：在 shell 中运行 evaltime_meta.py

$ python3 evaltime.py <[100]> evalsupport module start <[400]> MetaAleph body <[700]> evalsupport module end <[1]> evaltime_meta module start <[2]> ClassThree body <[200]> deco_alpha <[4]> ClassFour body <[6]> ClassFive body <[500]> MetaAleph.__init__ <[9]> ClassSix body <[500]> MetaAleph.__init__ <[11]> ClassThree tests .............................. <[300]> deco_alpha:inner_1 ➊ <[12]> ClassFour tests .............................. <[5]> ClassFour.method_y ➋ <[13]> ClassFive tests .............................. <[7]> ClassFive.__init__ <[600]> MetaAleph.__init__:inner_2 ➌ <[14]> ClassSix tests .............................. <[7]> ClassFive.__init__ <[600]> MetaAleph.__init__:inner_2 ➍ <[15]> evaltime_meta module end

❶ 装饰器依附到 ClassThree 类上之后，method_y 方法被替换成 inner_1 方法……

❷ 虽然 ClassFour 是 ClassThree 的子类，但是没有依附装饰器的 ClassFour 类却不受影响。

❸ MetaAleph 类的 __init__ 方法把 ClassFive.method_z 方法替换成 inner_2 函数。

❹ ClassFive 的子类 ClassSix 也是一样，method_z 方法被替换成 inner_2 函数。

注意，ClassSix 类没有直接引用 MetaAleph 类，但是却受到了影响，因为它是 ClassFive 的子类，进而也是 MetaAleph 类的实例，所以由 MetaAleph.__init__ 方法初始化。

如果想进一步定制类，可以在元类中实现 __new__ 方法。不过，通常情况下实现 __init__ 方法就够了。

现在，我们可以实践这些理论了。我们将创建一个元类，让描述符以最佳的方式自动创建储存属性的名称。

21.5　定制描述符的元类

回到 LineItem 系列示例。如果用户完全不用知道描述符或元类，直接继承库提供的类就能满足需求，那该多好。如示例 21-14 所示。

示例 21-14　bulkfood_v7.py：有元类的支持，继承 model.Entity 类即可

import model_v7 as model class LineItem(model.Entity): ➊ description = model.NonBlank() weight = model.Quantity() price = model.Quantity() def __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price def subtotal(self): return self.weight * self.price

➊ LineItem 是 model.Entity 的子类。

示例 21-14 理解起来相当容易，毕竟根本没有奇怪的句法。可是，model_v7.py 模块必须定义一个元类，而且 model.Entity 类是那个元类的实例。model_v7.py 模块中实现的 Entity 类如示例 21-15 所示。

示例 21-15　model_v7.py：EntityMeta 元类以及它的一个实例 Entity

class EntityMeta (type): """元类，用于创建带有验证字段的业务实体""" def __init__(cls, name, bases, attr_dict): super ().__init__(name, bases, attr_dict) ➊ for key, attr in attr_dict.items (): ➋ if isinstance (attr, Validated): type_name = type (attr).__name__ attr.storage_name = '_{}#{}'.format (type_name, key) class Entity (metaclass=EntityMeta): ➌ """带有验证字段的业务实体"""

❶ 在超类（在这里是 type）上调用 __init__ 方法。

❷ 与示例 21-4 中 @entity 装饰器的逻辑一样。

❸ 这个类的存在只是为了用起来便利：这个模块的用户直接继承 Entity 类即可，无需关心 EntityMeta 元类，甚至不用知道它的存在。

示例 21-14 中的代码能通过示例 21-3 中的测试。辅助模块 model_v7.py 比 model_v6.py 难理解，但是用户级别的代码更简单：只需继承 model_v7.Entity 类，Validated 字段就能自动获得储存属性的名称。

图 21-4 使用简单的图示说明了我们刚刚实现的逻辑。虽然有很多复杂的逻辑，但都隐藏在 model_v7 模块中。从用户的角度来看，示例 21-14 中的 LineItem 只是 Entity 的子类。这就是抽象的作用。

图 21-4：使用机器和小怪兽图示法（MGN）注解的 UML 类图。EntityMeta 元机器用于生产 LineItem 机器。描述符（如 weight 和 price）由 EntityMeta.__init__ 方法配置。注意 model_v7 模块的边界

除了把类链接到元类上的句法之外 5，目前编写元类使用的句法在 Python 2.2（这个版本对 Python 类型做了重大改造）之后都能使用。下一节介绍一个只能在 Python 3 中使用的功能。

511.7.1 节说过，Python 2.7 使用的是 __metaclass__ 类属性，类的声明体不支持 metaclass= 关键字参数。

21.6　元类的特殊方法 __prepare__

在某些应用中，可能需要知道类的属性定义的顺序。例如，对读写 CSV 文件的库来说，用户定义的类可能想把类中按顺序声明的字段与 CSV 文件中各列的顺序对应起来。

如前所述，type 构造方法及元类的 __new__ 和 __init__ 方法都会收到要计算的类的定义体，形式是名称到属性的映像。然而在默认情况下，那个映射是字典；也就是说，元类或类装饰器获得映射时，属性在类定义体中的顺序已经丢失了。

这个问题的解决办法是，使用 Python 3 引入的特殊方法 __prepare__。这个特殊方法只在元类中有用，而且必须声明为类方法（即，要使用 @classmethod 装饰器定义）。解释器调用元类的 __new__ 方法之前会先调用 __prepare__ 方法，使用类定义体中的属性创建映射。__prepare__ 方法的第一个参数是元类，随后两个参数分别是要构建的类的名称和基类组成的元组，返回值必须是映射。元类构建新类时，__prepare__ 方法返回的映射会传给 __new__ 方法的最后一个参数，然后再传给 __init__ 方法。

理论听起来很复杂，但是我见过的 __prepare__ 方法都十分简单。请看示例 21-16。

示例 21-16　 model_v8.py：这一版 EntityMeta 元类用到了 __prepare__ 方法，而且为 Entity 类定义了 field_names 类方法

class EntityMeta (type): """元类，用于创建带有验证字段的业务实体""" @classmethod def __prepare__(cls, name, bases): return collections.OrderedDict () ➊ def __init__(cls, name, bases, attr_dict): super ().__init__(name, bases, attr_dict) cls._field_names = [] ➋ for key, attr in attr_dict.items (): ➌ if isinstance (attr, Validated): type_name = type (attr).__name__ attr.storage_name = '_{}#{}'.format (type_name, key) cls._field_names.append (key) ➍ class Entity (metaclass=EntityMeta): """带有验证字段的业务实体""" @classmethod def field_names (cls): ➎ for name in cls._field_names: yield name

❶ 返回一个空的 OrderedDict 实例，类属性将存储在里面。

❷ 在要构建的类中创建一个 _field_names 属性。

❸ 这一行与前一版相比没有变化，不过这里的 attr_dict 是那个 OrderedDict 对象，由解释器在调用 __init__ 方法之前调用 __prepare__ 方法时获得。因此，这个 for 循环会按照添加属性的顺序迭代属性。

❹ 把找到的各个 Validated 字段添加到 _field_names 属性中。

❺ field_names 类方法的作用简单：按照添加字段的顺序产出字段的名称。

像示例 21-16 那样添加一些简单的代码之后，我们可以使用 field_names 类方法迭代任何 Entity 子类的 Validated 字段。示例 21-17 演示了这个新功能。

示例 21-17　bulkfood_v8.py：展示 field_names 用法的 doctest—— 无需修改 LineItem 类，field_names 方法继承自 model.Entity 类

>>> for name in LineItem.field_names(): ... print(name) ... description weight price

对元类的介绍到此结束。在现实世界中，框架和库会使用元类协助程序员执行很多任务，例如：

验证属性

一次把装饰器依附到多个方法上

序列化对象或转换数据

对象关系映射

基于对象的持久存储

动态转换使用其他语言编写的类结构

下一节将概述 Python 数据模型为所有类定义的方法。

21.7　类作为对象

Python 数据模型为每个类定义了很多属性，参见标准库参考中「Built-in Types」一章的「4.13. Special Attributes」一节。其中三个属性在本书中已经见过多次：__mro__、__class__ 和 __name__。此外，还有以下属性。

cls.__bases__

由类的基类组成的元组。

cls.__qualname__

Python 3.3 新引入的属性，其值是类或函数的限定名称，即从模块的全局作用域到类的点分路径。例如，在示例 21-6 中，内部类 ClassTwo 的 __qualname__ 属性，其值是字符串 'ClassOne.ClassTwo'，而 __name__ 属性的值是 'ClassTwo'。这个属性的规范是「PEP 3155—Qualified name for classes and functions」。

cls.__subclasses__()

这个方法返回一个列表，包含类的直接子类。这个方法的实现使用弱引用，防止在超类和子类（子类在 __bases__ 属性中储存指向超类的强引用）之间出现循环引用。这个方法返回的列表中是内存里现存的子类。

cls.mro()

构建类时，如果需要获取储存在类属性 __mro__ 中的超类元组，解释器会调用这个方法。元类可以覆盖这个方法，定制要构建的类解析方法的顺序。

dir (...) 函数不会列出本节提到的任何一个属性。

我们对类元编程的学习到此结束。这是个很大的话题，我只讲了皮毛。因此，本书各章都有「延伸阅读」一节。

21.8　本章小结

类元编程是指动态创建或定制类。在 Python 中，类是一等对象，因此本章首先说明如何通过调用内置的 type 元类，使用函数创建类。

接下来的一节继续讨论第 20 章使用描述符实现的 LineItem 类，解决一个遗留问题：如何让生成的储存属性名中包含托管属性的名称（例如，把 _Quantity#1 变成 _Quantity#price）。解决办法是使用类装饰器。说到底，类装饰器是函数，其参数是被装饰的类，用于审查和修改刚创建的类，甚至替换成其他类。

然后，本章讨论了模块中不同部分的代码何时运行。我们发现，所谓的「导入时」和「运行时」之间有重叠，不过很明显，import 语句会触发运行大量代码。知道代码何时运行至关重要，可是有些规则难以捉摸，因此我们通过两个计算时间练习对此做了说明。

接下来，本章介绍了元类。我们得知，所有类都直接或间接地是 type 的实例，因此在 Python 中，type 是「根元类」。然后，我们对之前的计算时间练习做了修改，以此说明元类可以定制类的层次结构。类装饰器则不同，它只能影响一个类，而且对后代可能没有影响。

随后，我们实际使用元类，解决 LineItem 类中储存属性的命名问题。最终写出的代码比类装饰器难懂一些，不过可以封装在一个模块里，这样用户只需继承看似普通的一个类（model.Entity），而不用知道它是元类（model.EntityMeta）的实例。这种处理方式让人想起了 Django 和 SQLAlchemy 的 ORM API：使用元类实现，用户却根本无需知道。

我们实现的第二个元类为 model.EntityMeta 类添加了一个小功能：定义 __prepare__ 方法，返回一个 OrderedDict 对象，用于储存名称到属性的映射。这样做能保留要构建的类在定义体中绑定属性的顺序，提供给元类的 __new__ 和 __init__ 等方法使用。在这个示例中，我们定义了类属性 _field_names，因此用户可以使用 Entity.field_names () 方法以 Validated 描述符出现在源码中的顺序获取描述符。

最后一节，我们概述了 Python 为所有类提供的属性和方法。

元类是充满挑战、让人兴奋的功能，有时会被故作聪明的程序员滥用。最后，我们回顾一下 Alex Martelli 在他写的「水禽和抽象基类」一文的最后给我们的建议：

此外，不要在生产代码中定义抽象基类（或元类）…… 如果你很想这样做，我打赌可能是因为你想「找茬」，刚拿到新工具的人都有大干一场的冲动。如果你能避开这些深奥的概念，你（以及未来的代码维护者）的生活将更愉快，因为代码简洁明了。

——Alex Martelli

说出上述至理名言的人不仅是 Python 元编程大师，还是造诣颇深的软件工程师，负责世界上几个最重要的 Python 应用。

21.9　延伸阅读

为了深入学习本章所述的知识，一定要阅读 Python 语言参考手册中「Data Model」一章里的「3.3.3. Customizing class creation」一节、「Built-in Functions」一章中 type 类的文档，以及标准库参考中「Built-in Types」一章里的「4.13. Special Attributes」一节。此外，在标准库参考中，types 模块的文档说明了 Python 3.3 引入的两个新函数，这两个函数用于辅助类元编程：types.new_class (...) 和 types. prepare_class (...)。

类装饰器的规范是「PEP 3129—Class Decorators」，作者是 Collin Winter，参考实现由 Jack Diederich 提供。Jack Diederich 在 PyCon 2009 大会上做了一场题为「Class Decorators: Radically Simple」的演讲（视频），对这个功能做了简单介绍。

Alex Martelli 写的《Python 技术手册（第 2 版）》对元类的说明很出色，还实现了 metaMetaBunch 元类，其作用与示例 21-2 中简单的 record_factory 函数一样，不过完善得多。Martelli 没有探讨类装饰器，因为这个功能在那本书出版后才引入。Beazley 和 Jones 在他们合著的《Python Cookbook（第 3 版）中文版》中提供了几个示例，很好地演示了类装饰器和元类。Michael Foord 写了一篇引人入胜的文章，题为「Meta-classes Made Easy: Eliminating self with Metaclasses」。副标题（「借助元类去掉 self」）说明了一切。

元类的主要参考资料有引入特殊方法 __prepare__ 的「PEP 3115—Metaclasses in Python 3000」，以及 Guido van Rossum 发布的文章「Unifying types and classes in Python 2.2」。这篇文章也适用于 Python 3，谈到了后来称为「新式类」的语义，包括描述符和元类，一定要阅读。Guido 在文中提到了 Ira R. Forman 与 Scott H. Danforth 合著的 Putting Metaclasses to Work: a New Dimension in Object-Oriented Programming（Addison- Wesley 出版社，1998 年），他在亚马逊上给这本书打了五颗星，还写了如下评论：

这本书促成 Python 2.2 实现了元类

可惜，这本书已经绝版了。Python 通过 super () 函数实现了协作式多重继承，谈到这方面的难题时，我总会提到这本书；据我所知，这本书是这方面最好的教程。6

6 摘自亚马逊网站中 Putting Metaclasses to Work 的商品目录页面。目前还有二手书出售。我买了一本，发现很难读懂，不过以后我可能会再读。

「PEP 487—Simpler customization of class creation」提议为 Python 3.5（写到这里时，处于内测阶段）添加一个新的特殊方法 __init_subclass__，7 让普通的类（即，不是元类）定制子类的初始化。与类装饰器一样，__init_subclass__ 方法能让类元编程变得更简单，但会导致元类这个强大的功能更难正确使用。

7 现在，Python 3.5 已经正式发布，PEP 487 没有在 Python 3.5 中实现，而是推迟到 Python 3.6 中。—— 编者注

如果你喜欢元编程，可能希望 Python 提供基本的元编程功能 ——Elixir 和 Lisp 语言族提供的句法宏。天遂人愿，我们有 MacroPy 可用。

杂谈

这是本书最后一篇「杂谈」了，首先我要从 Brian Harvey 与 Matthew Wright 合写的著作中引述一大段文字。Harvey 和 Wright 是加州大学（伯克利分校和圣巴巴拉分校）的计算机科学教授，他们在合著的 Simply Scheme 一书中写道：

计算机科学的教学方式分成两个流派，可以描述如下。

(1) 保守派 计算机程序已经变得极其大而复杂，超过了人类思维所能承载的限度。因此，计算机科学教育的任务是训练平庸的程序员，这样 500 个人合作便能开发出恰好满足需求的程序。

(2) 激进派 计算机程序已经变得极其大而复杂，超过了人类思维所能承载的限度。因此，计算机科学教育的任务是教人如何拓展思维，打破常规，学习以更广博、更强大和更灵活的方式思考，让思维超越程序。编程思想的各个方面在程序中必会得到充分体现。8

——Brian Harvey 和 Matthew Wright

Simply Scheme 前言

这是 Harvey 和 Wright 对计算机科学教育的夸张描述，不过也适用于编程语言的设计。现在，你应该能猜到，我赞成「激进派」，我认为 Python 也是以这种态度设计的。

为了稳扎稳打，Java 从一开始使用的就是存取方法，而且众多 Java IDE 都提供了生成读值方法和设值方法的快捷键；与此相比，特性算是一大进步。特性的主要优点是，一开始编写程序时可以先把属性设为公开的（遵照 KISS 原则），因为公开的属性无需大幅改动，随时都能变成特性。不过，描述符更进一步，提供了去除存取方法中逻辑重复的机制。这种机制特别有效，因此基本的 Python 结构在背后也用到了描述符。

另一个强大的想法是，把函数当作一等对象，这为高阶函数铺平了道路。描述符和高阶函数合在一起实现，使得函数和方法的统一成为可能。函数的 __get__ 方法能即时生成方法对象，把实例绑定到 self 参数上。这种做法相当优雅。9

最后，Python 中的类也是一等对象。作为一门对初学者友好的语言，Python 能提供类装饰器，允许用户定义功能完整的元类，这些强大的抽象真是太棒了。最棒的是，这些高级功能没有拖累日常编程（其实无形中提供了帮助）。Django 和 SQLAlchemy 等框架用起来这么方便，发展得这么成功，很大程度上归功于元类，而这些工具的用户甚至不知道元类的存在。不过，他们可以学习，去创建下一个伟大的库。

我还未见过有哪门语言像 Python 这样竭尽所能，让初学者易于入门，让专业人士用着顺手，让程序高手欢欣鼓舞。感谢 Guido van Rossum，以及为此努力的每个人。

8Brian Harvey and Matthew Wright, Simply Scheme (MIT Press, 1999), p. xvii. 伯克利分校的网站中有此书全文。

9David Gelernter 写的 Machine Beauty（Basic Books 出版社）是一本非常有趣的小书，对工程作品（从桥梁到软件）的优雅和美学做了阐述。

结语

Python 是给法定成年人使用的语言。

——Alan Runyan

