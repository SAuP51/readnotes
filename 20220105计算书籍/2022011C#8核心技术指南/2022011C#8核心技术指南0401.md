## 0401. C# 的高级特性

本章将在第 2 章、第 3 章概念的基础上探讨 C# 的高级特性。本章的前 4 节请按照顺序阅读，其他节则可以自由阅读。

### 4.1 委托

委托是一种知道如何对方法进行调用的对象。

委托类型定义了一类可以被委托实例调用的方法。具体来说，它定义了方法的返回类型和参数类型。以下语句定义了一个委托类型 Transformer：

delegate int Transformer (int x);

Transformer

兼容任何返回类型为 int

并有一个 int

类型参数的方法，例如：

static int Square (int x) { return x * x; }

或者可以简洁地写为：

static int Square (int x) => x * x;

将方法赋值给委托变量就能创建一个委托实例：

Transformer t = Square;

可以像调用方法一样调用委托实例：

int answer = t(3);  // answer is 9

以下是一个完整的例子：

delegate int Transformer (int x);class Test{ static void Main() {  Transformer t = Square;

// Create delegate instance  int result = t(3);

// Invoke delegate

Console.WriteLine (result);

// 9 } static int Square (int x) => x

* x;}

委托实例字面上是调用者的代理：调用者调用委托，而委托调用目标方法。这种间接调用方式可以将调用者和目标方法解耦。

以下语句：

Transformer t = Square;

是下面语句的简写：

Transformer t = new Transformer (Square);

从技术上讲，当引用没有括号和参数的 Square

方法时，我们指定的是一组方法。如果该方法被重载，C# 会根据赋值委托的签名选择正确的重载方法。

语句：

t(3)

是下面语句的简写：

t.Invoke(3)

委托和回调（callback）类似。回调一般用于描述捕获类似 C 函数指针的结构。

4.1.1　用委托编写插件方法

委托变量可以在运行时指定一个目标方法，这个特性可用于编写插件方法。下例中有一个名为 Transform

的公共方法，它对整数数组的每一个元素进行变换。Transform

方法接受一个委托参数并以此为插件方法执行变换操作：

public delegate int Transformer (int x);class Util{ public static void Transform (int[] values, Transformer t

)



{

f

or (int i = 0; i < values.Length; i++)



values[i] = t (values[i]);

}}

c

lass

Test{



sta

tic void Main()

{

i

nt[] values = { 1, 2, 3 };

U

til.Transform (values, Square);   // Hook

in the Square method

f

oreach (int i in values)



Console.Write (i + " ");      // 1

4  9

}



sta

tic int Square (int x) => x * x;}

Transform

方法是一个高阶函数（higher-order function），因为它是一个以函数为参数的函数（返回委托的方法也称为高阶函数）。

4.1.2　多播委托

所有的委托实例都拥有多播能力。这意味着一个委托实例可以引用一个目标方法，也可以引用一组目标方法。委托可以使用 +

和 +=

运算符联结多个委托实例。例如：

SomeDelegate d = SomeMethod1;

d += SomeMethod2;

最后一行等价于：

d = d + SomeMethod2;

现在调用 d

不仅会调用 SomeMethod1

，而且会调用 SomeMethod2

。委托会按照添加的顺序依次触发。

-

和 -=

运算符会从左侧委托操作数中将右侧委托操作数删除。例如：

d -= SomeMethod1;

现在，调用 d

只会触发 SomeMethod2

调用。

对值为 null

的委托变量进行 +

或者 +=

操作，等价于为变量指定一个新的值：

SomeDelegate d = null;

d += SomeMethod1;

// Equivalent (when d is null) to d = SomeMethod1;

同样，在只有唯一目标方法的委托上调用 -=

等价于为该变量指定 null

值。

委托是不可变的，因此调用 +=

和 -=

的实质是创建一个新的委托实例，并把它赋值给已有变量。

如果一个多播委托拥有非 void

的返回类型，则调用者将从最后一个触发的方法接收返回值。前面的方法仍然调用，但是返回值都会被丢弃。大部分调用多播委托的情况都会返回 void

类型，因此这个细小的差异就不存在了。

所有的委托类型都是从 System.MulticastDelegate

类隐式派生的。而 System.MulticastDelegate

继承自 System.Delegate

。C# 将委托中的 +

、-

、+=

、-=

运算符都编译成了 System.Delegate

的静态 Combine

和 Remove

方法。

多播委托的示例

若方法的执行时间很长，那么可以令该方法定期调用一个委托向调用者报告进程的执行情况。例如，在以下代码中，HardWork

方法通过调用 ProgressReporter

委托参数报告执行进度：

public delegate void ProgressReporter (int percentComplete);

public class Util{ public static void HardWork (ProgressReporter p) {  for (int i = 0; i < 10; i++)  {   p (i * 10);              // Invoke delega

t

e   System.Threading.Thread.Sleep (100); // Simulate hard



work  } }}

为了监视进度，我们在 Main

方法中创建了一个多播委托实例 p

。这样就可以通过两个独立的方法监视执行进度了：

class Test

{ static v

oi

d Main() {  Progre

ss

Reporter p = WritePro

gres

sToConsole;  p += W

ri

teProgressToFile;  Util.H

ar

dWork (p); }  static v

oi

d WriteProgressToCons

ole

(int percentComplete)  => Con

so

le.WriteLine (percent

Comp

lete);     static v

oi

d WriteProgressToFile

(in

t percentComplete)  => Sys

te

m.IO.File.WriteAllTex

t ("

progress.txt",







percentComplete.ToString());}

4.1.3　实例方法目标和静态方法目标

将实例方法赋值给委托对象时，后者不但要维护方法的引用，还需要维护方法所属实例的引用。System.Delegate

类的 Target

属性代表这个实例（如果委托引用的是一个静态方法，则该属性值为 null

）。例如：

public delegate void ProgressReporter (int percentComplete);

class Test{ static void Main() {  X x = new X();  ProgressReporter p = x.InstanceProgress;  p(99);                 // 99  Console.WriteLine (p.Target == x);   // True  Console.WriteLine (p.Method);     // Void InstanceP

r

ogress(Int3

2)

}}class X{ public void InstanceProgress (int percentComplete)  => Console.WriteLine (percentComplete);}

4.1.4　泛型委托类型

委托类型可以包含泛型类型参数。例如：

public delegate T Transformer<T> (T

arg);

根据上面的定义，可以写一个通用的 Transform

方法，让它对任何类型都有效：

public class Util{ public static void Transform<T> (T[] values, Transformer<T> t

)



{f

or (int i = 0; i < values.Length; i++)



values[i] = t (values[i]);

}}

c

lass

Test{



sta

tic void Main()

{

i

nt[] values = { 1, 2, 3 };

U

til.Transform (values, Square);   // Hook

in Square

f

oreach (int i in values)



Console.Write (i + " ");      // 1

4  9

}

sta

tic int Square (int x) => x * x;}

4.1.5　Func

和 Action

委托

有了泛型委托，就可以定义出一些非常通用的小型委托类型，它们可以具有任意的返回类型和（合理的）任意数目的参数。它们就是定义在 System

命名空间下的 Func

和 Action

委托（in

和 out

是标记可变性的修饰符，后面将会说明）：

delegate TResult Func <out TResult>        ();delegate TResult Func <in T, out TResult>     (T arg);delegate TResult Func <in T1, in T2, out TResult> (T1 arg1, T2 arg2);... and so on, up to T16

delegate void Action         ();delegate void Action <in T>     (T arg);delegate void Action <in T1, in T2> (T1 arg1, T2 arg2);... and so on, up to T16

这些委托都是非常通用的委托。前面例子中的 Transformer

委托就可以用一个带有 T

类型参数并返回 T

类型的 Func

委托代替：

public static void Transform<T> (T[] values, Func<T,T> transformer

)

{



f

or (int i = 0; i < values.Length; i++)



values[i] = transformer (values[i]);}

这些委托中没有涉及的场景只有 ref

、out

和指针参数了。

在.NET Framework 2.0 之前，并不存在 Func

和 Action

委托（因为那个时候还不存在泛型）。由于这个历史问题，所以框架里面的很多代码都使用自定义委托类型，而不是 Func

和 Action

。

4.1.6　委托和接口

能用委托解决的问题都可以用接口解决。例如，下面的 ITransformer

接口可以代替委托解决前面例子中的问题：

public interface ITransformer

{ int Transform (int x);}public class Util{ public static void Transform

Al

l (int[] values, ITransfo

rm

e

r t) {  for (int i = 0; i < values

.L

ength; i++) values[i] = t.Transform

(v

alues[i]); }}class Squarer : ITransformer{ public int Transform (int x

)

=> x * x;}...static void Main(){ int[] values = { 1, 2, 3 };

Util.TransformAll (values,

ne

w Squarer()); foreach (int i in values)  Console.WriteLine (i);}

如果以下一个或多个条件成立，委托可能是比接口更好的选择：

接口内仅定义了一个方法。

需要多播能力。

订阅者需要多次实现接口。

虽然在 ITransformer

的例子中不需要多播，但该接口仅仅定义了一个方法，而且订阅者有可能为了支持不同的变换（例如平方或立方变换）需要多次实现 ITransformer

接口。如果使用接口，由于 Test

只能实现一次 ITransformer

，因此我们就必须对每一种变换编写一个新的类型。这样做很麻烦：

class Squarer : ITransformer

{ public int Transform (int

x)

=> x * x;}class Cuber : ITransformer{ public int Transform (int

x)

=> x * x * x;}...static void Main(){ int[] values = { 1, 2, 3 }

; Util.TransformAll (values,

n

ew Cuber()); foreach (int i in values)  Console.WriteLine (i);}

4.1.7　委托的兼容性

类型的兼容性

即使签名相同，委托类型也互不兼容：

delegate void D1();

delegate void D2();

...D1 d1 = Method1;D2 d2 = d1;

/

/ Co

m

pile-time error

但是以下写法是有效的：

D2 d2 = new

D2 (d1);

如果委托实例指向相同的目标方法，则认为它们是等价的：

delegate void D();

...D d1 = Method1;D d2 = Method1;Console.WriteLine

(d1

=

= d2);     /

/ True

如果多播委托按照相同的顺序引用相同的方法，则认为它们是等价的。

参数的兼容性

当调用方法时，可以给方法的参数提供更加具体的变量类型，这是正常的多态行为。基于同样的原因，委托也可以有比它的目标方法参数类型更具体的参数类型，这称为逆变。例如：

delegate void StringAction (string s);

class Test{ static void Main()

{  StringAction sa = new StringAction



(ActOnObjec

t)

;  sa ("hello"); }  static void ActOnObject (object o) =

>

Console.Wr

it

eLine (o);  // hello

}

（和类型参数的可变性一样，委托的可变性仅适用于引用转换。）

委托只是替其他人调用方法。在本例中，在调用 StringAction

时，参数类型是 string

。当这个参数传递给目标方法时，参数隐式向上转换为 object

。

标准事件模式的设计宗旨是通过使用公共的 EventArgs

基类来利用逆变特性。例如，可以用两个不同的委托调用同一个方法，一个传递 MouseEventArgs

而另一个则传递 KeyEventArgs

。

返回类型的兼容性

调用一个方法时可能得到比请求类型更具体的返回值类型，这也是正常的多态行为。基于同样的原因，委托的目标方法可能返回比委托声明的返回值类型更加具体的返回值类型，这称为协变。例如：

delegate object ObjectRetriever();

class Test{ static void Main() {  ObjectRetriever o = new Object

R

etriever (R

et

rieveString);  object result = o();  Console.WriteLine (result);



// hello } static string RetrieveString() =

>

"hello";}

ObjectRetriever

期望返回一个 object

。但若返回 object

子类也是可以的，因为委托的返回值类型是协变的。

泛型委托类型的参数协变

第 3 章介绍了泛型接口是如何支持协变和逆变参数类型的。而委托也具有相同的功能。

如果要定义一个泛型委托类型，那么建议参考如下的准则：

将只用于返回值类型的类型参数标记为协变（out

）。

将只用于参数的任意类型参数标记为逆变（in

）。

这样可以依照类型的继承关系自然地进行类型转换。

以下（在 System

命名空间中定义的）委托拥有协变类型参数 TResult

：

delegate TResult Func<out TResult>();

它允许如下的操作：

Func<string> x = ...;

Func<object> y = x;

而下面（在 System

命名空间中定义）的委托拥有逆变类型参数 T

：

delegate void Action<in T> (T arg);

因而可以执行如下的操作：

Action<object> x = ...;

Action<string> y = x;

4.2　事件

当使用委托时，一般会出现两种角色：广播者（broadcaster）和订阅者（subscriber）。

广播者是包含委托字段的类型，它通过调用委托决定何时进行广播。

订阅者是方法的目标接收者。订阅者通过在广播者的委托上调用 +=

和 -=

来决定何时开始监听，何时监听结束。订阅者不知道也不会干涉其他的订阅者。

而事件就是正式定义这一模式的语言功能。事件是一种使用有限的委托功能实现广播者或订阅者模型的结构。使用事件的主要目的是保证订阅者之间互不影响。

声明事件最简单的方法是在委托成员的前面加上 event

关键字：

// Delegate definitionpublic delegate void PriceChangedHandler (decimal oldPrice,                     decimal newPrice);public class Broadcaster{ // Event declaration public event

PriceChangedHandler PriceChanged;

}

Broadcaster

类型中的代码对 PriceChanged

有完全的访问权限，并可以将其视为委托。而 Broadcaster

类型之外的代码只可以在 PriceChanged

事件上执行 +=

和 -=

操作。

观察下面的例子，在 Stock

类中，每当 Stock

的 Price

发生变化时，PriceChanged

事件就会触发：

public delegate void PriceChangedHandler (decimal oldPrice,                     decimal newPrice);public class Stock{ string symbol; decimal price; public Stock (string symbol) => this.symbol = symbol;  public event PriceChangedHandler PriceChanged;  public decimal Price {  get => price;  set  {   if (price == value) return;   // Exit if nothing has changed   decimal oldPrice = price;   price = value;   if (PriceChanged != null)      // If invocation list not    PriceChanged (oldPrice, price);

// empty, fire event.

} }}

事件的工作机制

当声明如下的委托时，在内部会发生三件事情：

public class Broadcaster{ public event

PriceChangedHandler PriceChanged;

}

首先，编译器将事件的声明翻译为如下的形式：

PriceChangedHandler priceChanged;  // private delegate

public event PriceChangedHandler PriceChanged{ add  { priceChanged += value; } remove { priceChanged -= value; }}

add

和 remove

关键字明确了事件的访问器，就像属性的访问器那样。我们稍后将讲解如何编写访问器。

其次，编译器在 Broadcaster

类中找到除调用 +=

和 -=

之外的 priceChanged

引用点，并将它们重定向到底层的 priceChanged

委托字段。

最后，编译器对事件上的 +=

和 -=

运算符操作相应地转换为调用事件的 add

或 remove

访问器。有意思的是当应用于事件时，+=

和 -=

的行为是唯一的，而不像其他情况下的作为 +

和 -

运算符与赋值运算符的简写。

上例中，如果将 event

关键字去掉，PriceChanged

就变成了普通的委托字段。虽然运行结果是不变的，但是 Stock

类就没有原来健壮了。因为这时订阅者可以通过以下方式相互影响：

通过重新指派 PriceChanged

替换其他的订阅者（不用 +=

运算符）。

清除所有的订阅者（将 PriceChanged

设置为 null

）。

通过调用其委托广播到其他的订阅者。

Windows Runtime（WinRT）的事件在语义上稍有不同：附加到事件时会返回一个令牌以便后续能够从事件分离。编译器透明地弥补了这个差异（内部保存了令牌字典），因此可以将 WinRT 事件当作普通的 CLR 事件来使用。

4.2.1　标准事件模式

在.NET Core 程序库中几乎所有和事件相关的定义中，都体现了一个标准的模式。该模式保证了程序库和用户代码使用事件的一致性。标准事件模式的核心是 System.EventArgs

类：一个预定义的没有成员（但是有一个静态的 Empty

属性）的类。EventArgs

是为事件传递信息的基类。在 Stock

示例中，我们可以继承 EventArgs

以便在 PriceChanged

事件触发时传递新旧 Price

值：

public class PriceChangedEventArgs : System.EventArgs

{ public readonly decimal LastPrice; public readonly decimal NewPrice;  public PriceChangedEventArgs (decimal lastPrice, de

ci

mal newPrice) {  LastPrice = lastPrice;  NewPrice = newPrice; }}

考虑到复用性，EventArgs

子类应当根据它包含的信息来命名（而非根据使用它的事件命名）。它一般将数据以属性或只读字段的方式暴露给外界。

EventArgs

子类就位后，下一步就是选择或者定义事件的委托了。这一步需要遵循三条规则：

委托必须以 void

作为返回值。

委托必须接受两个参数：第一个参数是 object

类型，第二个参数则是 EventArgs

子类。第一个参数表明了事件的广播者，第二个参数则包含了需要传递的额外信息。

委托的名称必须以 EventHandler

结尾。

框架定义了一个名为 System.EventHandler<>

的泛型委托，该委托满足以上提到的三个条件：

public delegate void EventHandler<TEventArgs>

(object source, TEventArgs e) where TEventA

rgs : EventArgs;

在泛型出现之前（C# 2.0 之前），我们只能以如下的方式书写自定义委托：

public delegate void PriceChangedHandler

(object sender, PriceChangedEventArgs

e);

出于历史原因，框架中的大部分事件使用的委托是这样定义的。

接下来就是定义所选委托类型的事件了。这里使用泛型的 EventHandler

委托：

public class Stock{ ... public event EventHandler<PriceChangedEventArgs> PriceChanged;

}

最后，该模式需要编写一个 protected

的虚方法来触发事件。方法名必须和事件名称一致，以 On

为前缀，并接收唯一的 EventArgs

参数：

public class Stock{ ...  public event EventHandler<PriceChangedEventArgs> PriceChanged;  protected virtual void OnPriceChanged (PriceChangedEventArgs e)

{

if (PriceChanged != null) PriceChanged (this, e);

}

}

为了在多线程下可靠地工作（见第 14 章），在测试和调用委托之前，需要将它保存在临时变量中：

var temp = PriceChanged;

if (temp != null) temp (

t

his, e);

我们可以使用 null

条件运算符来避免声明临时变量：

PriceChanged?.Invoke (this, e);

这种方式既线程安全又书写简明，是现阶段最好的事件触发方式。

这样就提供了一个子类可以调用或重写事件的关键点（假设不是密封类）。

以下是完整的例子：

using System;public class PriceChangedEventArgs : EventArgs{ public readonly decimal LastPrice; public readonly decimal NewPrice; public PriceChangedEventArgs (decimal lastPrice, decimal newPrice) {  LastPrice = lastPrice; NewPrice = newPrice; }}public class Stock{ string symbol; decimal price;  public Stock (string symbol) => this.symbol = symbol;  public event EventHandler<PriceChangedEventArgs> PriceChanged;  protected virtual void OnPriceChanged (PriceChangedEventArgs e)

{

PriceChanged?.Invoke (this, e);

}

p

ublic decimal Price {



get => price;

set

{

if (price == value)

retu

rn;

decimal oldPrice = p

rice

;

price = value;

OnPriceChanged (new

Pric

eChangedEventArgs

(oldPric

e, pri

ce));

} }

}cla

ss Test{ s

tatic void Main() {



Stock stock = new Stoc

k ("

THPW");

stock.Price = 27.10M;

// Register with the P

rice

Changed event

stock.PriceChanged +=

stoc

k_PriceChanged;

stock.Price = 31.59M; }

s

tatic void stock_PriceC

hang

ed (object sender,

PriceCh

angedE

ventArgs e) {



if ((e.NewPrice - e.La

stPr

ice) / e.LastPrice

> 0.1M)



Console.WriteLine ("

Aler

t, 10% stock price

increas

e!"); }

}

如果事件不需要传递额外的信息，则可以使用预定义的非泛型委托 EventHandler

。本例中，我们重写了 Stock

类，当 Price

属性发生变化时，触发 PriceChanged

事件，事件除了传达已发生的消息之外没有必须包含的信息。为了避免创建非必要的 EventArgs

实例，还使用了 EventArgs.Emtpy

属性：

public class Stock{ string symbol; decimal price;  public Stock (string symbol) { this.symbol = symbol; }  public event EventHandler

PriceChanged;  protected virtual void OnPriceChanged (EventArgs e)

{

PriceChanged?.Invoke (this, e);

}

public decimal Price {  get { return price; }  set  {   if (price == value) return;   price = value;   OnPriceChanged (EventArgs.Empty

);



}

}}

4.2.2　事件访问器

事件访问器是对事件的 +=

和 -=

功能的实现。默认情况下，访问器由编译器隐式实现。考虑如下的声明：

public event EventHandler PriceChanged;

编译器将其转化为：

一个私有的委托字段。

一对公有的事件访问器函数（add_PriceChanged

和 remove_PriceChanged

），它们将 +=

和 -=

操作转向了私有的委托字段。

也可以显式定义事件访问器来替代这个过程。以下是 PriceChanged

事件的手动实现：

private EventHandler priceChanged;     // Declare a private delegatepublic event EventHandler PriceChanged{ add  { priceChanged += value; }

remove { priceChanged -= value; }

}

本例在功能上和 C# 的默认访问器实现是等价的（C# 还使用了无锁的比较交换算法保证在更新委托时的线程安全性，请参见 http://albahari.com/threading

）。若自定义了事件访问器，C# 就不会生成默认的字段和访问器逻辑了。

显式定义事件访问器，可以在委托的存储和访问上进行更复杂的操作。这主要有三种情形：

当前事件访问器仅仅是广播事件的类的中继器。

当类定义了大量的事件，而大部分时间有很少的订阅者，例如 Windows 控件。在这种情况下，最好用一个字典存储订阅者的委托实例，因为字典比大量的空委托字段引用的存储开销更少。

当显式实现声明事件的接口时。

以下的例子展示了第三种情形：

public interface IFoo { event EventHandler Ev; }

class Foo : IFoo{ private EventHandler ev;  event EventHandler IFoo.Ev {  add  { ev += value; }  remove { ev -= value; } }}

事件的 add

和 remove

部分会分别编译为 add_

XXX

和 remove_

XXX

方法。

4.2.3　事件修饰符

和方法类似，事件也可以重写，可以是虚的、抽象的或者密封的，当然也可以是静态的。

public class Foo

{ public static

ev

ent EventHandler<EventArgs> StaticEvent; public virtual

e

vent EventHandler<EventArgs> VirtualEvent;}

4.3　Lambda 表达式

Lambda 表达式是一种可以替代委托实例的匿名方法。编译器会立即将 Lambda 表达式转换为以下两种形式之一：

一个委托实例

一个类型为 Expression<TDelegate>

的表达式树（该表达式树将 Lambda 表达式内部的代码表示为一个可遍历的对象模型，因此 Lambda 表达式的解释可以延迟到运行时进行，请参见 8.10 节）

以下的委托类型：

delegate int Transformer (int i);

可使用 Lambda 表达式 x => x * x

赋值，并可以调用该表达式：

Transformer sqr = x => x * x;

Console.WriteLine (sqr(3));

// 9

编译器在内部将这种 Lambda 表达式编译为一个私有的方法，并将表达式代码转移到该方法中。

Lambda 表达式拥有以下的形式：

(parameters) => expression-or-statement-block

为了方便，在只有一个可推测类型的参数时，可以省略参数表外围的小括号。

本例中，只有一个参数 x

，而表达式是 x * x

：

x => x * x;

Lambda 表达式的每一个参数都对应委托的一个参数，而表达式的类型（可以是 void

）对应着委托的返回类型。

本例中，x

对应参数 i

，表达式 x * x

的类型对应着返回值类型 int

，因此它和 Transformer

委托是兼容的：

delegate int Transformer (int i);

Lambda 表达式的代码除了表达式之外还可以是语句块，因此上例可以改写成：

x => { return x * x; };

Lambda 表达式通常与 Func

和 Action

委托一起使用，因此前面的表达式通常写成如下形式：

Func<int,int> sqr = x => x * x;

以下是带有两个参数的表达式示例：

Func<string,string,int> totalLength = (s1, s2) => s1.Length + s2.Length;

int total = totalLength ("hello", "world");  // total is 10;

4.3.1　显式指定 Lambda 参数的类型

编译器通常可以根据上下文推断出 Lambda 表达式的类型，但是当无法推断的时候则必须显式指定每一个参数的类型。请考虑如下方法：

void Foo<T> (T x)     {}

void Bar<T> (Action<T> a) {}

以下代码无法通过编译，因为编译器无法推断 x 的类型：

Bar (x => Foo (x));   // What type is x?

我们可以通过显式指定 x

的类型来修正这个问题：

Bar ((int x)

=> Foo (x));

这个简单的例子还可以用其他两种方式修正：

Bar<int>

(x => Foo (x));  // Specify type parameter for Bar

Bar<int> (Foo);      // As above, but with met

hod group

4.3.2　捕获外部变量

Lambda 表达式可以引用其定义所在的方法内定义的局部变量和参数（称之为外部变量）。例如：

static void Main(){ int factor = 2; Func<int, int> multiplier = n => n * factor

;



Console.WriteLine (multiplier (3));      // 6}

Lambda 表达式所引用的外部变量称为捕获变量。含有捕获变量的表达式称为闭包。

变量也可以被匿名方法和局部方法捕获。捕获变量的规则都是一样的。

捕获变量会在真正调用委托时赋值，而不是在捕获时赋值：

int factor = 2;Func<int, int> multiplier = n => n * factor;factor = 10;

Console.WriteLine (multiplier (3));      // 30

Lambda 表达式也可以更新捕获变量的值：

int seed = 0;

Func<int> nat

ural = () => seed++;Console.Write

Line (natural());      // 0Console.Write

Line (natural());      // 1Console.Write

Line (seed);        // 2

捕获变量的生命周期延伸到了和委托的生命周期一致。在以下例子中，局部变量 seed

本应该在 Natural

执行完毕后从作用域中消失，但由于 seed

被捕获，因此其生命周期已经和捕获它的委托 natural

保持一致了：

static Func<int> Natural(){ int seed = 0; return () => seed++;   // Returns a closure

}st

a

tic void Main(){

F

unc<int> natural =

Na

tural();

C

onsole.WriteLine (n

at

ural());   // 0

C

onsole.WriteLine (n

at

ural());   // 1}

在 Lambda 表达式内实例化的局部变量对于每一次委托实例的调用都是唯一的。如果更改上述示例，在 Lambda 表达式内实例化 seed

，则程序的结果（当然这个结果是不被期望的）将与之前不同：

static Func<int> Natural()

{ return() => { int seed =

0

; return seed++; };}static void Main(){ Func<int> natural = Natu

ra

l(); Console.WriteLine (natur

al

());      // 0 Console.WriteLine (natur

al

());      // 0}

内部捕获变量是通过将变量「提升」为私有类的字段的方式实现的。当调用方法时，实例化该私有类，并将其生命周期绑定在委托实例上。

捕获迭代变量

当捕获 for

循环中的迭代变量时，C# 会认为该变量是在循环体外定义的。这意味着同一个变量在每一次迭代都被捕获了，因此以下程序输出 333

而非 012

：

Action[] actions = new Action[3];for (int i = 0; i < 3; i++) actions [i] = () => Console.Write (i)

;



f

ore

ach (Action a in actions) a();   // 333

每一个闭包（加粗的部分）都捕获了相同的变量 i

（如果变量 i

在循环中保持不变，则非常有效；甚至可以在循环体中显式更改 i

的值），而这个后果是每一个委托只在调用的时候才看到 i

的值，而这时 i

已经是 3

了。将 for

展开更便于理解：

Action[] actions = new Action[3];

int i = 0;actions[0] = () => Console.Write

(i);i = 1;actions[1] = () => Console.Write

(i);i = 2;actions[2] = () => Console.Write

(i);i = 3;foreach (Action a in actions) a()

;  // 333

如果希望输出 012

，那么需要将迭代变量指定到循环内部的局部变量中：

Action[] actions = new Action[3];for (int i = 0; i < 3; i++){ int loopScopedi = i

; actions [i] = () => Console.Write (loopScopedi

);

}fo

re

ach (Action a in actions) a();   // 012

由于 loopScopedi

对于每一次迭代都是新创建的，因此每一个闭包都将捕获不同的变量。

在 C# 5.0 之前，foreach

循环和 for

循环在闭包中的行为是相同的：

Action[] actions = new Action[3];

int i = 0;foreach (char c in "abc") actions [i++] = () => Console.W

rite (c); foreach (Action a in actions) a()

;  // ccc

i

n C# 4.0

这会引起很大的困惑：与 for

循环不同，foreach

循环中的迭代变量是不可变的，所以可以将它作为循环体的局部变量。C# 5.0 修复了这个问题，上面的例子会输出「abc」。

4.3.3　Lambda 表达式和局部方法的对比

局部方法（请参见 3.1.3 节）和 Lambda 表达式的相应功能是重叠的。但局部方法拥有以下三个优势：

局部方法无须使用奇怪的技巧就可以实现递归（自己调用自己）。

局部方法避免了定义杂乱的委托类型。

局部方法的开销更小。

局部方法更加高效，因为它不需要间接使用委托（委托会消耗更多的 CPU 时钟周期并使用更多的内存），而且当它们访问局部变量的时候不需要编译器像委托那样将捕获变量放到一个隐藏类中。

但是，在许多情况下仍然需要使用委托。尤其是当需要调用高阶函数的时候，即使用委托作为参数的方法：

public void Foo (Func<int,bool>

predicate) { ... }

（第 8 章将涉及更多的内容。）在这种情况下，就不得不使用委托了。特别是，针对这种情况，Lambda 表达式通常会显得更加简洁和清晰。

4.4　匿名方法

匿名方法是 C# 2.0 引入的特性，并通过 C# 3.0 的 Lambda 表达式得到了极大的扩展。匿名方法类似于 Lambda 表达式，但是没有以下特性：

隐式类型的参数

表达式语法（匿名方法必须是一个语句块）

在赋值给 Expression<T>

时将其编译为表达式树的能力

匿名方法的写法是在 delegate

关键字后紧跟参数的声明（可选），然后是方法体。例如，以下面的委托为例：

delegate int Transformer (int i);

以下是实现和调用匿名方法的示例：

Transformer sqr = delegate (int x) {return x * x;}

;

C

onsole.WriteLine (sqr(3));              // 9

第一行代码在语义上等同于下面的 Lambda 表达式：

Transformer sqr =    (int x) => {return x * x;}

;

或者更简单的：

Transformer sqr =      x => x * x;

匿名方法和 Lambda 表达式捕获外部变量的方式是完全一样的。

完全省略参数的声明是匿名方法独有的特性，即使委托需要这些参数声明。该特性尤其适用于声明具有空事件处理器的事件：

public event EventHandler Clicked = delegate { };

这样，在触发事件时就避免了 null

检查。下面的写法是合法的：

// Notice that we omit the parameters:

Clicked += delegate { Console.WriteLin

e ("clicked"); };

4.5　try

语句和异常

try

语句是为了处理错误或者执行清理代码而定义的语句块。try

语句块后面必须跟 catch

语句块或者 finally

语句块，或者两者都有。当 try

块执行并发生错误时，则执行 catch

语句块。当 try

块结束时（或者如果当前是 catch

块，则当 catch

块结束时），不管有没有发生错误，都会执行 finally

块来执行清理代码。

catch

块可以访问 Exception

对象，该对象包含错误信息。在 catch

块中可以处理错误，也可以再次抛出异常。例如，记录日志并重新抛出异常或者抛出一个更高层次的异常。

finally

块为程序的执行提供了确定性：CLR 会尽最大努力保证其执行。它通常用于执行清理任务，例如关闭网络连接等。

try

语句的使用示例如下：

try

{ .

..

// exception may get thrown within execution of this block}cat

ch

(ExceptionA ex){ .

..

// handle exception of type ExceptionA}cat

ch

(ExceptionB ex){ .

..

// handle exception of type ExceptionB}fin

al

ly{ .

..

// cleanup code}

考虑如下的程序：

class Test

{ static i

nt

Calc (int x) => 10 / x;  static v

oi

d Main() {  int y

=

Calc (0);  Consol

e.

WriteLine (y); }}

由于 x

是 0

，因此运行时将抛出 DivideByZeroException

，程序终止。我们可以通过 catch

捕获异常来防止程序提前终止：

class Test{ static int Calc (int x) => 10 / x;  static void Main() {  try

{

int y = Calc (0);   Console.WriteLine (y);  }

catch (DivideByZeroException ex)

{

Console.WriteLine ("x cannot be zero");  }

Console.WriteLine ("program completed"); }}

输出为：

x cannot be zero

program complete

d

上述程序只是作为异常处理的简单示例。在实际工作中，更好的方法是在调用 Calc

之前显式检查除数是否为 0。

我们更提倡提前进行检查以避免错误，而不是依赖 try

/catch

块。因为异常处理的代价比较昂贵，通常需要超过几百个时钟周期。

当 try

语句中抛出异常时，公共语言运行时（CLR）会执行如下测试：try

语句是否具有兼容的 catch

语句块呢？

如果有，则执行点转移到可以处理相应异常的 catch

块。之后再跳转到 finally

块（如果有的话）继续正常执行。

如果没有，则执行点会直接跳转到 finally

语句块（如果有的话）。之后 CLR 会从调用栈中寻找其他的 try

语句块，如果找到则重复上述测试。

如果没有任何函数处理该异常，程序将终止执行。

4.5.1　catch

子句

catch

子句定义捕获哪些类型的异常，这些异常应当是 System.Exception

或者 System.Exception

的子类。

捕获 System.Exception

表示捕获所有可能的异常，通常用于如下场景：

不论何种类型的异常，程序都可以恢复。

（在记录日志之后）重新抛出该异常。

程序终止前的最后一个错误处理函数。

比上述更常见的做法则是捕获特定类型的异常（例如 OutOfMemoryException

），以避免出现设计中遗漏特定的情景的情况。

可以使用多个 catch

子句处理多种异常类型（同样，以下的例子也可以提前进行显式参数检查而不是进行异常处理）：

class Test

{ static v

oi

d Main (string[] args) {  try  {   byte

b

= byte.Parse (args[0]);   Cons

ol

e.WriteLine (b);  }  catch

(I

ndexOutOfRangeException ex)  {   Cons

ol

e.WriteLine ("Please provide at lea

st o

ne argum

ent");

}  catch

(F

ormatException ex)  {   Cons

ol

e.WriteLine ("That's not a number!"

);  }  catch

(O

verflowException ex)  {   Cons

ol

e.WriteLine ("You've given me more

than

a byte!

");  } }}

一个 catch

子句只针对一种给定的异常。如果想通过捕获更普遍的异常（如 System.Exception

）来构建安全网，则必须把处理特定异常的逻辑放在前面。

如果不需要访问异常的属性，可以捕获异常但不指定变量：

catch (OverflowException)  // no variable

{ ...}

甚至，可以同时忽略异常的类型和变量（即捕获所有的异常）：

catch { ... }

异常筛选器

在 catch

子句中添加 when

子句可以指定异常筛选器：

catch (WebException ex) when (ex.Status == WebExceptionStatus.Timeout)

{

...}

如果本例中抛出了 WebException

，则 when

关键字后指定的布尔表达式就会执行。如果执行结果为 false

，则 catch

块会被忽略，继而评估后续的 catch

块。有了异常筛选器后，就可以重复捕获同类型的异常了：

catch (WebException ex) when (ex.Status == WebExceptionStatus.Timeout)

{ ... }catch (WebException ex) when (ex.Status == WebExceptionStatus.SendFail

ure){ ... }

when

子句中的布尔表达式可能会产生副作用，例如调用一个方法记录诊断所需的异常的日志。

4.5.2　finally

块

无论代码是否抛出异常，也无论 try

程序块是否完全执行，finally

程序块总会执行。通常，finally

块用于执行清理工作。

finally

块会在以下任一种情况后执行：

在 catch

块执行完成后（或抛出一个新的异常时）。

try

块执行完成后（或者抛出了一个异常但没有任何 catch

块捕获该异常）。

控制逻辑使用 jump

语句离开了 try

块（例如 return

或 goto

）。

唯一能够阻止 finally

块执行的就是无限循环，或者应用程序进程突然终止。

finally

块为程序添加了确定性保证。在以下示例中，即使发生了以下情况，打开的文件也总是能够关闭：

try

块正常结束。

由于空文件（EndOfStream）

而提前返回。

读取文件时抛出了 IOException

。

static void ReadFile(){ StreamReader reader = null;  // In System.IO namespace try {  reader = File.OpenText ("file.txt");  if (reader.EndOfStream) return

;



Console.WriteLine (reader.ReadToEnd());

}

finally

{

if (reader != null) reader.Dispose();

}}

本例通过 StreamReader

的 Dispose

方法来关闭文件。在 finally

块中调用 Dispose

方法是贯穿.NET Core 的标准约定，在 C# 中也有 using

语句提供直接支持。

using

语句

许多类的内部都封装了非托管资源（例如文件句柄、图像句柄、数据库连接等）。这些类都实现了 System.IDisposable

接口，而该接口定义了一个名称为 Dispose

的无参数方法用于清除这些非托管资源。using

语句提供了一种在 finally

块中调用 IDisposable

接口对象的 Dispose

方法的优雅方式。因而以下语句：

using

(StreamReader reader = File.OpenText ("file.txt"))

{ ...}

完全等价于：

{



StreamReader reader = File.OpenText ("file.txt");

try

{

...

}

finally

{

if (reader != null)

((IDisposable)reader).Dispose();

}}

using

声明（C# 8）

如果忽略 using

语句后的括号和语句块，那么 using

语句就成了 using

声明。相关的资源会在程序执行到包含该声明的语句块外时得到释放：

if (File.Exists ("file.txt")){

using var reader = File.OpenText ("file.txt");

Console.WriteLine (reader.ReadLine()); ...}

在上述代码中，reader

对象会在程序执行到 if

语句块外时调用其 Dispose

方法。

4.5.3　抛出异常

运行时或用户代码都可以抛出异常。以下例子中，Display

方法会抛出 System.ArgumentNullException

：

class Test{ static void Display (string name) {  if (name == null)   throw new ArgumentNullException (nameof (name));

Console

.WriteLine (name); }  static vo

id Main() {  try { D

isplay (null); }  catch (

ArgumentNullException ex)  {   Conso

le.WriteLine ("Caught the exce

ptio

n")

;  } }}

throw

表达式

throw

也可以以表达式的形式出现在表达式体函数中：

public string Foo() => throw new NotImplementedException()

;

throw

表达式也可以出现在三元条件表达式中：

string ProperCase (string value) => value == null ? throw new ArgumentException ("value")

:



value == "" ? "" :

char.ToUpper (value[0

]) + value.Substring (1);

重新抛出异常

异常被捕获后可以再次抛出，例如：

try { ... }catch (Exception ex){ // Log error ... throw;     // Rethrow same exception

}

如果将 throw

替换为 throw ex

，那么这个例子仍然有效。但是新产生异常的 StackTrace

属性不再反映原始的错误。

重新抛出异常可用于需要记录错误但是并不将异常隐藏的情形，也可以在异常超出处理范围的情况下放弃对异常进行处理。

using System.Net;    // (See Chapter 16

)...string s = null;using (WebClient wc = new WebClient()) try { s = wc.DownloadString ("http://www.albahari.com/nutshell/"); } catch (WebException ex) {  if (ex.Status == WebExceptionStatus.Timeout)   Console.WriteLine ("Timeout");  Else   throw;   // Can't handle other sorts of WebException, so rethrow

}

上述例子可以使用异常筛选器简写成：

catch (WebException ex) when (ex.Status == WebExceptionStatus.Timeout)

{ Console.WriteLine ("Timeout");}

另一种常见情形是重新抛出某个明确类型的异常：

try

{ .

..

// Parse a DateTime from XML element data}cat

ch

(FormatException ex){ t

hr

ow new XmlException ("Invalid DateTime", ex);}

请注意，当构建 XmlException

时，我们将原始的异常 ex

作为第二个参数。这个参数将作为新异常的 InnerException

属性辅助诊断。几乎所有类型的异常都提供了类似的构造器。

在跨越信任边界时，常用做法是重新抛出一个不那么明确的异常，以防止技术信息泄露而给黑客可乘之机。

4.5.4　System.Exception

的关键属性

System.Exception

类的重要属性有以下几个：

StackTrace

：表示一个异常从起源到 catch 块的所有调用方法的字符串。

Message

：描述异常的字符串。

InnerException：导致外部异常的内部异常（如果有的话）。而内部异常本身也可以有另外一个 InnerException

。

C# 的所有异常都是运行时异常，没有和 Java 对等的编译时检查异常。

4.5.5　常用的异常类型

以下所列的异常类型在 CLR 和.NET Core 中广泛使用，可以在程序中抛出这些异常或者将其作为基类派生自定义的异常类型：

System.ArgumentException

：当使用不恰当的函数参数调用函数时抛出。这通常表明应用程序有缺陷。

System.ArgumentNullException

：ArgumentException

的子类，它在函数的参数（意外地）为 null

时抛出。

System.ArgumentOutOfRangeException

：ArgumentException

的子类。当（通常是数值）参数太大或者太小时抛出。例如，当向只能接受正数的函数传递负数时抛出。

System.InvalidOperationException

：当对象的状态无法使方法成功执行的时候抛出（不论参数值如何）。例如，读取未打开的文件或在列表对象已修改的情况下用枚举器访问其下一个元素。

System.NotSupportedException

：抛出该异常表示不支持特定的功能。例如，在 IsReadOnly

为 true

的集合上调用 Add

方法。

System.NotImplementedException

：表示函数还没有实现。

System.ObjectDisposedException

：当函数调用的对象已被销毁时抛出。

另一个常见的异常类型是 NullReferenceException

。当一个对象的值为 null

而访问其成员时，CLR 就会抛出这个异常（表示代码有缺陷）。使用下面的语句会直接抛出一个 NullReferenceException

异常（仅用于测试）：

throw null;

4.5.6　Try

XXX

方法模式

编写方法时需要考虑方法出错时的行为：可以返回某个特定的错误代码，也可以抛出一个异常。一般情况下，如果错误发生在正常的工作流程之外或者方法的直接调用者很可能无法处理这个错误时，选择抛出异常。但是有些情况下最好给调用者提供两种选择。int

类型是一个典型的例子，它为 Parse

方法定义了两个版本：

public int Parse   (string input);

public bool TryParse (string input,

out int returnValue);

如果解析失败，则 Parse

方法抛出一个异常，而 TryParse

方法则返回 false

。

可以用如下的方式令 XXX

方法调用 Try

XXX

方法来实现这种模式：

public return-type XXX

(input-type input

){ return-type

returnValue; if (!TryXXX

(input, out returnValue))  throw new YYY

Exception (...)

return return

Value;}

4.5.7　异常的替代方式

在 int.TryParse

中，函数可以通过返回类型或者参数向调用函数返回错误代码。尽管对于简单的可预见的错误这个方式可行，但是如果要应对所有的错误类型就显得捉襟见肘了。这样做不仅会使方法的签名晦涩，而且增加了不必要的复杂性，使代码变得混乱。此外，这种做法也不能推广到如运算符（例如，除法运算符）、属性等不是方法的函数上。此时，一种替代方式是将错误放在公共地方使其对调用栈中所有的函数都可见（例如：每一个线程中存储当前错误的静态方法）。但是，这要求每个函数都参与到这种错误传播模式中，本身既冗长又容易出错。

4.6　枚举类型和迭代器

4.6.1　枚举类型

枚举器是一个只读的且只能在值序列上前移的游标。在 C# 中，如果类型满足以下规则中的任一条，那么该类型就可以作为枚举器使用：

实现了 System.Collections.IEnumerator

接口。

实现了 System.Collections.Generic.IEnumerator<T>

接口。

拥有 public

的无参的 MoveNext

方法，并拥有一个 public

的名为 Current

的属性。

foreach

语句用来在可枚举对象上执行迭代操作。可枚举对象指逻辑上的序列，它本身不是游标，但是它可以在对象自身上生成游标。在 C# 中，如果类型满足以下规则中的任意一种，那么该类型就是一个可枚举类型：

实现了 System.Collections.IEnumerable

接口。

实现了 System.Collections.Generic.IEnumerable<T>

接口。

拥有 public

的无参 GetEnumerator

方法，且该方法返回一个枚举器。

枚举类型的模式如下：

class Enumerator

// Typically implements IEnumerator or IEnumerator<T>{ public IteratorVariableType

Current { get {...} } public bool MoveNext() {...}}class Enumerable

// Typically implements IEnumerable or IEnumerable<T>{ public Enumerator

GetEnumerator() {...}

}

以下是以高层次的方式使用 foreach 语句遍历单词 bear 中每一个字母的方法：

foreach (char c in "beer")

Console.WriteLine (c);

而下面是使用低层的调用（即不用 foreach

语句）遍历单词 bear 中每一个字母的方法：

using (var enumerator = "beer".GetEnumerator()

) while (enumerator.MoveNext()

) {  var element = enumerator.Current

;



Console.WriteLine (element);

}

如果枚举器实现了 IDisposable

，则 foreach

语句也会起到 using

语句的作用，隐式销毁枚举器对象。

第 7 章将详细介绍枚举相关的接口。

4.6.2　集合的初始化器

只需一个简单的步骤就可以实例化并填充可枚举对象：

using System.Collections.Generic;...List<int> list = new List<int> {1, 2, 3}

;

编译器将其翻译为：

using System.Collections.Generic;

...List<int> list = new List<int>();

list.Add (1);list.Add (2);list.Add (3);

它要求可枚举对象实现 System.Collections.IEnumerable

接口，并且有可以调用的带适当数量参数的 Add

方法。同样我们也能够使用类似的方式初始化字典（请参见 7.5 节）：

var dict = new Dictionary<int, string>()

{ { 5, "five" }, { 10, "ten" }};

或者更加简洁地写为：

var dict = new Dictionary<int, string>()

{ [3] = "three", [10] = "ten"};

第二种写法不仅适用于字典，而且适用于任何具有索引器的类型。

4.6.3　迭代器

foreach

语句是枚举器的消费者；相反，迭代器是枚举器的生产者。下例中，我们使用迭代器来返回斐波那契数列（斐波那契数列中的每一个数字是前两个数字之和）：

using System;using System.Collections.Generic;class Test{ static void Main() {  foreach (int fib in Fibs(6))   Console.Write (fib + " "); } static IEnumerable<int> Fibs (int fibCount) {  for (int i = 0, prevFib = 1, curFib = 1; i < fibCount; i++)  {   yield return prevFib;

int newFib = prevFib + curFib;   prevFib = curFib;   curFib = newFib;  } }}

输出为：

1 1 2 3 5 8

return

语句表示「这是该方法的返回值」，而 yield return

语句则表示「这是当前枚举器产生的下一个元素」。在每条 yield

语句中，控制都返回给调用者，但是必须同时维护被调用者的状态，以便调用者枚举下一个元素时方法能够继续执行。该状态的生命周期是与枚举器绑定的，当调用者枚举结束后，该状态就可以被释放。

编译器将迭代方法转换为实现了 IEnumerable<T>

或 IEnumerator<T>

的私有类。迭代器块中的逻辑被「反转」并分别进入编译器生成的枚举器类的 MoveNext

方法和 Current

属性。当调用迭代器方法的时候，所做的仅仅是实例化编译器生成的类，而迭代器代码并没有真正执行。编写的迭代器代码只有当开始枚举结果序列时才开始执行，通常使用 foreach

语句。

迭代器可以是局部方法（请参见 3.1.3 节）。

4.6.4　迭代器语义

迭代器是包含一个或者多个 yield

语句的方法、属性或者索引器。迭代器必须返回以下四个接口之一（否则编译器会产生相应错误）：

// Enumerable interfaces

System.Collections.IEnum

erableSystem.Collections.Gener

ic.IEnumerable<T>// Enumerator interfaces

System.Collections.IEnum

eratorSystem.Collections.Gener

ic.IEnumerator<T>

迭代器具有不同的语义，取决于迭代器返回的是可枚举接口还是枚举器接口，这将在第 7 章介绍。

一次可以使用多个 yield

语句，例如：

class Test{ static void Main() {  foreach (string s in Foo())   Console.WriteLine(s);     // Prints "One","Two","Three" }  static IEnumerable<string> Foo() {  yield return

"One";  yield return

"Two";  yield return

"Three";

}}

yield break

语句

return

语句在迭代器块中是非法的。在迭代器块中如果希望提前退出，应该使用 yield break

语句。我们可以对 Foo

做如下修改：

static IEnumerable<string> Foo (bool breakEarly){ yield return "One"; yield return "Two";  if (breakEarly)  yield break;

yield r

eturn "Three";}

迭代器和 try

/catch

/finally

语句块

yield return

语句不能出现在带 catch

子句的 try

语句块中：

IEnumerable<string> Foo()

{ try { yield return "One

";

}  // Illegal catch { ... }}

yield return

语句也不能出现在 catch

或者 finally

语句块中。出现这些限制的原因是编译器必须将迭代器转换为带有 MoveNext

、Current

和 Dispose

成员的普通类，而转换异常处理语句块会大大增加代码的复杂性。

但是可以在只带有 finally

块的 try

语句块中使用 yield

语句：

IEnumerable<string> Foo()

{ try { yield return "One

";

}  // OK finally { ... }}

当枚举器到达序列末尾或被销毁时就可以执行 finally

块了。如果枚举提前结束，则 foreach

语句会隐式销毁枚举器，这是消费枚举器的安全且正确的做法。当显式使用枚举器时，会有一个陷阱，即提前结束枚举而不销毁枚举器，从而绕过 finally

块的执行。可以将枚举器的使用显式包裹在 using

语句中来避免上述错误：

string firstElement = null;

var sequence = Foo();using (var enumerator = seq

uence.GetEnumerator())

if (enumerator.MoveNext()

)  firstElement = enumerat

or.Current;

4.6.5　组合序列

迭代器有高度可组合性。我们可以扩展前面的示例，只输出偶数斐波那契数列：

using System;using System.Collections.Generic;class Test{ static void Main() {  foreach (int fib in EvenNumbersOnly (Fibs(6)))   Console.WriteLine (fib); }  static IEnumerable<int> Fibs (int fibCount) {  for (int i = 0, prevFib = 1, curFib = 1; i < fibCount; i++)  {   yield return prevFib;

int newFib = prevFib + curFib;   prevFib = curFib;   curFib = newFib;  } }  static IEnumerable<int> EvenNumbers

Only (IEnumerable<int> s

equence) {  foreach (int x in sequence)   if ((x % 2) == 0)    yield return x; }}

每一个元素都只有到了最后关头（即执行 MoveNext ()

操作）时才会进行计算，图 4-1 显示了随时间变化的数据请求和数据输出。

迭代器模式的可组合性对 LINQ 而言非常重要，这将在第 8 章进行讨论。

图 4-1：组合序列

4.7　可空值类型

引用类型可以使用空引用表示一个不存在的值，然而值类型不能直接表示为 null

：

string s = null;    // OK, reference type

int i = null;     // Compile error, val

ue type cannot be null

若要在值类型中表示 null

，则必须使用特殊的结构（即可空值类型）。可空值类型是由值类型后加一个「?

」表示的：

int? i = null;           // OK, nullable type

Console.WriteLine (i == null);   // True

4.7.1　Nullable<T>

结构体

T?

会翻译为 System.Nullable<T>

，它是一个轻量级的不可变结构体。它只有两个字段，分别代表 Value

和 HasValue

。System.Nullable<T>

本质上很简单：

public struct Nullable<T> where T : struct

{ public T Value {get;} public bool HasValue {get;} public T GetValueOrDefault(); public T GetValueOrDefault (T defaultVal

ue

); ...}

代码：

int? i = null;

Console.WriteL

ine (i == null);       // True

将翻译为：

Nullable<int> i = new Nullable<int>();

Console.WriteLine (! i.HasValue);

// True

当 HasValue

为 false

时，若试图获得 Value

，将会抛出 InvalidOperationException

异常。当 HasValue

为 true

时，GetValueOrDefault ()

会返回 Value

，否则返回 new T ()

或者一个特定的自定义默认值。

T?

的默认值为 null

。

4.7.2　隐式和显式的可空值类型转换

从 T

到 T?

的转换是隐式的，反之则是显式的。例如：

int? x = 5;    // implicit

int y = (int)x;  // explicit

显式强制转换与直接调用可空对象的 Value

属性实质上是等价的。因此，当 HasValue

为 false

时将抛出 InvalidOperationException

。

4.7.3　装箱拆箱可空值

当 T?

类型的对象装箱后，堆中的装箱值包含的是 T

，而非 T?

。这种优化方式是可行的，因为装箱值已经是一个可以赋值为 null

的引用类型了。

C# 允许通过 as

运算符对一个可空值类型进行拆箱。如果强制转换出错，那么结果为 null

：

object o = "string";

int? x = o as int?;Console.WriteLine (x

.HasValue);  // Fal

se

4.7.4　运算符优先级提升

Nullable<T>

结构体并没有定义诸如 <

、>

、==

之类的运算符。尽管如此，以下代码仍然能够正常编译和执行：

int? x = 5;

int? y = 10

;bool b = x

< y;   //

true

这是因为编译器会从实际值类型借用或者「提升」< 运算符。在语义上，它会将前面的比较表达式转换为如下的语句：

bool b = (x.HasValue && y.HasValue) ? (x.Value < y.Value) : false;

换句话说，如果 x

和 y

都有值，那么它会通过 int

的 < 运算符做比较；否则会返回 false

。

运算符提升意味着可以隐式使用 T

的运算符来处理 T?

。可以专门针对 T?

进行运算符重载来实现特殊的空值行为。但是在大多数情况下，最好还是通过编译器来自动地应用系统的空值逻辑。以下是一些示例：

int? x = 5;int? y = null;// Equality operator examplesConsole.WriteLine (x == y);  // FalseConsole.WriteLine (x == null); // FalseConsole.WriteLine (x == 5);  // TrueConsole.WriteLine (y == null); // TrueConsole.WriteLine (y == 5);  // FalseConsole.WriteLine (y != 5);  // True// Relational operator examplesConsole.WriteLine (x < 6);   // TrueConsole.WriteLine (y < 6);   // FalseConsole.WriteLine (y > 6);   // False// All other operator examplesConsole.WriteLine (x + 5);   // 10Console.WriteLine (x + y);   // null

(prints empty line)

编译器会根据运算符的类别来执行空值逻辑。以下几小节将介绍这些不同的规则。

相等运算符（==

和！=

）

提升后的相等运算符可以像引用类型那样处理空值。这意味着两个 null

值是相等的：

Console.WriteLine (    null

==    null

);  // TrueConsole.WriteLine ((bool?)null

== (bool?)null

);  // True

而且：

如果只有一个操作数为 null

，那么两个操作数不相等。

如果两个操作数都不为 null

，则比较它们的 Value

。

关系运算符（<

、<=

、>=

、>

）

对于关系运算符而言，比较 null

操作数是没有意义的。因此比较空值和另外一个空值或非空值的结果都是 false

：

bool b = x < y;  // Translation:

bool b = (x.HasValue && y.HasValue

)

? (x.Value < y.Value)     : false;         // b is false (assuming x is 5 and



y is null)

其他运算符（+

、-

、*

、/

、%

、&

、|

、^

、<<

、>>

、+

、++

、--

、!

和～

）

当任意一个操作数为 null

时，这些运算符都会返回 null

。SQL 用户应当非常熟悉这种模式：

int? c = x + y;  // Translation:

int? c = (x.HasValue && y.HasValu

e

)     ? (int?) (x.Value + y.Va

l

ue)     : null;         // c is null (assuming x is 5 and



y is null)

唯一的例外是计算 bool?

的 &

和 |

运算符，稍后将对此进行详细讨论。

混合使用可空和非空类型操作数的运算符

混合使用可空或非空值类型是可行的，因为 T

与 T?

之间存在着隐式转换机制：

int? a = null;

int b = 2;int? c = a + b

;  // c is

null - equivalent to a + (int?)b

4.7.5　在 bool?

上使用 &

和｜

运算符

如果操作数的类型为 bool?

，那么 &

和 |

运算符会将 null

作为一个未知值看待。则 null | true

应当返回 true

，因为：

如果未知值为假的，那么结果为真；

如果未知值是真的，那么结果为真。

类似地，null & false

的结果为 false

。这个行为和 SQL 非常相似，以下的例子说明了一些其他的组合用法：

bool? n = null;bool? f = false;bool? t = true;Console.WriteLine (n | n);  // (null

)Console.WriteLine (n | f);  // (null

)Console.WriteLine (n | t);  // TrueConsole.WriteLine (n & n);  // (null

)Console.WriteLine (n & f);  // FalseConsole.WriteLine (n & t);  // (null

)

4.7.6　可空值类型和 null

运算符

可空值类型与？

运算符相辅相成（请参见 2.10.1 节）。如以下示例所示：

int? x = null;int y = x ?? 5;    // y is 5int? a = null, b = 1, c = 2;Console.WriteLine (a ?? b ?? c); // 1 (first non-null value

)

在可空值类型上使用？

运算符相当于调用 GetValueOrDefault

方法并提供一个显式的默认值，但变量如果不是 null

的话则不会使用默认值。

可空值类型同样适用于 null

条件运算符（请参见 2.10.3 节）。在下面的例子中，length

的值为 null

：

System.Text.StringBuilder sb = null;

int? length = sb?.ToString().Length;

还可以结合使用 null

合并运算符和 null

条件运算符来最终得到 0

而不是 null

：

int length = sb?.ToString().Length ?? 0; // Evaluates to 0 if sb is null

4.7.7　可空值类型的应用场景

可空值类型常用来表示未知的值，在数据库编程中尤为常见。数据库编程通常需要将类映射到具有可空列的数据表中。如果这些列是字符串类型（例如 Customer 表的 EmailAddress 列），就没有任何问题，因为字符串是一种 CLR 引用类型，因而可以为 null

；而有些 SQL 列的类型是值类型，因而要使用可空值类型将这些 SQL 的列映射到 CLR 中。例如：

// Maps to a Customer table in a database

public class Customer{ ... public decimal? AccountBalance;}

可空值类型还可以用于表示支持字段，即所谓的环境属性（ambient property）。如果环境属性的值为 null

，则返回父类的值。例如：

public class Row

{ ... Grid parent; Color? color; public Color C

ol

or {  get { return

c

olor ?

? parent.Color;

}  set { color

=

value

== parent.Color

? (Color?)null

: value; } }}

4.7.8　可空值类型的替代方案

在可空值类型成为 C# 语言的一部分之前（例如 C# 2.0 以前的版本），也有许多处理可空值类型的方式。由于历史原因，这些方式现在仍然存在于.NET Core 中。其中之一就是将一个特定的非空值指定为「空值」。字符串和数组类中就有这样的方式。例如 String.IndexOf

在找不到字符时会返回一个特殊的「魔法值」-1

。

int i = "Pink".IndexOf ('b');

Console.WriteLine (i);

// −1

然而，Array.IndexOf

只有在索引为 0

的时候才会返回 - 1

。最常见的规则是 IndexOf

返回比数据下限小 1

的值。在下例中，IndexOf

在没有找到某个元素时返回 0

。

// Create an array whose lower bound is 1 instead of 0:

Array a = Array.CreateInstance (typeof (string),                new int[] {2}, new int[

] {1});a.SetValue ("b", 2);Console.WriteLine (Array.IndexOf (a, "c")); // 0

指定「魔法值」会造成各种问题，以下列举了一些原因：

每一个值类型有不同的空值表示方式。与之相反，使用可空值类型可以用一种通用模式处理任意的值类型。

可能无法找到一个合理的值。例如上述例子中，我们无法总是使用 - 1

。更早的例子中表示一个未知账号余额的方式也有相同的问题。

如果忘记对魔法值进行测试可能导致长期忽略不正确的数据，直至在后续运行中出现一个出乎意料的结果。而如果忘记测试 HasValue

为 null

的情况，则会马上抛出 InvalidOperationException

。

没有在类型层面上处理值可以为 null

的能力。类型可以传达程序的意图，并允许编译器检查其正确性，从而和编译器的规则保持一致。

4.8　可空引用类型（C# 8）

可空值类型令值类型可以使用空值；而可空引用类型却正相反，它可以一定程度上防止引用类型的值为空值，并进一步避免 NullReferenceException

。

可空引用类型所提供的一定程度上的安全性完全是由编译器来承担的。当编译器发现代码可能存在产生 NullReferenceException

的风险时，它就会发出一系列警告。

如需启用可空引用类型功能，需要在.csproj 工程文件中添加相应的 Nullable

元素（这样做将在整个工程范围内启用该功能）：

<PropertyGroup> <Nullable>enable</Nullable>

</PropertyGroup>

也可以在代码中直接使用以下指令来圈定该功能的生效范围：

#nullable enable  // enables nullable reference types from this point on

#nullable disable // disables nullable reference types from this point on

#nullable restore // resets  nullable reference types to project setting

功能启用之后，编译器将默认认定引用非空。如需令引用类型接受空值，则需要添加？

后缀来标记该引用为可空引用类型。在以下示例中，s1

为不可空的，而 s2

是可空的：

#nullable enable  // Enable nullable reference typesstring s1 = null;  // Generates a compiler warning!string?

s2 = null; // OK: s2 is nullable reference type

由于可空引用类型是编译期功能，因此 string

和 string?

在运行时的行为是一致的。相反，可空值类型则在类型系统引入了名为 Nullable<T>

的新类型。

由于 x 没有初始化，以下代码将会生成一个警告：

class Foo { string x; }

如果通过字段初始化器或构造器代码对 x 进行初始化，警告就会消失。

4.8.1　null

包容运算符

当对可空引用类型执行解引用操作时，若编译器认为相应操作可能产生 NullReference-Exception

，则仍然会生成警告。在以下示例中，访问字符串对象的 Length

属性会生成警告：

void Foo (string?

s) => Console.Write (s.Length

);

此时，可以使用 null

包容运算符（!

）来消除这个警告：

void Foo (string? s) => Console.Write (s!.Length

);

上述示例中的 null 包容运算符是危险的，因为有可能抛出 NullReferenceException（而这恰恰是我们希望避免的）。因此可以做如下的修正：

void Foo (string? s)

{ if (s != null) Con

so

le.Write (s.Length);}

注意，此处无须使用 null

包容运算符。因为编译器通过静态流程分析足以推断出解引用操作是安全的（至少在这种简单的例子中），不会产生 NullReferenceException

。

编译器提供的检查和警告手段并非完全可靠，并且这种检查能够覆盖的情况也是非常有限的。例如，编译器无法得知数组的元素是否已经初始化，因此以下程序是不会产生编译器警告的：

var strings = new string[10];

Console.WriteLine (strings[0]

.Length);

4.8.2　隔离注解与警告上下文

使用 #nullable enable

指令（或者在工程文件中添加 <Nullable>enable</Nullable>

配置）启用可空引用类型将产生以下两个效果：

它启用了可空注解上下文（nullable annotation context）。该上下文指示编译器将所有引用类型的变量声明均视为非空类型；除非该变量有？

后缀的修饰。

它启用了可空警告上下文（nullable warning context）。该上下文指示编译器在发现代码可能产生 NullReferenceException

时生成一个警告。

有时，我们希望区分这两个概念，仅仅启用注解上下文或仅仅启用警告上下文（尽管只启用警告上下文的意义并不大）：

#nullable enable annotations

// Enable the annotation context// OR:#nullable enable warnings

// Enable the warning context

（上述技巧同样适用于 #nullable disable

和 #nullable restore

。）

也可以在工程文件中应用相应的配置：

<Nullable>annotations

</Nullable><!-- OR --><Nullable>warnings

</Nullable>

在特定的类或程序集上仅仅启用注解上下文可以作为将可空引用类型引入遗留代码库的良好开端。正确地注解 public

成员可以让遗留代码中的类或程序集和其他的类或程序集良好地配合，这样它们不但可以享受可空引用类型带来的好处，同时无须处理类或程序集中产生的警告。

4.8.3　将可空相关的警告视为错误

对于全新的工程，一开始就启用可空上下文是明智之举。除此之外，还可以再进一步，即将和可空相关的警告视为错误。这样除非解决所有和可空相关的警告，否则工程就无法完成编译：

<PropertyGroup> <Nullable>enable</Nullable> <WarningsAsErrors>CS8600;CS8602;CS8603</WarningsAsErrors>

</PropertyGroup>

4.9　扩展方法

扩展方法允许在现有类型上扩展新的方法而无须修改原始类型的定义。扩展方法是静态类的静态方法，其第一个参数需要用 this

修饰符修饰，且第一个参数的类型就是需要扩展的类型：

public static class StringHelper

{ public static bool IsCapitaliz

ed

(this string s) {  if (string.IsNullOrEmpty(s))

r

eturn false;  return char.IsUpper (s[0]); }}

IsCapitalized

扩展方法可以像 string

的实例方法那样进行调用。例如：

Console.WriteLine ("Perth".IsCapitalized());

编译后，扩展方法调用就会转换成普通的静态方法调用：

Console.WriteLine (StringHelper.IsCapitalized ("Perth"));

这个转换过程如下：

arg0.Method (arg1, arg2, ...);       // Extension method call

StaticClass.Method (arg0, arg1, arg2, ...); // Static method call

接口也一样可以扩展：

public static T First<T> (this IEnumerable<T>

sequence)

{ foreach

(T

element in sequence)  return

e

lement;     throw ne

w

InvalidOperationException ("No ele

ments!");}...Console.Wr

it

eLine ("Seattle".First());  // S

4.9.1　扩展方法链

扩展方法和实例方法类似，也可以用简单的方式进行链式调用。考虑如下两个函数：

public static class StringHelper

{ public static string Pluralize

(

this string s) {...} public static string Capitaliz

e

(this string s) {...}}

以下程序中的 x

和 y

是相同的，两者的最终结果均为 "Sausages"

。只不过 x

的计算过程使用了扩展方法，而 y

则使用了静态方法：

string x = "sausage".Pluralize().Capitalize();

string y = StringHelper.Capitalize (StringHelp

er.Pluralize ("sausage"));

4.9.2　二义性与解析

命名空间

当包含扩展方法的类在当前作用域内时（导入其所在的命名空间），我们才能访问扩展方法。例如以下示例中的扩展方法 IsCapitalized

：

using System;namespace Utils{ public static class StringHelper {  public static bool IsCapitalized

(this string s)

{   if (string

.IsNul

lOrEmpty(s)) return false;   return cha

r.IsUp

per (s[0]);  } }}

如果要使用 IsCapitalized

，那么下面的应用程序必须导入 Utils

命名空间，否则会出现编译时错误：

namespace MyApp{ using Utils;

c

lass Test {



static void

Main

() => Console.WriteLine ("Perth".IsCapitalized()); }

}

扩展方法与实例方法

任何兼容的实例方法的优先级总是高于扩展方法。在下面的例子中，即使参数 x

类型为 int

也会优先调用 Test

的 Foo

方法：

class Test{ public void Foo (object

x) { }  // This method always wins}static class Extensions{ public static void Foo (this Test t, int

x) { }

}

在上例子中，只能通过普通的静态调用语法（即 Extensions.Foo (...)

）来调用扩展方法：

扩展方法与扩展方法

如果两个扩展方法签名相同，则扩展方法必须作为普通的静态方法调用才能进行区分。当然，如果其中一个扩展方法具有更具体的参数，那么参数更具体的方法优先级更高。

例如，考虑以下两个类：

static class StringHelper{ public static bool IsCapitalized (this string

s) {...}}static class ObjectHelper{ public static bool IsCapitalized (this object

s) {...}

}

以下代码将调用 StringHelper

的 IsCapitalized

方法：

bool test1 = "Perth".IsCapitalized();

需要注意的是，类和结构体都比接口具体。

4.10　匿名类型

匿名类型是一个由编译器临时创建来存储一组值的简单类。如果要创建一个匿名类型，则可以使用 new

关键字，后面加上对象初始化器，指定该类型包含的属性和值。例如：

var dude = new { Name = "Bob", Age = 23 };

编译器将会把上述语句（大致）翻译为：

internal class AnonymousGeneratedTypeName{ private string name; // Actual field name is irrelevant private int  age;  // Actual field name is irrelevant  public AnonymousGeneratedTypeName (string name, int age) {  this.name = name; this.age = age; }  public string Name { get { return name; } } public int   Age { get { return age; } }  // The Equals and GetHashCode methods are overridden (see Chapter 6

).



// The ToString method is also overridden.}..

.va

r dude = new AnonymousGeneratedTypeName ("Bob

",

23)

;

匿名类型只能通过 var

关键字来引用，因为它并没有一个名字。

匿名类型的属性名称可以从本身为标识符（或者以标识符结尾）的表达式推断得到，例如：

int Age

= 23;var dude = new { Name = "Bob", Age,

Age.ToString().Length

};

上述代码等价于：

var dude = new { Name = "Bob", Age

= Age, Length

= Age.ToString().Length };

在同一程序集内声明的两个匿名类型实例，如果它们的元素名称和类型是相同的，那么它们在内部就是相同的类型：

var a1 = new { X = 2, Y = 4 };

var a2 = new { X = 2, Y = 4 };

Console.WriteLine (a1.GetType(

) == a2.GetType());  // True

此外，匿名类型重写了 Equals

方法从而能够执行比较运算：

Console.WriteLine (a1 == a2);     // False

Console.WriteLine (a1.Equals (a2));  // True

以下代码创建了一个匿名类型的数组：

var dudes = new[]

{ new { Name = "B

ob

", Age = 30 }, new { Name = "T

om

", Age = 40 }};

匿名类型的对象无法通过方法有效地返回，因为将函数返回类型指定为 var

是非法的：

var

Foo() => new { Name = "Bob", Age = 30 }; // Not legal!

因而我们只得用 object

或者 dynamic

作为返回值，而每一个调用 Foo

方法的点都需要动态绑定。这种方式会丧失静态类型的安全性（以及 Visual Studio 的 IntelliSense）：

dynamic

Foo() => new { Name = "Bob", Age = 30 }; // No static type safety.

匿名类型主要用于编写 LINQ 查询（参见第 8 章）。

4.11　元组

和匿名类型一样，元组（tuple）也是存储一组值的便捷方式。元组的主要目的是不使用 out

参数而从方法中返回多个值（这是匿名类型做不到的）。

元组几乎可以做到匿名类型能做到的任何事情，甚至更多。而它的缺点之一是命名元素的运行时类型擦除（接下来会进行介绍）。

创建元组字面量的最简单方式是在括号中列出期望的值。这样就可以创建一个包含匿名元素的元组，并使用 Item1

、Item2

等访问其中的元素。

var bob = ("Bob", 23)

;  // Allow compiler to infer the element types

Console.WriteLine (bob.Item1);  // BobConsole.WriteLine (bob.Item2);  // 23

元组是值类型，并且其元素是可变（可读可写）的：

var joe = bob;         // joe is a *copy* of bob

joe.Item1 = "Joe";       // Change joe's Item1 fro

m Bob to JoeConsole.WriteLine (bob);    // (Bob, 23)Console.WriteLine (joe);    // (Joe, 23)

和匿名类型不同，将每一个元素的类型列在括号中可以显式指定元组的类型。

(string,int)

bob = ("Bob", 23);

这意味着可以有效地从方法中返回元组：

static (string,int)

GetPerson() => ("Bob", 23)

;static void Main(){ (string,int)

person = GetPerson(); // Could use 'var' instead if we want

Console.WriteLine (person.Item1);  // Bob Console.WriteLine (person.Item2);  // 23}

元组和泛型配合默契，因此以下类型都是合法的：

Task<(string,int)>

Dictionary<(string

,int),Uri>IEnumerable<(int i

d, string name)>  // See bel

ow for naming elements

4.11.1　元组元素命名

当创建元组字面量时，可以为元组的元素起一些有意义的名字：

var tuple = (name:

"Bob", age:

23);Console.WriteLine (tuple.name

);   // BobConsole.WriteLine (tuple.age

);   // 23

当然也可以在指定元组类型时进行命名：

static (string name

, int age

) GetPerson() => ("Bob", 23);static void Main(){ var person = GetPerson();

Console.WriteLine (person.name

);  // Bob Console.WriteLine (person.age

);   // 23

}

需要指出，即使进行了命名也可以像匿名时那样使用 Item1

、Item2

来引用元素（虽然 Visual Studio 会在 IntelliSense 中隐藏这些字段）。

元素名字可以由属性或字段名字直接推断得出：

var now = DateTime.Now;

var tuple = (now.Day, n

ow.Month, now.Year);Console.WriteLine (tupl

e.Day);        // OK

如果元组（按顺序）对应的元素类型相同，则元组是类型兼容的。而其元素名称可以不同：

(string name, int age, char sex) bob1 = ("Bob", 23, 'M');(string age

, int sex

, char name

) bob2 = bob1;  // No error!

上述例子也会导致令人困惑的结果：

Console.WriteLine (bob2.name);  // M

Console.WriteLine (bob2.age);   // B

obConsole.WriteLine (bob2.sex);   // 2

3

类型擦除

之前提到过 C# 编译器会为匿名类型创建自定义类并为每一个元素创建命名的属性。在处理元组时则借助了一系列现存泛型结构体，这和匿名对象的处理方式是非常不同的：

public struct ValueTuple<T1>

public struct ValueTuple<T1,

T2>public struct ValueTuple<T1,

T2,T3>...

每一个 ValueTuple<>

结构体都有 Item1

、Item2

等字段。

因此，(string, int)

是 ValueTuple<string, int>

的别名。同时，这意味着命名的元组元素并没有底层类型的命名属性的支撑。这些名字仅仅存在于源代码和编译器的「想象」中。在运行时，这些名字大多会消失。当反编译引用命名元素的元组时，可以看到程序仅仅引用了 Item1

、Item2

这样的字段。若将元组变量赋值给一个 object

对象并在调试器下观察（或者在 LINQPad 下输出），就可以发现元素的名字完全消失了。因此，在绝大多数情况下，都不能用反射（见第 19 章）的方式确定元组在运行时的名字。

刚才提到元组的名字在大部分情况下都消失了，但也有例外的情况。当方法或属性返回命名元组类型时，编译器会将一个自定义特性 TupleElement-NamesAttribute

附加到成员的返回类型上以生成元素名称（请参见 4.13 节）。这样命名元素就可以支持跨程序集的方法调用（注意，在这种情况下，编译器没有可供参考的源代码）。

4.11.2　ValueTuple.Create

除前面提到的方法外，还可以在非泛型的 ValueTuple

类型上调用工厂方法来创建元组：

ValueTuple<string,int> bob1 = ValueTuple.Create

("Bob", 23);(string,int)      bob2 = ValueTuple.Create

("Bob", 23);

但这种方法无法创建命名元素，元素的命名完全依赖编译器的「魔力」。

4.11.3　元组的解构

元组隐式支持解构模式（请参见 3.1.5 节），因此可以将元组解构为独立的变量。因而以下代码：

var bob = ("Bob", 23);

string name = bob.Item

1

;int age = bob.Item2;

可以写为：

var bob = ("Bob", 23);(string name, int age) = bob;  // Deconstruct the bob tuple into

// separate variables (name and age).

Console.WriteLine (name);Console.WriteLine (age);

解构元组的语法和声明含有命名元素元组的语法有很多相似之处。下面的例子指出了它们的区别：

(string name, int age)   = bob;  // Deconstructing a tuple

(string name, int age) bob2 = bob;  // Declaring a new tuple

以下是另一个例子，其中包含了方法调用和类型推断（var

）：

static (string, int, char) GetBob() => ( "Bob", 23, 'M');static void Main(){ var (name, age, sex)

= GetBob();

Console.Wr

iteLine (name);    // Bob Console.Wr

iteLine (age);     // 23 Console.Wr

iteLine (sex);     // M}

4.11.4　元组的比较

和匿名类型一样，ValueTuple<>

类型重写了 Equals

方法来恰当地支持元组间的比较：

var t1 = ("one", 1);

var t2 = ("one", 1);

Console.WriteLine (t

1.Equals (t2));  //

True

ValueTuple<>

类型还重载了 ==

和！=

运算符：

Console.WriteLine (t1 == t2);  // True (from C# 7.3)

当然，它也重写了 GetHashCode

方法，因此元组对象可以作为字典中的键。关于相等比较的内容请参见 6.11 以及 7.5 节。

ValueTuple<>

类型实现了 IComparable

接口（请参见 6.12 节），因此元组可以用作排序的键使用。

4.11.5　System.Tuple

类

在 System

命名空间下还存在着另一类泛型类型：Tuple

（而不是 ValueTuple

）。Tuple

是在.NET Framework 4.0 时引入的。Tuple

是类，而 ValueTuple

类型是结构体。将元组定义为类这一决定经过反思后被认定是错误的：在典型的元组使用场景中，结构体在性能上更有优势（避免了不必要的内存分配）且几乎没有任何缺点。因此，微软在 C# 7 中增加了对元组的语言级支持，推荐使用新的 ValueTuple

而忽略之前的 Tuple

类型。在 C# 7 之前的代码中还能发现 Tuple

类的影子，但它们没有任何语言上的特殊支持，例如：

Tuple<string,int> t = Tuple.Create ("Bob", 23); // Factory method

Console.WriteLine (t.Item1);    // BobConsole.WriteLine (t.Item2);    // 23

4.12　模式

在第 3 章，我们展示了如何使用 is

运算符验证引用转换是否成功：

if (obj is string

)



Console.WriteLine (((string)obj).Length);

以上代码可以更加简洁地写为：

if (obj is string s

)



Console.WriteLine (s.Length);

以上代码引入了一种称为类型模式的模式。除了类型模式之外，is 运算符还支持其他在 C# 7 和 C# 8 中引入的模式，例如属性模式：

if (obj is string { Length:4 }

)



Console.WriteLine ("A string with 4 characters");

模式可以在以下上下文中使用：

is

运算符之后（variable is pattern

）

switch

语句中

switch

表达式

我们在 2.11.3 和 3.2.2 节中介绍了类型模式（并简要介绍了元组模式）。本节将介绍更多在 C# 7 和 C# 8 中引入的高级模式。大多数模式都是随 switch

语句或表达式一起使用的。这些模式可以实现如下功能：

减少 when

子句的使用

可以在先前无法支持的场景下使用 switch

本节介绍的模式在某些场景下有一定的作用。但请牢记这些高度模式化的 switch

语句都可以被简单的 if

语句（或者在某些情况下还可以使用三元运算符）来替代，而且其代码量并不会显著增加。

4.12.1　属性模式（C# 8）

属性模式可以匹配对象的一个或者多个属性值。例如，前一个例子示范了该模式和 is

运算符配合使用的情况：

if (obj is string { Length:4 }

) ...

但是，上述代码相比以下代码并没有显著的优势：

if (obj is string s && s.Length == 4) ...

属性模式与 swtich

语句或表达式联合使用可更具优势。以 System.Uri

类为例，这个类定义了 Scheme

、Host

、Port

和 IsLoopback

属性。在以下的防火墙代码中，可以使用 switch

表达式配合属性模式来决定是否允许访问特定的 URI：

bool ShouldAllow (Uri uri) => uri switch{ { Scheme: "http", Port: 80 }

=> true, { Scheme: "https", Port: 443 }

=> true, { Scheme: "ftp",  Port: 21 }

=> true, { IsLoopback: true      }

=> true,

_ => fa

lse};

属性模式支持属性嵌套，因此以下代码是合法的：

{ Scheme: string { Length: 4 }

, Port: 80 } => true,

我们总是基于类型和等值性进行匹配。如果要应用其他的运算符（例如 <），则必须使用 when

子句：

{ Scheme: "http", Port: 80 } when uri.Host.Length < 1000

=> true,

结合使用类型模式和属性模式也是可行的：

bool ShouldAllow (object

uri) => uri switch{ Uri

{ Scheme: "http", Port: 80 } => true, Uri

{ Scheme: "https", Port: 443 } => true,

...

就像类型模式那样，以上用法也可以在子句的末尾引入变量，并使用该变量的值：

Uri { Scheme: "http", Port: 80 } httpUri

=> httpUri

.Host.Length < 1000,

该变量也可以在 when

子句中使用：

Uri { Scheme: "http", Port: 80 } httpUri                 when

httpUri.Host.Length < 1000 => true,

属性模式中甚至可以在属性一级引入变量：

{ Scheme: "http", Port: 80, Host: string host

} => host

.Length < 1000,

同时引入变量支持隐式类型，因此可以将 string

替换为 var

。以下是完整的示例代码：

bool ShouldAllow (Uri uri) => uri switch{ { Scheme: "http", Port: 80, Host: var host

} => host

.Length < 1000,

{ Scheme: "ht

tps", Port: 443        } => true, { Scheme: "ft

p",  Port: 21         } => true, { IsLoopback:

true             } => true, _ => false};

想要找到一个通过使用模式而令代码变得更加简洁的例子并不容易。例如以上的例子，不使用模式的代码反而更加简短：

{ Scheme: "http", Port: 80 } => uri.Host

.Length < 1000,

4.12.2　元组模式（C# 8）

元组模式提供了切换多个值的简单机制：

enum Season { Spring, Summer, Fall, Winter };int AverageCelsiusTemperature (Season season, bool daytime) => (season, daytime)

switch

{  (Se

ason

.Spring, true) => 20,  (Se

ason

.Spring, false) => 16,  (Se

ason

.Summer, true) => 27,  (Se

ason

.Summer, false) => 22,  (Se

ason

.Fall, true) => 18,  (Se

ason

.Fall, false) => 12,  (Se

ason

.Winter, true) => 10,  (Se

ason

.Winter, false) => -2,  _ =

> th

row new Exception ("Unexpected co

mbination")};sitiona

l Pa

tterns (C# 8)

4.12.3　位置模式（C# 8）

若类型定义了 Deconstruct

方法（请参见 3.1.5 节），例如以下示例中的 Point

类：

class Point{ public readonly int X, Y; public Point (int x, int y) => (X, Y) = (x, y); public void Deconstruct (out int x, out int y)

{

x = X; y = Y;

}

}

就可以使用对象的位置属性作为匹配的模式：

var p = new Point (2, 3);Console.WriteLine (p is (2, 3)

);  // true

并用于 switch

语句或表达式：

string Print (object obj) => obj switch{ Point (0, 0)

=> "Empty point", Point (var x, var y)

when x == y => "Diagonal"

...};

4.12.4　var

模式

var

模式是 C# 7 引入的。它是类型模式的变种，即将类型名称替换为了 var

关键字。由于转换必定成功，因此它的目的仅仅是为了引入可重复使用的变量：

bool Test (int x, int y) =>  x * y is var product

&& product

> 10 && product

< 100;

否则需要书写如下的代码：

bool Test (int x, int y)

{ int product = x * y; return product > 10 &&

p

roduct < 100;}

能够在表达式体方法中使用 var

模式引入一个可复用的变量（本例中为 product

）的确方便。但是该模式只能在方法返回类型为 bool

时使用。

4.12.5　常量模式

常量模式是 switch

语句的核心（在 C# 7 之前，switch

语句仅支持常量模式）。为了和其他模式保持一致，常量模式从 C# 7 开始也支持 is

运算符了。因此以下程序是合法的：

void Foo (object obj){ // C# won't let you use the == operator, because obj is object. // However, we can use 'is' if (obj is 3

) ...

}

以上代码等价于：

void Foo (object obj){ if (obj is int && (int)obj == 3

) ...

}

4.13　特性

之前的内容中介绍过，在程序中可以使用修饰符（例如 virtual

或 ref

）给代码元素指定特性。这些结构都是语言内置的。而特性（Attribute）是一种将自定义信息添加到代码元素（程序集、类型、成员、返回值、参数和泛型类型参数）的扩展机制。这种可扩展性对于 C# 语言中那些深度集成在类型系统而不需要特殊关键字或结构的服务是非常有用的。

特性的一个常见应用场景是序列化和反序列化过程，即将任意对象转换为一个用于存储或传输的特定格式；或从特定格式生成对象的过程。在该场景下，可以在字段上使用特性来指定该字段的 C# 表示方式和特定格式表示方式间的转换关系。

4.13.1　特性类

特性是通过直接或者间接继承抽象类 System.Attribute

的类定义的。如果要将特性附加到代码元素中，那么就需要在该代码元素前用方括号指定特性的类型名称。例如，以下的例子将 ObsoleteAttribute

附加到 Foo

类上：

[ObsoleteAttribute]

public class Foo {...}

编译器可以识别该特性，并在编译时对引用该特性标记的类型或成员的行为产生警告。按照惯例，所有特性类型都以 Attribute

结尾。C# 能够识别这个后缀，并允许在为成员附加特性时忽略该后缀：

[Obsolete]

public class Foo {...}

ObsoleteAttribute

是在 System

命名空间中声明的一种类型，如下所示（为了简明起见省略部分代码）：

public sealed class ObsoleteAttribute : Attribute {...}

C# 语言和.NET Core 中包含了大量的预定义特性，第 19 章将介绍如何自定义特性。

4.13.2　命名特性参数和位置特性参数

特性可以包含参数。下面的例子将 XmlTypeAttribute

添加到一个类上。这个特性指示（在 System.Xml.Serialization

命名空间内定义的）XML 序列化器如何将对象转化为 XML 格式并接受哪些特性参数。以下代码中的特性将 CustomerEntity

类映射到了名为 Customer

的 XML 元素（位于 http://oreilly.com

命名空间）上：

[XmlType ("Customer", Namespace="http://oreilly.com")]

public class CustomerEntity { ... }

特性参数分为两类：位置参数和命名参数。在前一个例子中，第一个参数是位置参数，第二个参数是命名参数。位置参数对应特性类型的公有构造器的参数；命名参数则对应该特性类型的公有字段或者公有属性。

当指定特性时，必须包含对应特性构造器的位置参数，而命名参数则是可选的。

第 19 章将详细介绍哪些类型是有效的参数类型，以及这些参数的求值规则。

4.13.3　程序集与支持字段的特性

在不显式指定的情况下，特性的目标就是它后面紧跟的代码元素，一般是类型或者类型的成员。不过，也可以将特性附加到程序集。这就要求显式指定特性的目标了。以下代码展示了如何在程序集中添加 AssemblyFileVersion

特性以指定程序集的版本信息：

[assembly: AssemblyFileVersion ("1.2.3.4")]

从 C# 7.3 开始，可以使用 field:

前缀为自动属性的支持字段添加特性。该功能可用于序列化的控制：

[field:

NonSerialized]

public int MyP

roperty { get; set; }

4.13.4　指定多个特性

一个代码元素可以指定多个特性。特性可以列在同一对方括号中（用逗号分隔），或者分隔在多对方括号中，当然也可以是两种形式的结合。下面的三个例子在语义上是相同的：

[Serializable, Obsolete, CLSCompliant(false)]

public class Bar {...}[Serializable] [Obsolete] [CLSCompliant(false

)]public class Bar {...}[Serializable, Obsolete][CLSCompliant(false)]public class Bar {...}

4.14　调用者信息特性

我们可以在方法的可选参数上添加以下三种特性（称为调用者信息特性）中的一种。这些特性可以令编译器从调用者源代码中获取信息，并将这些信息作为默认值注入参数中：

[CallerMemberName]

：表示调用者的成员名称。

[CallerFilePath]

：表示调用者的源代码文件路径。

[CallerLineNumber]

：表示调用者源代码文件中的行号。

以下代码中的 Foo

方法演示了这三个特性：

using System;using System.Runtime.CompilerServices;class Program{ static void Main() => Foo(); static void Foo (  [CallerMemberName]

string memberName = null,  [CallerFilePath]

string filePath = null,  [CallerLineNumber]

int lineNumber = 0)

{  Console.WriteLin

e (m

emberName);  Console.WriteLin

e (f

ilePath);  Console.WriteLin

e (l

ineNumber); }}

假设程序位于 c:\source\test\Program.cs，则输出结果是：

Main

c:\s

ource\test\Program.cs6

和标准的可选参数一样，替代操作是在调用位置完成的。因此，Main

方法中的代码实际上是以下程序的语法糖：

static void Main() => Foo ("Main", @"c:\source\test\Program.cs", 6);

调用者信息特性适用于日志记录，也适用于实现某些模式（例如在对象的某个属性变化时触发变化通知事件）。事实上，.NET Core 有一个专门实现此效果的标准接口 INotifyPropertyChanged

（位于 System.ComponentModel

命名空间）：

public interface INotifyPropertyChanged{ event PropertyChangedEventHandler PropertyChanged;}public delegate void PropertyChangedEventHandler (object sender, PropertyChangedEventArgs e); public class PropertyChangedEventArgs : EventArgs{ public PropertyChangedEventArgs (string propertyName

);



public virtual string PropertyName { get; }}

注意 PropertyChangedEventArgs

参数需要接受发生变化的属性的名称。然而，在实现该接口时，使用 [CallerMemberName]

特性就无须在触发事件时提供属性名称了：

public class Foo : INotifyPropertyChanged{ public event PropertyChangedEventHandler PropertyChanged = delegate { };  void RaisePropertyChanged ([CallerMemberName]

string propertyName = null) {  PropertyChanged (this, new PropertyChangedEventArgs (propertyName)); }  string customerName; public string CustomerName {  get { return customerName; }  set  {   if (value == customerName) return;   customerName = value;   RaisePropertyChanged();

// The compiler converts the above line to:   // RaisePropertyChanged ("CustomerName");

} }}

4.15　动态绑定

动态绑定（dynamic binding）将绑定（即解析类型、成员和操作的过程）从编译时延迟到运行时。动态绑定适用于那些开发者知道某个特定的函数、成员或操作的存在，而编译器不知道的情况。这种情况通常出现在操作动态语言（例如 IronPython）和 COM 时。在这些情况下，如果不使用动态绑定就只能使用反射机制了。

动态类型是通过上下文关键字 dynamic

声明的：

dynamic d = GetSomeObject();

d.Quack();

动态类型会告诉编译器「不要紧张」，我们认为 d

的运行时类型具有一个 Quack

方法，但是我们无法静态地证明这一点。由于 d

是动态的，所以编译器推迟到运行时才将 Quack

绑定给 d

。为了真正理解这个概念，需要先区分静态绑定和动态绑定。

4.15.1　静态绑定与动态绑定

典型的绑定例子是在编译表达式时将名称映射到具体的函数。如果要编译如下的表达式，那么编译器需要找到 Quack

方法的实现：

d.Quack();

假设 d

的静态类型为 Duck

：

Duck d = ...

d.Quack();

最简单的情况是编译器找到 Duck

中无参数的 Quack

方法进行绑定。如果绑定失败，则编译器会将搜索范围扩大到具有可选参数的方法，即 Duck

基类的方法和将 Duck

作为第一个参数的扩展方法。如果还是没有找到匹配的方法，那么将发生一个编译错误。无论绑定的是什么样的方法，都必须是由编译器编译的，而且完全依赖于之前已经知道的操作数（本例中是 d

）类型。这就是所谓的静态绑定。

现在将 d

的静态类型改为 object

：

object d = ...

d.Quack();

调用 Quack

时会遇到一个编译错误。因为虽然存储在 d

中的值包含了一个名为 Quack

的方法，但是编译器无法得知（编译器所知的所有信息只有变量的类型 object

）。现在来将 d

的静态类型改为 dynamic

：

dynamic d = ...

d.Quack();

dynamic

类型类似于 object

，即一种同样不具备描述性的类型。但区别是动态类型能够在编译时不知道它存在的情况下使用它。动态对象是基于其运行时类型而非它的编译时类型进行绑定的。当编译器遇到动态绑定表达式时（通常是一个包含任意 dynamic

类型值的表达式），它仅对表达式进行打包以便后面运行时执行绑定。

在运行时，如果一个动态对象实现了 IDynamicMetaObjectProvider

，那么这个接口将用来执行绑定。否则，绑定的发生方式几乎与编译器已经事先知道动态对象的运行时类型的情况一样。这两种方式分别称为自定义绑定和语言绑定。

4.15.2　自定义绑定

自定义绑定是通过动态对象实现 IDynamicMetaObjectProvider

（IDMOP）接口来实现的。虽然可以在 C# 编写的类型上实现 IDMOP（这种方式也很有效），但是更常见的情况是从.NET 的动态语言运行时（Dynamic Language Runtime，DLR）实现的动态语言中（例如 IronPython 或者 IronRuby）获得 IDMOP 对象。这些语言的对象已经隐式实现了 IDMOP，通过这种方式可以直接定义操作的含义。

第 20 章将详细介绍自定义绑定器。现在则先写一个简单的绑定器来展示其功能：

using System;

using System.

Dynamic;public class

Test{ static void

Main() {  dynamic d

= new Duck();  d.Quack()

;         //

Q

uack method was ca

ll

ed  d.Waddle(

);         //

W

addle method was c

al

led }}public class

Duck : DynamicObject{ public over

ride bool TryInvokeMem

b

er (  InvokeMem

berBinder binder, obje

c

t[] args, out obje

ct

result) {  Console.W

riteLine (binder.Name

+

" method was call

ed

");  result =

null;  return tr

ue; }}

Duck

类实际上并没有 Quack

方法。相反，它使用自定义绑定拦截并解释所有方法的调用。

4.15.3　语言绑定

语言绑定是在动态对象未实现 IDynamicMetaObjectProvider

时发生的。语言绑定在处理设计不当的类型或绕过.NET 本身类型系统的限制时是非常有用的（将在第 20 章详细介绍）。例如，使用数值类型的一个常见问题是它没有通用接口。但是方法是可以动态绑定的，运算符也一样：

static dynamic Mean (dynamic x, dynamic y) => (x + y) / 2;

static void Main(){ int x = 3, y = 4; Console.WriteLine (Mean (x, y));}

其明显的好处是，不需要重复处理每种数值类型。然而，这样做失去了静态类型安全性的保护，因此更可能发生运行时异常，而非编译时错误。

动态绑定会损害静态类型安全性，但是不会影响运行时类型安全性。与反射机制（见第 19 章）不同，动态绑定不能绕过成员可访问性规则。

从设计角度，若动态对象的运行时类型在静态编译时已知，则语言的运行时绑定可以无限接近静态绑定的效果。在上述例子中，如果将 Mean

的参数直接声明为 int

类型，那么程序的行为是相同的。静态和动态绑定最显著的差异在于扩展方法，将在 4.15.11 节进行介绍。

动态绑定会对性能产生影响。然而，DLR 的缓存机制对同一个动态表达式的重复调用进行了优化，允许在循环中高效地调用动态表达式。因此在如今的硬件条件下，一个简单的动态表达式的处理开销可以控制在 100 纳秒以内。

4.15.4　RuntimeBinderException

如果成员绑定失败，那么程序会抛出 RuntimeBinderException

异常，可以将其看作一个运行时的编译时错误：

dynamic d = 5;

d.Hello();

// throws RuntimeBinderException

上述代码抛出异常的原因是 int

类型没有 Hello

方法。

4.15.5　动态类型的运行时表示

dynamic

和 object

类型之间有深度的等价关系。在运行时，以下表达式的结果为 true

：

typeof (dynamic) == typeof (object)

上述规则还可以扩展到构造类型和数组类型：

typeof (List<dynamic>) == typeof (List<object>)

typeof (dynamic[]) == typeof (object[])

与对象引用相似，动态引用也可以指向任意类型的对象（指针对象除外）：

dynamic x = "hello";

Console.WriteLine (x

.GetType().Name); // Stringx = 123; // No erro

r (despite same variable)Console.WriteLine (x

.GetType().Name); // Int32

在结构上，object

引用和动态引用没有任何区别。动态引用可以直接在它所指向的对象上执行动态操作。可以将 object

对象转换为 dynamic

，以便对 object

对象执行任意的动态操作：

object o = new System.Text.StringBuilder();

dynamic d = o;d.Append ("hello");Console.WriteLine (o);  // hello

在一个提供了公开的 dynamic

成员的类型上使用反射，就可以观察到这些成员就是标记了特性的 object

。例如：

public class Test

{ public dynamic

Fo

o;}

等价于：

public class Test

{ [System.Runtime

.C

ompilerServices.DynamicAttribute] public object F

oo

;}

因此，该类型的消费者知道 Foo

属性应该作为动态类型使用，而同时也可以在不支持动态绑定的语言上回退到 object

类型。

4.15.6　动态转换

dynamic

类型可以隐式从其他类型转换而来或转换为其他类型：

int i = 7;

dynamic d

= i;long j = d

;    // No

cast required (implicit conversion)

只有在动态对象的运行时类型能够隐式转换到目标静态类型时上述转换才能成功，上例中的转换之所以能够成功是因为 int

类型可以隐式转换为 long

类型。

下面的例子将会抛出 RuntimeBinderException

异常，因为 int

类型不能够隐式转换为 short

类型：

int i = 7;

dynamic d

= i;short j =

d;   // thro

ws RuntimeBinderException

4.15.7　var

与 dynamic

var

和 dynamic

类型表面上相似，但实际上是非常不同的：

var

说：「让编译器去确定我的类型吧」。

dynamic

说：「让运行时去确定我的类型吧」。

例如：

dynamic x = "hello"; // Static type is dynamic

, runtime type is stringvar y = "hello";   // Static type is string

, runtime type is string

int i = x;      //

Runtime error   (cannot convert string to int)int j = y;      //

Compile-time error (cannot convert string to int)

由 var

声明的变量的静态类型可以是 dynamic

：

dynamic x = "hello";

var y = x;

// Static type of y is dynamicint z = y;

// Runtime error (cannot convert string to int)

4.15.8　动态表达式

字段、属性、方法、事件、构造器、索引器、运算符和转换都可以动态调用。

若动态表达式的返回值为 void

，那么和静态类型的表达式一样，该结果是不能使用的。两者的区别是动态表达式的错误发生在运行时：

dynamic list = new List<int>();

var result = list.Add (5);

// RuntimeBinderException thrown

包含动态操作数的表达式一般来说也是动态的，这是缺少类型信息的影响向下传递造成的：

dynamic x = 2;

var y = x * 3;

// Static type of y is dynamic

这个规则有一些例外情况。首先，将动态表达式转换为静态类型会产生一个静态表达式：

dynamic x = 2;

var y = (int)x

;   // Static type of y is int

其次，构造器的调用总是产生静态表达式，即使调用时使用的是动态参数。以下示例中，x

会被静态地设置为 StringBuilder

类型：

dynamic capacity = 10;

var x = new System.Tex

t.StringBuilder (capacity);

此外，在极少数情况下，包含动态参数的表达式也是静态的，这些情况包括将索引传递给数组以及创建委托的表达式。

4.15.9　无动态接收者的动态调用

dynamic

的使用通常涉及动态接收者，即动态对象是动态函数调用的接收者：

dynamic x = ...;

x.Foo();

// x is the receiver

然而，还可以使用动态参数调用已知的静态函数。这种调用遵循动态重载解析规则，包括调用：

静态方法

实例构造器

已知静态类型的接收者的实例方法

下面的例子中，Foo

被动态绑定，且依赖于动态参数的运行时类型：

class Program

{ static void

F

oo (int x)  => Console.WriteLine ("int"); static void

F

oo (string x) => Console.WriteLine ("string");  static void

M

ain() {  dynamic x

=

5;  dynamic y

=

"watermelon";      Foo (x);



//  Foo (y);



// string }}

本例中并没有动态接收者，因此编译器可以静态进行基本的检查以确定动态调用是否能够成功。它会检查是否存在名称和参数数量匹配的函数。如果没有发现候选函数，则产生一个编译时错误。例如：

class Program

{ static void

F

oo (int x)  => Console.WriteLine ("int"); static void

F

oo (string x) => Console.WriteLine ("string");  static void

M

ain() {  dynamic x

=

5;  Foo (x, x

);

// Compiler error - wrong number of parameters  Fook (x);



// Compiler error - no such method name }}

4.15.10　动态表达式中的静态类型

在动态绑定中使用动态类型天经地义，但是静态类型在可能的情况下也可用在动态绑定中。例如：

class Program

{ static void

F

oo (object x, object y) { Console.WriteLine ("oo"); } static void

F

oo (object x, string y) { Console.WriteLine ("os"); } static void

F

oo (string x, object y) { Console.WriteLine ("so"); } static void

F

oo (string x, string y) { Console.WriteLine ("ss"); }  static void

M

ain() {  object o

=

"hello";  dynamic d

=

"goodbye";  Foo (o, d

);

// os }}

Foo(o, d)

的调用是动态绑定的，因为它的一个参数 d

的类型是 dynamic

。但是，由于 o

的类型是静态已知的，所以即使这个绑定是动态发生的，也会使用这个静态参数。本例中，重载解析器之所以选择 Foo

的第二个实现，是 o

的静态类型和 d

的运行时类型共同决定的。换句话说，编译器会尽其所能地静态化。

4.15.11　不可调用的函数

有些函数无法动态调用，例如：

扩展方法（通过扩展方法语法）

必须将类型转换为接口才能调用的接口成员

基类中被子类隐藏的成员

理解其中的原因对于理解动态绑定是非常有帮助的。

动态绑定需要两部分信息：调用函数的名称和调用该函数的对象。但是在上述三种不可调用的情况中还涉及一个只在编译时可见的附加类型。在本书成书之时，仍然无法动态指定这种附加类型。

当调用扩展方法时，其附加类型是隐含的，即定义扩展方法的静态类。编译器会根据源代码中的 using

指令来搜索这个类。由于 using

指令在编译后（当它们在绑定过程中完成了将简单的名称映射到完整命名空间限定名称之后）就消失了，因而扩展方法是仅存在于编译时的概念。

当通过接口调用成员时，需要通过一个隐式转换或显式转换来指定这个附加类型。有两种情况需要执行这个操作：调用显式实现的接口成员；或调用另一个程序集内部类型中实现的接口成员。以下示例中的两个类型展示了第一种情况：

interface IFoo  { void Test();    }

class Foo : IFoo { void IFoo.Test() {} }

为了调用 Test

方法，必须将类型显式转换为 IFoo

接口。如果用静态方式则很简单：

IFoo f = new Foo();  // Implicit cast to interface

f.Test();

考虑如下动态类型的例子：

IFoo

f = new Foo();

dynamic d = f;d.Test();

// Excep

tion thrown

我们用隐式转换（上面代码中加粗的部分）告知编译器将 f

的后续成员调用绑定到 IFoo

上而不是 Foo

上，换句话说，即通过 IFoo

接口的视角来查看对象。但是这个视角在运行时会消失，因此 DLR 无法完成这个绑定过程。这种运行时视角消失可以用以下代码来说明：

Console.WriteLine (f.GetType().Name);  // Foo

类似的情况也出现在调用隐藏的基类成员上：必须通过强制类型转换或者使用 base

关键字来指定一个附加类型，该附加类型会在运行时消失。

4.16　运算符重载

运算符可以通过重载以更自然的语法操作自定义类型。运算符重载最适合实现那种表示基元数据类型的结构体，例如自定义的数值类型。

下面的运算符符号都是可以重载的：

+(unary)  -(unary) !  ~ ++

--     +     -   * /

%     &     |   ^ <

<>>     ==    !=  > <

>=     <=

除此之外，以下运算符也是可以重载的：

隐式和显式转换（使用 implicit

和 explicit

关键字实现）

true

和 false

运算符（非字面量）

而以下运算符也可以间接重载：

复合赋值运算符（例如 +=

和 /=

）可以通过重写非复合运算符（例如 +

和 /

）隐式重写。

条件运算符 &&

和 ||

可以通过重写按位操作运算符 &

和 |

隐式重写。

4.16.1　运算符函数

运算符是通过声明运算符函数进行重载的。运算符函数具有以下规则：

函数名为 operator

关键字紧跟运算符符号。

运算符函数必须是 static

和 public

的。

运算符函数的参数即操作数。

运算符函数的返回类型表示表达式的结果。

运算符函数的操作数中至少有一个类型和声明运算符函数的类型是一致的。

以下例子用名为 Note

的结构体表示音符，并重载其 +

运算符：

public struct Note{ int value; public Note (int semitonesFromA) { value = semitonesFromA; } public static Note operator + (Note x, int semitones)

{

return new Note (x.value + semitones); }}

这个重载令 Note

可以和 int

相加：

Note B = new Note (2);

Note CSharp = B + 2;

重载运算符会自动支持相应的复合赋值运算符。在上例中，由于重载了 +

运算符，所以自然就可以使用 +=

了：

CSharp += 2;

和方法与属性一样，C# 可以将只含有一个表达式的运算符函数简洁地写成表达式体语法的形式：

public static Note operator + (Note x, int semitones)

=> new Note (x.value +

semitones);

4.16.2　重载相等和比较运算符

通常在我们使用结构体（或类，但不常见）时需要重载相等和比较运算符。重载相等和比较运算符有一些特殊的规则和要求，我们将在第 6 章详细介绍。这些规则可总结为：

成对重载：C# 编译器要求逻辑上成对的运算符必须同时定义。这些运算符包括（==

、!=

）、（<

、>

）和（<=

、>=

）。

Equals

和 GetHashCode

：在大多数情况下，如果重载了（==

）和（!=

）运算符，则必须重载 object

中定义的 Equals

和 GetHashCode

方法使之具有合理的行为。如果没有按照要求重载，则 C# 编译器会发出警告（将在 6.11 节详细介绍）。

IComparable

和 IComparable<T>

：如果重载了（<

、>

）和（<=

、>=

）运算符，那么还应当实现 IComparable

和 IComparable<T>

接口。

4.16.3　自定义隐式和显式转换

隐式和显式转换也是可重载的运算符。这些转换经过重载后，一般能使强相关的类型（例如数值类型）之间的转换变得更加简明自然。

如果要在弱相关的类型之间进行转换，则更适合采用以下方式：

编写一个以转换类型为参数的构造器。

编写（静态的）To

XXX

和 From

XXX

方法进行类型转换。

之前在介绍类型时提到，隐式转换意味着它能够保证转换一定成功，且转换时不会丢失信息。相反，若转换成功与否取决于运行时环境，或转换过程中可能丢失信息，则应当使用显式转换。

as

和 is

运算符会忽略自定义转换：

Console.WriteLine (554.37 is Note);  // False

Note n = 554.37 as Note;       // Error

在以下示例中，我们定义了 Note

类型和 double

（代表以赫兹为单位的音符频率）之间的转换规则：

...

//

Convert to hertzpub

lic static implicit

operator double (Note x) =

> 440 * Math.Pow (2,

(double) x.value / 12 ); //

Convert from hertz (

accurate to the nearest semitone)pub

lic static explicit

operator Note (double x) =

> new Note ((int) (0

.5 + 12 * (Math.Log (x/440) / Math.Log(2) ) ));...

Not

e n = (Note)554.37;

// explicit conversiondou

ble x = n;

// implicit conversion

按照之前的规则，相比实现隐式和显式运算符，在上例中实现 ToFrequency

（与静态的 FromFrequency

）方法可能更好。

4.16.4　重载 true

和 false

true

和 false

运算符只会在那些本身有布尔语义但无法转换为 bool

的类型中重载（这种类型并不多见）。例如，一个类型实现了三个状态逻辑：通过重载 true

和 false

运算符，这个类型就可以无缝地和条件语句以及运算符（if

、do

、while

、for

、&&

、||

和？:

）一起使用了。System.Data.SqlTypes.SqlBoolean

结构体就提供了这个功能：

SqlBoolean a = SqlBoolean.Null;

if (a) Console.WriteLine ("True");else if (!a) Console.WriteLine ("False");

else if (!a) Console.WriteLine ("False");else Console.WriteLine ("Null");

输出为：

Null

下面的代码重新实现了 SqlBoolean

中关于 true

和 false

运算符的那部分代码：

public struct SqlBoolean{ public static bool operator true

(SqlBoolean x)  => x.m_value == True.m_value;     public static bool operator false

(SqlBoolean x)

=> x.m_valu

e == False.m_value;     public static

SqlBoolean operator ! (SqlBoolean

x) {  if (x.m_val

ue == Null.m_value) return Null;  if (x.m_val

ue == False.m_value) return True;  return Fals

e; }  public static

readonly SqlBoolean Null = new Sq

lBoolean(

0); public static

readonly SqlBoolean False = new Sq

lBoolean(

1); public static

readonly SqlBoolean True = new Sq

lBoolean(

2);  private SqlBo

olean (byte value) { m_value = valu

e; } private byte

m_value;}

4.17　不安全的代码和指针

C# 中可以将代码块标记为不安全代码并使用 /unsafe

编译器选项来使用指针直接进行内存操作。指针类型主要用来与 C 语言 API 进行互操作，但是也可以用来访问托管堆以外的内存，或者处理严重影响性能的热点。

4.17.1　指针基础

对于每一种值类型或引用类型 V

，它们都有对应的指针类型 V*

。指针实例保存了变量的地址。指针类型可以（不安全地）转换为任何一种指针类型。主要的指针运算符有：

4.17.2　不安全的代码

使用 unsafe

关键字修饰类型、类型成员或者语句块，就可以在该范围内使用指针类型并可以像 C++ 那样对作用域内的内存执行指针操作。下面的例子用指针实现了快速的位图处理：

unsafe void BlueFilter (int[,] bitmap)

{ int length = bitmap.Length; fixed (int* b = bitmap) {  int* p = b;  for (int i = 0; i < length; i++)   *p++ &= 0xFF; }}

不安全代码比对应的安全代码运行速度更快，本例中使用了一个遍历数组索引和检查边界的嵌套循环。由于没有穿越托管运行环境的开销，不安全的 C# 方法可能比调用外部 C 函数的执行速度更快。

4.17.3　fixed

语句

fixed

语句是用来锁定托管对象的，例如前面例子中的位图。在程序执行过程中，许多对象都在堆上分配，并从堆上回收。为了避免不必要的内存浪费和内存的碎片化，垃圾回收器会移动这些对象。因此，如果一个对象的地址在引用时发生变化，那么指向该对象的指针是无效的。fixed

语句则告诉垃圾回收器「锁定」这个对象，而且不会移动它。这可能会对运行时效率产生一定影响，所以 fixed

代码块应当只供短暂使用，而且在代码块中应当避免在堆上分配内存。

在 fixed

语句中，可以获得一个指向任意值类型、任意值类型数组或字符串的指针。对于数组和字符串，指针实际上指向第一个值类型的元素。

对引用类型中的内联值类型操作需要事先锁定引用类型，例如：

class Test

{ int x; static v

oi

d Main() {  Test t

es

t = new T

est();  unsafe

{    fix

ed

(int* p

= &test.x)  // Pins

test

{     *

p

= 9;    }    Sys

te

m.Console

.WriteLine (test.x);  } }}

我们将在 25.6 节进一步介绍 fixed

语句。

4.17.4　指针取成员运算符

除了 &

和 *

运算符，C# 还支持 C++ 形式的 ->

运算符。该运算符可以在结构体上使用：

struct Test

{ int x; unsafe st

at

ic void M

ain() {  Test te

st

= new Te

st();  Test* p

=

&test;  p->x =

9;

System.

Co

nsole.Wri

teLine (test.x); }}

4.17.5　stackalloc

关键字

stackalloc

关键字将在栈上显式分配一块内存。由于内存是在栈上分配的，因此其生命周期和其他局部变量（这里的局部变量指那些没有被 Lambda 表达式、迭代块或异步方法捕获，因而生命周期也没有延长的变量）一样，受限于方法执行期。可以在这块内存上使用 []

运算符对其进行索引访问：

int* a = stackalloc int [10];

for (int i = 0; i < 10; ++i)  Console.WriteLine (a[i]);

// Print raw memory

第 24 章将介绍如何在无须使用 unsafe

关键字的情况下使用 Span<T>

管理这些分配在栈上的内存：

Span<int> a = stackalloc int [10];

for (int i = 0; i < 10; ++i) Console.WriteLine (a[i]);

4.17.6　固定大小的缓冲区

fixed

关键字的另一个用途是在结构体中创建固定大小的缓冲区（这个功能常用于调用非托管函数，请参见第 24 章）：

unsafe struct UnsafeUnicodeString{ public short Length; public fixed

byte Buffer[30];  // Allocate block of 30 bytes

}unsafe class UnsafeClass{ UnsafeUnicodeString uus;  public UnsafeClass (string s) {  uus.Length = (short)s.Length;  fixed (byte* p = uus.Buffer)   for (int i = 0; i < s.Length; i++)    p[i] = (byte) s[i]; }}class Test{ static void Main() { new UnsafeClass ("Christia

n

T

roy"); }}

固定大小的缓冲区不是数组：如果 Buffer

是数组类型，那么它就会成为一个存储在堆上的对象的引用，而非存储在结构体内部的 30 个字节了。

在本例中，fixed

关键字还用于将包含缓冲区的对象（UnsafeClass

实例）在堆上进行锁定。因此 fixed

表示了两个不同的事物：第一是大小固定，第二是位置固定。这两者通常一起使用，即固定大小的缓冲区必须在固定的位置使用。

4.17.7　void*

void

指针（void*

）不对指向的数据做任何的类型假设。它常用于处理原始内存的函数。任意的指针都可以隐式转换为 void*

。void*

不可解引用，且算术运算符也不能在 void

指针上使用，例如：

class Test

{ unsafe s

ta

tic void Main() {  short[

]

a = {1,1,2,3,5,8,13,21,34,5

5};  fixed

(s

hort* p = a)  {   //si

ze

of returns size of value-typ

e in

bytes   Zap

(p

, a.Length * sizeof (short))

;  }  foreac

h

(short x in a)   Syst

em

.Console.WriteLine (x);  //

Pri

nts all zeros }  unsafe s

ta

tic void Zap (void* memory,

int

byteCount) {  byte*

b

= (byte*) memory;   for

(i

nt i = 0; i < byteCount; i++

)    *b

++

= 0; }}

4.17.8　指向非托管代码的指针

指针也很适合于访问托管堆之外的数据（例如与 C 语言的动态链接库 [DLL] 或组件对象模型 [COM] 交互时），或处理不在主存储器上的数据（例如显存或嵌入式设备上的存储介质）。

4.18　预处理指令

预处理指令向编译器提供关于代码的附加信息。最常用的预处理指令是条件指令，它提供了一种控制某一块代码编译与否的方法，例如：

#define DEBUG

class MyClass{ int x; void Foo() {  #if DEBUG

Console.WriteLine ("Testing: x = {0}", x);  #endif

}

...}

在上述类中，Foo

方法中的语句将根据 DEBUG

符号定义与否有条件地对其中的语句进行编译。如果移除 DEBUG

符号，则其中的语句不会编译。预处理符号可以定义在源代码中（像上例中那样），也可以在工程级别的.csproj

文件中定义。

<PropertyGroup>

<DefineConsta

nts>DEBUG;ANOTHERSYMBOL</DefineConstants></PropertyGroup

>

#if

和 #elif

指令可以使用 ||

、&&

和！

运算符对多个符号进行或、与、非的逻辑运算。下面的指令会令编译器在 TESTMODE

符号定义时并且 DEBUG

符号未定义时编译其中的代码：

#if TESTMODE && !DEBUG

...

请谨记，这并不是普通的 C# 表达式，并且这些符号和程序中定义的变量是毫无关系的，不论是静态变量还是其他变量。

#error

和 #warning

符号可以避免条件指令的滥用。它可以在出现不符合要求的编译符号时产生一条错误或警告信息。表 4-1 列出了预处理指令：

表 4-1：预处理指令

4.18.1　Conditional

特性

使用 Conditional

特性修饰的特性只有在给定的预处理符号出现时才编译。例如：

// file1.cs#define DEBUGusing System;using System.Diagnostics;[Conditional("DEBUG")]

public class TestAttribute : Attribute {}// file2.cs#define DEBUG

[Test]class F

oo{ [Test

] strin

g s;}

当 DEBUG

符号在 file2.cs

范围内出现时，编译器才会将 [Test]

特性加入进来。

4.18.2　pragma

警告

当编译器发现代码中一些看似无意的疏忽时会给出警告信息。与错误不同，警告一般不会终止应用程序的编译过程。

编译器产生的警告信息在排查代码的缺陷时是非常有用的。然而，如果得到的是虚假的警告，那么它的实用性就大打折扣了。因此在大型应用程序中，保持良好的信噪比对于发现「真正的」警告非常重要。

对此，编译器允许通过 #pragma warning

指令有选择地避免一些警告。在下面的例子中，我们指示编译器在 Message

字段没有使用时不要产生警告。

public class Foo{ static void Main() { }  #pragma warning disable 414

static string Message = "Hello"; #pragma warning restore 414

}

忽略 #pragma warning

指令中的数字则意味着禁用或恢复所有的编译器警告。

如果希望彻底应用这个指令，则可以用 /warnaserror

开关让编译器将所有警告都显示为错误。

4.19　XML 文档

文档注释是一段记录类型或成员的嵌入式 XML。文档注释位于类型或成员声明之前，以三个斜线开头：

/// <summary>Cancels a running query.</summary>

public void Cancel() { ... }

多行的注释方法如下所示：

/// <summary>

/// Cancels a

running query/// </summary

>public void C

ancel() { ... }

或像这样：

/**

<summary> Cancels a running query. </summary>*/

public void Cancel() { ... }

若在.csproj 文件中添加如下的配置：

<PropertyGroup> <DocumentationFile>SomeFile.xml

</DocumentationFile>

</PropertyGroup>

则编译器会将此类文档注释抽取到特定的 XML 文件中。这个文件主要有两种用途：

若该文件和编译生成的程序集位于用一目录下，则 Visual Studio 和 LINQPad 等工具会自动加载该 XML 文件并在消费同名程序集时利用其中的信息提供 IntelliSense 智能成员列表。

可以使用第三方工具（例如 Sandcastle 或 NDoc）将 XML 文件转换为 HTML 帮助文件。

4.19.1　标准 XML 文档标签

以下是 Visual Studio 和文档生成器支持的标准 XML 标签：

<summary>

<summary>...</summary>

IntelliSense 中展示的类型或成员帮助信息，一般为一个短语或句子。

<remarks>

<remarks>...</remarks>

类型或成员的附加描述信息。文档生成器会获得这些信息，并将其合并到类型或成员的描述信息中。

<param>

<param name="name">...</param>

对方法参数的解释。

<returns>

<returns>...</returns>

对方法返回值的解释。

<exception>

<exception [cref="type"]>...</exception>

列出该方法可能抛出的一种异常（cref

是异常的类型）。

<permission>

<permission [cref="type"]>...</permission>

说明类型或成员所需的 IPermission

类型。

<example>

<example>...</example>

该标签代表文档生成器使用的示例。它通常包含描述性信息和源代码（源代码一般位于 <c>

或 <code>

标签内）。

<c>

<c>...</c>

内联的代码片段。该标签通常用在 <example> 标签内。

<code>

<code>...</code>

多行代码的示例。该标签通常在 <example>

标签内使用。

<see>

<see cref="member

">...</see>

将一个内联的交叉引用插入到另外一个类型或成员中。HTML 文档生成器通常将其转换为一个超链接。如果类型或者成员名称是无效的，则编译器会产生一条警告信息。如果要引用泛型类型，那么要使用花括号，例如：cref="Foo {T,U}"

。

<seealso>

<seealso cref="member

">...</seealso>

交叉引用另外一个类型或成员。文档生成器通常将其写入页面下方一个独立的「See Also」小节中。

<paramref>

<paramref name="name

"/>

在 <summary>

和 <remarks>

标签内引用参数。

<list>

<list type=[ bullet | number | table ]>

<listheader>  <term>...</term>  <description>...</description> </listheader> <item>  <term>...</term>  <description>...</description> </item></list>

令文档生成器生成一个带有项目符号、编号或表格式的列表。

<para>

<para>...</para>

令文档生成器为指定内容单独生成一个段落。

<include>

<include file='filename

' path='tagpath

[@name="id

"]'>...</include>

合并包含文档的外部 XML 文件。path

属性的值是用于查询该文件中某个特定元素的 XPath 查询。

4.19.2　用户定义标签

C# 编译器不仅可以识别预定义 XML 标签，还支持用户自定义标签。<param>

标签及其 cref

属性是编译器唯一需要进行特殊处理的部分（对于 <param>

标签，它将验证参数名称，并确保方法所有的参数都在文档中进行了记录；对于 cref

属性，它将确保属性所指是真实的类型或成员，并将其扩展为完全限定类型或成员 ID）。在自定义标签中也可以定义 cref

属性。其验证和扩展方式和预定义的 <exception>

、<permission>

、<see>

及 <seealso>

标签是一样的。

4.19.3　类型或成员交叉引用

类型名称和类型或成员的交叉引用将会转换为相应类型或成员的唯一 ID。这些名称是由 ID 所表示的内容的前缀与类型或成员的签名组成的。其中，成员的前缀有以下几种：

生成签名的规则有详细的文档，但非常复杂。

以下是一个类及其生成的 ID 的示例：

// Namespaces do not have independent signatures

namespace NS{ /// T:NS.MyClass class MyClass {  /// F:NS.MyClass.aField  string aField;      /// P:NS.MyClass.aProperty  short aProperty {get {...} set {...}}      /// T:NS.MyClass.NestedType  class NestedType {...};      /// M:NS.MyClass.X()  void X() {...}      /// M:NS.MyClass.Y(System.Int32,System.Doubl

e@,System.Dec

im

al@)  void Y(int p1, ref double p2, out decimal p3

) {...}

