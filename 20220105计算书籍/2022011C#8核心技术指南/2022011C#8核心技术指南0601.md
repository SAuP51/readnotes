第 6 章

框架基础

编程所需的许多核心功能并不是由 C# 语言提供的，而是由.NET Core 中的类型提供的。本章将介绍基础编程任务（例如虚相等比较、顺序比较以及类型转换）中各种类型的作用，还会介绍.NET 中的基础类型，例如 string

、DateTime

和 Enum

。

本章中的绝大部分类型位于 System

命名空间，但以下几种类型例外：

StringBuilder

类型定义在 System.Text

命名空间。该命名空间中还包含用于文本编码的类型。

CultureInfo

及其相关类型定义在 System.Globalization

命名空间。

XmlConvert

类型定义在 System.Xml

命名空间。

6.1　字符串与文本处理

6.1.1　char

C# 中的一个 char

代表一个 Unicode 字符。char

是 System.Char

的别名。第 2 章介绍了如何表示 char

字面量，例如：

char c = 'A';

char newLine

= '\n';

System.Char

定义了一系列静态方法对字符进行处理，例如 ToUpper

、ToLower

和 IsWhiteSpace

。这些方法既可以通过 System.Char

类型进行调用也可以使用其别名 char

进行调用：

Console.WriteLine (System.Char.ToUpper ('c'));  // C

Console.WriteLine (char.IsWhiteSpace ('\t'));   // T

rue

ToUpper

和 ToLower

会受到最终用户语言环境的影响，这可能会导致微妙的缺陷。例如，下面的表达式在土耳其语言环境中会得到 false

值：

char.ToUpper ('i') == 'I'

因为在土耳其语中，char.ToUpper ('i')

的结果是 'i'

（注意字符上面的点）。为了避免这个问题，System.Char

和 System.String

还提供了和语言环境无关的，有 Invariant

后缀的 ToUpper

和 ToLower

。它们会使用英语语言规则：

Console.WriteLine (char.ToUpperInvariant ('i'));  // I

它是以下写法的简化形式：

Console.WriteLine (char.ToUpper ('i', CultureInfo.InvariantCulture))

更多关于语言环境和文化的介绍请参考 6.4 节。

char

类型中有相当一部分静态方法用于字符分类，如表 6-1 所示。

对于更详细的分类，char

提供了一个名为 GetUnicodeCategory

的静态方法，它返回一个 UnicodeCategory

枚举值，它的成员即表 6-1 最右边一列的值。

我们完全有能力通过显式转换整数来合成一个 Unicode

集之外的 char

。因此要检测字符的有效性，可以调用 char.GetUnicodeCategory

方法：如果返回值为 UnicodeCategory.OtherNotAssigned

，那么字符就是无效的。

一个 char

字符占用 16 个二进制位，这足以表示基本多文种平面（Basic Multilingual Plane，BMP）中的所有 Unicode 字符。但是如果超出此范围，就必须使用替代组（surrogate pairs）：我们将在 6.1.5 节介绍它的使用方法。

6.1.2　字符串

C# 中的 string

（== System.String

）是一个不可变（不可修改）的字符序列。第 2 章介绍了如何表示字符串字面量，如何执行相等比较以及如何连接两个字符串。本节将介绍其余的字符串处理函数：System.String

类的静态和实例成员函数。

创建字符串

创建字符串的最简单方法就是将字面量赋给一个变量，这和第 2 章介绍的做法一样：

string s1 = "Hello";

string s2 = "First L

ine\r\nSecond Line";string s3 = @"\\serv

er\fileshare\helloworld.cs";

若要创建一个重复的字符序列，可以使用 string

类的构造器：

Console.Write (new string ('*', 10));   // **********

我们还可以从 char

数组来构造一个字符串，而 ToCharArray

方法则执行相反的操作：

char[] ca = "Hello".ToCharArray();

string s = new string (ca);

// s = "Hello"

string

类的重载构造器可以接受各种（不安全的）指针类型，以便从类似 char*

的类型中创建字符串。

null

和空字符串

空字符串指长度为零的字符串。使用字面量或静态 string.Empty

字段可以创建空字符串。若要判断字符串是否为空字符串，则可以执行一个相等比较，也可以测试它的 Length

属性：

string empty = "";

Console.WriteLine

(empty == "");       // TrueConsole.WriteLine

(empty == string.Empty);  // TrueConsole.WriteLine

(empty.Length == 0);    // True

字符串是引用类型，因此它可以为 null

：

string nullString = null;

Console.WriteLine (nullSt

ring == null);    // TrueConsole.WriteLine (nullSt

ring == "");     // FalseConsole.WriteLine (nullSt

ring.Length == 0);  // NullReferenceException

使用静态方法 string.IsNullOrEmpty

可以判断一个字符串是否为 null

或空字符串。

访问字符串中的字符

字符串的索引器可以返回指定索引位置的字符。和所有操作字符串的方法相似，索引是从 0 开始计数的。

string str = "abcde";

char letter = str[1];

// letter == 'b'

string

还实现了 IEnumerable<char>

，所以可以用 foreach

遍历它的字符：

foreach (char c in "123") Console.Write (c + ",");  // 1,2,3,

字符串内搜索

在字符串内执行搜索的最简单方法是 StartsWith

、EndsWith

和 Contains

，这些方法均返回 true

或 false

：

Console.WriteLine ("quick brown fox".EndsWith ("fox"));   // True

Console.WriteLine ("quick brown fox".Contains ("brown"));  // True

StartsWith

和 EndsWith

提供了重载方法，可以使用 StringComparison

枚举或者 CultureInfo

对象来控制大小写和文化相关的规则（请参见 6.1.3 节）。其默认行为是使用当前文化规则执行区分大小写的匹配。以下代码则使用了不变文化规则执行不区分大小写的搜索：

"abcdef".StartsWith ("aBc", StringComparison.InvariantCultureIgnoreCase

)

Contains

则没有提供这种便利的重载方法，但是可以使用 IndexOf

方法实现相同的效果。

IndexOf

的功能更强：它返回指定字符或者子字符串首次出现的位置（-1

则表示该子字符串不存在）：

Console.WriteLine ("abcde".IndexOf ("cd"));  // 2

IndexOf

也提供了重载方法，不但接受 StringComparison

枚举值，还可以接受 startPosition

参数指定初始搜索的索引位置。

Console.WriteLine ("abcde abcde".IndexOf ("CD", 6,

StringComparison.CurrentCulture

IgnoreCase));  // 8

LastIndexOf

和 IndexOf

类似，只是它是从后向前进行搜索的。

IndexOfAny

返回字符串中和给定字符集中的任意一个字符相匹配的第一个位置：

Console.Write ("ab,cd ef".IndexOfAny (new char[] {' ', ','} ));    // 2

Console.Write ("pas5w0rd".IndexOfAny ("0123456789".ToCharArray() )); // 3

LastIndexOfAny

则从相反方向执行相同操作。

string

是不可变的，因此所有处理字符串的方法都会返回一个新的字符串，而原始的字符串则不受影响（其效果和重新为字符串变量赋值一样）。

Substring

方法可以提取部分字符串：

string left3 = "12345".Substring (0, 3);   // left3 = "123";

string mid3 = "12345".Substring (1, 3);   // mid3 = "234";

若省略长度，则会得到字符串的剩余部分：

string end3 = "12345".Substring (2);    // end3 = "345";

Insert

和 Remove

会在特定的位置插入或者删除一些字符：

string s1 = "helloworld".Insert (5, ", ");  // s1 = "hello, world"

string s2 = s1.Remove (5, 2);         // s2 = "helloworld";

PadLeft

和 PadRight

会用指定的字符（如果未指定则使用空格）将字符串填充为指定的长度：

Console.WriteLine ("12345".PadLeft (9, '*')); // ****12345

Console.WriteLine ("12345".PadLeft (9));    //   12345

如果输入字符串长度大于填充长度，则返回不加修改的原始字符串。

TrimStart

和 TrimEnd

会从字符串的开头或结尾删除指定的字符，Trim

则是从开头和结尾执行删除操作。这些方法默认会删除空白字符（包括空格、制表符、换行符和这些字符的 Unicode

变体）：

Console.WriteLine (" abc \t\r\n ".Trim().Length);  // 3

Replace

会替换字符串中所有（非重叠的）特定字符或子字符串：

Console.WriteLine ("to be done".Replace (" ", " | ") ); // to | be | done

Console.WriteLine ("to be done".Replace (" ", "")  ); // tobedone

ToUpper

和 ToLower

会返回与输入字符串相对应的大写和小写字符串。默认情况下，它会受用户当前语言设置的影响；ToUpperInvariant

和 ToLowerInvariant

则总是应用英语字母表规则。

字符串的分割与连接

Split

会将字符串分割为若干部分：

string[] words = "The quick brown fox".Split();

foreach (string word in words) Console.Write (word + "|");  // The|quick|b

r

own|fox|

默认情况下，Split

使用空白字符作为分隔符；重载的方法也可以接受 char

和 string

分隔符的 params

数组。Split

还可以接受一个 StringSplitOptions

枚举值以删除空项。这在一行文本中有多种单词分隔符时很有用。

静态方法 Join

则执行和 Split

相反的操作。它需要一个分隔符和字符串的数组：

string[] words = "The quick brown fox".Split();

string together = string.Join (" ", words);

// The quick brown fox

静态方法 Concat

和 Join

类似，但是它只接受一个字符串的 params

数组，且不支持分隔符。Concat

操作和 +

运算符效果完全相同（实际上，编译器会将 +

转换为 Concat

）：

string sentence   = string.Concat ("The", " quick", " brown", " fox");

string sameSentence = "The" + " quick" + " brown" + " fox";

string.Format

与组合格式字符串

静态方法 Format

提供了创建嵌入变量的字符串的便利方法。嵌入的变量（或值）可以是任何类型，而 Format

则会直接调用它们的 ToString

方法。

包含嵌入变量的主字符串称为组合格式字符串。调用 String.Format

时，需要提供一个组合格式字符串，后面紧跟每一个嵌入的变量，例如：

string composite = "It's {0} degrees in {1} on this {2} morning";

string s = string.Format (composite, 35, "Perth", DateTime.Now.Da

yOfWeek);// s == "It's 35 degrees in Perth on this Friday morning"

（单位是摄氏度！）

插值字符串字面量可以实现和上述例子相同的效果（请参见 2.6.2 节）。只需在字符串前附加 $

符号，并将表达式写在花括号中：

string s = $

"It's hot this {DateTime.Now.DayOfWeek} morning";

花括号里的数字称为格式项。这些数字对应参数的位置，后面可以跟：

逗号与应用的最小宽度

冒号与格式字符串

最小宽度用于对齐各个列。如果其值为负数，则为左对齐，否则为右对齐：

string composite = "Name={0,-20}

Credit Limit={1,15:C}

";

Co

n

sole.WriteLine (string.Format (composite, "Mary", 500));Co

n

sole.WriteLine (string.Format (composite, "Elizabeth", 20000

));

运行结果为：

Name=Mary         Credit Limit=    $500.00

Name=Elizabeth      Credit Limit=   $20,000.00

如果不使用 string.Format

，则上述方法可写为：

string s = "Name=" + "Mary".PadRight (20) +

" Credit Limit=" + 500.ToString

("C").PadLeft (15);

上例中的信用额度是通过 "C"

格式字符串转换为货币值的。6.4 节将详细介绍格式字符串。

6.1.3　字符串的比较

.NET Core 在两个值的比较上划分了两个不同的概念：相等比较和顺序比较。相等比较验证两个实例是否在语义上是相同的，而顺序比较则验证两个实例（如果有的话）按照升序或者降序排列时哪一个应当首先出现。

相等比较并不是顺序比较的一个子集。这两种方法各自有不同的用途。例如，两个不同的值却可以有相同的排序位置。我们将在 6.11 节介绍相关内容。

字符串之间可以使用 ==

运算符或者 string

的 Equals

方法来进行相等比较。后者可以指定一些选项（例如不区分大小写），因此功能更强。

另一个不同点是，如果将变量转换为 object

类型，则 ==

就不一定是按字符串处理的了。我们将在 6.11 节说明原因。

字符串的顺序比较则可使用实例方法 CompareTo

或者静态方法 Compare

和 Compare- Ordinal

。这些方法会返回一个正数、负数或者 0，取决于第一个值是在第二个值之后、之前还是同时出现。

在详细介绍每一个方法之前，我们需要了解.NET 中的字符串比较算法。

序列比较与文化相关的字符串比较

字符串比较有两种基本算法：序列比较和文化相关的比较。序列比较会直接将字符串解析为数字（按照它们的 Unicode 字符数值）；而文化相关的比较则参照特定的字母表来解析字符。有两种特殊的文化：当前文化，基于计算机控制面板的设定；不变文化，在任何计算机上都是相同的（并且和美国文化密切一致）。

对于相等比较，序列和文化相关的算法都是非常有用的。而排序时，则通常选择文化相关的比较：因为当按照字符进行排序时，通常需要一个字母顺序表。序列比较依赖的是 Unicode 的数字位置，这恰好会使英文字母按照顺序排列，但即使是这样也可能不能满足要求。例如，在区分大小写的情况下，考虑如下字符串 "Atom"

、"atom"

和 "Zamia"

。使用不变文化则其排列顺序将是：

"atom", "Atom", "Zamia"

而使用序列比较则为：

"Atom", "Zamia", "atom"

这是因为不变文化封装了一个字母表，它认为大写字符与其对应的小写字符是相邻的（aAbBcCdD…）。然而序列比较算法将所有大写字母排列在前面，然后才是全部小写字母（A…Z，a…z）。这实际上回归到了 20 世纪 60 年代发明的 ASCII 字符集。

字符串的相等比较

尽管序列比较有其局限性，但是字符串的 ==

运算符总是执行区分大小写的序列比较。不带参数的 string.Equals

方法也是用同样的方式。这就是 string

类型的「默认」相等比较的行为。

字符串的 ==

和 Equals

方法选择序列算法的原因是它既高效又具有确定性。字符串相等比较是基础操作，远比顺序比较使用频繁。

「严格」的相等概念与 ==

运算符的一般用途是一致的。

下面的方法允许执行文化相关的不区分大小写比较：

public bool Equals(string value, StringComparison comparisonType);

public static bool Equals (string a, string b,              StringComparison comparisonType);

推荐使用静态的版本因为它在两个字符串中的一个或者全部为 null

时仍然有效。StringComparison

是枚举类型，其定义如下：

public enum StringComparison

{ CurrentCulture,



// Case-sensitive CurrentCultureIgnoreCase, InvariantCulture,



// Case-sensitive InvariantCultureIgnoreCase

, Ordinal,



// Case-sensitive OrdinalIgnoreCase}

例如：

Console.WriteLine (string.Equals ("foo", "FOO",

StringComparison.OrdinalIgno

reCase));  // TrueConsole.WriteLine ("ṻ" == "ǖ");

// FalseConsole.WriteLine (string.Equals ("ṻ", "ǖ",          StringComparison.CurrentCult

ure));   // ?

（上例中的第三个比较的结果是由计算机当前语言设置决定的。）

字符串的顺序比较

String

的实例方法 CompareTo

执行文化相关的区分大小写的顺序比较。与 ==

运算符不同，CompareTo

不使用序列比较。这是因为对于排序来说，文化相关的算法更为有效。

以下是方法的定义：

public int CompareTo (string strB);

实例方法 CompareTo

实现了 IComparable

泛型接口（它也是在整个.NET Core 中使用的标准比较协议）。这意味着 string

的 CompareTo

定义了字符串在应用程序中作为集合元素时排序的默认行为。关于 IComparable

的更多内容请参见 6.12 节。

对于其他类型的比较，则可以调用静态方法 Compare

和 CompareOrdinal

：

public static int Compare (string strA, string strB,

StringComparison comparis

onType);public static int Compare (string strA, string strB,

bool ignoreCase,              CultureInfo culture);public static int Compare (string strA, string strB,

bool ignoreCase);public static int CompareOrdinal (string strA, strin

g strB);

后两个方法是前面两个方法的快捷调用形式。

所有的顺序比较方法都返回正数、负数或者零，取决于第一个值是在第二个值之后，之前还是相同的位置：

Console.WriteLine ("Boston".CompareTo ("Austin"));  // 1

Console.WriteLine ("Boston".CompareTo ("Boston"));  // 0

Console.WriteLine ("Boston".CompareTo ("Chicago"));  // -

1Console.WriteLine ("ṻ".CompareTo ("ǖ"));       // 0

Console.WriteLine ("foo".CompareTo ("FOO"));     // -

1

以下语句使用当前文化进行不区分大小写的比较：

Console.WriteLine (string.Compare ("foo", "FOO", true));  // 0

指定 CultureInfo

对象可以植入任意的字母表：

// CultureInfo is defined in the System.Globalization namespace

CultureInfo german = CultureInfo.GetCultureInfo ("de-DE");int i = string.Compare ("Müller", "Muller", false, german);

6.1.4　StringBuilder

StringBuilder

类（System.Text

命名空间）表示一个可变（可编辑）的字符串。StringBuilder

可以直接进行子字符串的 Append

、Insert

、Remove

和 Replace

而无须替换整个 StringBuilder

。

StringBuilder

的构造器可以选择接受一个初始字符串值及其内部容量的初始值（默认为 16 个字符）。如果需要更大的容量，则 StringBuilder

会自动（以较小的性能代价）调整它的内部结构至其最大的容量（默认为 int.MaxValue

）。

StringBuilder

一般通过反复调用 Append

来构建较长的字符串，这比反复连接字符串类型对象要高效得多：

StringBuilder sb = new StringBuilder();for (int i = 0; i < 50; i++) sb.Append(i).Append(",")

;

可以调用 ToString ()

方法来获得最终结果：

Console.WriteLine (sb.ToString());

0,1,2,3,4,5,6,7,8,9,10,11,12,13,14

,

15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,3

8

,39,40,41,42,43,44,45,46,47,48,49,

AppendLine

执行 Append

操作，随后添加一个换行序列（在 Windows 下为 "\r\n"

）。而 AppendFormat

则接受一个组合格式字符串，这和 String.Format

是类似的。

除了 Insert

、Remove

和 Replace

方法（Replace

方法和字符串的 Replace

方法类似），StringBuilder

还定义了 Length

属性和一个可写的索引器（以获得或设置每一个字符）。

如果要清除 StringBuilder

的内容，可以创建一个新的 StringBuilder

或者将其 Length

设置为零。

将 StringBuilder

的 Length

属性设置为 0 并不会减小其内部容量。因此，如果之前 StringBuilder

已经包含了一百万个字符，则它在 Length

设置为 0 后仍然占用大约 2 MB 的内存。因此，如果希望释放这些内存，必须新建一个 StringBuilder

，然后将旧的对象清除出作用域（从而可以被垃圾回收）。

6.1.5　文本编码和 Unicode

字符集是一种字符配置，每一种配置包含一个数字码或者代码点。常用的字符集有两种：Unicode 和 ASCII。Unicode 具有约一百万个字符的地址空间，目前已经分配的大约有 100 000 个。Unicode 包括世界上使用最广泛的语言、一些历史语言以及特殊符号。ASCII 字符集只是 Unicode 字符集的前 128 个字符。它包括 US 风格键盘上的大多数字符。ASCII 比 Unicode 出现早 30 年，有时仍以其简单性和高效性而得到应用，它的每一个字符都是用一个字节表示的。

.NET 类型系统的设计使用的是 Unicode 字符集，但是它隐式支持 ASCII 字符集，因为 ASCII 字符集是 Unicode 的子集。

文本编码（text encoding）是将字符从其数字代码点映射到二进制表示的方法。在.NET 中，文本编码主要用于处理文本文件和流。当将一个文本文件读取到字符串时，文本编码器会将文件数据从二进制转换为 char

和 string

类型使用的内部 Unicode 表示形式。文本编码能够限制哪些字符可以被识别，并影响存储效率。

.NET 的文本编码分为两类：

一类是将 Unicode 字符映射到其他字符集

一类是使用标准的 Unicode 编码模式

第一类包含遗留的编码方式，例如 IBM 的 EBCDIC 以及包含前 128 个区域扩展字符的 8 位字符集（这种将字符集字以代码页进行区分的方法，在 Unicode 之前就已经普遍存在了）。ASCII 编码也属于这一类：它将对前 128 个字符编码，然后去掉其他字符。这个分类也包含 GB18030（这种编码方式并非遗留编码方式），这种编码是从 2000 年以后，在中国开发或在中国销售的应用程序的强制编码标准。

第二类是 UTF-8、UTF-16、UTF-32（和废弃的 UTF-7）。每一种编码方式在空间的使用效率上都有所差别。UTF-8 对于大多数文本而言是最具空间效率的：它使用 1～4 个字节来表示每一个字符。前 128 个字符每个字符只需要一个字节，这样它就可以兼容 ASCII。UTF-8 是最普遍的文本文件和流编码方式（特别是在 Internet 上），也是.NET 中默认的流的 I/O 编码方式（事实上，它几乎是所有隐式使用编码功能的默认编码方式）。

UTF-16 使用一个或者两个 16 位字来表示一个字符，它是.NET 内部表示字符和字符串的方式。有一些程序也使用 UTF-16 来写入文件内容。

UTF-32 是空间效率最低的：每一个代码点直接对应一个 32 位数，所以每一个字符都会占用 4 个字节。因此，UTF-32 很少使用。然而由于每一个字符都有相同的字节数，因此它可以简化随机访问操作。

获取 Encoding

对象

System.Text

中的 Encoding

类是封装文本编码的基类型。它有一些特性相似的子类，封装了其他编码方式。实例化一个配置正确的编码类的最简单方式是调用 Encoding.GetEncoding

方法，并传入标准的 IANA（互联网数字分配机构，Internet Assigned Numbers Authority）字符集名称。

Encoding utf8 = Encoding.GetEncoding ("utf-8");

Encoding chinese = Encoding.GetEncoding ("GB180

30");

以下这些最常用的编码方式也可以通过调用 Encoding

类的特定静态属性获得：

静态方法 GetEncodings

返回所有支持的编码方式的清单及其对应的标准 IANA 名称：

foreach (EncodingInfo info in Encoding.GetEncodings())

Console.WriteLine (info.Name);

获取编码方式的另一个方法是直接实例化 Encoding

类。这样做可以通过构造器参数来设置各种选项，包括：

在解码时，如果遇到无效字节序列，是否抛出异常。默认为 false

。

对 UTF-16 和 UTF-32 进行编码或解码时是否使用最高有效字节优先（大字节存储顺序）或最低有效字节优先（小字节存储顺序）。默认值为小字节存储顺序。这也是 Windows 操作系统的标准。

是否使用字节顺序标记（表示字节顺序的前缀）。

文件与流 I/O 编码

Encoding

对象最常见的应用是控制文件或流的文本读写操作。例如，下面的代码将 "Testing..."

以 UTF-16 的编码方式写入文件 data.txt 中：

System.IO.File.WriteAllText ("data.txt", "Testing...", Encoding.Unicode);

如果省略最后一个参数，则 WriteAllText

会使用最普遍的 UTF-8 编码方式。

UTF-8 是所有文件和流 I/O 的默认文本编码方式。

我们将在 15.3 节继续对这个问题进行阐述。

编码为字节数组

Encoding

对象可以将文本转换为字节数组，反之亦然。GetBytes

方法用指定的编码方式将 string

转换为 byte []

；而 GetString

则将 byte []

转换为 string

：

byte[] utf8Bytes = System.Text.Encoding.UTF8.GetBytes  ("0123456789");

byte[] utf16Bytes = System.Text.Encoding.Unicode.GetBytes ("0123456789");

byte[] utf32Bytes = System.Text.Encoding.UTF32.GetBytes  ("0123456789");

Console.WriteLine (utf8Bytes.Length);  // 10Console.WriteLine (utf16Bytes.Length);  // 20Console.WriteLine (utf32Bytes.Length);  // 40string original1 = System.Text.Encoding.UTF8.GetString  (utf8Bytes);string original2 = System.Text.Encoding.Unicode.GetString (utf16Bytes);string original3 = System.Text.Encoding.UTF32.GetString  (utf32Bytes);Console.WriteLine (original1);     // 0123456789Console.WriteLine (original2);     // 0123456789Console.WriteLine (original3);     // 0123456789

UTF-16 和替代组

前面提到.NET 将字符和字符串存储为 UTF-16 格式。由于 UTF-16 每一个字符需要一个或者两个 16 位的字，而 char

只有 16 位，这就意味着有些 Unicode 字符需要两个 char

来表示。这会造成两个后果：

字符串的 Length

属性值可能大于它的实际字节数。

一个 char

有时无法完整表示一个 Unicode 字符。

大多数应用程序会忽略这一点，因为几乎所有常用的字符都位于名为基本多文种平面（Basic Multilingual Plane，BMP）这个 Unicode 节。而这一节中的字符在 UTF-16 编码下只需要 16 位就可以表示。BMP 包括了几十种世界语言，并含有超过 30 000 个汉字字符。只有一些古代语言、乐谱符号和生僻汉字字符不包含在内。

如果需要支持双字字符，那么可以用如下的 char 类型下的静态方法将 32 位代码点转换为一个包含两个字符的字符串，同样也可以进行反向转换：

string ConvertFromUtf32 (int utf32)

int  ConvertToUtf32  (char highS

urrogate, char lowSurrogate)

双字字符称为替换字符。它们很容易辨认，因为每一个字都是从 0xD800

到 0xDFFF

。char

类型的以下静态方法可进行替换字符相关的判断：

bool IsSurrogate   (char c)

bool IsHighSurrogate (char c)

bool IsLowSurrogate (char c)

bool IsSurrogatePair (char hi

ghSurrogate, char lowSurrogate

)

System.Globalization

命名空间下的 StringInfo

类也提供了一组处理双字字符的方法和属性。

BMP 之外的字符一般需要特殊的字体，并且只有非常有限的操作系统支持。

6.2　日期和时间

在 System

命名空间中有三个不可变的结构体用以进行日期和时间的表示：DateTime

、DateTimeOffset

和 TimeSpan

。C# 没有定义与这些类型对应的关键字。

6.2.1　TimeSpan

TimeSpan

表示一段时间间隔或是一天内的时间。对于后者，它就是一个时钟时间（不包括日期）。它等同于从午夜开始到现在的时间（假设没有夏令时）。TimeSpan

的最小单位为 100 纳秒，最大值为一千万天，可以为正数也可以为负数。

创建 TimeSpan

的方法有三种：

通过它的一个构造器

通过调用其中一个静态方法 From...

通过两个 DateTime

相减得到

TimeSpan

的构造器如下：

public TimeSpan (int hours, int minutes, int seconds);

public TimeSpan (int days, int hours, int minutes, int

seconds);public TimeSpan (int days, int hours, int minutes, int

seconds,                          int

milliseconds);public TimeSpan (long ticks);  // Each tick = 100ns

如果希望指定一个单位时间（例如分钟、小时等）间隔，那么静态方法 From...

更方便：

public static TimeSpan FromDays (double value);

public static TimeSpan FromHours (double value)

;public static TimeSpan FromMinutes (double valu

e);public static TimeSpan FromSeconds (double valu

e);public static TimeSpan FromMilliseconds (double

value);

例如：

Console.WriteLine (new TimeSpan (2, 30, 0));   // 02:30:00

Console.WriteLine (TimeSpan.FromHours (2.5));  // 02:30:00

Console.WriteLine (TimeSpan.FromHours (-2.5));  // -02:30:0

0

TimeSpan

重载了 <

、>

、+

和 -

运算符。以下表达式可以得到一个 2.5 小时的 TimeSpan

：

TimeSpan.FromHours(2) + TimeSpan.FromMinutes(30);

下面的表达式则表示 10 天减去 1 秒所剩的时间间隔：

TimeSpan.FromDays(10) - TimeSpan.FromSeconds(1);  // 9.23:59:59

仍使用上述表达式展示 Days

、Hours

、Minutes

、Seconds

和 Milliseconds

这几个整数的类型属性：

TimeSpan nearlyTenDays = TimeSpan.FromDays(10) - TimeSpan.FromSeconds(1);

Console.WriteLine (nearlyTenDays.Days);     // 9Console.WriteLine (nearlyTenDays.Hours);     // 23Console.WriteLine (nearlyTenDays.Minutes);    // 59Console.WriteLine (nearlyTenDays.Seconds);    // 59Console.WriteLine (nearlyTenDays.Milliseconds); // 0

相反，Total...

属性则返回表示整个时间跨度的 double

类型值：

Console.WriteLine (nearlyTenDays.TotalDays);     // 9.99998842592593

Console.WriteLine (nearlyTenDays.TotalHours);     // 239.999722222222

Console.WriteLine (nearlyTenDays.TotalMinutes);    // 14399.9833333333

Console.WriteLine (nearlyTenDays.TotalSeconds);    // 863999Console.WriteLine (nearlyTenDays.TotalMilliseconds); // 863999000

静态的 Parse

方法则执行与 ToString

相反的操作，即将字符串转换为 TimeSpan

。TryParse

和 Parse

方法一样，只是在转换失败时返回 false

而非抛出异常。XmlConvert

类也提供了基于 XML 格式化标准协议的 TimeSpan

/ 字符串转换方法。

TimeSpan

的默认值是 TimeSpan.Zero

。

TimeSpan

也可以表示一天内的时间（从午夜到现在的时间）。要获得当前的时间，可以调用 DateTime.Now.TimeOfDay

。

6.2.2　DateTime

和 DateTimeOffset

DateTime

和 DateTimeOffset

都是表示日期或者时间的不可变结构体。它们的最小单位均为 100 纳秒，而且值的范围为 0001

～9999

年。

DateTimeOffset

和 DateTime

的功能类似。但是它主要的特点是存储了协调世界时（UTC）的偏移量，这使得在进行不同时区的时间值比较时也能得到有效的结果。

Microsoft 官方网站上有一篇关于引入 DateTimeOffset

的基本原理的文章，其标题为「A Brief History of DateTime」（https://oreil.ly/a1C2N

），作者是 Anthony Moore。

使用 DateTime

还是 DateTimeOffset

DateTime

和 DateTimeOffset

处理时区的方式不同。DateTime

具有三个状态标记来表示该 DateTime

是否是相对于：

当前计算机的本地时间

UTC（现代的格林尼治标准时间）不确定

而 DateTimeOffset

则更加明确，它将 UTC 的偏移量存储为一个 TimeSpan

：

July 01 2019 03:00:00 -06:00

这种特性必将影响相等比较结果，而这也是在 DateTime

和 DateTimeOffset

之间做出选择的主要依据。特别是：

DateTime

会在比较时忽略三状态标记。若两个值的年、月、日、时、分等相同，就认为它们是相等的。

如果两个值指的是相同的时间点，那么 DateTimeOffset

则认为它们是相等的。

夏令时会使这种差异的区分显得更加重要，即使应用程序不需要处理多个地理时区时也面临这个问题。

因此，DateTime

会认为以下两个值是不相等的，而 DateTimeOffset

则认为是相同的：

July 01 2019 09:00:00 +00:00 (GMT)

July 01 2019 03:00:00 -06:00 (loca

l time, Central America)

在大多数情况下，DateTimeOffset

的相等比较逻辑都会更好。例如，在计算两个国际事件哪个先于另一个发生时，DateTimeOffset

就可以隐式地给出正确的答案。类似地，策划分布式拒绝服务攻击的黑客也会触及 DateTimeOffset

！如果使用 DateTime

进行相同的操作，则需要在整个应用程序中统一时区（一般是 UTC）。而这有两个问题：

为了给最终用户友好的体验，UTC DateTime

需要在格式化之前显式转换为本地时间。

人们很容易忘记上述规则而直接使用本地的 DateTime

。

如果在运行时只关心本地计算机的时间，则 DateTime

会更好。例如，如果希望在每个跨国办公室的本地时间的下周日凌晨三点（这是活动最少的时间）调度一次存档操作，则使用 DateTime

可能更合适，因为它与每一个站点的本地时间相对应。

在内部，DateTimeOffset

使用一个短整数来存储以分钟为单位的 UTC 偏移量。它不会存储任何与时区有关的信息，所以我们无法区分 + 08:00 偏移值指的是新加坡时间还是珀斯时间。

我们将在 6.3 节深入阐述时区和相等比较操作。

SQL Server 2008 引入了同名的数据类型以直接对 DateTimeOffset

进行支持。

创建 DateTime

DateTime

定义了能够接受年、月、日（还有可选的时、分、秒、毫秒）等整数值的构造器：

public DateTime (int year, int month, int day);

public DateTime (int year, int month, int day,         int hour, int minute, int seco

n

d, int millisecond);

如果只指定日期，则时间会隐式设置为午夜（0:00）。

DateTime

的构造器也允许指定一个 DateTimeKind

，这是一个具有以下值的枚举：

Unspecified, Local, Utc

这三个值与前面介绍的三个状态标记对应。Unspecified

是默认值，表示 DateTime

并未指定时区信息。Local

表示相对于当前计算机的本地时区。本地的 DateTime

并没有包含它引用了哪一个时区的信息，也不像 DateTimeOffset

那样包含相对 UTC 的偏移量。

DateTime

的 Kind

属性返回其 DateTimeKind

值。

DateTime

的构造器也提供了重载以接受 Calendar

对象。这意味着可以使用 System.Globalization

下的 Calendar

的子类来指定一个日期：

DateTime d = new DateTime (5767, 1, 1,

new System.G

lobalization.HebrewCalendar());Console.WriteLine (d);  // 12/12/200

6 12:00:00 AM

（本例中日期的格式取决于计算机控制面板中的设置。）DateTime

总是使用默认的公历，而本例在构造时进行了一次转换。如果要使用另一个日历进行计算，则需要调用 Calendar

子类的方法。

也可以使用 long

类型的计数值（tick）来构造 DateTime

，其中计数值是从 01/01/0001 年的午夜开始计时的，间隔为 100 纳秒。

在互操作性上，DateTime

提供了静态方法 FromFileTime

和 FromFileTimeUtc

以转换 Windows 文件的时间（其类型为 long

），同时提供了 FromOADate

用于转换 OLE 的日期 / 时间（类型为 double

）。

若要从字符串创建 DateTime

，则可以调用 Parse

或 ParseExact

静态方法。这两个方法都接受可选的标记或格式提供器，ParseExact

还接受格式字符串。我们将在 6.4 节详细讨论日期时间的解析。

创建 DateTimeOffset

DateTimeOffset

和 DateTime

具有类似的构造器，其区别是 DateTimeOffset

还需要指定一个 TimeSpan

类型的 UTC 偏移量：

public DateTimeOffset (int year, int month, int day,            int hour, int minute, int second,            TimeSpan offset

);public DateTimeOffset (int year, int month, int day,            int hour, int minute, int second, int millisecond,            TimeSpan offset

);

TimeSpan

必须是整数分钟数，否则构造器会抛出异常。

DateTimeOffset

也有接受 Calendar

对象、long

计数值的构造器，以及接受字符串的 Parse

和 ParseExact

静态方法。

还可以通过以下构造器从现有的 DateTime

创建 DateTimeOffset

：

public DateTimeOffset (DateTime dateTime);

public DateTimeOffset (DateTime dateTime,

TimeSpan offset);

也可以通过隐式类型转换创建：

DateTimeOffset dt = new DateTime (2000, 2, 3);

从 DateTime

隐式转换到 DateTimeOffset

是非常贴心的设计。因为大多数.NET Core 类型都支持 DateTime

而不是 DateTimeOffset

。

如果没有指定偏移量，则可以使用以下规则从 DateTime

值推断出偏移量：

如果 DateTime

具有一个 Utc

的 DateTimeKind

，那么偏移量为零。

如果 DateTime

具有一个 Local

或 Unspecified

（默认）的 DateTimeKind

，那么偏移量以本地时区计算。

为了进行反方向转换，DateTimeOffset

提供了三个返回 DateTime

的属性：

UtcDateTime

属性会返回一个 UTC 的 DateTime

。

LocalDateTime

属性会返回一个以本地时区（在需要的时候进行转换）表示的 DateTime

。

DateTime

属性返回忽略时区表示的 DateTime

，其 Kind

属性为 Unspecified

（例如，它返回一个加上了偏移量的 UTC 时间）。

获得当前 DateTime

/DateTimeOffset

DateTime

和 DateTimeOffset

都具有一个静态的 Now

属性，它会返回当前的日期和时间：

Console.WriteLine (DateTime.Now);     // 11/11/2019 1:23:45 PM

Console.WriteLine (DateTimeOffset.Now);  // 11/11/2019 1:23:45 PM

-06:00

DateTime

还有一个 Today

属性，它将返回日期的部分：

Console.WriteLine (DateTime.Today);    // 11/11/2019 12:00:00 AM

静态的 UtcNow

属性会返回 UTC 的当前日期和时间：

Console.WriteLine (DateTime.UtcNow);    // 11/11/2019 7:23:45 AM

Console.WriteLine (DateTimeOffset.UtcNow); // 11/11/2019 7:23:45 AM

+00:00

这些方法的返回精度取决于操作系统，一般情况下都在 10～20 毫秒范围内。

日期和时间的处理

DateTime

和 DateTimeOffset

都提供了相似的返回各种日期时间元素的实例属性：

DateTime dt = new DateTime (2000, 2, 3,

10, 20, 30)

;Console.WriteLine (dt.Year);     //

2000Console.WriteLine (dt.Month);    //

2Console.WriteLine (dt.Day);     //

3Console.WriteLine (dt.DayOfWeek);  //

ThursdayConsole.WriteLine (dt.DayOfYear);  //

34Console.WriteLine (dt.Hour);     //

10Console.WriteLine (dt.Minute);    //

20Console.WriteLine (dt.Second);    //

30Console.WriteLine (dt.Millisecond); //

0Console.WriteLine (dt.Ticks);    //

630851700300000000Console.WriteLine (dt.TimeOfDay);  //

10:20:30 (returns a TimeSpan)

DateTimeOffset

还有一个返回 TimeSpan

类型偏移量的属性 Offset

。

DateTime

和 DateTimeOffset

都提供了以下可进行日期时间运算的实例方法（大部分方法接受 double

或 int

类型的参数）：

AddYears AddMonths  AddDays

AddHours AddMinutes AddSeco

nds AddMilliseconds AddTicks

这些方法都返回新的 DateTime

或 DateTimeOffset

，并考虑了闰年问题，同时还可以通过输入负数来执行减法运算。

Add

方法会将一个 TimeSpan

值和 DateTime

或 DateTimeOffset

值相加。重载的 +

运算符也可以执行同样的操作：

TimeSpan ts = TimeSpan.FromMinutes (90);

Console.WriteLine (dt.Add (ts));Console.WriteLine (dt + ts);

// same as above

当然，还可以从 DateTime

或 DateTimeOffset

减去一个 TimeSpan

值，或将两个 DateTime

/DateTimeOffset

值相减。后一种运算会返回一个 TimeSpan

：

DateTime thisYear = new DateTime (2015, 1, 1);

DateTime nextYear = thisYear.AddYears (1);TimeSpan oneYear = nextYear - thisYear;

DateTime

的格式化和解析

调用 DateTime

的 ToString

会将结果格式化为一个短日期（全部都是数字），后面跟一个长时间（包括秒）。例如：

11/11/2019 11:50:30 AM

默认情况下，在操作系统的控制面板中可以设置日、月、年哪一个部分在前，是否用前置的 0 补齐位数，以及使用 12 小时还是 24 小时表示法。

调用 DateTimeOffset

的 ToString

效果是一样的，只是它同时会返回偏移量：

11/11/2019 11:50:30 AM -06:00

ToShortDateString

和 ToLongDateString

方法只返回日期部分。长日期格式也是在控制面板中设置的，例如「Wednesday, 11 November 2015」。ToShortTimeString

和 ToLongTimeString

则仅返回时间部分，例如 17:10:10（前者不包含秒）。

刚刚介绍的这四个方法实际上是使用四种不同格式字符串的快捷方式。ToString

重载后可以接受格式字符串和格式提供器。这些参数提供了大量的选项来控制区域设置的生效方式。相关内容请参见 6.4 节。

如果文化设置和格式化方式差异过大，那么可能造成 DateTime

和 Date-TimeOffset

的解析出错。此时，可以在 ToString

中指定文化无关的格式字符串（例如「o」

）来忽略文化设置。

DateTime dt1 = DateTime.Now;string cannotBeMisparsed = dt1.ToString ("o")

;

D

ateTime dt2 = DateTime.Parse (cannotBeMisparsed);

而 Parse

/TryParse

和 ParseExact

/TryParseExact

静态方法则执行和 ToString

相反的操作：将字符串转换为 DateTime

或 DateTimeOffset

。这些方法同样进行了重载以接受格式提供器。Try*

方法会在解析失败时返回 false

而不会抛出 FormatException

。

DateTime

和 DateTimeOffset

的空值

由于 DateTime

和 DateTimeOffset

都是结构体，因此它们是不能为 null

的。当需要将其设置为 null

时，可以使用如下两种方法：

使用 Nullable

类型（例如 DateTime?

或 DateTimeOffset?

）。

使用 DateTime.MinValue

或 DateTimeOffset.MinValue

静态字段（它们同时也是这些类型的默认值）。

使用可空值类型通常是最佳方法，因为编译器可以防止代码出现错误。DateTime.MinValue

对于兼容 C# 2.0（引入了可空值类型）之前编写的代码是很有用的。

在 DateTime.MinValue

上调用 ToUniversalTime

或 ToLocalTime

可能返回一个不为 DateTime.MinValue

的值（取决于在 GMT 的哪一边）。如果恰好就在 GMT（夏令时以外的英格兰地区），那么完全没有问题，因为本地时间和 UTC 时间是相同的。这真是对英格兰严冬之苦的补偿！

6.3　日期和时区

本节将更详细地介绍时区对 DateTime

和 DateTimeOffset

的影响。同时还会介绍两种类型：TimeZone

和 TimeZoneInfo

，它们提供了各个时区偏移量以及夏令时信息。

6.3.1　DateTime

与时区

DateTime

处理时区的方式很简单。它将 DateTime

存储为两部分信息：

一个 62 位数，表示从 01/01/0001 开始的时间计数值。

一个 2 位枚举数，表示 DateTimeKind

（Unspecified

、Local

或 Utc

）。

当比较两个 DateTime

实例时，参与比较的只有它们的计数值，而 DateTimeKinds

则被忽略：

DateTime dt1 = new DateTime (2000, 1, 1, 10, 20, 30, DateTimeKind.Local);

DateTime dt2 = new DateTime (2000, 1, 1, 10, 20, 30, DateTimeKind.Utc);Console.WriteLine (dt1 == dt2);     // TrueDateTime local = DateTime.Now;DateTime utc = local.ToUniversalTime();Console.WriteLine (local == utc);    // False

实例方法 ToUniversalTime

/ToLocalTime

会将日期时间转换为 UTC / 本地时间。这些方法会使用计算机的当前时区设置，返回 DateTimeKind

为 Utc

或 Local

的全新 DateTime

。如果在 DateTimeKind

为 Utc

的 DateTime

上调用 ToUniversalTime

，或是在 Local

的 DateTime

上调用 ToLocalTime

，不会发生任何转换。但是，如果在 Unspecified

的 DateTime

上调用 ToUniversalTime

或 ToLocalTime

，则会发生转换。

使用 DateTime.SpecifyKind

静态方法可以创建一个 Kind

不同的 DateTime

：

DateTime d = new DateTime (2015, 12, 12); // Unspecified

DateTime utc = DateTime.SpecifyKind (d, DateTimeKind.Utc)

;Console.WriteLine (utc);      // 12/12/2015 12:00:0

0 AM

6.3.2　DateTimeOffset

与时区

DateTimeOffset

内部包括一个值总是为 UTC 的 DateTime

字段和一个用 16 位整数表示的以分钟计量的 UTC 偏移量。在比较时只比较（UTC 的）DateTime

字段，偏移量主要用于格式化。

ToUniversalTime

/ToLocalTime

方法会返回一个表示相同时间点的 DateTimeOffset

，但是分别具有一个 UTC 或本地时间的偏移量。与 DateTime

不同，这些方法不会影响底层的日期 / 时间值，只影响偏移量：

DateTimeOffset local = DateTimeOffset.Now;

DateTimeOffset utc  = local.ToUniversalTi

me();Console.WriteLine (local.Offset);  // -06

:00:00 (in Central America)Console.WriteLine (utc.Offset);   // 00:

00:00Console.WriteLine (local == utc);

// True

如果要在比较中将 Offset

也考虑在内，可以使用 EqualsExact

方法：

Console.WriteLine (local.EqualsExact (utc));   // False

6.3.3　TimeZone

和 TimeZoneInfo

TimeZone

和 TimeZoneInfo

类均提供时区名称、时区的 UTC 偏移量和夏令时规则。其中 TimeZoneInfo

具有更强的功能。

两者最大的区别是 TimeZone

只能够访问本地时区，而 TimeZoneInfo

则能够访问全世界的时区。而且 TimeZoneInfo

具有更加丰富的（虽然有时使用不便）夏令时描述规则模型。

TimeZone

TimeZone.CurrentTimeZone

静态方法会根据本地设置返回一个 TimeZone

对象。以下示例展示了位于加利福尼亚时的执行效果：

TimeZone zone = TimeZone.CurrentTimeZone;

Console.WriteLine (zone.StandardName);

// Pacific Standard TimeConsole.WriteLine (zone.DaylightName);

// Pacific Daylight Time

IsDaylightSavingTime

和 GetUtcOffset

方法的使用方式如下：

DateTime dt1 = new DateTime (2019, 1, 1);

DateTime dt2 = new DateTime (2019, 6, 1);

Console.WriteLine (zone.IsDaylightSavingT

ime (dt1));   // TrueConsole.WriteLine (zone.IsDaylightSavingT

ime (dt2));   // FalseConsole.WriteLine (zone.GetUtcOffset (dt1

));       // -08:00:00Console.WriteLine (zone.GetUtcOffset (dt2

));       // -07:00:00

GetDaylightChanges

方法会返回指定年份的夏令时信息：

DaylightTime day = zone.GetDaylightChanges (2019);

Console.WriteLine (day.Start.ToString ("M"));

// 10 MarchConsole.WriteLine (day.End.ToString ("M"));

// 03 NovemberConsole.WriteLine (day.Delta);

// 01:00:00

TimeZoneInfo

TimeZoneInfo

类和 TimeZone

类的使用方式类似。TimeZoneInfo.Local

属性返回本地时区：

TimeZoneInfo zone = TimeZoneInfo.Local;

Console.WriteLine (zone.StandardName);

// Pacific Standard TimeConsole.WriteLine (zone.DaylightName);

// Pacific Daylight Time

TimeZoneInfo

也提供了 IsDaylightSavingTime

和 GetUtcOffset

方法，和 TimeZone

的不同之处是它们既接受 DateTime

参数也接受 DateTimeOffset

参数。

调用 FindSystemTimeZoneById

方法并提供时区 ID 就可以获得世界上任何一个时区的 TimeZoneInfo

。这个功能是 TimeZoneInfo

独有的，接下来演示的功能亦如此。我们将切换到西澳大利亚时区，个中原因很快就会明朗：

TimeZoneInfo wa = TimeZoneInfo.FindSystemTimeZoneById

("W. Australia Standard Time");Console.WriteLine (wa.Id);          // W. Au

stralia Standard TimeConsole.WriteLine (wa.DisplayName);     // (GMT+

08:00) PerthConsole.WriteLine (wa.BaseUtcOffset);    // 08:00

:00Console.WriteLine (wa.SupportsDaylightSavingTime);

// True

Id

属性就是传递给 FindSystemTimeZoneById

方法的参数。可以使用 GetSystem-TimeZones

静态方法返回全世界所有的时区。因此可以用如下方式打印全部有效时区的 ID 字符串：

foreach (TimeZoneInfo z in TimeZoneInfo.GetSystemTimeZones())

Console.WriteLine (z.Id);

通过调用 TimeZoneInfo.CreateCustomTimeZone

可以创建一个自定义时区。因为 TimeZoneInfo

是不可变的，所以在创建时必须输入方法需要的所有相关的数据。

调用 ToSerializedString

方法可以将预定义的或者自定义的时区序列化为具有可读性的字符串，并可以通过 TimeZoneInfo.FromSerializedString

进行反序列化。

ConvertTime

静态方法可以将 DateTime

或 DateTimeOffset

从一个时区转换到另一个时区。该方法可同时接受源时区和目标时区的 TimeZoneInfo

对象，也可以仅仅包含目标时区的 TimZoneInfo

对象。若想要直接从 UTC 时间进行转换，或者直接转换到 UTC 时间，则可以调用 ConvertTimeFromUtc

和 ConvertTimeToUtc

。

TimeZoneInfo

专门提供了处理夏令时的方法：

IsInvalidTime

：该方法在 DateTime

位于夏令时时钟向前跳过的时间区间之内时返回 true

。

IsAmbiguousTime

：该方法在 DateTime

或者 DateTimeOffset

处于由于时钟回拨而重复的时间区间之内时返回 true

。

GetAmbiguousTimeOffsets

：该方法返回一个二义的 DateTime

或者 DateTimeOffset

的 TimeSpan

数组，该数组中的值为可选的有效偏移值。

和 TimeZone

不同，从 TimeZoneInfo

中无法直接得到夏令时起止日期。相反，必须调用 GetAdjustmentRules

来得到所有年份的所有夏令时规则的声明汇总。每一个规则都有代表其有效日期范围的 DateStart

和 DateEnd

属性：

foreach (TimeZoneInfo.AdjustmentRule rule in wa.GetAdjustmentRules())

Console.WriteLine ("Rule: applies from " + rule.DateStart +                  " to " + rule.DateEnd);

西澳大利亚时区在 2006 年季度中期时首次引入夏令时，并在 2009 年废除。这意味着需要对第一年设置一条特殊的规则，因此该时区夏令时有两条规则：

Rule: applies from 1/01/2006 12:00:00 AM to 31/12/2006 12:00:00 AM

Rule: applies from 1/01/2007 12:00:00 AM to 31/12/2009 12:00:00 AM

每个 AdjustmentRule

都拥有一个 TimeSpan

类型的 DaylightDelta

属性（这个属性的值几乎在每种情况下都是一小时），以及名为 DaylightTransitionStart

和 Daylight-TransitionEnd

的属性。后两个属性全部为 TimeZoneInfo.TransitionTime

类型。该类型具有如下属性：

public bool IsFixedDateRule { get; }

public DayOfWeek DayOfWeek { get; }public int Week { get; }public int Day { get; }public int Month { get; }public DateTime TimeOfDay { get; }

转换时间有些复杂，因为它既需要表示固定日期也需要表示浮动日期。浮动日期是类似「三月的最后一个星期日」这样的日期。转换时间的解释规则如下：

对于转换结束时间：如果 IsFixedDateRule

为 true

，Day

是 1

，Month

是 1

，TimeOfDay

是 DateTime.MinValue

，则这个年份没有夏令时的结束时间（这只可能出现在南半球刚刚引入夏令时的某个地区）。

否则，如果 IsFixedDateRule

为 true

，那么 Month

、Day

和 TimeOfDay

属性决定了规则调整的起止时间。

否则，如果 IsFixedDateRule

为 false

，那么 Month

、DayOfWeek

、Week

和 TimeOfDay

属性共同决定了规则调整的起止时间。

在最后一种情况中，Week

所指的是月份的周数，「5」代表最后一周。可以通过列举 wa

时区的调整规则来说明这一点：

foreach (TimeZoneInfo.AdjustmentRule rule in wa.GetAdjustmentRules())

{ Console.WriteLine ("Rule: applies from " + rule.DateStart +                  " to " + rule.DateEnd); Console.WriteLine ("  Delta: " + rule.DaylightDelta); Console.WriteLine ("  Start: " + FormatTransitionTime                  (rule.DaylightTransitionStart, fal

se

)); Console.WriteLine ("  End:  " + FormatTransitionTime                  (rule.DaylightTransitionEnd, true)

);

Console.WriteLine();}

FormatTransitionTime

方法使用了以上介绍的规则：

static string FormatTransitionTime (TimeZoneInfo.TransitionTime tt,

bool endTime){ if (endTime && tt.IsFixedDateRule       && tt.Day == 1 && tt.Month == 1       && tt.TimeOfDay == DateTime.MinValue)  return "-"; string s; if (tt.IsFixedDateRule)  s = tt.Day.ToString(); else  s = "The " +    "first second third fourth last".Split() [tt.Week - 1] +    " " + tt.DayOfWeek + " in"; return s + " " + DateTimeFormatInfo.CurrentInfo.MonthNames [tt.Mo

nth-1]      + " at " + tt.TimeOfDay.TimeOfDay;}

6.3.4　夏令时与 DateTime

如果使用 DateTimeOffset

或 UTC 的 DateTime

进行相等比较，那么结果是不受夏令时影响的。但是对于本地时间的 DateTime

，则可能会受到夏令时的影响。

这些规则可以总结为：

夏令时只影响本地时间，不影响 UTC 时间。

当且仅当使用本地时间的 DateTime

时，当夏令时的时钟回拨时，基于时间前移的比较将得到错误的结果。

即使时钟回拨了，也总是可以可靠地将本地时间转换为 UTC 时间，反之亦然。

IsDaylightSavingTime

方法可以告诉我们给定的本地 DateTime

是否处在夏令时中。如果向该方法传递 UTC 时间，则该方法永远返回 false

。

Console.Write (DateTime.Now.IsDaylightSavingTime());   // True or false

Console.Write (DateTime.UtcNow.IsDaylightSavingTime()); // Always false

假定 dto

是一个 DateTimeOffset

对象，那么下面的表达式将得到同样的效果：

dto.LocalDateTime.IsDaylightSavingTime

夏令时的结束会给本地时间相关的算法带来复杂的问题。当时钟回拨时，同样的小时数（更准确地说是时间差值 Delta

）将会重复。我们可以通过将一个 DateTime

实例化至这个模糊时区，然后再减去 Delta

来展示这一点（你可以尝试运行本例来体验有趣的夏令时问题）：

DaylightTime changes = TimeZone.CurrentTimeZone.GetDaylightChanges (2010);

TimeSpan halfDelta = new TimeSpan (changes.Delta.Ticks / 2);DateTime utc1 = changes.End.ToUniversalTime() - halfDelta;DateTime utc2 = utc1 - changes.Delta;

当代码依赖于时钟前移时，将这些变量转换为本地时间后就可以发现为什么应当用 UTC 而不是本地时间：

DateTime loc1 = utc1.ToLocalTime(); // (Pacific Standard Time)DateTime loc2 = utc2.ToLocalTime();Console.WriteLine (loc1);      // 2/11/2010 1:30:00 AMConsole.WriteLine (loc2);      // 2/11/2010 1:30:00 AMConsole.WriteLine (loc1 == loc2);  // True

尽管 loc1

和 loc2

显示的结果是相同的，但是其内部是不一样的。DateTime

保留了一个特殊的位来表示当前二义的本地时间位于模糊时区的哪一边，但是这个位并不会影响比较的结果（如上例）。但是如果使用非二义性方式格式化 DateTime

，这个信息就会起作用了：

Console.Write (loc1.ToString ("o")); // 2010-11-02T02:30:00.0000000-08:00

Console.Write (loc2.ToString ("o")); // 2010-11-02T02:30:00.0000000-07:00

将本地时间转化为 UTC 时，这个特殊位也将发挥作用，以确保本地时间和 UTC 之间相互转换的正确性：

Console.WriteLine (loc1.ToUniversalTime() == utc1);  // True

Console.WriteLine (loc2.ToUniversalTime() == utc2);  // True

在两个任意的 DateTime

上先调用 ToUniversalTime

方法就可以对其进行有效比较。这个规则当且仅当其中一个日期的 DateTimeKind

属性值为 Unspecified

时失效。这个潜在的危险性是倾向于使用 DateTimeOffset

的另一个原因。

6.4　格式化和解析

格式化指将对象转换为字符串；而解析则是将字符串转换为对象。这两种操作在编程时都是很常用的，因此.NET Core 提供了一系列机制来执行这些任务：

ToString

和

Parse

这两个方法是很多类型默认具备的功能。

格式提供器

对象上的其他 ToString

（以及 Parse

）重载方法会接受格式字符串或格式提供器。格式提供器不仅使用灵活而且和文化相关。.NET Core 自带了数值类型和 DateTime

、DateTimeOffset

的格式提供器。

XmlConvert

这个静态类提供了基于 XML 标准的格式化和解析方法。如果希望使用文化无关的转换，或希望避免误解析时，可以使用 XmlConvert

作为有效的通用转换器。XmlConvert

支持数值类型、bool

、DateTime

、DateTimeOffset

、TimeSpan

和 Guid

。

类型转换器

这种转换器是面向设计器和 XAML 解析器的。

本节将讨论前面两种机制，尤其是格式提供器。XmlConvert

、类型转换器以及其他转换机制将在后续章节中介绍。

6.4.1　ToString

和 Parse

最简单的格式字符串的机制是 ToString

方法，它能为所有简单的值类型（bool

、DateTime

、DateTimeOffset

、TimeSpan

、Guid

和所有数值类型）生成有意义的字符串输出。同时这些类型都定义了静态的 Parse

方法来完成反向的转换：

string s = true.ToString();   // s = "True"

bool b = bool.Parse (s);    // b = true

如果解析失败，则会抛出 FormatException

。很多类型还定义了 TryParse

方法，在转换失败时返回 false

而不抛出异常：

bool failure = int.TryParse ("qwerty", out int i1);

bool success = int.TryParse ("123", out int i2);

如果仅关心解析是否成功而不关心解析的结果，则可以丢弃相应变量：

bool success = int.TryParse ("123", out int _);

如果预期会遇到错误，那么调用 TryParse

比在异常处理块中调用 Parse

要更优雅，也执行得更快。

DateTime

(Offset

) 和数值类型的 Parse

和 TryParse

方法会使用本地的文化设置。因而可以指定一个 CultureInfo

对象改变这个设置。而指定一个不变文化通常是个好主意。例如，在德国将「1.234」

解析为 double

类型将得到 1234

：

Console.WriteLine (double.Parse ("1.234"));  // 1234 (in Germany)

这是因为在德国，「.

」表示千位分隔符而不是小数点。指定不变文化就可以解决上述问题：

double x = double.Parse ("1.234", CultureInfo.InvariantCulture

);

同样的方法也适用于 ToString ()

：

string x = 1.234.ToString (CultureInfo.InvariantCulture);

6.4.2　格式提供器

有些情况下需要对格式化和解析进行更多的控制。例如，格式化 DateTime (Offset)

有很多种方式。格式提供器提供了大量的控制格式化和解析的方式，并支持数值类型和日期 / 时间类型。格式提供器还可以提供用户界面的格式化和解析控制。

使用格式提供器的方式是使用 IFormattable

接口。所有的数值类型以及 DateTime (Offset)

类型都实现了这个接口：

public interface IFormattable

{ string ToString (string for

ma

t, IFormatProvider formatProvider);}

第一个参数是格式字符串，第二个参数是格式提供器。格式字符串提供指令；而格式提供器则决定了这些指令将如何转换。例如：

NumberFormatInfo f = new NumberFormatInfo();

f.CurrencySymbol = "$$";Console.WriteLine (3.ToString ("C", f));

// $$ 3.00

这里的 "C"

是表示货币的格式字符串，而 NumberFormatInfo

对象是一个格式提供器，它决定了货币（和其他数值形式）该如何展示。这个机制也支持全球化。

所有数字和日期的格式字符串都可以从 6.5 节中找到。

如果指定一个 null

格式字符串或 null

格式提供器，那么它们会使用其默认值。默认的格式提供器为 CultureInfo.CurrentCulture

。如果没有重新赋值，那么它对应了计算机运行时的控制面板设置。例如：

Console.WriteLine (10.3.ToString ("C", null)); // $10.30

方便起见，大多数类型都重载了 ToString

方法以忽略 null

提供器：

Console.WriteLine (10.3.ToString ("C"));   // $10.30

Console.WriteLine (10.3.ToString ("F4"));  // 10.300

0 (Fix to 4 D.P.)

在 DateTime (Offset)

类型或数值类型上调用无参数的 ToString

方法等价于使用默认的格式提供器，且格式字符串为空字符串。

.NET Core 定义了以下三种格式提供器（它们都实现了 IFormatProvider

）：

NumberFormatInfo

DateTimeFormatIn

foCultureInfo

所有的 enum

类型都可以格式化，但是它们并没有特殊的 IFormatter

类。

格式提供器和 CultureInfo

在格式提供器的上下文中，CultureInfo

扮演了根据文化的区域设置返回 NumberFormat-Info

和 DateTimeFormatInfo

两个格式提供器的间接机制。

在下面的例子中，我们使用了一个特殊的文化（英国英语）：

CultureInfo uk = CultureInfo.GetCultureInfo ("en-GB");

Console.WriteLine (3.ToString ("C", uk));   // £3.0

0

上述范例使用了适用于 en-GB 文化的默认的 NumberFormatInfo

对象。

下面的例子使用不变文化对 DateTime

进行了格式化。不变文化总是保持相同的设置，和计算机的设置无关：

DateTime dt = new DateTime (2000, 1, 2);

CultureInfo iv = CultureInfo.InvariantCu

lture;Console.WriteLine (dt.ToString (iv));

// 01/02/2000 00:00:00Console.WriteLine (dt.ToString ("d", iv)

);    // 01/02/2000

不变文化是基于美国文化的。但是有如下的不同：

货币符号是 ¤ 而非 $

。

日期和时间的格式化带有前导零（仍然是月份在前）。

使用 24 小时制计时，不使用 AM/PM 标识符。

使用 NumberFormatInfo

和 DateTimeFormatInfo

下例中实例化了一个 NumberFormatInfo

对象并将组分隔符从逗号修改为空格。使用它可以将数字格式化为保留小数点后 3 位的形式：

NumberFormatInfo f = new NumberFormatInfo ();

f.NumberGroupSeparator = " ";Console.WriteLine (12345.6789.ToString ("N3",

f));  // 12 345.679

NumberFormatInfo

或 DateTimeFormatInfo

的初始设置是基于不变文化的。但有时选择不同的文化作为起点可能更合适。为此，可以 Clone

一个现有的格式提供器：

NumberFormatInfo f = (NumberFormatInfo)

CultureInfo.Curre

ntCulture.NumberFormat.Clone();

虽然原生的格式提供器是只读的，但是克隆出来的实例总是可写的。

组合格式化

组合格式字符串可以将变量替代符和格式字符串组合在一起。静态方法 String.Format

可以接受一个组合格式字符串（参见 6.1.2 节）：

string composite = "Credit={0:C}

";

Co

nsole.WriteLine (string.Format (composite, 500));  // Credit=$500.00

Console

类重载了 Write

和 WriteLine

方法以接受一个组合格式字符串，因此上述例子可以简化为：

Console.WriteLine ("Credit={0:C}", 500);  // Credit=$500.00

同样可以在 StringBuilder

上（调用 AppendFormat

方法）和处理 I/O 操作的 TextWriter

上（见第 15 章）追加组合格式字符串。

string.Format

方法可以接受一个可选的格式提供器参数。一个简单应用场景是调用任意对象的 ToString 方法，同时传递格式提供器：

string s = string.Format (CultureInfo.InvariantCulture, "{0}", someObject);

上述代码和以下代码是等价的：

string s;

if (someO

bject is IFormattable) s = ((I

Formattable)someObject).ToString

(null,



CultureInfo.InvariantCulture);else if (

someObject == null) s = "";

else s = som

eObject.ToString();

通过格式提供器进行解析

格式提供器并未对解析提供标准接口。相反，每一个参与的类型都会重载它的静态 Parse

（和 TryParse

）方法来接受格式提供器，以及可选的 NumberStyles

或 DateTime-Styles

枚举参数。

NumberStyles

和 DateTimeStyles

将决定解析的工作方式：它们提供了一些自定义设置，例如是否允许括号或者货币符号出现在输入字符串中（默认这两个选项都是否定的）。例如：

int error = int.Parse ("(2)");  // Exception thrown

int minusTwo = int.Parse ("(2)", NumberStyles.Intege

r

|                 NumberStyles.AllowP

a

rentheses);  // OKdecimal fivePointTwo = decimal.Parse ("£5.20", Numbe

r

Styles.Currency,            CultureInfo.GetCultureInfo ("

e

n-GB"));

下一节中列出了所有的 NumberStyles

和 DateTimeStyles

的成员以及每个成员的默认解析规则。

IFormatProvider

和 ICustomFormatter

所有的格式提供器都实现了 IFormatProvider

接口：

public interface IFormatProvider { object GetFormat (Type formatType); }

这个方法提供了一种间接进行格式化的手段，CultureInfo

就是用它来返回合适的 NumberFormatInfo

或 DateTimeInfo

对象并完成格式化操作的。

实现了 IFormatProvider

和 ICustomFormatter

，就能编写自定义的格式提供器了（该自定义格式提供器可以和现有类型配合工作）。ICustomFormatter

接口仅定义了一个方法：

string Format (string format, object arg, IFormatProvider formatProvider);

下例中的自定义格式提供器将数字转换为单词：

public class WordyFormatProvider : IFormatProvider, ICustomFormatter

{ static readonly string[] _numberWords =  "zero one two three four five six seven eight nine minus point".S

pl

it(); IFormatProvider _parent;  // Allows consumers to chain format pro

vi

ders public WordyFormatProvider () : this (CultureInfo.CurrentCulture)

{

} public WordyFormatProvider (IFormatProvider parent) => _parent = p

ar

ent; public object GetFormat (Type formatType) {  if (formatType == typeof (ICustomFormatter)) return this;  return null; } public string Format (string format, object arg, IFormatProvider p

ro

v) {  // If it's not our format string, defer to the parent provider:  if (arg == null || format != "W")   return string.Format (_parent, "{0:" + format + "}", arg);  StringBuilder result = new StringBuilder();  string digitList = string.Format (CultureInfo.InvariantCulture,                   "{0}", arg);  foreach (char digit in digitList)  {   int i = "0123456789-.".IndexOf (digit);   if (i == -1) continue;   if (result.Length > 0) result.Append (' ');   result.Append (_numberWords[i]);  }  return result.ToString(); }}

注意在 Format

方法中，我们使用 string.Format

并指定 InvariantCulture

将输入数字转换为字符串。虽然它比直接在 arg

对象上调用 ToString ()

复杂，但调用 ToString

方法将会使用 CurrentCulture

。需要使用不变文化的原因后续会进行展示：

int i = "0123456789-.".IndexOf (digit);

这里的关键是数字字符串仅仅由 0123456789-.

等字符组成，并不包含国际化字符。

以下示例展示了 WordyFormatProvider

的使用方法：

double n = -123.45;

IFormatProvider fp

= new WordyFormatProvider();

Console.WriteLine (

string.Format (fp, "{0:C} in words is {0:W}", n)

);// -$123.45 in word

s is minus one two three point four five

自定义格式提供器只能用在组合格式字符串中。

6.5　标准格式字符串与解析标记

标准格式字符串决定了数值类型或 DateTime

/DateTimeOffset

转换为字符串的方式。格式字符串有两种：

标准格式字符串

提供基本的格式控制。标准格式字符串是由一个字母及其后的可选数字组成。例如 "C"

或 "F2"

。

自定义格式字符串

通常使用模板对每一个字符实现精细控制，例如 "0:#.000E+00"

。

自定义格式字符串与自定义格式提供器无关。

6.5.1　数字格式字符串

表 6-2 列出了所有的标准数字格式字符串。

自动舍入通常是有好处的，因而很少会被注意到。然而，如果需要往返转换一个数字就可能产生问题。换言之，即将数字转换为字符串，再转换回数字（可能反复多次）同时保持其值不变。因此，需要使用 R

、G17

和 G9

格式字符串来处理这种隐式舍入。

如果不提供数字格式字符串（或者使用 null

或空字符串），那么相当于使用不带数字的「G」

标准格式字符串。这包括以下两种形式：

小于 10-4

或大于该类型精度的数字将表示为指数形式（科学记数法）。

受 float

和 double

精度限制的两位小数是经过舍入的，以避免从二进制形式转换为十进制时的内在不精确性。

表 6-3 列出了一些自定义数字格式字符串。

6.5.2　NumberStyles

每一种数值类型都定义了一个静态的 Parse

方法，它接受 NumberStyles

参数。NumberStyles

是一个标记枚举类型，当把字符串转换为数字时，它可以决定读取字符串的方式。它有以下几个可以组合的成员：

AllowLeadingWhite  AllowTrailingWhite

AllowLeadingSign   AllowTrailingSignAllowParentheses   AllowDecimalPointAllowThousands    AllowExponentAllowCurrencySymbol AllowHexSpecifier

NumberStyles

也定义了以下的复合成员：

None Integer Float Number HexNumber Currency Any

除了 None

，所有的复合值都包含了 AllowLeadingWhite

和 AllowTrailingWhite

，其余的标记如图 6-1 所示，其中对最常使用的三种进行了加粗标记：

图 6-1：组合 NumberStyles

若调用 Parse

而不设定任何标记，则会使用如图 6-2 所示的默认值。

图 6-2：数值类型的默认解析标记

若不希望使用图 6-2 所示的默认值，那么必须显式指定 NumberStyles

：

int thousand = int.Parse ("3E8", NumberStyles.HexNumber);

int minusTwo = int.Parse ("(2)", NumberStyles.Integer |                 NumberStyles.AllowParent

heses);double aMillion = double.Parse ("1,000,000", NumberStyles

.Any);decimal threeMillion = decimal.Parse ("3e6", NumberStyles

.Any);decimal fivePointTwo = decimal.Parse ("$5.20", NumberStyl

es.Currency);

因为没有指定格式提供器，所以这个例子支持本地货币符号、组分隔符、小数点等。下例以硬编码的方式使用欧元符号和空格组分隔符来表示货币：

NumberFormatInfo ni = new NumberFormatInfo();

ni.CurrencySymbol = "€";ni.CurrencyGroupSeparator = " ";double million = double.Parse ("€1 000 000",

NumberStyles.Currency, ni

);

6.5.3　日期 / 时间格式字符串

DateTime

/DateTimeOffset

的格式字符串根据它们是否使用文化和格式提供器的设置可分为两组。使用文化和格式提供器的格式字符串列在表 6-4 中，而其他格式字符串列在表 6-5 中。范例输出结果来自下面的 DateTime

（表 6-4 中列出的是不变文化下的结果）：

new DateTime (2000, 1, 2, 17, 18, 19);

▼表 6-4：文化相关的日期 / 时间格式字符串

▼表 6-5：文化无关的日期 / 时间格式字符串

"r"

、"R"

和 "u"

格式字符串会添加一个表示 UTC 的后缀，但是它们不能将本地时间自动转换为 UTC 时间（所以必须自行进行转换）。奇怪的是，"U"

会自动转换为 UTC，但是它不会添加时区后缀！事实上，"o"

是上述分类符中唯一一个不需要干预就能产生一个明确的 DateTime

的格式分类符。

DateTimeFormatInfo

还支持自定义字符串，与数字的自定义格式字符串相似，详细的清单可以从 Microsoft 的在线文档中得到。下面是一个自定义格式字符串的示例：

yyyy-MM-dd HH:mm:ss

DateTime

的解析与误解析

将月份或天数放在前面的日期字符串是有二义性的，非常容易出现误解析，对于国际用户尤甚。在用户界面控制上，由于格式化和解析强制使用同一设置，因此往往不存在这种问题。但是在写入文件的过程中，日期时间的误解析则会造成问题。下面是两种解决方法：

在格式化和解析时总是显式指定相同的文化（例如不变文化）。

以一种文化无关的方式格式化 DateTime

和 DateTimeOffset

。

第二种方法更加可靠，尤其是适用于选择将 4 位数的年份放在前面的格式的场合，因为这种字符串不易被误解析。而且，使用符合标准的年份在前的格式字符串（如 "o"

）能够正确解析用同样设置格式化的本地字符串（就像 O 型万能供血者一样）。使用 "s"

或者 "u"

格式化的日期还具有可排序的优点。

为了演示这一点，假设生成了下面与文化无关的 DateTime

字符串 s

：

string s = DateTime.Now.ToString ("o");

"o"

格式字符串的输出中包含毫秒。下面的自定义格式字符串结果与 "o"

的相同，但是不包括毫秒：

yyyy-MM-ddTHH:mm:ss K

可以用两种方式来解析上述字符串。ParseExact

要求严格匹配指定的格式字符串（还可以使用 XmlConvert

的 ToString

和 ToDateTime

方法来达到相似的效果）：

DateTime dt1 = DateTime.ParseExact (s, "o", null);

Parse

方法则隐式接受 "o"

格式和 CurrentCulture

格式：

DateTime dt2 = DateTime.Parse (s);

上述方法对 DateTime

和 DateTimeOffset

都有效。

如果已知要解析的字符串格式，那么使用 ParseExact

会更好。因为它意味着如果字符串的格式不正确就会抛出异常，这远远好于得到一个误解析的日期。

6.5.4　DateTimeStyles

DateTimeStyles

是一个标记枚举类型。它可以在调用 DateTime

(Offset

) 的 Parse

方法时提供额外的控制指令。以下列出了其成员：

None,

Allow

LeadingWhite, AllowTrailingWhite, AllowInnerWhite,Assum

eLocal, AssumeUniversal, AdjustToUniversal,NoCur

rentDateDefault, RoundTripKind

除此以外还有一个复合成员 AllowWhiteSpaces

：

AllowWhiteSpaces = AllowLeadingWhite | AllowTrailingWhite | AllowInnerWhite

其默认值为 None

。这意味着不允许有多余的空格（属于标准 DateTime

模式的空格除外）。

AssumeLocal

和 AssumeUniversal

可以在字符串没有时区信息后缀（例如 Z

或 + 9:00

）时使用，AdjustToUniversal

仍会参照时区后缀，但随后会使用当前区域设置将其转换为 UTC。

如果解析包含时间但不包含日期的字符串，则会默认使用今天的日期。如果指定了 NoCurrentDateDefault

标记，使用的日期则为 0001 年 1 月 1 日。

6.5.5　枚举格式字符串

第 6.9 节将介绍枚举值的格式化与解析。表 6-6 列出了每一种格式字符串及将其应用于以下表达式的输出结果：

Console.WriteLine (System.ConsoleColor.Red.ToString (formatString));

表 6-6：枚举格式字符串

6.6　其他转换机制

在前面两节中，我们介绍了格式提供器这一.NET 主要的格式化和解析机制。其他的重要转换机制则分散在各种类型和命名空间中。有些可以和 string

相互转换，有些则采用其他的转换方式。本节将讨论以下内容：

Convert

类及其功能：

采用舍入方式而非截断方式的实数到整数转换

解析二进制、八进制和十六进制数字

动态转换

Base-64 转换

XmlConvert

及其在 XML 格式化和解析中的作用

类型转换器及其在设计器和 XAML 格式化和解析中的作用

支持二进制转换的 BitConverter

6.6.1　Convert

类

.NET Core 将以下类型称为基本类型：

bool

、char

、string

、System.DateTime

和 System.DateTimeOffset

所有的 C# 数值类型

静态类 Convert

定义了将每一个基本类型转换为其他基本类型的方法。可是这些方法大部分都没有什么实际用处；要么抛出异常，要么是隐式转换的冗余方法。然而，也有一些方法还是很有用的，我们将在接下来的章节介绍。

所有的基类型都（显式）实现了 IConvertible

接口，该接口定义了转换为其他基类型的方法。在大多数情况下，这些方法的实现只是简单地调用了 Convert

类的某个方法。编写一个接受类型为 IConvertible

的参数的方法在特定情况下也有很大用处。

实数到整数的舍入转换

第 2 章介绍了数值类型之间的显式和隐式转换。概括为：

隐式转换只支持无损转换（例如 int

到 double

的转换）

有损转换则需要使用显式转换（例如 double

到 int

的转换）

转换操作是进行了效率优化的，因此它将截断不符合要求的数据。这可能导致将实数转换为整数的操作出现问题。因为在这种情况下通常希望将结果进行舍入而非截断。Convert

类的数值转换方法正是为此准备的，它们总是采用舍入的方式：

double d = 3.9;int i = Convert.ToInt32

(d);  // i == 4

Convert

采用银行家舍入的方式，将中间值转换为偶整数（这样可以避免正负偏差）。如果银行家舍入方式不适用，那么可以对实数调用 Math.Round

方法，该方法可以使用额外的参数控制中间值的舍入方式。

解析二进制、八进制和十六进制数字

To

（整数类型）的方法包括一些重载方法，它们可以将数字解析为其他进制：

int thirty = Convert.ToInt32 ("1E", 16);  // Parse in hexadecimal

uint five = Convert.ToUInt32 ("101", 2);  // Parse in binary

第二个参数指定了进制数，它可以是任何一种进制，但必须是二、八、十或十六进制之一！

动态转换

有时，转换的具体类型在运行时才能确定，因此，Convert

类提供了 ChangeType

方法：

public static object ChangeType (object value, Type conversionType);

源类型和目标类型必须都是基本类型之一。ChangeType

还可以接受可选的 IFormatProvider

参数。例如：

Type targetType = typeof (int);

object source = "42";object result = Convert.ChangeT

ype (source, targetTyp

e

);Console.WriteLine (result);

// 42Console.WriteLine (result.GetTy

pe());  // System.Int

3

2

上述方法的用途之一是编写可以处理多种类型的反序列化器。它还能够将任意枚举类型转换为对应的整数类型（请参见 6.9 节）。

但 ChangeType

无法指定格式字符串，也无法指定解析标记。

Base 64 转换

有时，我们需要将一些二进制数据（例如位图）嵌入 XML 文件或电子邮件之类的文本文档。而 Base 64 是普遍使用的方式，它使用 ASCII 字符集中的 64 个字符将二进制数据编码为可读的字符。

Convert

类的 ToBase64String

方法可以将字节数组转换为 Base 64 格式；而 FromBase64String

则执行相反的操作。

6.6.2　XmlConvert

若需要处理 XML 文件的数据读写，System.Xml

命名空间下的 XmlConvert

提供了格式化和解析的最佳方法。XmlConvert

的方法无须提供特殊的格式字符串就能够处理 XML 格式的细微差别。例如，XML 中的 true

是 "true"

而不是 "True"

。.NET Core 在内部也经常使用 XmlConvert

，它还可以用在通用的与文化无关的序列化操作中。

XmlConvert

中的格式化方法均为重载的 ToString

方法，而解析方法则称为 ToBoolean

、ToDateTime

等：

string s = XmlConvert.ToString (true);     // s = "true"

bool isTrue = XmlConvert.ToBoolean (s);

DateTime

的格式化和解析方法可以接受一个 XmlDateTimeSerializationMode

参数。这个参数是枚举类型，其可能的值为：

Unspecified, Local, Utc, RoundtripKind

若 DateTime

的时区并非和转换的目标一致，则使用 Local

和 Utc

会在格式化时进行一次转换，并将时区信息附加到字符串：

2010-02-22T14:08:30.9375      // Unspecified

2010-02-22T14:07:30.9375+09:00   // Local2010-02-22T05:08:30.9375Z     // Utc

Unspecified

会在格式化之前删除附加到 DateTime

的时区信息（如 DateTimekind

）。RoundtripKind

则保持 DateTime

的 DateTimeKind

，因此当重新对其进行解析时，解析出来的 DateTime

会和格式化之前的 DateTime

保持严格一致。

6.6.3　类型转换器

类型转换器在设计时环境中执行格式化和解析操作。它们也能够解析 XAML（Extensible Application Markup Language，可扩展应用程序标记语言）文档中的值。XAML 主要用于 WPF。

在.NET Core 中有超过 100 种类型转换器，用于处理颜色、图像和 URL 等数据。相反，格式提供器则只为一些简单的值类型提供了实现。

类型转换器通常会采用多种方式解析字符串，而这个过程并不需要提示。例如，在 Visual Studio 的 WPF 应用程序中，如果在属性窗口中将控件的 BackColor

属性赋值为 Beige

，则 Color

类型转换器就会判断出引用的是一个颜色名称而非 RGB 字符或系统颜色值。类型转换器的灵活性使它在设计器和 XAML 文档之外的环境中也很有用。

所有的类型转换器都是 System.ComponentModel

命名空间中 TypeConverter

类型的子类。如果要获得一个 TypeConverter

，则需要调用 TypeDescripter.GetConverter

方法。以下例子获得了一个 Color

（位于 System.Drawing

命名空间中）类型的 Type-Converter

：

TypeConverter cc = TypeDescriptor.GetConverter (typeof (Color));

TypeConverter

的诸多方法还包括 ConvertToString

和 ConvertFromString

方法。可以按以下的方式进行调用：

Color beige = (Color) cc.ConvertFromString ("Beige");

Color purple = (Color) cc.ConvertFromString ("#800080"

);Color window = (Color) cc.ConvertFromString ("Window")

;

按照惯例，类型转换器的名称应以 Converter

结尾，并且通常与它们转换的类型位于同一个命名空间。类型是通过 TypeConverterAttribute

与转换器联系在一起的。这样设计器就可以自动获得对应的转换器了。

类型转换器还可以提供一些设计时的服务，例如为设计器生成标准的下拉列表项，或者辅助代码序列化。

6.6.4　BitConverter

BitConverter

大多数基本类型都可以通过调用 BitConverter.GetBytes

方法转换为字节数组：

foreach (byte b in BitConverter.GetBytes (3.5))

Console.Write (b + " ");

// 0 0 0 0 0 0 12 64

BitConverter

还提供了将字节数组转换为其他类型的方法，例如 ToDouble

。

BitConverter

不支持 decimal

和 DateTime

(Offset

) 类型，但是可以通过 decimal.GetBits

将 decimal

转换为一个 int

数组。另外，decimal

也提供了一个接受 int

数组的构造器。

对于 DateTime

，则可以调用实例的 ToBinary

方法，它会返回一个 long

，然后就可以通过 BitConverter

进行转换了。静态的 DateTime.FromBinary

方法则可以执行相反的操作。

6.7　全球化

应用程序的国际化包括两个方面：全球化和本地化。

全球化涉及三个任务（重要性从大到小）：

保证程序在其他文化环境中运行时不会出错。

采用本地文化的格式化规则，例如日期的显示。

设计程序，使之能够从将来编写和部署的附属程序集中读取文化相关的数据和字符串。

本地化则是为上面的最后一个任务针对特定文化编写附属程序集。这个任务可以在程序编写完成之后进行，相关内容将在 18.5 节详细介绍。

.NET Core 本身能够通过设置特定的文化规则来完成第二个任务。我们已经知道了如何在 DateTime

或整数类型上使用本地格式规则调用 ToString

。但是这可能令第一个任务失败并导致程序中断，因为此时日期和数字将按照当前的确定的文化进行格式化。之前介绍过，其解决方式就是在格式化和解析时指定一个文化（例如不变文化），或者使用和文化无关的方法（例如 XmlConvert

中的方法）。

6.7.1　全球化检查清单

我们在本章中已经介绍了全球化的一些重要知识点。以下是对一些必要任务的总结：

认识 Unicode 和文本编码（请参见 6.1.5 节）。

要记住 char

和 string

的一些方法是与文化相关的，如 ToUpper

和 ToLower

，除非希望区分不同的文化，否则应当使用 ToUpperInvariant

和 ToLowerInvariant

。

推荐使用与文化无关的方式对 DateTime

和 DateTimeOffset

进行格式化和解析，例如 ToString ("o")

以及 XmlConvert

。

除非希望使用本地文化行为，否则请在格式化和解析数字或日期 / 时间时指定一个文化。

6.7.2　测试

在测试中可以通过重新指定 System.Threading

命名空间下的 Thread

的 CurrentCulture

属性来模拟不同的文化。下面的代码将把当前文化修改为土耳其文化：

Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo ("tr-TR");

土耳其文化是非常好的测试用例，因为：

"i".ToUpper() != "I"

且 "I".ToLower () != "i"

。

日期使用日。月。年的方式进行格式化（请注意分隔符为.

）。

小数点的符号为「逗号」而非「点」。

还可以通过修改 Windows 控制面板中的数字和日期格式设置来进行测试，这些修改会反映到默认文化设置（CultureInfo.CurrentCulture

）中。

CultureInfo.GetCultures()

会返回一个包含所有可用文化的数组。

Thread

和 CultureInfo

还支持 CurrentUICulture

属性。这个属性主要用于本地化。（将在第 18 章进行介绍）。

6.8　操作数字

6.8.1　转换

我们在前面的章节中已经介绍了数值转换方面的内容。表 6-7 总结了所有可能的转换。

表 6-7：数值转换总结

6.8.2　Math

表 6-8：列出了静态类 Math

的所有成员。其中，三角函数接受 double

类型的参数，而其他方法（例如 Max

）则被重载以支持所有的数值类型。Math

类还定义了数学常量 E (

e

)

和 PI

。

表 6-8：静态类 Math 的方法

Round

方法能够指定舍入的小数位数以及如何处理中间值（远离 0 或者使用银行家舍入方式）。Floor

和 Ceiling

会将数字舍入到最接近的整数，Floor

总是向下舍入，而 Ceiling

总是向上舍入（即使是负数）。

Max

和 Min

只接受两个参数。因此如果要从一个数组或数字序列中得到结果，请使用 System.Linq.Enumerable

中的 Max

和 Min

扩展方法。

6.8.3　BigInteger

BigInteger

结构体是一种特殊数值类型，它位于 System.Numerics

命名空间。它可以表示任意大的整数而不会丢失精度。

C# 并没有对 BigInteger

提供原生支持，所以无法采用字面量表示 BigInteger

的值。但是，可以将任意整数类型隐式转换为 BigInteger

，例如：

BigInteger twentyFive = 25;   // implicit conversion from integer

为了表示更大的数字，例如 10100

，则可以使用 BigInteger

的诸如 Pow

（幂运算）之类的静态方法：

BigInteger googol = BigInteger.Pow (10, 100);

或者也可以使用 Parse

方法从字符串创建：

BigInteger googol = BigInteger.Parse ("1".PadRight (101, '0'));

在这个对象上调用 ToString ()

方法则可以打印所有的数字：

Console.WriteLine (googol.ToString()

); // 10000000000000000000000000000

00000000000000000000000000000000000

000000000000000000000000000000000000

使用显式类型转换运算符可以将 BigInteger

转换为标准数值类型（有可能损失精度），也可以进行反向转换。例如：

double g2 = (double) googol;    // Explicit cast

BigInteger g3 = (BigInteger) g2;  // Explicit cast

Console.WriteLine (g3);

这个例子的输出结果演示了精度丢失的情况：

9999999999999999673361688041166912...

BigInteger

重载了包括取余数（%

）在内的所有算术运算符，还重载了顺序比较以及相等比较运算符。

另一种创建 BigInteger

的方式是从字节数组进行创建。以下代码生成了一个用于加密的 32 字节随机数，随后将其赋值到一个 BigInteger

上：

// This uses the System.Security.Cryptography namespace:

RandomNumberGenerator rand = RandomNumberGenerator.Creat

e();byte[] bytes = new byte [32];rand.GetBytes (bytes);var bigRandomNumber = new BigInteger (bytes);  // Conve

rt to BigInteger

将数字存储到 BigInteger

中可以获得值类型的语义，这是使用 BigInteger

相比使用字节数组的优点。调用 ToByteArray

可以将 BigInteger

再次转换回字节数组。

6.8.4　Complex

Complex

结构体是另外一个特殊的数值类型，它表示实部和虚部均为 double

类型的复数。Complex

和 BigInteger

位于相同的命名空间。

使用 Complex

之前需要指定其实部和虚部的值来进行实例化：

var c1 = new Complex (2, 3.5);

var c2 = new Complex (3, 0);

标准的数值类型可以隐式转换为复数类型。

可以通过属性访问 Complex

结构体的实部和虚部值及其相位角和模。

Console.WriteLine (c1.Real);    // 2

Console.WriteLine (c1.Imaginary); // 3

.5Console.WriteLine (c1.Phase);   // 1

.05165021254837Console.WriteLine (c1.Magnitude); // 4

.03112887414927

还可以通过指定相位角和模来构建 Complex

：

Complex c3 = Complex.FromPolarCoordinates (1.3, 5);

Complex

也重载了标准的算术运算符：

Console.WriteLine (c1 + c2);  // (5, 3.5)

Console.WriteLine (c1 * c2);  // (6, 10.5

)

Complex

结构体还有一些静态方法可以支持更高级的函数，例如：

三角函数（Sin

、Asin

、Sinh

、Tan

，等等）

取对数和求幂

Conjugate

（求共轭复数）

6.8.5　Random

Random

类能够生成类型为 byte

、integer

或 double

的伪随机数序列。

使用 Random

之前需要将其实例化，并可以传递一个可选的种子参数来初始化随机数序列。使用相同的种子（在相同的 CLR 版本下）一定会产生相同的数字序列。这个特性在行为重现过程中非常有用。

Random r1 = new Random (1);

Random r2 = new Random (1);

Console.WriteLine (r1.Next

(100) + ", " + r1.Next (100)

);   // 24, 11Console.WriteLine (r2.Next

(100) + ", " + r2.Next (100)

);   // 24, 11

若不需要重现性，那么在创建 Random

时就无须提供种子，此时将用当前系统时间来生成种子。

由于系统时钟只有有限的精度，因此两个创建时间非常相近（一般在 10 毫秒之内）的 Random

实例会生成相同值序列。常用的方法是每当需要一个随机数时才实例化一个 Random

对象，而不是重用同一个对象。

声明单例的静态 Random

实例是一个不错的模式。但是在多线程环境下可能会出现问题，因为 Random

对象并非线程安全的。我们将在 22.8 节介绍一种变通方法。

调用 Next (

n

)

将生成一个 0

到 n

-

1 的随机整数；调用 NextDouble

将生成一个 0

到 1 的随机 double

值；而调用 NextBytes

将使用随机值填充一个字节数组。

Random

的随机性对于高安全性要求的应用程序（如加密）而言并不够高。因此.NET Core 提供了一种密码强度的随机数生成器，它位于 System.Security.Cryptography

命名空间。其使用方式如下：

var rand = System.Security.Cryptography.RandomNumberGenerator.Create();

byte[] bytes = new byte [32];rand.GetBytes (bytes);    // Fill the byte array with random numbers

.

这种随机数生成器的缺点是不够灵活：填充字节数组是唯一的获得随机数的方法。因此要获得一个整数，必须使用 BitConverter

：

byte[] bytes = new byte [4];

rand.GetBytes (bytes);int i = BitConverter.ToInt32

(bytes, 0);

6.9　枚举

我们在第 3 章介绍了 C# 的枚举类型，并说明了如何组合成员，判断相等性，使用逻辑运算符以及执行转换。.NET 通过 System.Enum

类型扩展了 C# 对枚举的支持。这个类型有两种角色：

针对所有的 enum

类型提供类型统一

定义静态实用方法

类型统一意味着可以将任意枚举成员隐式转换为 System.Enum

实例：

enum Nut { Walnut, Hazelnut, Macadamia }

enum Size { Small, Medium, Large }static void Main(){ Display (Nut.Macadamia);   // Nut.Mac

adamia Display (Size.Large);    // Size.La

rge}static void Display (Enum value){ Console.WriteLine (value.GetType().Name

+ "." + value.ToString());}

System.Enum

的静态实用方法的主要功能是执行转换操作或获得枚举的成员列表。

6.9.1　枚举值转换

枚举值有三种表示形式：

enum

成员

对应的整数

字符串

本节将介绍如何在上述形式间进行转换。

将枚举值转换为整数

首先回顾一下 enum

成员及其整数值的显式转换方法。如果在编译时就知道确切的 enum

类型，则显式转换可以正确地将枚举值转换为整数形式：

[Flags]public enum BorderSides { Left=1, Right=2, Top=4, Bottom=8 }...int i = (int)

BorderSides.Top;      // i == 4BorderSides side = (BorderSides)

i;    // side == BorderSides.Top

可以用同样的方法将 System.Enum

实例转换为整数类型。但先要将其转换为 object

而后再转换为整数类型：

static int GetIntegralValue (Enum anyEnum)

{ return (int) (object) anyEnum;}

上述方法要求事先知道枚举对应的整数类型：若传入一个 long

类型的 enum

则该方法将会崩溃。如果希望编写一个适应任意整数类型的 enum

方法，则可以采用以下三种方式。第一种方式是调用 Convert.ToDecimal

：

static decimal GetAnyIntegralValue (Enum anyEnum)

{ return Convert.ToDecimal (anyEnum);}

这个方法之所以奏效是因为每一种整数类型（包括 ulong

）都可以无损地转换为 decimal

。第二种方式是首先调用 Enum.GetUnderlyingType

以获得 enum

的整数类型，然后再调用 Convert.ChangeType

：

static object GetBoxedIntegralValue (Enum anyEnum)

{ Type integralType = Enum.GetUnderlyingType (anyE

nu

m.GetType()); return Convert.ChangeType (anyEnum, integralType

);

}

这个方法会保持原始的整数类型，例如：

object result = GetBoxedIntegralValue (BorderSides.Top);

Console.WriteLine (result);

// 4Console.WriteLine (result.GetType());

// System.Int32

GetBoxedIntegralType

方法实际上并没有执行值转换。相反，它将同一个值重新装箱到了另一种类型。它将一个以枚举类型表示的整数值转换为以整数类型表示的整数值。我们将在 6.9.3 节对其做进一步的介绍。

第三种方式是调用 Format

或 ToString

方法，并指定 "d"

或 "D"

格式字符串。这样就将 enum

变量的整数值转换为了一个字符串。这种方式在编写自定义的序列化器时是很有用的：

static string GetIntegralValueAsString (Enum anyEnum)

{ return anyEnum.ToString ("D");   // returns some

th

ing like "4"}

将整数转换为枚举值

Enum.ToObject

可将整数值转换为一个给定类型的 enum

实例：

object bs = Enum.ToObject (typeof (BorderSides), 3);

Console.WriteLine (bs);

// Left, Right

上述做法是以下代码的动态版本：

BorderSides bs = (BorderSides) 3;

ToObject

的重载方法可以接受几乎所有的整数类型以及 object

（后者支持任何装箱后的整数类型）。

字符串转换

要将 enum

转换为字符串，可以调用静态的 Enum.Format

方法，也可以调用实例的 ToString

方法。两个方法都接受格式字符串参数，其中 "G"

表示默认的格式化行为，"D"

表示将实际的整数值输出为字符串，"X"

和 "D"

一样，只不过使用十六进制数，而 "F"

则表示格式化一个不带 Flags

的枚举组合成员。相关的示例列表可参见 6.5 节。

Enum.Parse

可以将字符串转换为 enum

，其输入为 enum

类型和一个包含多个成员的字符串：

BorderSides leftRight = (BorderSides) Enum.Parse (typeof (BorderSides),

"Left, Right");

该方法还包含第三个可选参数以执行不区分大小写的解析，如果成员不存在则抛出 ArgumentException

。

6.9.2　列举枚举值

Enum.GetValues

返回一个包含 enum

类型所有成员的数组：

foreach (Enum value in Enum.GetValues (typeof (BorderSides)))

Console.WriteLine (value);

该数组也包括复合成员，例如 LeftRight = Left | Right

。

Enum.GetNames

执行相同的操作，但返回的是一个字符串数组。

在内部，CLR 通过反射来实现 GetValues

和 GetNames

，其结果会被缓存起来以提高效率。

6.9.3　枚举的工作方式

enum

的语义很大程度上是由编译器决定的。在 CLR 中，enum

实例（未拆箱）与它的实际整数值在运行时是没有区别的。CLR 中定义的 enum

仅仅是 System.Enum

的子类型，而每一个成员则是其静态整数类型字段。这意味着在通常情况下使用 enum

是非常高效的，其运行时开销和整数常量的开销一致。

这个方案的缺点在于 enum

虽然支持静态方式，却不具有强类型安全性。相关示例见第 3 章：

[Flags] public enum BorderSides { Left=1, Right=2, Top=4, Bottom=8 }

...BorderSides b = BorderSides.Left;b += 1234;             // No error!

当编译器无法执行验证（如本例）时，运行时也同样不会抛出异常。

前面提到 enum

实例与其整数值在运行时没有区别，但以下示例中的行为却又有些不一样：

[Flags] public enum BorderSides { Left=1, Right=2, Top=4, Bottom=8 }

...Console.WriteLine (BorderSides.Right.ToString());    // RightConsole.WriteLine (BorderSides.Right.GetType().Name);  // BorderSi

des

考虑到 enum

实例在运行时的性质，我们有理由认为本例应当输出 2

和 Int32

！而实际的行为则是由编译器的一些巧妙实现造成的。C# 会在调用 enum

实例的虚方法（例如 ToString

或 GetType

）前显式地将其装箱，而当 enum

实例装箱后，其运行时包装就可以访问引用的 enum

类型了。

6.10　Guid

结构体

Guid

结构体表示一个全局唯一标识符：一个在生成时就几乎可以肯定为全世界唯一的 16 字节值。Guid

在应用程序和数据库中通常作为各种排序的键，Guid

可表示的值总共有 2128

或 3.4×1018

个。

调用静态的 Guid.NewGuid

方法可以创建一个新的唯一的 Guid

：

Guid g = Guid.NewGuid ();

Console.WriteLine (g.ToSt

ring()); // 0d57629c-7d6e-4847-97cb-9e2fc25083fe

也可以使用构造器实例化一个现有的 Guid 值。常用的两种构造器为：

public Guid (byte[] b);  // Accepts a 16-byte array

public Guid (string g);  // Accepts a formatted str

ing

当以字符串形式出现时，Guid

是一个由 32 位十六进制数字表示的值，并在第 8 个、第 12 个、第 16 个和第 20 个数字之后可以添加可选的连字符。整个字符串还可以放在方括号或花括号中：

Guid g1 = new Guid ("{0d57629c-7d6e-4847-97cb-9e2fc25083fe}");

Guid g2 = new Guid ("0d57629c7d6e484797cb9e2fc25083fe");Console.WriteLine (g1 == g2); // True

Guid

是一个结构体，支持值类型的语义，因而前面的例子可以使用相等运算符。

Guid

的 ToByteArray

方法可以将其转换为字节数组。

Guid.Empty

静态属性将返回一个空的 Guid

（全部为零），它通常用来表示 null

。

6.11　相等比较

到现在为止，我们都认为 ==

和！=

就是相等比较的全部。但是相等比较是非常复杂而细微的，有时还需要使用其他的方法和接口。本节将介绍 C# 和.NET 的相等比较协议，主要关注的问题有两个：

==

和！=

在什么时候能够满足相等比较的需要，什么时候不满足，有哪些替代的方法？

什么时候应当为类型自定义相等比较逻辑？如何定义？

在详细介绍相等比较协议以及其定制方法之前，首先要了解值相等和引用相等的基本概念。

6.11.1　值相等和引用相等

相等有两种：

值相等：两个值在某种意义上是相等的。

引用相等：两个引用指向完全相同的对象。

除非被重写，否则：

值类型使用值相等。

引用类型使用引用相等。

实际上值类型只能使用值相等（除非被装箱）。一个简单的例子就是比较两个数字：

int x = 5, y = 5;Console.WriteLine (x == y);  // True (by virtue of value equality)

更复杂的例子就是比较两个 DateTimeOffset

结构体。下面的两个 DateTimeOffset

指向同一个时间点，所以它们应该是相等的，输出结果为 True

：

var dt1 = new DateTimeOffset (2010, 1, 1, 1

, 1, 1, TimeSpan.FromHours(8

));var dt2 = new DateTimeOffset (2010, 1, 1, 2

, 1, 1, TimeSpan.FromHours(9

));

Con

sole.WriteLine (dt1 == dt2);  // True

DateTimeOffset

是一个结构体，但是它的相等语义是比较复杂的。默认情况下，结构体采用一种特殊相等语义，称为结构化相等（structural equality），即如果其所有的成员都相等，那么两个结构体相等（你可以创建一个结构体，然后调用它们的 Equals

方法来验证这一点，后续内容将对此进行更详细的介绍）。

引用类型默认采用引用相等的比较形式。在下面的例子中，尽管它们所指的对象具有相同的内容，但是 f1

和 f2

是不相等的：

class Foo { public int X; }

...Foo f1 = new Foo { X = 5 };

Foo f2 = new Foo { X = 5 };

Console.WriteLine (f1 == f2

);

// False

相反，f3

和 f1

相等。因为它们引用了同一个对象：

Foo f3 = f1;

Console.Writ

eLine (f1 == f3);  // True

我们将在本节的后面介绍如何自定义引用类型来实现值相等。System

命名空间的 Uri

类就是自定义值相等的例子：

Uri uri1 = new Uri ("http://www.linqpad.net");

Uri uri2 = new Uri ("http://www.linqpad.net");

Console.WriteLine (uri1 == uri2);

// True

string

类也具有相似的特性：

var s1 = "http://www.linqpad.net";

var s2 = "http://" + "www.linqpad.

net";Console.WriteLine (s1 == s2);

// True

6.11.2　标准相等比较协议

类型的相等比较实现共有三种标准协议：

==

和！=

运算符

object

对象的 Equals

虚方法

IEquatable<T>

接口

此外，我们还将在第 7 章讨论相等比较的扩展协议以及 IStructuralEquatable

接口。

==

和！=

我们在很多例子中都使用了标准的 ==

和！=

运算符进行相等或不相等比较。==

与！=

的特殊性在于它们是运算符，因此它们是以静态方式解析的（实际上，它们本身的实现就是静态函数）。因此，当我们使用 ==

与！=

时，C# 会在编译时根据类型确定哪一个函数将执行比较操作，且没有使用任何虚行为。一般这种判断结果都和我们的期望一致。在下面的例子中，由于 x

和 y

都是 int

类型，因此编译器将 == 运算符绑定到了 int

类型上。

int x = 5;

int y = 5;

Console.Wr

iteLine (x

== y);   // True

但是在以下示例中，编译器会将 ==

运算符绑定到 object

类型上：

object x = 5;

object y = 5;

Console.Write

Line (x == y);

// False

object

是一个类（因而也是一个引用类型），因此 object

的 ==

运算符将对 x

和 y

进行引用相等比较。但由于 x

和 y

引用都是在堆上装箱后的不同对象，其结果自然为 false

。

Object.Equals

虚方法

为了正确比较上例中的 x

和 y

，我们可以使用 Equals

虚方法。Equals

是定义在 System.Object

中的方法，因此所有类型都支持这个方法：

object x = 5;object y = 5;Console.WriteLine (x.Equals (y)

);   // True

Equals

是在运行时根据对象的实际类型解析的。在上例中它会调用 Int32

的 Equals

方法，在操作数上进行值相等比较从而返回 true

。对于引用类型，Equals

默认进行引用相等比较。对于结构体，Equals

会调用每一个字段的 Equals

进行结构化比较。

为什么要这么复杂

你可能会疑惑为什么 C# 的设计人员不将 ==

设计成虚函数以避免这个问题，这样它在功能上就等同于 Equals

。这样设计有以下三个原因：

如果第一个操作数为 null

，则 Equals

将会抛出 NullReferenceException

而失败。但是静态的运算符不会。

==

运算符是静态解析的，因此它执行得非常快。这意味着可以轻松编写出计算密集型的代码而无须额外学习其他语言，例如 C++。

有时 ==

和 Equals

分别应用不同的相等比较定义非常有用。我们将在本节后面介绍这一点。

总之，设计的复杂性反映了情形的复杂性：相等概念涵盖的情形很广泛。

因此 Equals

适合用来比较两个未知类型的对象。下面的方法可比较两个任意类型的对象：

public static bool AreEqual (object obj1, object obj2)

=> obj1.Equals (obj2);

然而这个例子在第一个参数为 null

时会抛出 NullReferenceException

而失败。以下是修正后的方法：

public static bool AreEqual (object obj1, object obj2){ if (obj1 == null) return obj2 == null;

return obj1.Equals (obj2);}

或者可以更简洁地写为：

public static bool AreEqual (object obj1, object obj2)

=> obj1 == null ? obj2 == null : obj1.Equals (obj2);

object.Equals

静态方法

object

类提供了一个静态的辅助方法，该方法正是实现了前一个例子中的 AreEqual

操作。虽然它的名字与虚方法的相同，都是 Equals

，但是不会有冲突，因为它会接受两个参数：

public static bool Equals (object objA, object objB)

如果对象的类型在编译时未知，那么该方法可以提供支持 null

值的相等比较算法：

object x = 3, y = 3;

Console.WriteLine (o

bject.Equals (x, y));  // Truex = null;Console.WriteLine (o

bject.Equals (x, y));  // Falsey = null;Console.WriteLine (o

bject.Equals (x, y));  // True

这在编写泛型类型时是很有用的。以下代码若使用 ==

或！=

而不是 object.Equals

，则无法正常编译：

class Test <T>{ T _value; public void SetValue (T newValue) {  if (!object.Equals (newValue, _value))

{

_value = newValue;

OnValueChanged();  } } prot

ected virtual void OnValu

eChanged() { ... }}

此处无法使用运算符，因为编译器无法绑定一个类型未知的静态方法。

更加精确地实现上述比较的方式是使用 EqualityComparer<T>

类。其优点是无须进行装箱。

if (!EqualityComparer<T>.Default.Equals

(newValue, _value))

我们将在 7.8 节详细介绍 EqualityComparer<T>

。

object.ReferenceEquals

静态方法

有时候，我们需要强制进行引用相等比较。静态方法 object.ReferenceEquals

就可以实现这种比较：

class Widget { ... }class Test{ static void Main() {  Widget w1 = new Widget();  Widget w2 = new Widget();  Console.WriteLine (object.ReferenceEquals (w1, w2));   // False

}}

此处进行引用比较的原因是有可能 Widget

类重写了 Equals

虚方法导致 w1.Equals (w2)

返回 true

。此外，Widget

类还可以重载 ==

运算符令 w1 == w2

同样返回 true

。在这两种情况下，调用 object.ReferenceEquals

都能够保证正常的引用相等语义。

另一种强制进行引用相等比较的方法是将值转换为 object

，然后再使用 ==

运算符。

IEquatable<T>

接口

调用 object.Equals

方法会对值类型进行强制装箱。由于装箱操作比实际比较操作的开销还高，因此这种方式在对性能高度敏感的场景中是不可接受的。C# 2.0 引入了 IEquatable<T>

接口来解决这个问题：

public interface IEquatable<T>

{ bool Equals (T other);}

IEquatable<T>

接口在实现上可以得到和 object

的 Equals

虚方法完全相同的结果，但速度上更快。大多数.NET 类型都实现了 IEquatable<T>

。我们还可以在泛型类型中使用 IEquatable<T>

作为约束：

class Test<T> where T : IEquatable<T>

{ public bool IsEqual (T a, T b) {  return a.Equals (b)

;   // No boxing with generic T

}}

即使我们删除泛型约束，这个类仍然可以编译。但是 a.Equals (b)

就会绑定到速度更慢的 object.Equals

方法（假定 T

是一个值类型）上。

Equals

和 ==

在何时不会等价

之前提到，有时 ==

和 Equals

应当具有不同的关于「相等」的定义。例如：

double x = double.NaN;Console.WriteLine (x == x);      // False

Console.WriteLine (x.Equals (x));   // True

double

类型的 ==

运算符强制规定一个 NaN

不等于任何对象，即使另一个值也是 NaN

。这从数学角度来说是非常自然的，并且也反映了底层 CPU 的行为。但是，Equals

方法必须支持自反相等，即：

x.Equals (x)

必须总是返回 true

。

Equals

的这种行为对于集合和字典来说至关重要，否则就无法找到之前存储的项。

对于值类型来说，分别对 Equals

和 ==

应用不同的相等定义的做法是非常少见的。但这种做法在引用类型中要多得多，即开发者自定义 Equals

实现值的相等比较，而仍旧令 ==

执行（默认的）引用相等比较。StringBuilder

类就是采用了这种方式：

var sb1 = new StringBuilder ("foo");var sb2 = new StringBuilder ("foo");Console.WriteLine (sb1 == sb2);     // False (referential equality)

Console.WriteLine (sb1.Equals (sb2));  // True (value equality)

接下来我们将介绍如何自定义相等操作。

6.11.3　相等比较和自定义类型

先来回顾一下默认的相等比较行为：

值类型采用相等比较。

引用类型采用引用相等比较。

此外：

结构体的 Equals

方法默认采用结构化值相等比较（例如，它会比较结构体中的每个字段）。

有时，创建类型时重写这个行为是很有用的，以下两种情况都适用于这种做法：

为了改变相等比较的含义。

为了加快结构体相等比较的速度。

修改相等比较的语义

当 ==

和 Equals

默认行为不符合类型的要求且和使用者期望的行为不一致时就应当修改相等比较的语义。例如 DateTimeOffset

，这是一个具有两个私有字段的结构体：一个 UTC 的 DateTime

和一个整数偏移量。如果让我们来实现这个类型的话，我们可能希望在相等比较时仅考虑 UTC 的 DateTime

字段且无须考虑偏移字段。再比如诸如 double

类型和 float

类型这种支持 NaN

值的数值类型。如果我们自己来实现这些类型，也希望在相等比较时能支持 NaN

值的比较逻辑。

对于类而言，有时将值相等（而不是引用相等）作为默认行为可能更自然。这通常适用于小型持有很少数据的类，例如 System.Uri

（或者 System.String

）。

提高结构体相等比较的速度

结构体默认的结构化相等比较算法速度较低。通过重写 Equals

来实现这个过程能够获得近 20% 的性能提升。重载 ==

运算符并实现 IEquatable<T>

接口可以避免相等比较过程中的装箱操作，这同样可以将速度再提升 20%。

重写引用类型的相等比较语义并不能提高性能。因为引用相等比较的默认算法只需要比较两个 32 位或者 64 位整数，其运行速度已经非常快了。

自定义相等语义实际上还有另一个原因，那就是为了改进结构体的散列算法，以提高散列表的性能。这是因为相等比较和散列内在上是存在关联的。我们将在后面的小节介绍散列。

如何重写相等语义

下面是重写相等语义的步骤：

重写 GetHashCode ()

和 Equals ()

方法。

（可选）重载！=

和 ==

。

（可选）实现 IEquatable<T>

。

重写 GetHashCode

GetHashCode

是 Object

类型中的一个虚方法。也许在 System.Object

这个只拥有很少预定义成员的类型中定义这个应用范围狭窄且用途特定的方法很怪异。因为它只服务以下两种类型：

System.Collections.Hashtable

System.Collections.Generic.D

ictionary<TKey,TValue>

这些类型都是散列表，即一些使用键来存储和获取元素的集合。散列表支持一个基于键的高效分配元素的方法。它要求每一个键都是 Int32

整数（称为散列码）。散列码对于每个键来说不需要唯一，但是为了实现最佳的散列表性能，它要尽可能保持差异。散列表在系统中的地位是非常重要的，因此在 System.Object

中定义了 GetHashCode

方法，令每一种类型都能够生成散列码。

我们将在 7.5 节详细介绍散列表。

引用类型和值类型都有默认的 GetHashCode

实现。这意味只要不重写 Equals

，就不用重写 GetHashCode

（如果重写了 GetHashCode

，那么几乎可以肯定 Equals

方法也会被重写）。

下面是重写 object.GetHashCode

的其他规则：

它必须在 Equals

方法返回 true

的两个对象上返回相同的值。因此，GetHashCode

和 Equals

通常成对地重写。

它不能抛出异常。

如果重复调用相同的对象，那么必须返回相同的值（除非对象改变）。

为了实现最佳的散列表性能，GetHashCode

应当尽可能避免为两个不同的值返回相同的散列码。这也是方才在结构体上重写 GetHashCode

和 Equals

的第三个原因，其目的就是为了实现更高效的散列算法。结构体的默认散列算法是在运行时生成的，它基于结构体的每一个字段值来计算散列码。

相反，类的默认 GetHashCode

的实现是基于一个内部对象标识的。基于目前的 CLR 实现，这个标识在所有实例中是唯一的。

如果一个对象作为键添加到字典后其散列码发生了变化，那么这个对象在字典中将不可访问。因此可以基于不可变的字段进行散列码计算以避免这个问题。

我们稍后将用一个完整的例子展示重写 GetHashCode

的方法。

重写 Equals

object.Equals

的逻辑如下：

对象不可能是 null

（除非它是一个可空类型）。

相等是自反性的（对象与其自身相等）。

相等是可交换的（如果 a.Equals (b)

，那么 b.Equals (a)

）。

相等是可传递的（如果 a.Equals (b)

且 b.Equals (c)

，那么 a.Equals (c)

）。

相等比较操作是可以重复并且可靠的（它不会抛出异常）。

重载 ==

和！=

除了重写 Equals

，我们还可选择性地重载相等和不等运算符。这种重载几乎都会发生在结构体上，否则 ==

和！=

运算符将无法在该类型上工作。

对于类，则有两种处理方法：

不重载 ==

和！=

，这样它们会应用引用相等比较规则。

重写 Equals

的同时重载 ==

和！=

运算符。

第一种方法通常用于自定义类型，特别是可变类型。它能够保证该类型符合一般预期，即对于引用类型，==

与！=

执行引用相等比较以避免产生歧义。我们之前看到过如下例子：

var sb1 = new StringBuilder ("foo");var sb2 = new StringBuilder ("foo");Console.WriteLine (sb1 == sb2);     // False (referential equality)

Console.WriteLine (sb1.Equals (sb2));  // True (value equality)

第二种方法适用于那些不需要引用相等比较的类型。它们一般是不可变类型，例如 string

和 System.Uri

类。它们有时是良好的结构体候选者。

虽然可以重载！=

使之具有！(==)

之外的语义，但是这在实际中是几乎不可能发生的，只在与 float.NaN

进行比较时例外。

实现 IEquatable<T>

为了保持完整性，若重写 Equals

，最好也实现 IEquatable<T>

接口。它的结果应总是与重写的 Equals

方法保持一致。借助 Equals

方法来实现 IEquatable<T>

接口几乎没有程序开销，如下面的例子所示。

范例：Area

结构体

假设我们需要一个结构体来表示一块区域，且该区域的长和宽是可以互换的，即 5×10 等于 10×5（这种类型应该适用于排列矩形图形的算法）。

以下是完整的代码：

public struct Area : IEquatable <Area>

{ public readonly int Measure1; public readonly int Measure2; public Area (int m1, int m2) {  Measure1 = Math.Min (m1, m2);  Measure2 = Math.Max (m1, m2); } public override bool Equals (object

ot

her) {  if (!(other is Area)) return false

;  return Equals ((Area) other);



// Calls method below } public bool Equals (Area other)



// Implements IEquatable<Area>  => Measure1 == other.Measure1 && M

ea

sure2 == other.Measure2; public override int GetHashCode()  => HashCode.Combine (Measure1, Mea

su

re2); public static bool operator == (Area

a

1, Area a2) => a1.Equals (a2); public static bool operator != (Area

a

1, Area a2) => !a1.Equals (a2);}

下面是另一种实现 Equals

的方法，即使用可空值类型：

Area? otherArea = other as Area?;

return otherArea.HasValue && Equa

ls (otherArea.Value);

上述代码在实现 GetHashCode

方法时使用了.NET Core 的 HashCode.Combine

函数来创建一个组合的散列值（在该函数之前，实现相同功能的主流方式是使用每一个散列值乘以一个素数，再将其累加起来）。

以下示例展示了 Area

结构体的行为：

Area a1 = new Area (5, 10);

Area a2 = new Area (10, 5);

Console.WriteLine (a1.Equal

s (a2));  // TrueConsole.WriteLine (a1 == a2

);     // True

扩展相等比较器

如果你希望类型在不同的特定情形下使用不同的相等语义，那么可以使用扩展接口 IEqualityComparer

。它在与标准的集合类一起使用时非常有效，我们会在下一章讲到它。具体请参见 7.8 节。

6.12　顺序比较

除了标准的相等比较协议之外，C# 和.NET 还定义了确定对象之间相对顺序的标准协议。基本的协议包括：

IComparable

接口（IComparable

和 IComparable<T>

接口）

>

和 <

运算符

IComparable

接口可用于普通的排序算法。在以下示例中，静态的 Array.Sort

方法可以奏效的原因是 System.String

实现了 IComparable

接口：

string[] colors = { "Green", "Red", "Blue" };Array.Sort (colors);

foreach (string c in colors) Console.Write (c + " ");  // Blue Green Red

<

和 >

运算符用途更加专门化，它们大多数情况用于数值类型的比较，由于它们是静态解析的，因此可以转换为高效的字节码，适用于计算密集的算法。

.NET Core 还通过 IComparer

接口提供了扩展排序协议。相关内容将在第 7 章的最后一节介绍。

6.12.1　IComparable

IComparable

的定义方式如下：

public interface IComparable    { int CompareTo (object other); }

public interface IComparable<in T> { int CompareTo (T other);   }

这两个接口实现了相同的功能。对于值类型，泛型安全的接口执行速度比非泛型接口要快。它们的 CompareTo

方法按照如下的方式执行：

如果 a

在 b

之后，则 a.CompareTo (b)

应当返回一个正数。

如果 a

和 b

位置相同，那么 a.CompareTo (b)

返回 0

。

如果 a

在 b

之前，则 a.CompareTo (b)

应当返回一个负数。

例如：

Console.WriteLine ("Beck".CompareTo ("Anne"));    // 1

Console.WriteLine ("Beck".CompareTo ("Beck"));    // 0

Console.WriteLine ("Beck".CompareTo ("Chris"));   // -

1

大多数的基本类型都实现了这两种 IComparable

接口。在编写自定义类型时有时也需要实现这些接口。稍后我们将介绍一个这样的例子。

IComparable

与 Equals

假设一种类型既重写了 Equals

，又实现了 IComparable

接口。那么当 Equals

返回 true

时，CompareTo

返回 0

。这种行为是符合预期的。但也有例外的情况：

当 Equals

返回 false

时，CompareTo

可以返回任何结果（只要其内部规则是一致的）。

换句话说，相等比较是严格的，排序比较则不然（违反这一点，排序算法就会出错）。所以，CompareTo

的结果可能是所有的对象都相同，而 Equals

却可以表达「有一些对象比其他对象相同程度更高」的意思。

System.String

就是最好的例子。string

的 Equals

方法和 ==

运算符采用的都是序列比较，即它会比较每一个字符的 Unicode 值。然而，其 CompareTo

方法使用的却是较为宽泛的与文化相关的比较。在大多数计算机中，字符串 "ǖ"

和 "ǖ"

用 Equals

比较时是不同的，然而用 CompareTo

比较时则是相同的。

我们将在第 7 章讨论扩展排序协议 IComparer

。它可以在调用排序方法或实例化支持排序的集合时指定新的排序算法。自定义的 IComparer

还可以进一步明确 CompareTo

和 Equals

的区别。例如，不区分大小写的字符串顺序比较器比较 "A"

和 "a"

时会返回 0

，反之亦然。总之：CompareTo

永远不会比 Equals

更严格。

当为自定义的类型实现 IComparable

接口时，可以将下面一行代码添加到 CompareTo

的开头来确保遵守上述规则：

if (Equals (other)) return 0;

此后，在确保逻辑一致的前提下可以返回任何值。

6.12.2　<

和 >

有些类型定义了 <

和 >

运算符，例如：

bool after2010 = DateTime.Now > new DateTime (2010, 1, 1);

可以肯定，<

和 >

运算符的实现在功能上应当与 IComparable

接口保持一致。这也是在整个.NET Core 中都适用的标准做法。

同样，若重载了 <

和 >

运算符，那么也应当同时实现 IComparable

接口，这也是一种标准做法。但反之则不然。事实上，大部分实现了 IComparable

的.NET 类型都没有重载 <

和 >

运算符。这与相等比较的处理方法不同。对于相等比较，如果类型重写了 Equals

，一般也会重载 == 运算符。

通常，在以下情况下才会重载 <

和 >

运算符：

类型具有固有的「大于」和「小于」概念（对应于 IComparable

的更宽泛的「之前」和「之后」概念）。

这种比较只能用一种方式或在一个上下文下执行。

比较的结果在各种文化中保持不变。

System.String

并不满足最后一点：字符串的比较结果可能会因语言的不同而不同，因此 string

类型并不支持 <

和 >

运算符，例如：

bool error = "Beck" > "Anne";    // Compile-time error

6.12.3　实现 IComparable

接口

以下的结构体代表了一个音符。它实现了 IComparable

接口并重载了 <

和 >

运算符。为了演示的完整性，我们还重写了 Equals

/GetHashCode

方法并重载了 ==

和！=

运算符：

public struct Note : IComparable<Note>, IEquatable<Note>, IComparable

{ int _semitonesFromA; public int SemitonesFromA { get { return _semitonesFromA; } } public Note (int semitonesFromA) {  _semitonesFromA = semitonesFromA; } public int CompareTo (Note other)      // Generic IComparable

<T

> {  if (Equals (other)) return 0;  // Fail-safe check  return _semitonesFromA.CompareTo (other._semitonesFromA); } int IComparable.CompareTo (object other)   // Nongeneric ICompara

bl

e {  if (!(other is Note))   throw new InvalidOperationException ("CompareTo: Not a note");  return CompareTo ((Note) other); } public static bool operator < (Note n1, Note n2)   => n1.CompareTo (n2) < 0; public static bool operator > (Note n1, Note n2)  => n1.CompareTo (n2) > 0; public bool Equals (Note other)  // for IEquatable<Note>  => _semitonesFromA == other._semitonesFromA; public override bool Equals (object other) {  if (!(other is Note)) return false;  return Equals ((Note) other); } public override int GetHashCode() => _semitonesFromA.GetHashCode();

public static bool operator == (Note n1, Note n2) => n1.Equals (n2)

; public static bool operator != (Note n1, Note n2) => !(n1 == n2);}

6.13　实用类

6.13.1　Console

类

静态类 Console

用于处理控制台应用程序的标准输入 / 输出。命令行（控制台）应用程序的输入是利用键盘通过 Read

、ReadKey

以及 ReadLine

方法得到的，而输出则通过 Write

和 WriteLine

方法显示在文本窗口上。还可以通过 WindowLeft

、WindowTop

、WindowHeight

以及 WindowWidth

属性控制窗口的位置和尺寸。也可以修改 BackgroundColor

和 ForegroundColor

属性控制背景及前景的颜色，并通过 CursorLeft

、CursorTop

和 CursorSize

属性控制鼠标指针：

Console.WindowWidth = Console.LargestWindowWidth;

Console.ForegroundColor = ConsoleColor.Green;Console.Write ("test... 50%");Console.CursorLeft -= 3;Console.Write ("90%");   // test... 90%

Write

和 WriteLine

的重载方法可以接受一个组合格式字符串（参见 6.1 节中的 String.Format

方法）。然而，这两个方法都不接受格式提供器，因此无法使用 CultureInfo.CurrentCulture

（可以通过显式调用 string.Format

解决）。

Console.Out

属性会返回一个 TextWriter

实例。将 Console.Out

传递给一个接受 TextWriter

的方法，使其向 Console

写入内容是一种有效的程序诊断方式。

除此之外，还可以通过 SetIn

和 SetOut

方法重定向 Console

的输入和输出流：

// First save existing output writer:

System.IO.TextWriter oldOut = Console

.Out;// Redirect the console's output to a

file:using (System.IO.TextWriter w = Syste

m.IO.File.CreateText                ("e:\

\output.txt")){ Console.SetOut (w); Console.WriteLine ("Hello world");}// Restore standard console outputConsole.SetOut (oldOut);

第 15 章将介绍 Stream

和 TextWriter

的工作方式。

在 Visual Studio 中运行 WPF 或 Windows Forms 应用程序时，（在调试模式下）Console

的输出流会自动重定向到 Visual Studio 的输出窗口。因此 Console.Write

可用于诊断问题。但是在大多数情况下，使用 System.Diagnostics

命名空间的 Debug

和 Trace

类更合适（见第 13 章）。

6.13.2　Environment

类

静态类 System.Environment

提供了很多有用的属性：

文件和文件夹：CurrentDirectory

、SystemDirectory

、CommandLine

计算机和操作系统：MachineName

、ProcessorCount

、OSVersion

、NewLine

用户登录：UserName

、UserInteractive

、UserDomainName

诊断信息：TickCount

、StackTrace

、WorkingSet

、Version

除此之外，还可以通过 GetFolderPath

方法获得更多的文件夹。相关内容将在 15.6 节介绍。

如需要访问操作系统的环境变量（在命令行提示符下输入「set」时看到的结果），可使用三个方法：GetEnvironmentVariable

、GetEnvironmentVariables

和 SetEnvironmentVariable

。

可通过 ExitCode

属性来设置应用程序的返回值。当程序被命令行或批处理文件调用时，FailFast

方法可以在不执行清理操作的情况下立即终止程序。

Environment

类同样适用于 Windows 应用商店开发，但仅提供非常有限的几个成员（ProcessorCount

、NewLine

和 FailFast

）。

6.13.3　Process

类

System.Diagnostics

命名空间的 Process

类可以启动一个新的进程（第 13 章将介绍如何使用这个类与其他的进程进行交互）。

出于安全性考虑，Windows 商店应用不能使用 Process

类，因此无法在这种应用中任意启动进程。只能使用 Windows.System.Launcher

类来「启动」一个具有访问权限的 URI 或者文件，例如：

Launcher.LaunchUriAsync (new Uri ("http://albahari.com"));

var file = await KnownFolders.DocumentsLibrary               .GetFileAsync ("foo.txt");Launcher.LaunchFileAsync (file);

上述操作将使用（与 URI 方案或文件扩展名）关联的应用程序打开 URI 或者文件，且当前程序必须处于前台才能够执行这个操作。

静态方法 Process.Start

有很多种重载形式，最简单的重载方法仅接受一个文件名称以及可选的参数：

Process.Start ("notepad.exe");

Process.Start ("notepad.exe",

"e:\\file.txt");

而最灵活的重载方法接受一个 ProcessStartInfo

实例。通过这个方法，我们能够捕获并重定向被启动进程的输入、输出以及错误输出（如果 UseShellExecute

属性为 false

）。以下代码将捕获 ipconfig

命令的输出：

ProcessStartInfo psi = new ProcessStartInfo

{ FileName = "cmd.exe", Arguments = "/c ipconfig /all", RedirectStandardOutput = true, UseShellExecute = false};Process p = Process.Start (psi);string result = p.StandardOutput.ReadToEnd(

);

Console.WriteLine (result);

如果不将输出重定向，则 Process.Start

会与调用者并行执行。如果希望等待进程结束，那么可以调用 Process

对象的 WaitForExit

方法（可同时传递可选的超时时间参数）。

重定向输出流和错误流

当 UseShellExecute

为 false

时（.NET Core 的默认值），我们可以捕获标准的输入、输出和错误流，并通过 StandardInput

、StandardOutput

和 StandardError

属性从这些流中读取或向它们中写入数据。

同时重定向标准输出流和标准错误流是不太容易的，因为通常情况下无法预见从两个流中读取数据的顺序（无法事先知道数据是如何交错写入两个流中的）。要解决这个问题就需要同时从两个流中读取数据，即从至少一个流中异步地读取数据。其过程如下：

处理 OutputDataReceived

或 ErrorDataReceived

事件。这些事件将在收到输出流数据与错误流数据时触发。

调用 BeginOutputReadLine

或 BeginErrorReadLine

方法。这将开始事件的生成过程。

以下的方法将启动一个可执行程序，并同时捕获其输出流和错误流：

(string output, string errors) Run (string exePath, string args = ""){ using var p = Process.Start (new ProcessStartInfo (exePath, args) {  RedirectStandardOutput = true,  RedirectStandardError = true,  UseShellExecute = false, }); var errors = new StringBuilder (); // Read from the error stream asynchronously... p.ErrorDataReceived

+= (sender, errorArgs) => {  if (errorArgs.Data != null) errors.AppendLine (errorArgs.Data)

; }; p.BeginErrorReadLine (); // ...while we read from the output stream synchronously: string output = p.StandardOutput.ReadToEnd()

;





p.WaitForExit();



return (output, err

ors.ToString());}

UseShellExecute

UseShellExecute

标志可以更改 CLR 启动进程的方式。当 UseShellExecute

为 true

时，可以执行如下的操作：

指定文件或文档的路径而非指定可执行文件路径（操作系统会使用相关的应用程序打开文件或者文档）。

指定 URL（操作系统会使用默认的 Web 浏览器打开指定的 URL）。

（在 Windows 操作系统中）指定 Verb 属性（Verb 属性为字符串类型值，例如设置为 runas 可以令进程以管理员权限启动）。

在.NET Core 中，UseShellExecute

默认值为 false

，而在.NET Framework 中，其默认值为 true

。这是一个中断性变更，因此将程序代码从.NET Framework 移植到.NET Core 时请务必检查所有针对 Process.Start

的调用。

但是，此时将无法重定向输入输出流。如果需要重定向输入输出流，但仍需要以文件或文档来启动进程，则可以将 UseShellExecute

设置为 false

，启动命令行进程（cmd.exe），并辅以「/c

」开关。可以参考之前调用 ipconfig

命令的范例。

在 Windows 操作系统中，使用 UseShellExecute

将指示 CLR 使用 Windows 的 ShellExecute 函数而非 CreateProcess 函数。在 Linux 系统中，UseShellExecute

将指示 CLR 调用 xdg-open、gnome-open 或 kfmclient。

6.13.4　AppContext

类

静态类 System.AppContext

具有以下两个常用属性：

BaseDirectory

属性返回应用程序启动时所在的目录。这个目录对于程序集的解析工作（找到并加载依赖）和配置文件的定位（例如 appsettings.json）非常重要。

TargetFrameworkName

属性返回当前应用程序基于的.NET Core 框架的名称和版本（该信息可在.runtimeconfig.json 文件中指定）。其值对应的框架可能比运行时实际使用的框架版本要更老一些。

此外，AppContext 类还管理了一个全局的以字符串为键，布尔类型为值的字典对象。该对象为程序库的作者提供了一套标准的允许用户来打开或关闭程序库功能的机制。如不希望向大多数用户开放这些试验性功能，则可以使用这种非类型化机制。

例如，程序库的消费者可以使用如下方式启用程序库的某个功能：

AppContext.SetSwitch ("MyLibrary.SomeBreakingChange", true);

程序库中的代码则可以使用如下的方式对相关功能的开关状态进行检查：

bool isDefined, switchValue;

isDefined = AppContext.TryGe

tSwitch ("MyLibrary.SomeBreakingChange",

out switchValue);

TryGetSwitch

方法将在开关未定义的情况下返回 false

。这样我们就可以区分未定义和值为 false

这两种不同的情况了，这种区分是非常必要的。

有趣的是，TryGetSwitch

方法的设计是一个 API 设计方式的反例。这个方法没有必要使用 out

参数，应返回一个可空的 bool

类型。其 true

、false

和 null

分别对应打开、关闭和未定义状态。这样就可以使用以下的写法进行查询了：

bool switchValue = AppContext.GetSwitch ("...") ?? false;

