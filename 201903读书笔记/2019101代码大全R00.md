## 记忆时间

## 卡片

### 0101. 反常识卡——

这本书的主题核心，就是最大的反常识卡，并且注意时间脉络。

#### 01. 常识

#### 02. 反常识

#### 03. 知识来源

比如提出者，如何演化成型的；书或专栏具体出现的地方。

#### 04. 例子

### 0201. 术语卡——数据为中心

根据反常识，再补充三个证据——就产生三张术语卡。

例子。

### 0202. 术语卡——

### 0203. 术语卡——

### 0301. 人名卡——

根据这些证据和案例，找出源头和提出术语的人是谁——产生一张人名卡，并且分析他为什么牛，有哪些作品，生平经历是什么。

维基百科链接：有的话。

#### 01. 出生日期

用一句话描述你对这个大牛的印象。

#### 02. 贡献及经历

#### 03. 论文及书籍

#### 04. 演讲汇总

找一个他的 TED 演讲，有的话。

### 0401. 金句卡——

最后根据他写的非常震撼的话语——产生一张金句卡。

### 0501. 行动卡——

行动卡是能够指导自己的行动的卡。

### 0601. 任意卡——

最后还有一张任意卡，记录个人阅读感想。

## 模板

### 1. 逻辑脉络

用自己的话总结主题，梳理逻辑脉络，也就是这本书整个地图里这一章所在的节点。

### 2. 摘录及评论

1『自己的观点』

2『行动指南』

3『与其他知识的连接』

## 前言

本书从软件质量和编程思想等方面论述了软件构造问题，并详细论述了紧跟潮流的新技术、高屋建瓴的观点、通用的概念，还含有丰富而典型的程序示例。

直到现在，这些技术中的大部分仍然没有在软件编程中广泛采用，其主要原因是这些研究成果主要发表在高度专业性的学术刊物中，普通的程序员们无心顾及。Sridhar Raghavan 和 Donald Chand (1989) 的研究表明，一项新技术从诞生到被工业界广泛采用大约需要 5 到 15 年的时间。本书的目的就是希望能够缩短新技术推广周期，使广大的程序员们可以迅速地获得软件开发的最新方法与手段。

1、完备的软件创建。参考本书从质量和编程思想等方面论述了软件构造问题。几乎囊括了生成子程序、数据的输入输出与控制结构、调试、代码调整策略与技术等各方面的细节。在使用本书时不必逐页阅读每一个细节，只要在需要时查阅你所感兴趣的章节即可。请把本书作为手册而不是作为教科书来使用。

2、方便而实用的检查表。书中附有用于检查软件的结构设计、设计方法、模块和子程序等质量的检查表，以供评估软件质量之用。同时，关于变量名、控制结构、方案布置、测试用例等等检查表也将使你获益匪浅。

3、紧跟潮流的新技术。书中论述了许多目前最先进的技术，其中许多还只是刚刚投入应用。由于本书取材于实践经验和最新研究成果两个方面，因此书中所提供的技术在相当长的时间内都不会过时。

4、高屋建瓴的观点。阅读本书将使你跳出日常琐碎工作的圈子，对软件开发有一个总体上的把握与认识。繁杂的日常工作往往使程序员们穷于应付而无暇阅读浩如烟海的书籍与资料，本书丰富而翔实的第一手资料将弥补这一缺憾，使你对软件开发的策略作出正确決策而不致陷入旷日持久的消耗战中。

5、通用的概念。无论你用的是 Pascal、C、C++、Ada、Basic、Cotran 还是 COBOL，都可以从本书所论述的概念、方法和技巧中获得教益。

6、丰富而典型性的程序示例。书中含有大约 500 多个正反两方面的程序示例。之所以引入这么多的示例，是因为笔者就是从各种例程中吸取了大部分的知识、经验与诀窍，因此笔者认为最好的学习方法是多看例程。例程是用多种语言写成的，因为对于程序员来说，掌握多种语言是其必不可少的基本素质之一。而且，只有掌握了不受语法规则限制的编程准则，才能真正有效地提高你的编程效率和质量。为了减轻由于使用多种语言所带来的额外负担，在例程中除非确有必要，尽量避开了各个语言过于独特的部分。事实上，如果你真正注意每个例程所要说明的问题的话，那么不必详细理解每个程序段，你也可以清楚地懂得程序的意义。同时，为了进一步减轻读者的负担，对程序中有意义的部分作了标记。

本书中所论述的技术不仅填补了初级与高级编程课本之间的空白，而且也为程序员们提供了一个有关编程技巧的信息来源。比如当你读过 C 语言初级教程之后，你可以再读 C 语言高级教程，然后再去读 C 语言高级的高级教程，但读完这些书后，你还能再读什么书呢？你可以再去读关于 PC、Macintosh 或 UNIX 等硬件或操作系统的书或者其它有关编程细节的书——因为你如果不了解实现环境详情的话是无法充分有效地使用语言和程序的。但这只是讨论了编程的一个方面，最有效的编程技术是那些不受实现环境及语言限制的技术。其它书往往忽略了这点，但这恰怡是本书的重点。

1、创建活动未受到应有的重视。在一段时期内，软件开发与编码被当作是一回事，但随着软件开发周期中的其它活动被认识，这一领域内的主要努力全部集中到了项目管理、需求分析、设计和测试等方面，创建活动成了被遗忘的角落。与这种现象相对应的思想是认为创建活动是软件开发中无关紧要的部分。于是，刚入门的程序员被派去进行创建工作，为那些已经由上一阶段设计好的子程序编码。工作几年之后，他可能会被提升至需求分析或项目管理部门。于是，这位程序员也会自豪地感到他不必再去编码。

2、创建活动是非常重要的。创建活动被忽视的另一个原因是：研究者和程序员们错误地认为与其它开发活动相比，创建活动是一相对来说比较机械的活动，没有什么值得改进的。没有什么比这种想法离事实更远了。在小规模项目中，创建活动约占工作量的 80%，在中型项目中也要占 50% 的工作量，而发生在创建活动中的错误则占总错误的 50% 到 75%。一项会产生 50% 到 75% 错误的工作是有许多待改进之处的。一些人认为，虽然创建时的错误占到总错误的 50% 到 75%，但修改它们的费用与分析、设计错误相比要少得多。的确，创建时的错误修改费用与前期工作错误修改费用相比是要少一些，但是绝对数并不少。Gerald Weinberg 曾在 1983 年报道过三个错误，每个错误的修改费用都高达数百万美元，而每个错误都是一行编码层次上的代码错误。因此，绝不能以修改费用相对少为理由来忽视创建活动。

具有讽刺意味的是，被忽视的创建活动事实上是唯一任何规模项目都必不可少的活动。需求可以进行猜想而不必分析；结构可以被省略而不必设计。系统测试也可以不进行。但是，如果你想有一个程序的话，你就不得不进行创建活动。

## 01 欢迎进入软件创建世界

### 1. 逻辑脉络

软件创建的概念及其重要性。

### 2. 摘录及评论

1、创建活动是总体设计和系统测试之间承上启下的工作。

2、创建活动主要包括：详细设计、编码、调试和单元测试。

3、关于创建活动的其它称谓有：实现、编程等。

4、创建活动质量对软件质量有潜在影响。

5、在最后的分析中，对创建活动理解的好坏，决定了一个程序员素质的高低，这将在本书其余部分论述。

因此「Construction」指的是建造某个东西的过程。这个过程可能包括：计划、设计、检验等方面的某些工作，但是，它主要是指在这其中的创造性工作。

问题定义；需求分析；实现计划；总体设计；详细设计；创建即实现；系统集成；单元测试；系统测试；校正性的维护；功能强化。

如果你以前从事过一些不太正规的研制工作，你可能以为列出的这个表有些太详细了。而如果你从事过一些正式的项目，你就会认为这个表非常准确。在正规性与随意性之间达到平衡是非常困难的。这会在以后章节中讨论。

如果你是自学编程员或是主要从事非正规研制工作，你很可能还没有意识到这些在生产软件中所需要的工作步骤。在潜意识中，你把这些工作统统称为编程。在非正式项目中，当你在考虑设计软件时，你所想到的主要活动可能就是研究者们所指的「创建」工作。

关于「创建」的直觉概念是非常准确的，但它往往缺乏正确观点。把创建活动放到与其相关活动的背景中，有助于我们在适当重视其它非创建工作的同时，把主要精力放在正确的任务上。

正如图中所指出的，创建活动主要指编码和调试过程，但也包括详细设计和测试中的某些工作。假如这是本关于软件开发所有方面的书，它应该涉及到开发过程所有方面并给予同等重视。但因为这是一本关于创建技术的手册，所以我们只重点论述创建活动及相关主题。如果把这本书比喻成一只狗，那么它将用鼻子轻擦创建活动，尾巴扫过设计与测试，而同时向其它开发活动汪汪叫。

创建活动有时被称作「实现」，它有时被叫作「编码和调试」，有时也称之为「编程」。「编码」实在不是一个很好的叫法，因为它隐含着把已经设计好的程序机械地翻译成机器语言的过程；创建则无此含义，它指的是在上述过程中的创造性和决策性活动，在本书中，将交替使用「实现」、「编程」和「创建」。

下面是创建活动中所包含的一些特定任务。

1. 验证基础工作已经完成，可以进行创建工作。

2. 设计和编写子程序与模块。

3. 创立数据类型并命名变量。

4. 选择控制结构并组织语句块。

5. 找出并修正错误。

6. 评审其它小组的细节设计和代码，同时接受其它小组评审。

7. 通过仔细地格式化和征集意见改进编码。

8. 对分别完成的软件单元进行综合。

9. 调整编码使其更小、更快。

创建活动包括如此众多的工作，人们可能会禁不住要问：「哪些是创建活动呢？」。一般认为，非创建活动包括：管理活动、需求分析、软件总体设计、用户交互界面设计、系统测试、维护工作等。这其中每项工作都与创建工作一样，会直接影响到项目的最终成败（那些需要两个人以上合作至少一星期项目的成败）。关于这其中每一项活动都有很不错的论著，在本书每章后都列出这些书的书名。

为什么创建活动是重要的？原因如下：

1、创建活动是开发软件的重要组成部分。随项目规模不同，创建活动在整个开发活动中所占时间为 30%~80% 之间，在任何计划中占有如此大时间比例的活动必然会影响计划的成败，这是不言而喻的。

2、创建活动在软件开发中处于枢纽地位。分析和设计是创建活动的基础工作，对系统进行测试以证实创建活动是正确的则是其后续工作，因而创建活动是软件开发的核心工作。

3、把主要精力集中于创建活动，可以极大地提高程序员的生产效率。由 Sackman、Erikson 和 Grant 在 1968 年进行的实验表明，每个程序员的效率系数的变化范围为 10~20，这一结果随后又被其它几个实验所证实。最优秀程序员与普通程序员的巨大差异表明，普通程序员提高效率的潜力是非常大的。

4、创建活动的产品，源代码，往往是软件的唯一精确描述。在许多项目中，程序员可得到的唯一文件便是代码本身。需求说明和设计文档可能会过时，但源代码却总是最新的。因此，源代码必须具有最好的质量。一个软件成功与否的关键，就在于是否不断运用技术来改进源代码。而这些技术恰怡是在创建阶段，才能得以最有效的应用。

5、创建活动是唯一一项必不可少的工作。理论上一个软件项目要经过精心的需求分析和总体设计，然后再进行创建，接着对其进行彻底的、严格的系统测试。然而，实际工作中的软件项目，往往越过前两个阶段而直接进行创建活动，最后，由于有太多的错误要修改，系统测试又被弃之路旁。但是，不管一个项目的计划多么疏漏而又如何匆忙，创建活动都是必不可少的。无论怎样精简，改进创建活动都是改进软件开发工作的方法。

## 02 利用隐喻对编程进行更深刻的理解

### 1. 逻辑脉络

会运用隐喻实在太重要，去理解软件创建过程中各个层次里的「隐喻」。

### 2. 摘录及评论

隐喻仅仅是启发，而不是公式，因此，它们更倾向于比较随便，无拘无束。

1、隐喻通过把软件开发与你所熟知的事情联系在一起，从而使你对其有更深刻的理解。

2、一些隐喻要好于其它隐喻。

3、把软件创建与建造建筑物类比，表明开发软件前要精心准备，并表明了大规模项目与小规模项目之间的差别。

4、认为软件开发实践是智能工具箱中的工具进一步表明，每个程序员都有许多自己的工具，没有任何一种工具是万能的。为每件工作选择合适的工具，是成为一个优秀程序员的首要素质之一。

计算机科学的语言可能是所有科学领域中最丰富的。想象一下。你走进一间干净整洁、温度严格控制在 68 F 的房间，在这里，你将会找到病毒、蠕虫、臭虫、炸弹、崩溃、火焰、扭曲的变形者、特洛伊木马和致命错误，在其它领域中，你会遇到这种情况吗？这些形象的隐喻描述了特定的软件现象。同样形象的隐喻描述了更为广泛的现象，你可以利用它们来加深你对软件开发的理解。

3『《我们赖以生存的隐喻》』

重大发现往往是从类比中产生的。通过把一个你所陌生的事物与你所熟知的事物比较，你会对它有进一步的认识，从而形成你对它的独到的深刻理解，这种隐喻方法被称之「模型化」。在科学发展史上，充满了利用类比而产生的发现。化学家 Kekle 梦见一条蛇咬住了自己的尾巴，醒来后，他由此联想到苯的结构，提出了苯是环形分子的假说，这一假说在 1966 年被 Barbour 用实验所证实。分子运动论是在 「保龄球」 模型上建立起来的。在这里，分子被假想为具有质量并且与保龄球一样相互之间进行完全弹性碰撞的小球，并且在此基础上，又产生了许多有用的模型。

光的波动理论是在与声音类比的基础上产生的。光与声都具有振幅（亮度与音量），频率（颜色与音调）和其它类似性质。这种类比是如此有效，以致于科学家们花费了大量时间来寻找像空气传播声音一样传播光的物质 「以太」，但他们从来也没能找到。有时如此有效的类比这次却导出了错误结果。

通常，模型的力量在于它能提供生动形象的概念而易被人整个接受。并提供特性、联系和附加的疑问，有时模型会提出令人困惑的问题，这时往往是由于模型被误解了，那些建筑 「以太」 的科学家们，就是因为误解了模型。

正如你所预料的，有些模型比其它的要好。好的模型要简单、与其它模型关联密切、能解释大部分实验事实和观测现象。

比如一个悬在铁链上来回晃动的大石头。在 Galileo 之前，Aristotelian 看到它时想到的是重物必然要从高处落下来停在低处，他认为石头是在克服阻力下落，而当 Galileo 看到同一现象时他认为自己看到了一个单摆，他认为石头是在不断地重复同一运动。

这两个模型所提供的信息是截然不同的。Aristotelian 认为石头是在下落，因而他关心的是石头的重量、升起的高度及停下所需的时间。而 Galileo 从单摆模型出发，他关心的是石头的重量、铁链的半径、石头的角位移及石头每摆一次所需要的时间。Galileo 之所以能发现单摆定律，就是因为他的模型与 Aristotelian 不同，从而导致他们提出了不同的问题。

隐喻对加深软件理解所做出的贡献，与它对其它领域所做出的贡献一样大。1973 年，在图灵奖颁奖演说中，Charles Bachman 叙述了从地心说向日心说转移的过程。Ptolemy 的地心说统治了近 1400 年。直到 1543 年，Copernicus 提出了日心说，这一思想模型的转变导致了一系列新星的发现，把月亮定义为卫星而不是行星，也改变了人类对自身在宇宙中地位的理解。

Bachman 把天文学中从地心说向日心说的转变，与 70 年代前期在计算机编程中的变化作了个对比。在当时，数据处理正从以计算机为中心向以数据库为中心进行转变。Bachman 指出，在旧的处理模式中，数据被当成是一个连续流过计算机的卡片流（以计算机为中心）；而在新的模式中，数据好比是一个水池，而计算机则偶尔涉足其中（以数据库为中心）。

1『以数据库为中心的理念，给出的比喻实在是太赞了。』

今天，很难想象谁会认为太阳绕着地球转；也同样难以想象谁会把数据当成流过计算机的卡片流。在这两个例子中，旧的理论一旦被抛弃，很难想象有谁会再把它捡起来。具有讽刺意味的是，旧理论的相信者认为新理论荒唐可笑，就像我们今天看旧理论一样。

当日心说出现之后，地心说便成了那些相信它的天文学家的阻得。同样，计算机中心模式也已经成了那些相信它的计算机科学家的阻碍，因为我们现在已经有了数据库中心模式。

如果一旦看了新的模型，我们便说：「哦，当然正确的模型更有用，其余的都是错误的」，那只会降低模型的作用。因为这太偏激了。科学史并不是由一系列从 「错误」 模型到 「正确」 模型开关组成的，而是逐渐由 「坏的」 模型变为 「较好」 的模型，从包含面较窄到包含面较宽，从覆盖领域较少到覆盖领域较多。

1『「科学」的思维方式，理论逐渐被证伪的过程。』

事实上，很多被较好模型替代的旧模型仍然在发挥作用。例如，工程师们仍然在用牛顿力学进行工程计算，虽然它已经被相对论力学所取代。

软件科学是一门比其它学科年轻得多的学科，还很不成熟，远未形成一套标准的模型。所以，现在拥有的是大量相互矛盾的模型。这其中有些很好，有些则很差。因此，对这些模型理解得好坏，便决定了你对软件开发理解的好坏。

软件隐喻更像是一束搜索灯光，而不是一张地图，它并不会告诉你到哪里去寻找答案；它只给你以启发，教你如何寻找答案，而不是像数学算法一样硬性规定出到哪里找出答案。

一个公式是一套完整建立的、进行某一些任务的规则。它的结果是可以预测的、确定的，并不取决于运气。公式会告诉你直接从 A 点走到 B 点，中间不准绕路，不准随意顺便访问 C、D、E 或 F 点，也不准停下来闻一下玫瑰花香或者喝杯咖啡什么的，一切必须按规定来。

启发是一种帮助你寻求答案的技术。它的结果往往和运气有关，因为它只告诉你如何去找，而并未告诉你应该找到些什么。它不会告诉你怎样直接从点 A 到点 B。甚至很可能它根本就不知道点 A 和点 B 在哪里。事实上，可以认为启发是一个穿着小丑儿外套的公式。它往往不可预测，更富有趣味，不会保证一定会发生或不会发生什么。

比如，开车去某人家的公式是这样的：沿 167 号公路向南到 Sumner，从 Bonney 湖出口向山上开 2.4 英里，借助加油站的灯光向左拐，在第一个右转弯处向右转，再拐入通向褐色房子的公路，寻找的门牌号是北大街 714 号。

以下则是一个如何找到我们房屋的启发：找到我们寄给你的最后一封信，开车到回信地址所说的小镇，到了镇上后随便问哪个人我们住哪儿，别担心，镇上的人都认识我们。如果你谁也遇不到的话，就打电话找我们。

公式和启发之间的区别是微妙的，这两个例子或许会说明一些问题。从本书的角度来看它们之间的主要区别是：它们与答案之间的直接程度。公式给予直接指令；而启发则告诉你该怎样找到这些指令，或者至少告诉你到哪里寻找它们。

如果有一套指令告诉你该如何解决程序中的问题，这当然会使编程变得很容易，而且结果也可以预测了。但是编程科学目前还没有那样发达，也许永远也不会。编程中最富于挑战性的问题便是将问题概念化，编程中许多错误往往都是概念性错误，因为每个程序在概念上都是独特的，所以创立一套可以指导每一个问题的规则是非常困难，甚至是不可能的。这样，从总体上知道该如何解决问题，便几乎和知道某一特定问题的答案一样重要了。

你是怎样使用软件隐喻的呢？应该用它来帮助你获得关于编程过程的内在理解，利用它们来帮助你考虑编程活动，想象解决问题的更好办法。你不要一看到某一行代码就说这与这一章所使用的某个隐喻相矛盾。随着时间推移，在编程过程当中使用隐喻的程序员肯定比不使用这方法的人编写代码更快更好。

随着软件的发展，隐喻越来越多，已经到了使人迷惑的地步，Fred Brooks 说写软件就像耕种、猎狼或者在一个沥青矿坑中淹死一只恐龙。Paul Heekel 说这就像电影《白雪公主与七个小矮人》。David Gries 说这是科学，Donald Knuth 则说这是门艺术，Watts Hamphrey 则说这是一个过程，Peter Freeman 说这是个系统，Harlan Mills 认为这就像解数学题、做外科手术、或者是宰一条狗，Mark Spinrad 和 Curt Abraham 说这更像是开发西部、在冰水中洗澡或者围着营火吃豆子。

开发软件最原始的隐喻出自 「写代码」（Writing Code） 一词。这个写的隐喻说明开发一个程序就像随便写封信，你准备好纸、笔和墨水，坐下从头写到尾就算完成了。这不需要任何正式计划，你只是把你要说的都写出来。

许多想法都源于写隐喻。Jon Beitle 说，你应该准备好一杯白兰地，一支上等雪茄，与你喜欢的猎狗一同坐在火边，像一个优秀小说家一样享受一次 「自由编程」。Brian 和 Kernighan 把写隐喻风格的书称为《风格要素》（《The Elements of Style》）之后，把他们编程风格的书称作《编程风格要素》（《The Elements of Programming Style》），程序员们则经常谈论程序的 「可读性」。

在一些小问题中，写代码隐喻可以充分描述它们。但是对于其余的问题，它就力不从心了，它不可能全面彻底地描述软件开发过程。写往往是一种个人活动，而软件开发往往需要许多人分担各种不同的责任。当你写完一封信时，你把它装进信封并把它寄出去后，你就再也不能改变它的内容了，无论从哪个角度说，这项工作都已经完成了。软件的内容是很容易改变的却很难彻底完成。几乎有 50% 的软件开发工作量是在软件最初发行之后才进行的（Lientz 和 Swanson, 1980)。编写软件，主要工作量集中在初始阶段。在软件创建中，把精力集中于初始阶段往往不如在初始工作完成后，再集中精力进行代码的重新调整工作。简而言之，写隐喻往往把软件工作表示成是一项过于简单而刻板的工作。

不幸的是，写隐喻已经通过我们这个星球上最流行的软件书 —— Fred Brooks 的《The Mythical Man Month》而变得永存了。Brooks 说，「扔掉一个计划，又有什么呢？」 这使得我们联想到一大堆被扔进废纸篓的手稿。当你写封家常信问候你叔叔时，准备扔掉一封信是可能的这也可能是 Brooks 1975 年写那本书时，当时软件工程的水平。

但是，到了九十年代，再把写隐喻解释为准备扔掉一封信时，恐怕是不合时宜的。现在，开发一个主要系统的投资已经相当于建一幢十层办公楼或造一艘远洋客轮的费用了。我们应该在第一次调试时就完成它，或者在它们成本最低时试几次运气，其它几个隐喻较好地解决了说明达到这一目的的方法问题。

与刻板的写隐喻相反，一些软件开发者认为你应该把创建软件当作播种或培植庄稼（Growing a System）。你设计一小部分，编码一小部分，测试一小部分，然后在某个时候把它加到系统上，通过小步走你减小了每次可能遇到的错误。有时，一项先进的技术可能是通过拙劣的隐喻来表达的。在这种情况下，应努力保留这项技术并换一个隐喻来表达它。在这里增量技术是先进的，但是种庄稼的比喻则是十分拙劣的。

一次干一点儿的想法可能和植物生长有某种类似之处，但是耕种类比实在太牵强，而且也令人感到陌生，因而也就很快被后面的隐喻所取代了。很难把耕种隐喻推广到每次做一点儿这简单想法之外。如果你来用耕种隐喻，你就会发现自己在谈论给系统计划施肥，减少详细设计，通过有效地田间管理提高编码产量，最后收获编码。你也会谈论进行轮作，用种小麦代替大麦，让土地体息一年以提高土壤中的养分。

软件种植隐喻的弱点是你对于软件开发失去了直接控制。你在春天播种代码，最后在秋天收获一大堆代码。

有时候，人们在谈论种植软件而事实上他们指的是软件积累（System Accretion）。这两个隐喻是密切联系的，但是软件积累更深刻一些。「积累」 这个词，含有通过外加或吸收，绶慢生长的意思，就像河蚌逐渐分泌酸钙形成珍珠一样。在地质学上，水中悬浮物逐渐沉积形成陆地的过程也与此相似。

这并不是说你要从水中悬浮物里沉积出代码来；这只意味着你应该学会每次向你的系统中加一点儿东西。另外一个与积累密切相联的词是增量。增量设计、构造、测试是软件开发的最强有力工具之一。「增量」 一词在设计者心目中还远未达到 「结构化」 或 「面向对象设计」 等的地位，所以迄今为止也没有一本关于这方面的论述，这实在是令人遗憾的，因为这种书中所收集的技术将具有极大的潜力。

在增量开发中，你首先设计系统可以运行的最简单版本。它甚至可以不接受实际数据输入，或者对数据进行处理。它也可以不产生输出，只需要成为一个坚实的骨架结构，以便能承受将要在它之上发展的真实系统。它可以调用任何一个实现预定功能而设立的伪子程序。就像河蚌刚开始产生珍珠的核 —— 一粒沙子。

当你搭好骨架后，逐渐地往上添加肌肉和皮肤。你把每一个伪子程序变成真正的子程序。此时你不必再假设产生结果了，你可以随意访问一个代码来产生结果。也不必使其假设接收输入，你可以用同样的方法让它接收输入。你每次加入一点儿代码直到你最终完成它。

这种方法的发展是令人印象非常深刻的。Fred Brooks，在 1975 年时还认为：「应做好建造一个扔掉一个的准备」，在 1987 年时，却说在过去的岁月里，还没有一样东西像增量概念这样如此深刻地改变了他自己的实践或效率。

增量隐喻的力量在于：作为一个隐喻，它并没有过分作出许诺，它不像耕种隐喻那样容易被错误延伸。河蚌育珍珠的联想对理解增量发展法或积累法有很大帮助。

建造软件（building software）。「建造」 一词的想象比 「写」 或者 「种植」软件的想象更为贴切，它与 「增量」 软件的想法是基本一致的。建造隐喻暗示了许多诸如计划、准备、执行等工作阶段。如果你仔细研究这个隐喻，你还会发现它还暗示着其它许多东西。

建造一个四英尺高的塔需要一双稳健的手、一个平台和十个完好的啤酒罐。而建造一个四百英尺高的塔却决不仅仅是需要一千个啤酒罐就够了，它还需要一种完全不同的计划和创建方法。

如果你想建一个简单的建筑物，比如说一个狗舍，你买来了木板和钉子，到下午的时候，你已经给你的爱犬造好了一幢新房子，假设你忘了修一个门，不过这没关系，你可以补救一下或推倒一节重新开始。你所浪费的不过是一个下午的时间罢了。这与小型软件的发展失败非常类似。如果你有 25 行代码设计错了。那你重新再来一遍好了，你不会因此浪费许多的。

然而如果你是在造一幢房子，那修建的过程就要复杂些了，而拙劣设计的后果也严重得多。首先，你必须決定造一幢什么样的房子，这就像软件开发中的问题定义。然后，你与建筑师必须搞出一个你们都同意的总体方案，这和软件的总体设计是一样的。接着，你又画出细节蓝图并找来一位承包商，这相当于软件中的详细设计。下面的工作是选好房址、打地基、建造起房屋的框架、建好墙壁并加上屋顶、用干斤锤检查墙壁是否垂直，这同软件创建基本差不多。当房屋的绝大部分工作已经完成时，你请来园艺师和装修师，以便使你的房间和空地得到最好的利用，这可以与软件优化相类似。在整个过程中，会有各种监督人员来检查房址、地基、框架、供电系统和其它东西，这也可以与软件开发中的评审和鉴定相类似。

较大的规模和复杂性往往意味着可以产生较大的成果。在修房子的时候，材料可能比较贵，但更大的花费是劳动力。拆掉一面墙并把它移到六英尺之外是很昂贵的，但并不是因为你浪费了许多钉子，而是因为你需要付出劳动。你应该尽可能精心设计，以避免那些本可避免的错误，以降低成本。在开发软件过程中，材料更便宜，然而劳动力成本却更高。改变一个报告的格式，可能与移走一幢房子里的墙壁一样昂贵，因为二者成本的主要部分都是劳动力。

这两个活动之间还有什么类似之处呢？在建房子中，你不会去建造那些你可以现成买来的东西，比如洗衣机、烘干机，电冰箱、吸尘器等，除非你是个机械迷。同时，你也会去购买已经做好的地毯、门、窗和浴室用品，而不是自己动手建。如果你正在建造一个软件，你也会这样做。你会推广使用高级语言的特点，而不是去编写操作系统一级的代码。你也会利用已经存在的显示控制和数据库处理系统，利用已经通过的子程序。如果样样都自己动手是很不明智的。

如果你想修建一幢陈设一流的别墅，情况就不同了，你可能定做全套家具，因为希望洗碗机、冰箱等与你的家具协调一致，同时你还会定做別具风格的门和窗户。这种定制化的方式与流软件开发也是非常类似的。为了这一目的，你可能创建精度更高、速度更快的科学公式。你也会设计自己的显示控制、数据库处理系统和自己的子程序，以使整个软件给人以一气阿成，天衣无缝的感觉。

当然这两种建造方法也要付出代价，工作的每一步都要依据事先制定好的计划进行。如果软件开发工作的顺序有误，那么这个软件将是难以编码、难以测试和难以调试的。这可能会使整个计划延误甚至失败，因为每个人从事的工作都非常复杂，把它们综合到一起后会使人无所适从。

如果你在盖办公楼时工作做得不好，那么在楼内办公的人便可能面临危险。同样，如果你在创建医药、航空电子、空中交通管制、加工控制等软件时工作做得不好，后果也可能是灾难性的。危及别人生命是劣质软件的最可怕后果，但并不是它的唯一危害。如果公司的股东们因为你编写了错误软件而赔钱，那也是令人遗憾的。无论如何，无辜的人们没有义务为你的工作失误而付出代价。

对于软件作修改与建造建筑物也有类似之处。如果你要移走的那面墙壁还要支撑其它东西而不仅仅是隔开两个房间，那么你要付出的成本将会更高。同样，对软件做结构性的修改也将比增加或减少外设特征付出更高昂的代价。

最后，建筑类比对于超大型软件也是同样适用的。一幢超大型建筑物存在错误的后果将是灾难性的，整个工程可能不得不返工。建筑师们在制定和审查计划时是非常仔细的，他们往往留出安全裕度，多用 10% 的材料来加强结构总比一幢大楼坍塌要好得多，同时还必须仔细注意工时计划，在修建帝国大厦时，每辆卡车的每次卸货时间都留出了十五分钟的裕度。因为如果有一辆卡车不能在指定时间到达指定的位置，整个计划就有可能被延误。

同样，对于超大型软件来说，计划工作需要比一般的大型软件在更高的层次上进行。1977 年，Capers Jones 估计说，对于一个拥有 750,000 行代码的系统来说，可能需要多达 600 页的功能定义文件。对于一个人来说，不要说理解这种规模全部的设计，就是读完它也是非常困难的。安全系数对于这种项目是必须的，制定该系统的工时计划尤为重要。当我们在建造与帝国大厦同等经济规模的软件时，我们也需要同等严密的计划。而我们现在才刚刚开始考虑这种规模项目的计划技术。

这两者之间的相似还可以推广到其它方面，这就是为什么建筑物创建隐喻是如此强有力的原因。许多常用的软件词汇来源于建筑学，如：软件体系结构、搭结构架、构造、分割代码、插入子程序等等。

智能工具箱（The Intelectual Toolbox）。在过去的十几年中，优秀的软件开发人员们积累了几十条关于开发软件的技术和技巧，有些像咒语般灵验，这些技术不是规则，它们是分析工具。一个优秀的工匠知道用什么样的工具干哪一样工作，而且知道该如何使用它们。程序员也是如此，关于编程你理解得越深入你的工具箱里的工具也就越多，何时何地该如何运用它们的知识也就越多。

把方法和技巧当作工具是很有益处的，因为这样可以使我们对其有一个正确的态度。不要把最新的 「面向对象设计技术」 当作上帝赐予的法宝，它不过是一件在某些场合下有用而在某些场合下又无用的技术。如果你拥有的唯一工具就是一把锤子，那么你就会把整个世界都当作一个钉子。好在没有人会花 500 美元一天的费用来雇佣一个仅告诉你去买一把可以解决一切问题的锤子的研究小组，也没有人建议你丢掉你的改锥、手钻和电烙铁。

在软件开发中，常常会有人告诉你用一种方法来代替另外一种方法。这实在不幸，如果你仅仅采用一种方法，那你就会把整个世界都当成那个工具的作用对象。你会失去用更适合的方法解决问题的机会。工具箱隐喻有助于我们保留一切方法、技巧、技术等，并在适当的时候使用它们。

复合隐喻（Combing Metaphors）。因为隐喻更像是一种启发，而不是公式，所以，它们并不是互相排斥的。你可以同时使用增量隐崳和建筑隐崳。如果你愿意的话，你也可以采用 「写」 隐喻，或者把写隐喻与耕种隐喻一起使用。只要能激发你的思想，你尽可以采用一切你认为合适的隐喻。

使用隐喻是一项模糊的事情。你不得不把它们外推到可以从中受到启发的外延中。如果你把它过分外推或者推广到了错误方向，它很可能使你误入歧途。就像是再好的工具也有可能被误用一样，你也可能错误使用隐喻。但是，它们的作用将无可置疑地使其成为你的智能工具箱中的一件有力工具。

## 03 软件创建的先决条件

### 1. 逻辑脉络

软件创建之前应该完成的工作：。

### 2. 摘录及评论

1、如果想开发一个高质量的软件，必须自始至终重视质量问题。在开始阶段强调质量往往比在最后强调质量更为有效。

2、程序员的份内工作之一便是向老板和同事宣传软件的开发过程，包括在编程开始前从事先决条件准备工作的重要性。

3、如果问题定义工作做得不好，那么在创建阶段，所解决的问题可能并不是用户真正要解决的问题。

4、如果需求分析工作做得不好，很可能因此而漏掉要解决问题中的重要细节。在创建工作后更改需求，要比在需求分析阶段进行更改的成本高 20 到 100 倍。所以，在开始编程前一定要确认需求定义工作一切正常。

5、在编程前规定好约定，在创建工作结束后再改变代码来满足约定几乎是不可能的。在创建活动开始之前如果无法完成准备工作，可以尝试在不太稳固的基础上进行创建活动。

在开始修造一幢房屋之前，建筑工人会评审蓝图，确认所有用料已经备齐，并检查房子的地基。建筑工人为修建摩天大楼和修建狗舍所做的准备工作是截然不同的。但不管是什么样的项目，准备工作总是和需要相适应的，并且应在工程正式开始前做完。

本章主要论述在软件创建之前所要做的准备工作，对于建筑业来说，项目的成败往往在开工前就已经决定了。如果基础打得不好，或者项目计划进行得不充分，你所能做的最多也就是防止计划失败，根本谈不上做好。如果你想做一件精美的首饰，那么就得用钻石作原料。如果你用的是砖头，那你所能得到的最好结果不过是块漂亮的砖头而已。







