# 2019018Python编程R01

## 记忆时间

2019-12-10

## 前言

如何学习编写第一个程序，每个程序员都有不同的故事。我还是个孩子时就开始学习编程了，当时我父亲在计算时代的先锋之一——数字设备公司（Digital Equipment Corporation）工作。我使用一台简陋的计算机编写了第一个程序，这台计算机是父亲在家里的地下室组装而成的，它没有机箱，裸露的主板与键盘相连，显示器是裸露的阴极射线管。我编写的这个程序是一款简单的猜数字游戏，其输出类似于下面这样。

看到家人玩着我编写的游戏，而且它完全按我预期的方式运行，我心里不知有多满足。此情此景我永远都忘不了。儿童时期的这种体验一直影响我至今。现在，每当我通过编写程序解决了一个问题时，心里都会感到非常满足。相比于孩提时期，我现在编写的软件满足了更大的需求，但通过编写程序获得的满足感几乎与从前一样。

本书旨在让你成为优秀的程序员，具体地说，是优秀的 Python 程序员。通过阅读本书，你将迅速掌握编程概念，打下坚实的基础，并养成良好的习惯。阅读本书后，你就可以开始学习 Python 高级技术，并能够更轻松地掌握其他编程语言。

在本书的第一部分，你将学习编写 Python 程序时需要熟悉的基本编程概念，你刚接触几乎任何编程语言时都需要学习这些概念。你将学习各种数据以及在程序中将数据存储到列表和字典中的方式。你将学习如何创建数据集合以及如何高效地遍历这些集合。你将学习使用 while 和 if 语句来检查条件，并在条件满足时执行代码的一部分，而在条件不满足时执行代码的另一部分——这可为自动完成处理提供极大的帮助。

你将学习获取用户输入，让程序能够与用户交互，并在用户没停止输入时保持运行状态。你将探索如何编写函数来让程序的各个部分可重用，这样你编写执行特定任务的代码后，想使用它多少次都可以。然后，你将学习使用类来扩展这种概念以实现更复杂的行为，从而让非常简单的程序也能处理各种不同的情形。你将学习编写妥善处理常见错误的程序。学习这些基本概念后，你就能编写一些简短的程序来解决一些明确的问题。最后，你将向中级编程迈出第一步，学习如何为代码编写测试，以便在进一步改进程序时不用担心可能引入 bug。第一部分介绍的知识让你能够开发更大、更复杂的项目。

在第二部分，你将利用在第一部分学到的知识来开发三个项目。你可以根据自己的情况，以最合适的顺序完成这些项目；你也可以选择只完成其中的某些项目。在第一个项目（第 12~14 章）中，你将创建一个类似于《太空入侵者》的射击游戏。这个游戏名为《外星人入侵》，它包含多个难度不断增加的等级。完成这个项目后，你就能够自己动手开发 2D 游戏了。

第二个项目（第 15~17 章）介绍数据可视化。数据科学家的目标是通过各种可视化技术来搞懂海量信息。你将使用通过代码生成的数据集、已经从网络下载下来的数据集以及程序自动下载的数据集。完成这个项目后，你将能够编写能对大型数据集进行筛选的程序，并以可视化方式将筛选出来的数据呈现出来。

在第三个项目（第 18~20 章）中，你将创建一个名为「学习笔记」的小型 Web 应用程序。这个项目能够让用户将学到的与特定主题相关的概念记录下来。你将能够分别记录不同的主题，还可以让其他人建立账户并开始记录自己的学习笔记。你还将学习如何部署这个项目，让任何人都能够通过网络访问它，而不管他身处何方。

## 01. 起步

### 1. 逻辑脉络

初步了解 Python，安装 Python3，安装文本编辑器 sublime text。

### 2. 摘录及评论

如果你按前面的步骤做，应该能够成功地搭建编程环境。但如果你始终无法运行程序 hello_world.py，可尝试如下几个解决方案。

1. 程序存在严重的错误时，Python 将显示 traceback。Python 会仔细研究文件，试图找出其中的问题。trackback 可能会提供线索，让你知道是什么问题让程序无法运行。

2. 离开计算机，先休息一会儿，再尝试。别忘了，在编程中，语法非常重要，即便是少一个冒号、引号不匹配或括号不匹配，都可能导致程序无法正确地运行。请再次阅读本章相关的内容，再次审视你所做的工作，看看能否找出错误。

3. 推倒重来。你也许不需要把一切都推倒重来，但将文件hello_world.py删除并重新创建它也许是合理的选择。

4. 让别人在你的计算机或其他计算机上按本章的步骤重做一遍，并仔细观察。你可能遗漏了一小步，而别人刚好没有遗漏。

5. 请懂 Python 的人帮忙。当你有这样的想法时，可能会发现在你认识的人当中就有人使用 Python。

6. 本章的安装说明在网上也可以找到，其网址为 https://www.nostarch.com/pythoncrash-course/。对你来说，在线版也许更合适。

7. 到网上寻求帮助。附录 C 提供了很多在线资源，如论坛或在线聊天网站，你可以前往这些地方，请求解决过你面临的问题的人提供解决方案。

1『第 6 条里的这个网站：[Art & Design | No Starch Press](https://nostarch.com/catalog/art-photography-design)』

## 02. 变量和简单数据类型

### 1. 逻辑脉络

如何使用变量和字符串和数字的数据类型。

### 2. 摘录及评论

在 Python 中使用变量时，需要遵守一些规则和指南。违反这些规则将引发错误，而指南旨在让你编写的代码更容易阅读和理解。请务必牢记下述有关变量的规则。

1. 变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打头，例如，可将变量命名为 message_1，但不能将其命名为 1_message。

2. 变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名 greeting_message 可行，但变量名 greeting message 会引发错误。

3. 不要将 Python 关键字和函数名用作变量名，即不要使用 Python 保留用于特殊用途的单词，如 print （请参见附录 A.4）。

4. 变量名应既简短又具有描述性。例如，name 比 n 好，student_name 比 s_n 好，name_length 比 length_of_persons_name 好。

5. 慎用小写字母 l 和大写字母 O，因为它们可能被人错看成数字 1 和 0。

要创建良好的变量名，需要经过一定的实践，在程序复杂而有趣时尤其如此。随着你编写的程序越来越多，并开始阅读别人编写的代码，将越来越善于创建有意义的变量名。

1『

字符串涉及到的字符串函数有：

1. 首个字母变大写 title() 、修改成大写 upper()、修改成小写 lower()。

2. 剔除函数，删除首个空格 lstrip() 、删除末尾空格 rstrip() 和同时删除首个及末尾空格 strip()。

3. 拼接用 +。

4. 制表符 \t、换行符 \n。

5. 把数据类型转化为字符串 str()。

』

在 Python 中，注释用井号（# ）标识。井号后面的内容都会被 Python 解释器忽略，如下所示：

编写注释的主要目的是阐述代码要做什么，以及是如何做的。在开发项目期间，你对各个部分如何协同工作了如指掌，但过段时间后，有些细节你可能不记得了。当然，你总是可以通过研究代码来确定各个部分的工作原理，但通过编写注释，以清晰的自然语言对解决方案进行概述，可节省很多时间。

要成为专业程序员或与其他程序员合作，就必须编写有意义的注释。当前，大多数软件都是合作编写的，编写者可能是同一家公司的多名员工，也可能是众多致力于同一个开源项目的人员。训练有素的程序员都希望代码中包含注释，因此你最好从现在开始就在程序中添加描述性注释。作为新手，最值得养成的习惯之一是，在代码中编写清晰、简洁的注释。

如果不确定是否要编写注释，就问问自己，找到合理的解决方案前，是否考虑了多个解决方案。如果答案是肯定的，就编写注释对你的解决方案进行说明吧。相比回过头去再添加注释，删除多余的注释要容易得多。

编程语言 Perl 曾在互联网领域长期占据着统治地位，早期的大多数交互式网站使用的都是 Perl 脚本。彼时，「解决问题的办法有多个」被 Perl 社区奉为座右铭。这种理念一度深受大家的喜爱，因为这种语言固有的灵活性使得大多数问题都有很多不同的解决之道。在开发项目期间，这种灵活性是可以接受的，但大家最终认识到，过于强调灵活性会导致大型项目难以维护：要通过研究代码搞清楚当时解决复杂问题的人是怎么想的，既困难又麻烦，还会耗费大量的时间。

经验丰富的程序员倡导尽可能避繁就简。Python 社区的理念都包含在 Tim Peters 撰写的「Python 之禅」中。要获悉这些有关编写优秀 Python 代码的指导原则，只需在解释器中执行命令 import this。这里不打算赘述整个「Python 之禅」，而只与大家分享其中的几条原则，让你明白为何它们对 Python 新手来说至关重要。

Python 程序员笃信代码可以编写得漂亮而优雅。编程是要解决问题的，设计良好、高效而漂亮的解决方案都会让程序员心生敬意。随着你对 Python 的认识越来越深入，并使用它来编写越来越多的代码，有一天也许会有人站在你后面惊呼：「哇，代码编写得真是漂亮！」

Simple is better than complex.

如果有两个解决方案，一个简单，一个复杂，但都行之有效，就选择简单的解决方案吧。这样，你编写的代码将更容易维护，你或他人以后改进这些代码时也会更容易。

Complex is better than complicated.

现实是复杂的，有时候可能没有简单的解决方案。在这种情况下，就选择最简单可行的解决方案吧。

Readability counts.

即便是复杂的代码，也要让它易于理解。开发的项目涉及复杂代码时，一定要为这些代码编写有益的注释。

There should be one -- and preferably only one -- obvious way to do it.

如果让两名 Python 程序员去解决同一个问题，他们提供的解决方案应大致相同。这并不是说编程没有创意空间，而是恰恰相反！然而，大部分编程工作都是使用常见解决方案来解决简单的小问题，但这些小问题都包含在更庞大、更有创意空间的项目中。在你的程序中，各种具体细节对其他 Python 程序员来说都应易于理解。

Now is better than never.

你可以将余生都用来学习 Python 和编程的纷繁难懂之处，但这样你什么项目都完不成。不要企图编写完美无缺的代码；先编写行之有效的代码，再决定是对其做进一步改进，还是转而去编写新代码。

等你进入下一章，开始研究更复杂的主题时，务必牢记这种简约而清晰的理念。如此，经验丰富的程序员定将对你编写的代码心生敬意，进而乐意向你提供反馈，并与你合作开发有趣的项目。

1『

python 交互解释器里输入 import this

	>>> import this

The Zen of Python, by Tim Peters

Beautiful is better than ugly.

Explicit is better than implicit.

Simple is better than complex.

Complex is better than complicated.

Flat is better than nested.

Sparse is better than dense.

Readability counts.

Special cases aren't special enough to break the rules.

Although practicality beats purity.

Errors should never pass silently.

Unless explicitly silenced.

In the face of ambiguity, refuse the temptation to guess.

There should be one-- and preferably only one --obvious way to do it.

Although that way may not be obvious at first unless you're Dutch.

Now is better than never.

Although never is often better than *right* now.

If the implementation is hard to explain, it's a bad idea.

If the implementation is easy to explain, it may be a good idea.

Namespaces are one honking great idea -- let's do more of those!

[免费中文Python电子书（教程） - FooFish-Python之禅](https://foofish.net/python-free-ebook.html)

』

## 03. 列表简介

### 1. 逻辑脉络

列表的概念，以及如何使用其元素，比如访问、修改、删除、增加、排序、确定长度、避免索引错误等等。

### 2. 摘录及评论

在本章中，你学习了：列表是什么以及如何使用其中的元素；如何定义列表以及如何增删元素；如何对列表进行永久性排序，以及如何为展示列表而进行临时排序；如何确定列表的长度，以及在使用列表时如何避免索引错误。

在本章和下一章中，你将学习列表是什么以及如何使用列表元素。列表让你能够在一个地方存储成组的信息，其中可以只包含几个元素，也可以包含数百万个元素。列表是新手可直接使用的最强大的 Python 功能之一，它融合了众多重要的编程概念。

列表由一系列按特定顺序排列的元素组成。你可以创建包含字母表中所有字母、数字 0~9 或所有家庭成员姓名的列表；也可以将任何东西加入列表中，其中的元素之间可以没有任何关系。鉴于列表通常包含多个元素，给列表指定一个表示复数的名称（如 letters 、digits 或 names ）是个不错的主意。

在 Python 中，第一个列表元素的索引为 0，而不是 1。在大多数编程语言中都是如此，这与列表操作的底层实现相关。根据这种简单的计数方式，要访问列表的任何元素，都可将其位置减 1，并将结果作为索引。例如，要访问第四个列表元素，可使用索引 3。Python 为访问最后一个列表元素提供了一种特殊语法。通过将索引指定为 -1，可让 Python 返回最后一个列表元素。这种语法很有用，因为你经常需要在不知道列表长度的情况下访问最后的元素。这种约定也适用于其他负数索引，例如，索引 -2 返回倒数第二个列表元素，索引 -3 返回倒数第三个列表元素，以此类推。

你创建的大多数列表都将是动态的，这意味着列表创建后，将随着程序的运行增删元素。例如，你创建一个游戏，要求玩家射杀从天而降的外星人；为此，可在开始时将一些外星人存储在列表中，然后每当有外星人被射杀时，都将其从列表中删除，而每次有新的外星人出现在屏幕上时，都将其添加到列表中。在整个游戏运行期间，外星人列表的长度将不断变化。

方法 append() 让动态地创建列表易如反掌，例如，你可以先创建一个空列表，再使用一系列的 append() 语句添加元素。下面来创建一个空列表，再在其中添加元素 'honda' 、'yamaha' 和 'suzuki' ：

这种创建列表的方式极其常见，因为经常要等程序运行后，你才知道用户要在程序中存储哪些数据。为控制用户，可首先创建一个空列表，用于存储用户将要输入的值，然后将用户提供的每个新值附加到列表中。

使用方法 insert() 可在列表的任何位置添加新元素。为此，你需要指定新元素的索引和值。

有时候，你要将元素从列表中删除，并接着使用它的值。例如，你可能需要获取刚被射杀的外星人的 x 和 y 坐标，以便在相应的位置显示爆炸效果；在 Web 应用程序中，你可能要将用户从活跃成员列表中删除，并将其加入到非活跃成员列表中。方法 pop() 可删除列表末尾的元素，并让你能够接着使用它。术语弹出 （pop）源自这样的类比：列表就像一个栈，而删除列表末尾的元素相当于弹出栈顶元素。

方法 pop() 是怎么起作用的呢？假设列表中的摩托车是按购买时间存储的，就可使用方法 pop() 打印一条消息，指出最后购买的是哪款摩托车。

如果你不确定该使用 del 语句还是 pop() 方法，下面是一个简单的判断标准：如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用 del 语句；如果你要在删除元素后还能继续使用它，就使用方法 pop()。

方法 remove() 只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来判断是否删除了所有这样的值。你将在第 7 章学习如何这样做。

在你创建的列表中，元素的排列顺序常常是无法预测的，因为你并非总能控制用户提供数据的顺序。这虽然在大多数情况下都是不可避免的，但你经常需要以特定的顺序呈现信息。有时候，你希望保留列表元素最初的排列顺序，而有时候又需要调整排列顺序。Python 提供了很多组织列表的方式，可根据具体情况选用。

在并非所有的值都是小写时，按字母顺序排列列表要复杂些。决定排列顺序时，有多种解读大写字母的方式，要指定准确的排列顺序，可能比我们这里所做的要复杂。然而，大多数排序方式都基于本节介绍的知识。

要反转列表元素的排列顺序，可使用方法 reverse()。假设汽车列表是按购买时间排列的，可轻松地按相反的顺序排列其中的汽车。方法 reverse() 永久性地修改列表元素的排列顺序，但可随时恢复到原来的排列顺序，为此只需对列表再次调用 reverse() 即可。

使用函数 len() 可快速获悉列表的长度。在你需要完成如下任务时，len() 很有用：确定还有多少个外星人未被射杀，需要管理多少项可视化数据，网站有多少注册用户等。

刚开始使用列表时，经常会遇到一种错误。假设你有一个包含三个元素的列表，却要求获取第四个元素，这将导致索引错误。发生索引错误却找不到解决办法时，请尝试将列表或其长度打印出来。列表可能与你以为的截然不同，在程序对其进行了动态处理时尤其如此。通过查看列表或其包含的元素数，可帮助你找出这种逻辑错误。

1『

列表涉及到的方法有：

1. 列组末尾增加元素的 append()。

2. 列组特定索引位置处增加元素 insert()。

3. 列组特定索引位置处弹出元素 pop()，也可以用语句 del。如果不知道该元素的索引号，但知道它的「值」，可以用方法 remove()。

4. 对列组里的元素进行永久性按字母顺序排序 sort()，临时性排序的话用 sorted()。

5. 将列表里的元素反转 reverse()。

6. 使用函数 len() 可快速获悉列表的长度，len(cars)。

』

## 04. 操作列表

### 1. 逻辑脉络

如何遍历列表里的元素（for 循环），学会避免缩进错误，如何创建以及使用数字列表，如何对列表切片，如何复制一个列表，如何创建一个元组，如何设置 Python 的代码格式。

### 2. 摘录及评论

在本章中，你学习了：如何高效地处理列表中的元素；如何使用 for 循环遍历列表，Python 如何根据缩进来确定程序的结构以及如何避免一些常见的缩进错误；如何创建简单的数字列表，以及可对数字列表执行的一些操作；如何通过切片来使用列表的一部分和复制列表。你还学习了元组（它对不应变化的值提供了一定程度的保护），以及在代码变得越来越复杂时如何设置格式，使其易于阅读。

在本章中，你将学习如何遍历整个列表，这只需要几行代码，无论列表有多长。循环让你能够对列表的每个元素都采取一个或一系列相同的措施，从而高效地处理任何长度的列表，包括包含数千乃至数百万个元素的列表。

你经常需要遍历列表的所有元素，对每个元素执行相同的操作。例如，在游戏中，可能需要将每个界面元素平移相同的距离；对于包含数字的列表，可能需要对每个元素执行相同的统计运算；在网站中，可能需要显示文章列表中的每个标题。需要对列表中的每个元素都执行相同的操作时，可使用 Python 中的 for 循环。

假设我们有一个魔术师名单，需要将其中每个魔术师的名字都打印出来。为此，我们可以分别获取名单中的每个名字，但这种做法会导致多个问题。例如，如果名单很长，将包含大量重复的代码。另外，每当名单的长度发生变化时，都必须修改代码。通过使用 for 循环，可让 Python 去处理这些问题。

1『for 后面有个冒号 :，并且下面的 print() 语句一定要缩进。』

Python 再次打印变量 magician 的值——当前为 'david'。接下来，Python 再次执行整个循环，对列表中的最后一个值——'carolina' 进行处理。至此，列表中没有其他的值了，因此 Python 接着执行程序的下一行代码。在这个示例中，for 循环后面没有其他的代码，因此程序就此结束。

刚开始使用循环时请牢记，对列表中的每个元素，都将执行循环指定的步骤，而不管列表包含多少个元素。如果列表包含一百万个元素，Python 就重复执行指定的步骤一百万次，且通常速度非常快。

另外，编写 for 循环时，对于用于存储列表中每个值的临时变量，可指定任何名称。然而，选择描述单个列表元素的有意义的名称大有帮助。例如，对于小猫列表、小狗列表和一般性列表，像下面这样编写 for  循环的第一行代码是不错的选择。

在 for 循环中，想包含多少行代码都可以。在代码行 for magician in magicians 后面，每个缩进的代码行都是循环的一部分，且将针对列表中的每个值都执行一次。因此，可对列表中的每个值执行任意次数的操作。

在 for 循环后面，没有缩进的代码都只执行一次，而不会重复执行。

使用 for 循环处理数据是一种对数据集执行整体操作的不错的方式。例如，你可能使用 for 循环来初始化游戏——遍历角色列表，将每个角色都显示到屏幕上；再在循环后面添加一个不缩进的代码块，在屏幕上绘制所有角色后显示一个 Play Now 按钮。

Python 根据缩进来判断代码行与前一个代码行的关系。在前面的示例中，向各位魔术师显示消息的代码行是 for 循环的一部分，因为它们缩进了。Python 通过使用缩进让代码更易读；简单地说，它要求你使用缩进让代码整洁而结构清晰。在较长的 Python 程序中，你将看到缩进程度各不相同的代码块，这让你对程序的组织结构有大致的认识。

当你开始编写必须正确缩进的代码时，需要注意一些常见的缩进错误。例如，有时候，程序员会将不需要缩进的代码块缩进，而对于必须缩进的代码块却忘了缩进。通过查看这样的错误示例，有助于你以后避开它们，以及在它们出现在程序中时进行修复。

有时候，循环能够运行而不会报告错误，但结果可能会出乎意料。试图在循环中执行多项任务，却忘记缩进其中的一些代码行时，就会出现这种情况。

例如，如果忘记缩进循环中的第 2 行代码（它告诉每位魔术师，我们期待他的下一次表演），就会出现这种情况。第二条 print 语句（见❶）原本需要缩进，但 Python 发现 for 语句后面有一行代码是缩进的，因此它没有报告错误。最终的结果是，对于列表中的每位魔术师，都执行了第一条 print 语句，因为它缩进了；而第二条 print 语句没有缩进，因此它只在循环结束后执行一次。由于变量 magician 的终值为 'carolina'，因此只有她收到了消息 “looking forward to the next trick”。

为避免意外缩进错误，请只缩进需要缩进的代码。在前面编写的程序中，只有要在 for 循环中对每个元素执行的代码需要缩进。

这也是一个逻辑错误，与 4.2.2 节的错误类似。Python 不知道你的本意，只要代码符合语法，它就会运行。如果原本只应执行一次的操作执行了多次，请确定你是否不应该缩进执行该操作的代码。

1『所以说很多 bug 都是逻辑错误。』

for 语句末尾的冒号告诉 Python，下一行是循环的第一行。

需要存储一组数字的原因有很多，例如，在游戏中，需要跟踪每个角色的位置，还可能需要跟踪玩家的几个最高得分。在数据可视化中，处理的几乎都是由数字（如温度、距离、人口数量、经度和纬度等）组成的集合。

列表非常适合用于存储数字集合，而 Python 提供了很多工具，可帮助你高效地处理数字列表。明白如何有效地使用这些工具后，即便列表包含数百万个元素，你编写的代码也能运行得很好。

1『基本思路是用列表、字典等方式储存数据，然后调用各种强大的第三方库来操作这些数据做分析。』

要创建数字列表，可使用函数 list() 将 range() 的结果直接转换为列表。如果将 range() 作为 list() 的参数，输出将为一个数字列表。

使用函数 range() 时，还可指定步长。例如，下面的代码打印 1~10 内的偶数：range(1,11,2)。

使用函数 range() 几乎能够创建任何需要的数字集，例如，如何创建一个列表，其中包含前 10 个整数（即 1~10）的平方呢？在 Python 中，两个星号（** ）表示乘方运算。下面的代码演示了如何将前 10 个整数的平方加入到一个列表中。

1『创建数字型列表就用 range() 和 list() 的结合体。』

创建更复杂的列表时，可使用上述两种方法中的任何一种。有时候，使用临时变量会让代码更易读；而在其他情况下，这样做只会让代码无谓地变长。你首先应该考虑的是，编写清晰易懂且能完成所需功能的代码；等到审核代码时，再考虑采用更高效的方法。

1『个人认为，用不用临时变量得试具体情况而定。』

前面介绍的生成列表 squares 的方式包含三四行代码，而列表解析让你只需编写一行代码就能生成这样的列表。列表解析将 for 循环和创建新元素的代码合并成一行，并自动附加新元素。面向初学者的书籍并非都会介绍列表解析，这里之所以介绍列表解析，是因为等你开始阅读他人编写的代码时，很可能会遇到它们。

要使用这种语法，首先指定一个描述性的列表名，如 squares ；然后，指定一个左方括号，并定义一个表达式，用于生成你要存储到列表中的值。在这个示例中，表达式为 value^2，它计算平方值。接下来，编写一个 for 循环，用于给表达式提供值，再加上右方括号。在这个示例中，for 循环为 for value in range(1,11)，它将值 1~10 提供给表达式 value**2。请注意，这里的 for 语句末尾没有冒号。

2『好好去了解一下列表解析的概念。』

1『

数字列表涉及到的函数：

1. range() 函数可以生成一系列数字，将 range() 函数与 list() 函数结合起来即可创建数字列表。

2. 对数字列表简单计算的函数，比如取最大值 max()，取最小值 min()，取和 sum()。

』

在第 3 章中，你学习了如何访问单个列表元素。在本章中，你一直在学习如何处理列表的所有元素。你还可以处理列表的部分元素——Python 称之为切片。

要创建切片，可指定要使用的第一个元素和最后一个元素的索引。与函数 range() 一样，Python 在到达你指定的第二个索引前面的元素后停止。要输出列表中的前三个元素，需要指定索引 0~3，这将输出分别为 0 、1 和 2 的元素。

在很多情况下，切片都很有用。例如，编写游戏时，你可以在玩家退出游戏时将其最终得分加入到一个列表中。然后，为获取该玩家的三个最高得分，你可以将该列表按降序排列，再创建一个只包含前三个得分的切片。处理数据时，可使用切片来进行批量处理；编写 Web 应用程序时，可使用切片来分页显示信息，并在每页显示数量合适的信息。

要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引（[:] ）。这让 Python 创建一个始于第一个元素，终止于最后一个元素的切片，即复制整个列表。

这里将 my_foods 赋给 friend_foods，而不是将 my_foods 的副本存储到 friend_foods （见❶）。这种语法实际上是让 Python 将新变量 friend_foods 关联到包含在 my_foods 中的列表，因此这两个变量都指向同一个列表。鉴于此，当我们将 'cannoli' 添加到 my_foods 中时，它也将出现在 friend_foods 中；同样，虽然 'ice cream' 好像只被加入到了 friend_foods 中，但它也将出现在这两个列表中。

1『复制列表副本的话：friend_foods = my_foods[:] 』

列表非常适合用于存储在程序运行期间可能变化的数据集。列表是可以修改的，这对处理网站的用户列表或游戏中的角色列表至关重要。然而，有时候你需要创建一系列不可修改的元素，元组可以满足这种需求。

Python 将不能修改的值称为不可变的，而不可变的列表被称为元组。元组看起来犹如列表，但使用圆括号而不是方括号来标识。定义元组后，就可以使用索引来访问其元素，就像访问列表元素一样。相比于列表，元组是更简单的数据结构。如果需要存储的一组值在程序的整个生命周期内都不变，可使用元组。

随着你编写的程序越来越长，有必要了解一些代码格式设置约定。请花时间让你的代码尽可能易于阅读；让代码易于阅读有助于你掌握程序是做什么的，也可以帮助他人理解你编写的代码。为确保所有人编写的代码的结构都大致一致，Python 程序员都遵循一些格式设置约定。学会编写整洁的 Python 后，就能明白他人编写的 Python 代码的整体结构——只要他们和你遵循相同的指南。要成为专业程序员，应从现在开始就遵循这些指南，以养成良好的习惯。

若要提出 Python 语言修改建议，需要编写 Python 改进提案 （Python Enhancement Proposal，PEP）。PEP 8 是最古老的 PEP 之一，它向 Python 程序员提供了代码格式设置指南。PEP 8 的篇幅很长，但大都与复杂的编码结构相关。Python 格式设置指南的编写者深知，代码被阅读的次数比编写的次数多。代码编写出来后，调试时你需要阅读它；给程序添加新功能时，需要花很长的时间阅读代码；与其他程序员分享代码时，这些程序员也将阅读它们。如果一定要在让代码易于编写和易于阅读之间做出选择，Python 程序员几乎总是会选择后者。

PEP 8 建议每级缩进都使用四个空格，这既可提高可读性，又留下了足够的多级缩进空间。

很多 Python 程序员都建议每行不超过 80 字符。最初制定这样的指南时，在大多数计算机中，终端窗口每行只能容纳 79 字符；当前，计算机屏幕每行可容纳的字符数多得多，为何还要使用 79 字符的标准行长呢？这里有别的原因。专业程序员通常会在同一个屏幕上打开多个文件，使用标准行长可以让他们在屏幕上并排打开两三个文件时能同时看到各个文件的完整行。PEP 8 还建议注释的行长都不超过 72 字符，因为有些工具为大型项目自动生成文档时，会在每行注释开头添加格式化字符。

PEP 8 中有关行长的指南并非不可逾越的红线，有些小组将最大行长设置为 99 字符。在学习期间，你不用过多地考虑代码的行长，但别忘了，协作编写程序时，大家几乎都遵守 PEP 8 指南。在大多数编辑器中，都可设置一个视觉标志——通常是一条竖线，让你知道不能越过的界线在什么地方。

要将程序的不同部分分开，可使用空行。你应该使用空行来组织程序文件，但也不能滥用；只要按本书的示例展示的那样做，就能掌握其中的平衡。例如，如果你有 5 行创建列表的代码，还有 3 行处理该列表的代码，那么用一个空行将这两部分隔开是合适的。然而，你不应使用三四个空行将它们隔开。空行不会影响代码的运行，但会影响代码的可读性。Python 解释器根据水平缩进情况来解读代码，但不关心垂直间距。

1『[PEP 8 -- Style Guide for Python Code | Python.org](https://www.python.org/dev/peps/pep-0008/)』

## 05. if 语句

### 1. 逻辑脉络

如何使用 if 语句，比如简单的 if 语句、if-else 语句和 if-elif-else 结构，再比如包括加了关键词 add 和 or 的；学会使用 for 循环遍历列表的同时结合 if 语句。

### 2. 摘录及评论

在本章中，你学习了如何编写结果要么为 Ture 要么为 False 的条件测试。你学习了如何编写简单的 if 语句、if-else 语句和 if-elif-else 结构。在程序中，你使用了这些结构来测试特定的条件，以确定这些条件是否满足。你学习了如何在利用高效的 for 循环的同时，以不同于其他元素的方式对特定的列表元素进行处理。你还再次学习了 Python 就代码格式方面提出的建议，这可确保即便你编写的程序越来越复杂，其代码依然易于阅读和理解。

编程时经常需要检查一系列条件，并据此决定采取什么措施。在 Python 中，if 语句让你能够检查程序的当前状态，并据此采取相应的措施。

在本章中，你将学习条件测试，以检查感兴趣的任何条件。你将学习简单的 if 语句，以及创建一系列复杂的 if 语句来确定当前到底处于什么情形。接下来，你将把学到的知识应用于列表，以编写 for 循环，以一种方式处理列表中的大多数元素，并以另一种不同的方式处理包含特定值的元素。

1『注意：if 语句和 else 语句后面都有个冒号 : 』

每条 if 语句的核心都是一个值为 True 或 False 的表达式，这种表达式被称为条件测试。Python 根据条件测试的值为 True 还是 False 来决定是否执行 if 语句中的代码。如果条件测试的值为 True，Python 就执行紧跟在 if 语句后面的代码；如果为 False，Python 就忽略这些代码。

在 Python 中检查是否相等时区分大小写。如果大小写很重要，这种行为有其优点。但如果大小写无关紧要，而只想检查变量的值，可将变量的值转换为小写，再进行比较，用 lower() 函数。函数 lower() 不会修改存储在变量 car 中的值，因此进行这样的比较时不会影响原来的变量。

网站采用类似的方式让用户输入的数据符合特定的格式。例如，网站可能使用类似的测试来确保用户名是独一无二的，而并非只是与另一个用户名的大小写不同。用户提交新的用户名时，将把它转换为小写，并与所有既有用户名的小写版本进行比较。执行这种检查时，如果已经有用户名 'john' （不管大小写如何），则用户提交用户名 'John' 时将遭到拒绝。

要判断两个值是否不等，可结合使用惊叹号和等号（!= ），其中的惊叹号表示不，在很多编程语言中都如此。

你编写的大多数条件表达式都检查两个值是否相等，但有时候检查两个值是否不等的效率更高。

在 if 语句中可使用各种数学比较，这让你能够直接检查关心的条件。

你可能想同时检查多个条件，例如，有时候你需要在两个条件都为 True 时才执行相应的操作，而有时候你只要求一个条件为 True 时就执行相应的操作。在这些情况下，关键字 and 和 or 可助你一臂之力。

要检查是否两个条件都为 True，可使用关键字 and 将两个条件测试合而为一；如果每个测试都通过了，整个表达式就为 True ；如果至少有一个测试没有通过，整个表达式就为 False。为改善可读性，可将每个测试都分别放在一对括号内，但并非必须这样做。

关键字 or 也能够让你检查多个条件，但只要至少有一个条件满足，就能通过整个测试。仅当两个测试都没有通过时，使用 or 的表达式才为 False。

有时候，执行操作前必须检查列表是否包含特定的值。例如，结束用户的注册过程前，可能需要检查他提供的用户名是否已包含在用户名列表中。在地图程序中，可能需要检查用户提交的位置是否包含在已知位置列表中。

要判断特定的值是否已包含在列表中，可使用关键字 in。来看你可能为比萨店编写的一些代码；这些代码首先创建一个列表，其中包含用户点的比萨配料，然后检查特定的配料是否包含在该列表中。

还有些时候，确定特定的值未包含在列表中很重要；在这种情况下，可使用关键字 not in。例如，如果有一个列表，其中包含被禁止在论坛上发表评论的用户，就可在允许用户提交评论前检查他是否被禁言。

随着你对编程的了解越来越深入，将遇到术语布尔表达式，它不过是条件测试的别名。与条件表达式一样，布尔表达式的结果要么为 True，要么为 False。布尔值通常用于记录条件，如游戏是否正在运行，或用户是否可以编辑网站的特定内容。

在跟踪程序状态或程序中重要的条件方面，布尔值提供了一种高效的方式。

if 语句有很多种，选择使用哪种取决于要测试的条件数。前面讨论条件测试时，列举了多个 if 语句示例，下面更深入地讨论这个主题。

简单的 if 语句。在第 1 行中，可包含任何条件测试，而在紧跟在测试后面的缩进代码块中，可执行任何操作。如果条件测试的结果为 True，Python 就会执行紧跟在 if 语句后面的代码；否则 Python 将忽略这些代码。在 if 语句中，缩进的作用与 for 循环中相同。如果测试通过了，将执行 if 语句后面所有缩进的代码行，否则将忽略它们。

经常需要在条件测试通过了时执行一个操作，并在没有通过时执行另一个操作；在这种情况下，可使用 Python 提供的 if-else 语句。if-else 语句块类似于简单的 if 语句，但其中的 else 语句让你能够指定条件测试未通过时要执行的操作。if-else 结构非常适合用于要让 Python 执行两种操作之一的情形。在这种简单的 if-else 结构中，总是会执行两个操作中的一个。

经常需要检查超过两个的情形，为此可使用 Python 提供的 if-elif-else 结构。Python 只执行 if-elif-else 结构中的一个代码块，它依次检查每个条件测试，直到遇到通过了的条件测试。测试通过后，Python 将执行紧跟在它后面的代码，并跳过余下的测试。在现实世界中，很多情况下需要考虑的情形都超过两个。可根据需要使用任意数量的 elif 代码块。

❶处的 elif 代码块在顾客的年龄超过 65（含）时，将价格设置为 5 美元，这比使用 else 代码块更清晰些。经过这样的修改后，每个代码块都仅在通过了相应的测试时才会执行。

else 是一条包罗万象的语句，只要不满足任何 if 或 elif 中的条件测试，其中的代码就会执行，这可能会引入无效甚至恶意的数据。如果知道最终要测试的条件，应考虑使用一个 elif 代码块来代替 else 代码块。这样，你就可以肯定，仅当满足相应的条件时，你的代码才会执行。

if-elif-else 结构功能强大，但仅适合用于只有一个条件满足的情况：遇到通过了的测试后，Python 就跳过余下的测试。这种行为很好，效率很高，让你能够测试一个特定的条件。

然而，有时候必须检查你关心的所有条件。在这种情况下，应使用一系列不包含 elif 和 else 代码块的简单 if 语句。在可能有多个条件为 True，且你需要在每个条件为 True 时都采取相应措施时，适合使用这种方法。

我们首先创建了一个列表，其中包含顾客点的配料（见❶）。❷ 处的 if 语句检查顾客是否点了配料蘑菇（'mushrooms' ），如果点了，就打印一条确认消息。❸ 处检查配料辣香肠（'pepperoni' ）的代码也是一个简单的 if 语句，而不是 elif 或 else 语句；因此不管前一个测试是否通过，都将进行这个测试。❹ 处的代码检查顾客是否要求多加芝士（'extra cheese' ）；不管前两个测试的结果如何，都会执行这些代码。每当这个程序运行时，都会进行这三个独立的测试。

总之，如果你只想执行一个代码块，就使用 if-elif-else 结构；如果要运行多个代码块，就使用一系列独立的 if 语句。

通过结合使用 if 语句和列表，可完成一些有趣的任务：对列表中特定的值做特殊处理；高效地管理不断变化的情形，如餐馆是否还有特定的食材；证明代码在各种情形下都将按预期那样运行。

到目前为止，对于处理的每个列表都做了一个简单的假设，即假设它们都至少包含一个元素。我们马上就要让用户来提供存储在列表中的信息，因此不能再假设循环运行时列表不是空的。有鉴于此，在运行 for 循环前确定列表是否为空很重要。

在这里，我们首先创建了一个空列表，其中不包含任何配料（见❶）。在 ❷ 处我们进行了简单检查，而不是直接执行 for 循环。在 if 语句中将列表名用在条件表达式中时，Python 将在列表至少包含一个元素时返回 True，并在列表为空时返回 False。如果 requested_toppings 不为空，就运行与前一个示例相同的 for 循环；否则，就打印一条消息，询问顾客是否确实要点不加任何配料的普通比萨（见❸）。

在 ❶ 处，我们定义了一个列表，其中包含比萨店供应的配料。请注意，如果比萨店供应的配料是固定的，也可使用一个元组来存储它们。在 ❷ 处，我们又创建了一个列表，其中包含顾客点的配料，请注意那个不同寻常的配料——'french fries'。在 ❸ 处，我们遍历顾客点的配料列表。在这个循环中，对于顾客点的每种配料，我们都检查它是否包含在供应的配料列表中（见❹）；如果答案是肯定的，就将其加入到比萨中，否则将运行 else 代码块（见❺）：打印一条消息，告诉顾客不供应这种配料。

本章的每个示例都展示了良好的格式设置习惯。在条件测试的格式设置方面，PEP 8 提供的唯一建议是，在诸如 == 、>= 和<= 等比较运算符两边各添加一个空格，例如，if age < 4: 要比 if age<4: 好。这样的空格不会影响 Python 对代码的解读，而只是让代码阅读起来更容易。

1『个人感觉，只要有冒号 :，可以形成代码块的都是要缩进的。那么，逆向想，只要有缩进的，是不是漏掉了冒号呢？』

## 06. 字典

### 1. 逻辑脉络

字典的概念；如何使用字典（创建、修改、访问元素、遍历、删除等）；字典的嵌套，比如列表里存放字典、字典里存放列表、字典里存放字典。

### 2. 摘录及评论

在本章中，你学习了：如何定义字典，以及如何使用存储在字典中的信息；如何访问和修改字典中的元素，以及如何遍历字典中的所有信息；如何遍历字典中所有的「键-值」对、所有的键和所有的值；如何在列表中嵌套字典、在字典中嵌套列表以及在字典中嵌套字典。

你将学习能够将相关信息关联起来的 Python 字典。你将学习如何访问和修改字典中的信息。鉴于字典可存储的信息量几乎不受限制，因此我们会演示如何遍历字典中的数据。另外，你还将学习存储字典的列表、存储列表的字典和存储字典的字典。

理解字典后，你就能够更准确地为各种真实物体建模。你可以创建一个表示人的字典，然后想在其中存储多少信息就存储多少信息：姓名、年龄、地址、职业以及要描述的任何方面。你还能够存储任意两种相关的信息，如一系列单词及其含义，一系列人名及其喜欢的数字，以及一系列山脉及其海拔等。

在 Python 中，字典是一系列「键-值」对。每个键都与一个值相关联，你可以使用键来访问与之相关联的值。与键相关联的值可以是数字、字符串、列表乃至字典。事实上，可将任何 Python 对象用作字典中的值。在 Python 中，字典用放在花括号 {}  中的一系列「键-值」对表示。

「键-值」对是两个相关联的值。指定键时，Python 将返回与之相关联的值。键和值之间用冒号分隔，而「键-值」对之间用逗号分隔。在字典中，你想存储多少个「键-值」对都可以。

字典是一种动态结构，可随时在其中添加「键-值」对。要添加「键-值」对，可依次指定字典名、用方括号括起的键和相关联的值。

下面在字典 alien_0 中添加两项信息：外星人的 x 坐标和 y 坐标，让我们能够在屏幕的特定位置显示该外星人。我们将这个外星人放在屏幕左边缘，且离屏幕上边缘 25 像素的地方。由于屏幕坐标系的原点通常为左上角，因此要将该外星人放在屏幕左边缘，可将 x 坐标设置为 0；要将该外星人放在离屏幕顶部 25 像素的地方，可将 y 坐标设置为 25。

这个字典的最终版本包含四个「键-值」对，其中原来的两个指定外星人的颜色和点数，而新增的两个指定位置。注意，「键-值」对的排列顺序与添加顺序不同。Python 不关心「键-值」对的添加顺序，而只关心键和值之间的关联关系。

使用字典来存储用户提供的数据或在编写能自动生成大量「键-值」对的代码时，通常都需要先定义一个空字典。

要修改字典中的值，可依次指定字典名、用方括号括起的键以及与该键相关联的新值。

对于字典中不再需要的信息，可使用 del 语句将相应的「键-值」对彻底删除。使用 del 语句时，必须指定字典名和要删除的键。

在前面的示例中，字典存储的是一个对象（游戏中的一个外星人）的多种信息，但你也可以使用字典来存储众多对象的同一种信息。例如，假设你要调查很多人，询问他们最喜欢的编程语言，可使用一个字典来存储这种简单调查的结果。

正如你看到的，我们将一个较大的字典放在了多行中。其中每个键都是一个被调查者的名字，而每个值都是被调查者喜欢的语言。确定需要使用多行来定义字典时，在输入左花括号后按回车键，再在下一行缩进四个空格，指定第一个「键-值」对，并在它后面加上一个逗号。此后你再次按回车键时，文本编辑器将自动缩进后续「键-值」对，且缩进量与第一个「键-值」对相同。

定义好字典后，在最后一个「键-值」对的下一行添加一个右花括号，并缩进四个空格，使其与字典中的键对齐。另外一种不错的做法是在最后一个「键-值」对后面也加上逗号，为以后在下一行添加「键-值」对做好准备。

注意：对于较长的列表和字典，大多数编辑器都有以类似方式设置其格式的功能。对于较长的字典，还有其他一些可行的格式设置方式，因此在你的编辑器或其他源代码中，你可能会看到稍微不同的格式设置方式。

这个示例还演示了如何将较长的 print 语句分成多行。单词 print 比大多数字典名都短，因此让输出的第一部分紧跟在左括号后面是合理的（见❶）。请选择在合适的地方拆分要打印的内容，并在第一行末尾（见❷）加上一个拼接运算符（+ ）。按回车键进入 print 语句的后续各行，并使用 Tab 键将它们对齐并缩进一级。指定要打印的所有内容后，在 print 语句的最后一行末尾加上右括号（见❸）。

一个 Python 字典可能只包含几个「键-值」对，也可能包含数百万个「键-值」对。鉴于字典可能包含大量的数据，Python 支持对字典遍历。字典可用于以各种方式存储信息，因此有多种遍历字典的方式：可遍历字典的所有「键-值」对、键或值。

for 语句的第二部分包含字典名和方法 items() （见❶），它返回一个「键-值」对列表。接下来，for 循环依次将每个「键-值」对存储到指定的两个变量中。在前面的示例中，我们使用这两个变量来打印每个键（见❷）及其相关联的值（见❸）。

注意，即便遍历字典时，「键-值」对的返回顺序也与存储顺序不同。Python 不关心「键-值」对的存储顺序，而只跟踪键和值之间的关联关系。

在 6.2.6 节的示例 favorite_languages.py 中，字典存储的是不同人的同一种信息；对于类似这样的字典，遍历所有的「键-值」对很合适。如果遍历字典 favorite_languages，将得到其中每个人的姓名和喜欢的编程语言。

遍历字典时，会默认遍历所有的键，因此，如果将上述代码中的 for name in favorite_languages.keys(): 替换为 for name in favorite_languages:，输出将不变。

方法 keys() 并非只能用于遍历；实际上，它返回一个列表，其中包含字典中的所有键，因此 ❶ 处的代码行只是核实 'erin' 是否包含在这个列表中。由于她并不包含在这个列表中，因此打印一条消息，邀请她参加调查。

字典总是明确地记录键和值之间的关联关系，但获取字典的元素时，获取顺序是不可预测的。这不是问题，因为通常你想要的只是获取与键相关联的正确的值。

要以特定的顺序返回元素，一种办法是在 for 循环中对返回的键进行排序。为此，可使用函数 sorted() 来获得按特定顺序排列的键列表的副本：

如果你感兴趣的主要是字典包含的值，可使用方法 values()，它返回一个值列表，而不包含任何键。例如，如果我们想获得一个这样的列表，即其中只包含被调查者选择的各种语言，而不包含被调查者的名字。

这种做法提取字典中所有的值，而没有考虑是否重复。涉及的值很少时，这也许不是问题，但如果被调查者很多，最终的列表可能包含大量的重复项。为剔除重复项，可使用集合（set）。集合类似于列表，但每个元素都必须是独一无二的。通过对包含重复元素的列表调用 set()，可让 Python 找出列表中独一无二的元素，并使用这些元素来创建一个集合。在 ❶ 处，我们使用了 set() 来提取 favorite_languages.values() 中不同的语言。

	for language in set(favorite_languages.values()):

1『字典里每个「键-值」对之间记得要用逗号 , 隔开。』

1『遍历字典里的「键-值」对用函数 items()；遍历字典里的键用函数 keys()；遍历字典里的值用函数 values()。』

有时候，需要将一系列字典存储在列表中，或将列表作为值存储在字典中，这称为嵌套。你可以在列表中嵌套字典、在字典中嵌套列表甚至在字典中嵌套字典。正如下面的示例将演示的，嵌套是一项强大的功能。

字典 alien_0 包含一个外星人的各种信息，但无法存储第二个外星人的信息，更别说屏幕上全部外星人的信息了。如何管理成群结队的外星人呢？一种办法是创建一个外星人列表，其中每个外星人都是一个字典，包含有关该外星人的各种信息。

这些外星人都具有相同的特征，但在 Python 看来，每个外星人都是独立的，这让我们能够独立地修改每个外星人。

在什么情况下需要处理成群结队的外星人呢？想象一下，可能随着游戏的进行，有些外星人会变色且移动速度会加快。必要时，我们可以使用 for 循环和 if 语句来修改某些外星人的颜色。例如，要将前三个外星人修改为黄色的、速度为中等且值 10 个点，可以这样做。

经常需要在列表中包含大量的字典，而其中每个字典都包含特定对象的众多信息。例如，你可能需要为网站的每个用户创建一个字典（就像 6.3.1 节的 user.py 中那样），并将这些字典存储在一个名为 users 的列表中。在这个列表中，所有字典的结构都相同，因此你可以遍历这个列表，并以相同的方式处理其中的每个字典。

有时候，需要将列表存储在字典中，而不是将字典存储在列表中。例如，你如何描述顾客点的比萨呢？如果使用列表，只能存储要添加的比萨配料；但如果使用字典，就不仅可在其中包含配料列表，还可包含其他有关比萨的描述。

1『字典里的「值」可以是任意数据类型。』

在下面的示例中，存储了比萨的两方面信息：外皮类型和配料列表。其中的配料列表是一个与键 'toppings' 相关联的值。要访问该列表，我们使用字典名和键 'toppings'，就像访问字典中的其他值一样。这将返回一个配料列表，而不是单个值。

每当需要在字典中将一个键关联到多个值时，都可以在字典中嵌套一个列表。在本章前面有关喜欢的编程语言的示例中，如果将每个人的回答都存储在一个列表中，被调查者就可选择多种喜欢的语言。在这种情况下，当我们遍历字典时，与每个被调查者相关联的都是一个语言列表，而不是一种语言；因此，在遍历该字典的 for 循环中，我们需要再使用一个 for 循环来遍历与被调查者相关联的语言列表。

正如你看到的，现在与每个名字相关联的值都是一个列表（见❶）。请注意，有些人喜欢的语言只有一种，而有些人有多种。遍历字典时（见❷），我们使用了变量 languages 来依次存储字典中的每个值，因为我们知道这些值都是列表。在遍历字典的主循环中，我们又使用了一个 for 循环来遍历每个人喜欢的语言列表（见❸）。

列表和字典的嵌套层级不应太多。如果嵌套层级比前面的示例多得多，很可能有更简单的解决问题的方案。

可在字典中嵌套字典，但这样做时，代码可能很快复杂起来。例如，如果有多个网站用户，每个都有独特的用户名，可在字典中将用户名作为键，然后将每位用户的信息存储在一个字典中，并将该字典作为与用户名相关联的值。

## 07. 用户输入和 while 循环

### 1. 逻辑脉络

如何使用输入函数 input()，主要是针对字符串的输入；数字的输入用 int()；while 循环的使用；如何使用 while 循环来处理列表和字典。

### 2. 摘录及评论

在本章中，你学习了：如何在程序中使用 input() 来让用户提供信息；如何处理文本和数字输入，以及如何使用 while 循环让程序按用户的要求不断地运行；多种控制 while 循环流程的方式：设置活动标志、使用 break 语句以及使用 continue 语句；如何使用 while 循环在列表之间移动元素，以及如何从列表中删除所有包含特定值的元素；如何结合使用 while 循环和字典。

大多数程序都旨在解决最终用户的问题，为此通常需要从用户那里获取一些信息。例如，假设有人要判断自己是否到了投票的年龄，要编写回答这个问题的程序，就需要知道用户的年龄，这样才能给出答案。因此，这种程序需要让用户输入其年龄，再将其与投票年龄进行比较，以判断用户是否到了投票的年龄，再给出结果。

在本章中，你将学习如何接受用户输入，让程序能够对其进行处理。在程序需要一个名字时，你需要提示用户输入该名字；程序需要一个名单时，你需要提示用户输入一系列名字。为此，你需要使用函数 input()。

你还将学习如何让程序不断地运行，让用户能够根据需要输入信息，并在程序中使用这些信息。为此，你需要使用 while 循环让程序不断地运行，直到指定的条件不满足为止。

通过获取用户输入并学会控制程序的运行时间，可编写出交互式程序。

使用函数 input() 时，Python 将用户输入解读为字符串。为解决这个问题，可使用函数 int()，它让 Python 将输入视为数值。函数 int() 将数字的字符串表示转换为数值表示。将数值输入用于计算和比较前，务必将其转换为数值表示。

处理数值信息时，求模运算符 （%）是一个很有用的工具，它将两个数相除并返回余数。

for 循环用于针对集合中的每个元素都一个代码块，而 while 循环不断地运行，直到指定的条件不满足为止。

你每天使用的程序很可能就包含 while 循环。例如，游戏使用 while 循环，确保在玩家想玩时不断运行，并在玩家想退出时停止运行。如果程序在用户没有让它停止时停止运行，或者在用户要退出时还继续运行，那就太没有意思了；有鉴于此，while 循环很有用。

在前一个示例中，我们让程序在满足指定条件时就执行特定的任务。但在更复杂的程序中，很多不同的事件都会导致程序停止运行；在这种情况下，该怎么办呢？

例如，在游戏中，多种事件都可能导致游戏结束，如玩家一艘飞船都没有了或要保护的城市都被摧毁了。导致程序结束的事件有很多时，如果在一条 while 语句中检查所有这些条件，将既复杂又困难。

在要求很多条件都满足才继续运行的程序中，可定义一个变量，用于判断整个程序是否处于活动状态。这个变量被称为标志，充当了程序的交通信号灯。你可让程序在标志为True 时继续运行，并在任何事件导致标志的值为 False 时让程序停止运行。这样，在 while 语句中就只需检查一个条件——标志的当前值是否为 True，并将所有测试（是否发生了应将标志设置为 False 的事件）都放在其他地方，从而让程序变得更为整洁。

这个程序的输出与前一个示例相同。在前一个示例中，我们将条件测试直接放在了 while 语句中，而在这个程序中，我们使用了一个标志来指出程序是否处于活动状态，这样如果要添加测试（如 elif 语句）以检查是否发生了其他导致 active 变为 False 的事件，将很容易。在复杂的程序中，如很多事件都会导致程序停止运行的游戏中，标志很有用：在其中的任何一个事件导致活动标志变成 False 时，主游戏循环将退出，此时可显示一条游戏结束消息，并让用户选择是否要重新玩。

要立即退出 while 循环，不再运行循环中余下的代码，也不管条件测试的结果如何，可使用 break 语句。break 语句用于控制程序流程，可使用它来控制哪些代码行将执行，哪些代码行不执行，从而让程序按你的要求执行你要执行的代码。

例如，来看一个让用户指出他到过哪些地方的程序。在这个程序中，我们可以在用户输入 'quit' 后使用 break 语句立即退出 while 循环：

要返回到循环开头，并根据条件测试结果决定是否继续执行循环，可使用 continue 语句，它不像 break 语句那样不再执行余下的代码并退出整个循环。

每个 while 循环都必须有停止运行的途径，这样才不会没完没了地执行下去。

每个程序员都会偶尔因不小心而编写出无限循环，在循环的退出条件比较微妙时尤其如此。如果程序陷入无限循环，可按 Ctrl + C，也可关闭显示程序输出的终端窗口。

要避免编写无限循环，务必对每个 while 循环进行测试，确保它按预期那样结束。如果你希望程序在用户输入特定值时结束，可运行程序并输入这样的值；如果在这种情况下程序没有结束，请检查程序处理这个值的方式，确认程序至少有一个这样的地方能让循环条件为 False 或让 break 语句得以执行。

到目前为止，我们每次都只处理了一项用户信息：获取用户的输入，再将输入打印出来或作出应答；循环再次运行时，我们获悉另一个输入值并作出响应。然而，要记录大量的用户和信息，需要在 while 循环中使用列表和字典。

for 循环是一种遍历列表的有效方式，但在 for 循环中不应修改列表，否则将导致 Python 难以跟踪其中的元素。要在遍历列表的同时对其进行修改，可使用 while 循环。通过将 while 循环同列表和字典结合起来使用，可收集、存储并组织大量输入，供以后查看和显示。

我们首先创建了一个未验证用户列表（见❶），其中包含用户 Alice、Brian 和 Candace，还创建了一个空列表，用于存储已验证的用户。❷ 处的 while 循环将不断地运行，直到列表 unconfirmed_users 变成空的。在这个循环中，❸ 处的函数 pop() 以每次一个的方式从列表 unconfirmed_users 末尾删除未验证的用户。由于 Candace 位于列表 unconfirmed_users 末尾，因此其名字将首先被删除、存储到变量current_user 中并加入到列表 confirmed_users 中（见❹）。接下来是 Brian，然后是 Alice。

为模拟用户验证过程，我们打印一条验证消息并将用户加入到已验证用户列表中。未验证用户列表越来越短，而已验证用户列表越来越长。未验证用户列表为空后结束循环，再打印已验证用户列表。

在第 3 章中，我们使用函数 remove() 来删除列表中的特定值，这之所以可行，是因为要删除的值在列表中只出现了一次。如果要删除列表中所有包含特定值的元素，该怎么办呢？

假设你有一个宠物列表，其中包含多个值为 'cat' 的元素。要删除所有这些元素，可不断运行一个 while 循环，直到列表中不再包含值 'cat'，如下所示。

可使用 while 循环提示用户输入任意数量的信息。下面来创建一个调查程序，其中的循环每次执行时都提示输入被调查者的名字和回答。我们将收集的数据存储在一个字典中，以便将回答同被调查者关联起来：

1『

学会设置一个标志：

```
active = True

while active:
	代码
```

』

这个程序首先定义了一个空字典（responses），并设置了一个标志（polling_active），用于指出调查是否继续。只要 polling_active 为 True，Python 就运行 while 循环中的代码。

在这个循环中，提示用户输入其用户名及其喜欢爬哪座山（见❶）。将这些信息存储在字典 responses 中（见❷），然后询问用户调查是否继续（见❸）。如果用户输入 yes，程序将再次进入 while 循环；如果用户输入 no，标志 polling_active 将被设置为 False，而 while 循环将就此结束。最后一个代码块（见❹）显示调查结果。

## 08. 函数

### 1. 逻辑脉络

如何定义一个函数；实参传递给函数的几种方式（顺序实参、关键词实参、默认值）；函数返回值的使用；如何将函数与列表、字典、if 语句、while 语句等结合起来使用，比如把列表当作一个形参在函数里传递列表；如何将函数存储成一个模块供其他函数使用。

### 2. 摘录及评论

在本章中，你学习了：如何编写函数，以及如何传递实参，让函数能够访问完成其工作所需的信息；如何使用位置实参和关键字实参，以及如何接受任意数量的实参；显示输出的函数和返回值的函数；如何将函数同列表、字典、if 语句和 while 循环结合起来使用。你还知道了如何将函数存储在被称为模块的独立文件中，让程序文件更简单、更易于理解。最后，你学习了函数编写指南，遵循这些指南可让程序始终结构良好，并对你和其他人来说易于阅读。

程序员的目标之一是，编写简单的代码来完成任务，而函数有助于你实现这样的目标。它们让你编写好代码块并确定其能够正确运行后，就可置之不理。确定函数能够正确地完成其工作后，你就可以接着投身于下一个编码任务。

函数让你编写代码一次后，想重用它们多少次就重用多少次。需要运行函数中的代码时，只需编写一行函数调用代码，就可让函数完成其工作。需要修改函数的行为时，只需修改一个代码块，而所做的修改将影响调用这个函数的每个地方。

使用函数让程序更容易阅读，而良好的函数名概述了程序各个部分的作用。相对于阅读一系列的代码块，阅读一系列函数调用让你能够更快地明白程序的作用。

函数还让代码更容易测试和调试。如果程序使用一系列的函数来完成其任务，而其中的每个函数都完成一项具体的工作，测试和维护起来将容易得多：你可编写分别调用每个函数的程序，并测试每个函数是否在它可能遇到的各种情形下都能正确地运行。经过这样的测试后你就能信心满满，深信你每次调用这些函数时，它们都将正确地运行。

紧跟在 def greet_user()：后面的所有缩进行构成了函数体。❷ 处的文本是被称为文档字符串 （docstring）的注释，描述了函数是做什么的。文档字符串用三引号括起，Python 使用它们来生成有关程序中函数的文档。

在函数 greet_user() 的定义中，变量 username 是一个形参 ——函数完成其工作所需的一项信息。在代码 greet_user('jesse') 中，值 'jesse' 是一个实参。实参是调用函数时传递给函数的信息。我们调用函数时，将要让函数使用的信息放在括号内。在 greet_user('jesse') 中，将实参 'jesse' 传递给了函数 greet_user()，这个值被存储在形参 username 中。大家有时候会形参、实参不分，因此如果你看到有人将函数定义中的变量称为实参或将函数调用中的变量称为形参，不要大惊小怪。

1『注意啊，传递给函数的实参得是字符串，否则不认的。』

鉴于函数定义中可能包含多个形参，因此函数调用中也可能包含多个实参。向函数传递实参的方式很多，可使用位置实参，这要求实参的顺序与形参的顺序相同；也可使用关键字实参，其中每个实参都由变量名和值组成；还可使用列表和字典。

你调用函数时，Python 必须将函数调用中的每个实参都关联到函数定义中的一个形参。为此，最简单的关联方式是基于实参的顺序。这种关联方式被称为位置实参。

关键字实参是传递给函数的「名称—值」对。你直接在实参中将名称和值关联起来了，因此向函数传递实参时不会混淆（不会得到名为 Hamster 的 harry 这样的结果）。关键字实参让你无需考虑函数调用中的实参顺序，还清楚地指出了函数调用中各个值的用途。

编写函数时，可给每个形参指定默认值。在调用函数中给形参提供了实参时，Python 将使用指定的实参值；否则，将使用形参的默认值。因此，给形参指定默认值后，可在函数调用中省略相应的实参。使用默认值可简化函数调用，还可清楚地指出函数的典型用法。

请注意，在这个函数的定义中，修改了形参的排列顺序。由于给 animal_type 指定了默认值，无需通过实参来指定动物类型，因此在函数调用中只包含一个实参——宠物的名字。然而，Python 依然将这个实参视为位置实参，因此如果函数调用中只包含宠物的名字，这个实参将关联到函数定义中的第一个形参。这就是需要将 pet_name 放在形参列表开头的原因所在。

1『函数定义里，必须把没有默认值的形参设置在前面，否者语法错误。』

使用默认值时，在形参列表中必须先列出没有默认值的形参，再列出有默认值的实参。这让 Python 依然能够正确地解读位置实参。

函数并非总是直接显示输出，相反，它可以处理一些数据，并返回一个或一组值。函数返回的值被称为返回值。在函数中，可使用 return 语句将值返回到调用函数的代码行。返回值让你能够将程序的大部分繁重工作移到函数中去完成，从而简化主程序。

1『字符串的方法 title() 总是漏掉后面的 ()。』

有时候，需要让实参变成可选的，这样使用函数的人就只需在必要时才提供额外的信息。可使用默认值来让实参变成可选的。

然而，并非所有的人都有中间名，但如果你调用这个函数时只提供了名和姓，它将不能正确地运行。为让中间名变成可选的，可给实参 middle_name 指定一个默认值——空字符串，并在用户没有提供中间名时不使用这个实参。为让 get_formatted_name() 在没有提供中间名时依然可行，可给实参 middle_name 指定一个默认值——空字符串，并将其移到形参列表的末尾。

函数可返回任何类型的值，包括列表和字典等较复杂的数据结构。例如，下面的函数接受姓名的组成部分，并返回一个表示人的字典：

可将函数同本书前面介绍的任何 Python 结构结合起来使用。例如，下面将结合使用函数 get_formatted_name() 和 while 循环，以更正规的方式问候用户。

我们添加了一条消息来告诉用户如何退出，然后在每次提示用户输入时，都检查他输入的是否是退出值，如果是，就退出循环。现在，这个程序将不断地问候，直到用户输入的姓或名为 'q'  为止：

你经常会发现，向函数传递列表很有用，这种列表包含的可能是名字、数字或更复杂的对象（如字典）。将列表传递给函数后，函数就能直接访问其内容。

将列表传递给函数后，函数就可对其进行修改。在函数中对这个列表所做的任何修改都是永久性的，这让你能够高效地处理大量的数据。

我们创建了一个未打印的设计列表，还创建了一个空列表，用于存储打印好的模型。接下来，由于我们已经定义了两个函数，因此只需调用它们并传入正确的实参即可。我们调用 print_models() 并向它传递两个列表；像预期的一样，print_models() 模拟打印设计的过程。接下来，我们调用 show_completed_models()，并将打印好的模型列表传递给它，让其能够指出打印了哪些模型。描述性的函数名让别人阅读这些代码时也能明白，虽然其中没有任何注释。

相比于没有使用函数的版本，这个程序更容易扩展和维护。如果以后需要打印其他设计，只需再次调用 print_models() 即可。如果我们发现需要对打印代码进行修改，只需修改这些代码一次，就能影响所有调用该函数的地方；与必须分别修改程序的多个地方相比，这种修改的效率更高。

这个程序还演示了这样一种理念，即每个函数都应只负责一项具体的工作。第一个函数打印每个设计，而第二个显示打印好的模型；这优于使用一个函数来完成两项工作。编写函数时，如果你发现它执行的任务太多，请尝试将这些代码划分到两个函数中。别忘了，总是可以在一个函数中调用另一个函数，这有助于将复杂的任务划分成一系列的步骤。

有时候，需要禁止函数修改列表。例如，假设像前一个示例那样，你有一个未打印的设计列表，并编写了一个将这些设计移到打印好的模型列表中的函数。你可能会做出这样的决定：即便打印所有设计后，也要保留原来的未打印的设计列表，以供备案。但由于你将所有的设计都移出了 unprinted_designs，这个列表变成了空的，原来的列表没有了。为解决这个问题，可向函数传递列表的副本而不是原件；这样函数所做的任何修改都只影响副本，而丝毫不影响原件。

虽然向函数传递列表的副本可保留原始列表的内容，但除非有充分的理由需要传递副本，否则还是应该将原始列表传递给函数，因为让函数使用现成列表可避免花时间和内存创建副本，从而提高效率，在处理大型列表时尤其如此。

有时候，你预先不知道函数需要接受多少个实参，好在 Python 允许函数从调用语句中收集任意数量的实参。例如，来看一个制作比萨的函数，它需要接受很多配料，但你无法预先确定顾客要多少种配料。下面的函数只有一个形参 *toppings，但不管调用语句提供了多少实参，这个形参都将它们统统收入囊中。

形参名 *toppings 中的星号让 Python 创建一个名为 toppings 的空元组，并将收到的所有值都封装到这个元组中。函数体内的 print 语句通过生成输出来证明 Python 能够处理使用一个值调用函数的情形，也能处理使用三个值来调用函数的情形。它以类似的方式处理不同的调用，注意，Python 将实参封装到一个元组中，即便函数只收到一个值也如此。

如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python 先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。例如，如果前面的函数还需要一个表示比萨尺寸的实参，必须将该形参放在形参 *toppings 的前面。

有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的「键-值」对——调用语句提供了多少就接受多少。一个这样的示例是创建用户简介：你知道你将收到有关用户的信息，但不确定会是什么样的信息。在下面的示例中，函数 build_profile() 接受名和姓，同时还接受任意数量的关键字实参。

函数 build_profile() 的定义要求提供名和姓，同时允许用户根据需要提供任意数量的名称—值对。形参 **user_info 中的两个星号让 Python 创建一个名为 user_info 的空字典，并将收到的所有「名称-值」对都封装到这个字典中。在这个函数中，可以像访问其他字典那样访问 user_info 中的「名称-值」对。

在 build_profile() 的函数体内，我们创建了一个名为 profile 的空字典，用于存储用户简介。在 ❶ 处，我们将名和姓加入到这个字典中，因为我们总是会从用户那里收到这两项信息。在 ❷ 处，我们遍历字典 user_info 中的「键-值」对，并将每个「键-值」对都加入到字典 profile 中。最后，我们将字典 profile 返回给函数调用行。

我们调用 build_profile()，向它传递名（'albert' ）、姓（'einstein' ）和两个键—值对（location='princeton' 和 field='physics' ），并将返回的 profile 存储在变量 user_profile 中，再打印这个变量。在这里，返回的字典包含用户的名和姓，还有求学的地方和所学专业。调用这个函数时，不管额外提供了多少个「键-值」对，它都能正确地处理。

编写函数时，你可以以各种方式混合使用位置实参、关键字实参和任意数量的实参。知道这些实参类型大有裨益，因为阅读别人编写的代码时经常会见到它们。要正确地使用这些类型的实参并知道它们的使用时机，需要经过一定的练习。就目前而言，牢记使用最简单的方法来完成任务就好了。你继续往下阅读，就会知道在各种情况下哪种方法的效率是最高的。

函数的优点之一是，使用它们可将代码块与主程序分离。通过给函数指定描述性名称，可让主程序容易理解得多。你还可以更进一步，将函数存储在被称为「模块」的独立文件中，再将模块导入 到主程序中。import 语句允许在当前运行的程序文件中使用模块中的代码。

通过将函数存储在独立的文件中，可隐藏程序代码的细节，将重点放在程序的高层逻辑上。这还能让你在众多不同的程序中重用函数。将函数存储在独立文件中后，可与其他程序员共享这些文件而不是整个程序。知道如何导入函数还能让你使用其他程序员编写的函数库。

1『

导入函数的方法有：导入整个模块、导入特定的函数、使用 as 给函数指定别名、使用 as 给模块指定别名、导入模块中的所有函数。

导入整个模块：import pizza

使用 as 给模块指定别名：import pizza as piz

导入特定的函数：from pizza import make_pizza

使用 as 给函数指定别名：from pizza import make_pizza mp

』

	import pizza

Python 读取这个文件时，代码行 import pizza 让 Python 打开文件 pizza.py，并将其中的所有函数都复制到这个程序中。你看不到复制的代码，因为这个程序运行时，Python 在幕后复制这些代码。你只需知道，在 making_pizzas.py 中，可以使用 pizza.py 中定义的所有函数。要调用被导入的模块中的函数，可指定导入的模块的名称 pizza 和函数名 make_pizza()，并用句点分隔它们（见❶）。这些代码的输出与没有导入模块的原始程序相同：

	module_name.function_name()

你还可以导入模块中的特定函数，这种导入方法的语法如下：

	from module_name import function_name
	
	from module_name import function_name as piz

通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数。若使用这种语法，调用函数时就无需使用句点。由于我们在 import 语句中显式地导入了函数 make_pizza()，因此调用它时只需指定其名称。

你还可以给模块指定别名。通过给模块指定简短的别名（如给模块 pizza 指定别名 p ），让你能够更轻松地调用模块中的函数。相比于 pizza.make_pizza()，p.make_pizza() 更为简洁：

	import module_name as mn

import 语句中的星号让 Python 将模块 pizza 中的每个函数都复制到这个程序文件中。由于导入了每个函数，可通过名称来调用每个函数，而无需使用句点表示法。然而，使用并非自己编写的大型模块时，最好不要采用这种导入方法：如果模块中有函数的名称与你的项目中使用的名称相同，可能导致意想不到的结果：Python 可能遇到多个名称相同的函数或变量，进而覆盖函数，而不是分别导入所有的函数。

最佳的做法是，要么只导入你需要使用的函数，要么导入整个模块并使用句点表示法。这能让代码更清晰，更容易阅读和理解。这里之所以介绍这种导入方法，只是想让你在阅读别人编写的代码时，如果遇到类似于下面的 import 语句，能够理解它们。

编写函数时，需要牢记几个细节。应给函数指定描述性名称，且只在其中使用小写字母和下划线。描述性名称可帮助你和别人明白代码想要做什么。给模块命名时也应遵循上述约定。

每个函数都应包含简要地阐述其功能的注释，该注释应紧跟在函数定义后面，并采用文档字符串格式。文档良好的函数让其他程序员只需阅读文档字符串中的描述就能够使用它：他们完全可以相信代码如描述的那样运行；只要知道函数的名称、需要的实参以及返回值的类型，就能在自己的程序中使用它。

给形参指定默认值时，等号两边不要有空格：

	def function_name(parameter_0, parameter_1='default value')

对于函数调用中的关键字实参，也应遵循这种约定：

	function_name(value_0, parameter_1='value')

[PEP 8 -- Style Guide for Python Code | Python.org](https://www.python.org/dev/peps/pep-0008/) 建议代码行的长度不要超过 79 字符，这样只要编辑器窗口适中，就能看到整行代码。如果形参很多，导致函数定义的长度超过了 79 字符，可在函数定义中输入左括号后按回车键，并在下一行按两次 Tab 键，从而将形参列表和只缩进一层的函数体区分开来。

所有的 import 语句都应放在文件开头，唯一例外的情形是，在文件开头使用了注释来描述整个程序。

## 09. 类

### 1. 逻辑脉络

类的概念；如何创建和使用类（创建一个类后实例化，然后调用其属性和方法，以及如何修改实例的属性值）；如何使用类的继承；如何导入一个类（导入单个类、在一个模块里存储多个类、在一个模块里导入多个类、在一个模块里导入另一个模块等）。

### 2. 摘录及评论

在本章中，你学习了：如何编写类；如何使用属性在类中存储信息，以及如何编写方法，以让类具备所需的行为；如何编写方法 __init__()，以便根据类创建包含所需属性的实例。你见识了如何修改实例的属性——包括直接修改以及通过方法进行修改。你还了解了：使用继承可简化相关类的创建工作；将一个类的实例用作另一个类的属性可让类更简洁。

你了解到，通过将类存储在模块中，并在需要使用这些类的文件中导入它们，可让项目组织有序。你学习了 Python 标准库，并见识了一个使用模块 collections 中的 OrderedDict 类的示例。最后，你学习了编写类时应遵循的 Python 约定。

面向对象编程是最有效的软件编写方法之一。在面向对象编程中，你编写表示现实世界中的事物和情景的类，并基于这些类来创建对象。编写类时，你定义一大类对象都有的通用行为。基于类创建对象时，每个对象都自动具备这种通用行为，然后可根据需要赋予每个对象独特的个性。使用面向对象编程可模拟现实情景，其逼真程度达到了令你惊讶的地步。

根据类来创建对象被称为实例化，这让你能够使用类的实例。在本章中，你将编写一些类并创建其实例。你将指定可在实例中存储什么信息，定义可对这些实例执行哪些操作。你还将编写一些类来扩展既有类的功能，让相似的类能够高效地共享代码。你将把自己编写的类存储在模块中，并在自己的程序文件中导入其他程序员编写的类。

理解面向对象编程有助于你像程序员那样看世界，还可以帮助你真正明白自己编写的代码：不仅是各行代码的作用，还有代码背后更宏大的概念。了解类背后的概念可培养逻辑思维，让你能够通过编写程序来解决遇到的几乎任何问题。

随着面临的挑战日益严峻，类还能让你以及与你合作的其他程序员的生活更轻松。如果你与其他程序员基于同样的逻辑来编写代码，你们就能明白对方所做的工作；你编写的程序将能被众多合作者所理解，每个人都能事半功倍。

使用类几乎可以模拟任何东西。下面来编写一个表示小狗的简单类 Dog ——它表示的不是特定的小狗，而是任何小狗。对于大多数宠物狗，我们都知道些什么呢？它们都有名字和年龄；我们还知道，大多数小狗还会蹲下和打滚。由于大多数小狗都具备上述两项信息（名字和年龄）和两种行为（蹲下和打滚），我们的 Dog 类将包含它们。

根据约定，在 Python 中，首字母大写的名称指的是类。这个类定义中的括号是空的，因为我们要从空白创建这个类。在 ❷ 处，我们编写了一个文档字符串，对这个类的功能作了描述。

类中的函数称为方法 ；你前面学到的有关函数的一切都适用于方法，就目前而言，唯一重要的差别是调用方法的方式。❸ 处的方法 __init__() 是一个特殊的方法，每当你根据 Dog 类创建新实例时，Python 都会自动运行它。在这个方法的名称中，开头和末尾各有两个下划线，这是一种约定，旨在避免 Python 默认方法与普通方法发生名称冲突。

我们将方法__init__() 定义成了包含三个形参：self 、name 和 age。在这个方法的定义中，形参 self 必不可少，还必须位于其他形参的前面。为何必须在方法定义中包含形参 self  呢？因为 Python 调用这个 __init__() 方法来创建 Dog 实例时，将自动传入实参 self。每个与类相关联的方法调用都自动传递实参 self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。我们创建 Dog 实例时，Python 将调用 Dog 类的方法 __init__()。我们将通过实参向 Dog() 传递名字和年龄；self 会自动传递，因此我们不需要传递它。每当我们根据 Dog 类创建实例时，都只需给最后两个形参（name 和 age ）提供值。

❹处定义的两个变量都有前缀self。以self 为前缀的变量都可供类中的所有方法使用，我们还可以通过类的任何实例来访问这些变量。self.name = name 获取存储在形参name 中的值，并将其存储到变量name 中，然后该变量被关联到当前创建的实例。self.age = age 的作用与此类似。像这样可通过实例访问的变量称为属性。

Dog 类还定义了另外两个方法：sit() 和 roll_over() （见❺）。由于这些方法不需要额外的信息，如名字或年龄，因此它们只有一个形参 self。我们后面将创建的实例能够访问这些方法，换句话说，它们都会蹲下和打滚。当前，sit() 和 roll_over() 所做的有限，它们只是打印一条消息，指出小狗正蹲下或打滚。但可以扩展这些方法以模拟实际情况：如果这个类包含在一个计算机游戏中，这些方法将包含创建小狗蹲下和打滚动画效果的代码。如果这个类是用于控制机器狗的，这些方法将引导机器狗做出蹲下和打滚的动作。

在 Python 2.7 中创建类时，需要做细微的修改——在括号内包含单词 object。

这里使用的是前一个示例中编写的 Dog 类。在 ❶ 处，我们让 Python 创建一条名字为 'willie' 、年龄为 6 的小狗。遇到这行代码时，Python 使用实参 'willie' 和 6 调用 Dog 类中的方法 __init__()。方法 __init__() 创建一个表示特定小狗的示例，并使用我们提供的值来设置属性 name 和 age。方法 __init__() 并未显式地包含 return 语句，但 Python 自动返回一个表示这条小狗的实例。我们将这个实例存储在变量 my_dog 中。在这里，命名约定很有用：我们通常可以认为首字母大写的名称（如 Dog ）指的是类，而小写的名称（如 my_dog ）指的是根据类创建的实例。

你可以使用类来模拟现实世界中的很多情景。类编写好后，你的大部分时间都将花在使用根据类创建的实例上。你需要执行的一个重要任务是修改实例的属性。你可以直接修改实例的属性，也可以编写方法以特定的方式进行修改。

类中的每个属性都必须有初始值，哪怕这个值是 0 或空字符串。在有些情况下，如设置默认值时，在方法 __init__() 内指定这种初始值是可行的；如果你对某个属性这样做了，就无需包含为它提供初始值的形参。

可以以三种不同的方式修改属性的值：直接通过实例进行修改；通过方法进行设置；通过方法进行递增（增加特定的值）。

编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可使用继承。一个类继承另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为父类，而新类称为子类。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。

首先是 Car 类的代码（见❶）。创建子类时，父类必须包含在当前文件中，且位于子类前面。在 ❷ 处，我们定义了子类 ElectricCar。定义子类时，必须在括号内指定父类的名称。方法 __init__() 接受创建 Car 实例所需的信息（见❸）。

❹处的 super() 是一个特殊函数，帮助 Python 将父类和子类关联起来。这行代码让 Python调用 ElectricCar 的父类的方法 __init__()，让 ElectricCar 实例包含父类的所有属性。父类也称为超类 （superclass），名称 super 因此而得名。

为测试继承是否能够正确地发挥作用，我们尝试创建一辆电动汽车，但提供的信息与创建普通汽车时相同。在 ❺ 处，我们创建 ElectricCar 类的一个实例，并将其存储在变量 my_tesla 中。这行代码调用 ElectricCar 类中定义的方法 __init__()，后者让 Python 调用父类 Car 中定义的方法 __init__()。我们提供了实参 'tesla' 、'model s' 和 2016。

让一个类继承另一个类后，可添加区分子类和父类所需的新属性和方法。下面来添加一个电动汽车特有的属性（电瓶），以及一个描述该属性的方法。我们将存储电瓶容量，并编写一个打印电瓶描述的方法。

对于 ElectricCar 类的特殊化程度没有任何限制。模拟电动汽车时，你可以根据所需的准确程度添加任意数量的属性和方法。如果一个属性或方法是任何汽车都有的，而不是电动汽车特有的，就应将其加入到 Car 类而不是 ElectricCar 类中。这样，使用 Car 类的人将获得相应的功能，而 ElectricCar 类只包含处理电动汽车特有属性和行为的代码。

对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。为此，可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样，Python 将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。假设 Car 类有一个名为 fill_gas_tank() 的方法，它对全电动汽车来说毫无意义，因此你可能想重写它。下面演示了一种重写方式。现在，如果有人对电动汽车调用方法 fill_gas_tank()，Python 将忽略 Car 类中的方法 fill_gas_tank()，转而运行上述代码。使用继承时，可让子类保留从父类那里继承而来的精华，并剔除不需要的糟粕。

使用代码模拟实物时，你可能会发现自己给类添加的细节越来越多：属性和方法清单以及文件都越来越长。在这种情况下，可能需要将类的一部分作为一个独立的类提取出来。你可以将大型类拆分成多个协同工作的小类。例如，不断给 ElectricCar 类添加细节时，我们可能会发现其中包含很多专门针对汽车电瓶的属性和方法。在这种情况下，我们可将这些属性和方法提取出来，放到另一个名为 Battery 的类中，并将一个 Battery 实例用作 ElectricCar 类的一个属性。

模拟较复杂的物件（如电动汽车）时，需要解决一些有趣的问题。续航里程是电瓶的属性还是汽车的属性呢？如果我们只需描述一辆汽车，那么将方法 get_range() 放在 Battery 类中也许是合适的；但如果要描述一家汽车制造商的整个产品线，也许应该将方法 get_range() 移到 ElectricCar 类中。在这种情况下，get_range() 依然根据电瓶容量来确定续航里程，但报告的是一款汽车的续航里程。我们也可以这样做：将方法 get_range() 还留在 Battery 类中，但向它传递一个参数，如 car_model ；在这种情况下，方法 get_range() 将根据电瓶容量和汽车型号报告续航里程。

这让你进入了程序员的另一个境界：解决上述问题时，你从较高的逻辑层面（而不是语法层面）考虑；你考虑的不是 Python，而是如何使用代码来表示实物。到达这种境界后，你经常会发现，现实世界的建模方法并没有对错之分。有些方法的效率更高，但要找出效率最高的表示法，需要经过一定的实践。只要代码像你希望的那样运行，就说明你做得很好！即便你发现自己不得不多次尝试使用不同的方法来重写类，也不必气馁；要编写出高效、准确的代码，都得经过这样的过程。

随着你不断地给类添加功能，文件可能变得很长，即便你妥善地使用了继承亦如此。为遵循 Python 的总体理念，应让文件尽可能整洁。为在这方面提供帮助，Python 允许你将类存储在模块中，然后在主程序中导入所需的模块。

在 ❶ 处，我们包含了一个模块级文档字符串，对该模块的内容做了简要的描述。你应为自己创建的每个模块都编写文档字符串。

1『三个双引号的即文档字符串。』

导入类是一种有效的编程方式。如果在这个程序中包含了整个 Car 类，它该有多长呀！通过将这个类移到一个模块中，并导入该模块，你依然可以使用其所有功能，但主程序文件变得整洁而易于阅读了。这还能让你将大部分逻辑存储在独立的文件中；确定类像你希望的那样工作后，你就可以不管这些文件，而专注于主程序的高级逻辑了。

虽然同一个模块中的类之间应存在某种相关性，但可根据需要在一个模块中存储任意数量的类。类 Battery 和 ElectricCar 都可帮助模拟汽车，因此下面将它们都加入模块 car.py 中。

可根据需要在程序文件中导入任意数量的类。如果我们要在同一个程序中创建普通汽车和电动汽车，就需要将 Car 和 ElectricCar 类都导入。

在 ❶ 处从一个模块中导入多个类时，用逗号分隔了各个类。导入必要的类后，就可根据需要创建每个类的任意数量的实例。

你还可以导入整个模块，再使用句点表示法访问需要的类。这种导入方法很简单，代码也易于阅读。由于创建类实例的代码都包含模块名，因此不会与当前文件使用的任何名称发生冲突。

要导入模块中的每个类，可使用下面的语法：

	from module_name import *

不推荐使用这种导入方式，其原因有二。

首先，如果只要看一下文件开头的 import 语句，就能清楚地知道程序使用了哪些类，将大有裨益；但这种导入方式没有明确地指出你使用了模块中的哪些类。这种导入方式还可能引发名称方面的困惑。如果你不小心导入了一个与程序文件中其他东西同名的类，将引发难以诊断的错误。这里之所以介绍这种导入方式，是因为虽然不推荐使用这种方式，但你可能会在别人编写的代码中见到它。

需要从一个模块中导入很多类时，最好导入整个模块，并使用 module_name.class_name 语法来访问类。这样做时，虽然文件开头并没有列出用到的所有类，但你清楚地知道在程序的哪些地方使用了导入的模块；你还避免了导入模块中的每个类可能引发的名称冲突。

有时候，需要将类分散到多个模块中，以免模块太大，或在同一个模块中存储不相关的类。将类存储在多个模块中时，你可能会发现一个模块中的类依赖于另一个模块中的类。在这种情况下，可在前一个模块中导入必要的类。例如，下面将 Car 类存储在一个模块中，并将 ElectricCar 和 Battery 类存储在另一个模块中。我们将第二个模块命名为 electric_car.py，并将 Battery 和 ElectricCar 类复制到这个模块中。ElectricCar 类需要访问其父类 Car，因此在 ❶ 处，我们直接将 Car 类导入该模块中。如果我们忘记了这行代码，Python 将在我们试图创建 ElectricCar 实例时引发错误。我们还需要更新模块 car，使其包含Car 类。

正如你看到的，在组织大型项目的代码方面，Python 提供了很多选项。熟悉所有这些选项很重要，这样你才能确定哪种项目组织方式是最佳的，并能理解别人开发的项目。

一开始应让代码结构尽可能简单。先尽可能在一个文件中完成所有的工作，确定一切都能正确运行后，再将类移到独立的模块中。如果你喜欢模块和文件的交互方式，可在项目开始时就尝试将类存储到模块中。先找出让你能够编写出可行代码的方式，再尝试让代码更为组织有序。

Python 标准库是一组模块，安装的 Python 都包含它。你现在对类的工作原理已有大致的了解，可以开始使用其他程序员编写好的模块了。可使用标准库中的任何函数和类，为此只需在程序开头包含一条简单的 import 语句。下面来看模块 collections 中的一个类——OrderedDict。

字典让你能够将信息关联起来，但它们不记录你添加「键-值」对的顺序。要创建字典并记录其中的「键-值」对的添加顺序，可使用模块 collections 中的 OrderedDict 类。OrderedDict 实例的行为几乎与字典相同，区别只在于记录了「键-值」对的添加顺序。

我们首先从模块 collections 中导入了 OrderedDict 类（见❶）。在 ❷ 处，我们创建了 OrderedDict 类的一个实例，并将其存储到 favorite_languages 中。请注意，这里没有使用花括号，而是调用 OrderedDict() 来创建一个空的有序字典，并将其存储在 favorite_languages 中。接下来，我们以每次一对的方式添加「名字-语言」对（见❸）。在 ❹ 处，我们遍历 favorite_languages，但知道将以添加的顺序获取调查结果。

这是一个很不错的类，它兼具列表和字典的主要优点（在将信息关联起来的同时保留原来的顺序）。等你开始对关心的现实情形建模时，可能会发现有序字典正好能够满足需求。随着你对标准库的了解越来越深入，将熟悉大量可帮助你处理常见情形的模块。

Python Module of the Week ：要了解 Python 标准库，一个很不错的资源是网站 Python Module of the Week。请访问 http://pymotw.com/ 并查看其中的目录，在其中找一个你感兴趣的模块进行探索，或阅读模块 collections 和 random 的文档。

3『[Python 3 Module of the Week — PyMOTW 3](https://pymotw.com/3/)』

你必须熟悉有些与类相关的编码风格问题，在你编写的程序较复杂时尤其如此。

1. 类名应采用「驼峰命名法」，即将类名中的每个单词的首字母都大写，而不使用下划线。实例名和模块名都采用小写格式，并在单词之间加上下划线。

2. 对于每个类，都应紧跟在类定义后面包含一个文档字符串。这种文档字符串简要地描述类的功能，并遵循编写函数的文档字符串时采用的格式约定。每个模块也都应包含一个文档字符串，对其中的类可用于做什么进行描述。

3. 可使用空行来组织代码，但不要滥用。在类中，可使用一个空行来分隔方法；而在模块中，可使用两个空行来分隔类。

4. 需要同时导入标准库中的模块和你编写的模块时，先编写导入标准库模块的 import 语句，再添加一个空行，然后编写导入你自己编写的模块的 import 语句。在包含多条 import 语句的程序中，这种做法让人更容易明白程序使用的各个模块都来自何方。

1『以上是 python 类的编码风格，一定要牢记。』

## 10. 文件和异常

### 1. 逻辑脉络

如何读取数据；如何写入数据；如何处理异常；如何用 json 存储 Python 的数据结构。

### 2. 摘录及评论

在本章中，你学习了：如何使用文件；如何一次性读取整个文件，以及如何以每次一行的方式读取文件的内容；如何写入文件，以及如何将文本附加到文件末尾；什么是异常以及如何处理程序可能引发的异常；如何存储 Python 数据结构，以保存用户提供的信息，避免用户每次运行程序时都需要重新提供。

在本章中，你将学习处理文件，让程序能够快速地分析大量的数据；你将学习错误处理，避免程序在面对意外情形时崩溃；你将学习异常，它们是 Python 创建的特殊对象，用于管理程序运行时出现的错误；你还将学习模块 json，它让你能够保存用户数据，以免在程序停止运行后丢失。

学习处理文件和保存数据可让你的程序使用起来更容易：用户将能够选择输入什么样的数据，以及在什么时候输入；用户使用你的程序做一些工作后，可将程序关闭，以后再接着往下做。学习处理异常可帮助你应对文件不存在的情形，以及处理其他可能导致程序崩溃的问题。这让你的程序在面对错误的数据时更健壮——不管这些错误数据源自无意的错误，还是源自破坏程序的恶意企图。你在本章学习的技能可提高程序的适用性、可用性和稳定性。

文本文件可存储的数据量多得难以置信：天气数据、交通数据、社会经济数据、文学作品等。每当需要分析或修改存储在文件中的信息时，读取文件都很有用，对数据分析应用程序来说尤其如此。例如，你可以编写一个这样的程序：读取一个文本文件的内容，重新设置这些数据的格式并将其写入文件，让浏览器能够显示这些内容。

要使用文本文件中的信息，首先需要将信息读取到内存中。为此，你可以一次性读取文件的全部内容，也可以以每次一行的方式逐步读取。

在这个程序中，第 1 行代码做了大量的工作。我们先来看看函数 open()。要以任何方式使用文件——哪怕仅仅是打印其内容，都得先打开文件，这样才能访问它。函数 open() 接受一个参数：要打开的文件的名称。Python 在当前执行的文件所在的目录中查找指定的文件。在这个示例中，当前运行的是 file_reader.py，因此 Python 在 file_reader.py 所在的目录中查找 pi_digits.txt。函数 open() 返回一个表示文件的对象。在这里，open('pi_digits.txt') 返回一个表示文件 pi_digits.txt 的对象；Python 将这个对象存储在我们将在后面使用的变量中。

关键字 with 在不再需要访问文件后将其关闭。在这个程序中，注意到我们调用了open()，但没有调用 close() ；你也可以调用 open() 和 close() 来打开和关闭文件，但这样做时，如果程序存在 bug，导致 close() 语句未执行，文件将不会关闭。这看似微不足道，但未妥善地关闭文件可能会导致数据丢失或受损。如果在程序中过早地调用 close()，你会发现需要使用文件时它已关闭 （无法访问），这会导致更多的错误。并非在任何情况下都能轻松确定关闭文件的恰当时机，但通过使用前面所示的结构，可让 Python去确定：你只管打开文件，并在需要时使用它，Python 自会在合适的时候自动将其关闭。

有了表示 pi_digits.txt 的文件对象后，我们使用方法 read() （前述程序的第2行）读取这个文件的全部内容，并将其作为一个长长的字符串存储在变量 contents 中。这样，通过打印 contents 的值，就可将这个文本文件的全部内容显示出来。

当你将类似 pi_digits.txt 这样的简单文件名传递给函数 open() 时，Python 将在当前执行的文件（即 .py 程序文件）所在的目录中查找文件。

根据你组织文件的方式，有时可能要打开不在程序文件所属目录中的文件。例如，你可能将程序文件存储在了文件夹 python_work 中，而在文件夹 python_work 中，有一个名为 text_files 的文件夹，用于存储程序文件操作的文本文件。虽然文件夹 text_files 包含在文件夹 python_work 中，但仅向 open() 传递位于该文件夹中的文件的名称也不可行，因为 Python 只在文件夹 python_work 中查找，而不会在其子文件夹 text_files 中查找。要让 Python 打开不与程序文件位于同一个目录中的文件，需要提供文件路径，它让 Python 到系统的特定位置去查找。

通过使用绝对路径，可读取系统任何地方的文件。就目前而言，最简单的做法是，要么将数据文件存储在程序文件所在的目录，要么将其存储在程序文件所在目录下的一个文件夹（如 text_files）中。

在 ❶ 处，我们将要读取的文件的名称存储在变量 filename 中，这是使用文件时一种常见的做法。由于变量 filename 表示的并非实际文件——它只是一个让 Python 知道到哪里去查找文件的字符串，因此可轻松地将 'pi_digits.txt' 替换为你要使用的另一个文件的名称。调用 open() 后，将一个表示文件及其内容的对象存储到了变量 file_object 中（见❷）。这里也使用了关键字 with，让 Python 负责妥善地打开和关闭文件。为查看文件的内容，我们通过对文件对象执行循环来遍历文件中的每一行（见❸）。

使用关键字 with 时，open() 返回的文件对象只在 with 代码块内可用。如果要在 with 代码块外访问文件的内容，可在 with 代码块内将文件的各行存储在一个列表中，并在 with 代码块外使用该列表：你可以立即处理文件的各个部分，也可推迟到程序后面再处理。

在变量 pi_string 存储的字符串中，包含原来位于每行左边的空格，为删除这些空格，可使用 strip() 而不是 rstrip()。

可使用方法 replace() 将字符串中的特定单词都替换为另一个单词。下面是一个简单的示例，演示了如何将句子中的 'dog' 替换为'cat' ：

保存数据的最简单的方式之一是将其写入到文件中。通过将输出写入文件，即便关闭包含程序输出的终端窗口，这些输出也依然存在：你可以在程序结束运行后查看这些输出，可与别人分享输出文件，还可编写程序来将这些输出读取到内存中并进行处理。

在这个示例中，调用 open() 时提供了两个实参（见❶）。第一个实参也是要打开的文件的名称；第二个实参（'w' ）告诉 Python，我们要以写入模式打开这个文件。打开文件时，可指定读取模式 （'r' ）、写入模式 （'w' ）、附加模式 （'a' ）或让你能够读取和写入文件的模式（'r+' ）。如果你省略了模式实参，Python 将以默认的只读模式打开文件。

如果你要写入的文件不存在，函数 open() 将自动创建它。然而，以写入（'w' ）模式打开文件时千万要小心，因为如果指定的文件已经存在，Python 将在返回文件对象前清空该文件。

在 ❷ 处，我们使用文件对象的方法 write() 将一个字符串写入文件。这个程序没有终端输出，但如果你打开文件 programming.txt，将看到其中包含如下一行内容：

像显示到终端的输出一样，还可以使用空格、制表符和空行来设置这些输出的格式。

如果你要给文件添加内容，而不是覆盖原有的内容，可以附加模式打开文件。你以附加模式打开文件时，Python 不会在返回文件对象前清空文件，而你写入到文件的行都将添加到文件末尾。如果指定的文件不存在，Python 将为你创建一个空文件。

Python 使用被称为异常的特殊对象来管理程序执行期间发生的错误。每当发生让 Python 不知所措的错误时，它都会创建一个异常对象。如果你编写了处理该异常的代码，程序将继续运行；如果你未对异常进行处理，程序将停止，并显示一个 traceback，其中包含有关异常的报告。

异常是使用 try-except 代码块处理的。try-except 代码块让 Python 执行指定的操作，同时告诉 Python 发生异常时怎么办。使用了 try-except 代码块时，即便出现异常，程序也将继续运行：显示你编写的友好的错误消息，而不是令用户迷惑的 traceback。

在上述traceback中，❶ 处指出的错误 ZeroDivisionError 是一个异常对象。Python 无法按你的要求做时，就会创建这种对象。在这种情况下，Python 将停止运行程序，并指出引发了哪种异常，而我们可根据这些信息对程序进行修改。下面我们将告诉 Python，发生这种错误时怎么办；这样，如果再次发生这样的错误，我们就有备无患了。

当你认为可能发生了错误时，可编写一个 try-except 代码块来处理可能引发的异常。你让 Python 尝试运行一些代码，并告诉它如果这些代码引发了指定的异常，该怎么办。我们将导致错误的代码行 print(5/0) 放在了一个 try 代码块中。如果 try 代码块中的代码运行起来没有问题，Python 将跳过 except 代码块；如果 try 代码块中的代码导致了错误，Python 将查找这样的 except  代码块，并运行其中的代码，即其中指定的错误与引发的错误相同。

在这个示例中，try 代码块中的代码引发了 ZeroDivisionError 异常，因此 Python 指出了该如何解决问题的 except 代码块，并运行其中的代码。这样，用户看到的是一条友好的错误消息，而不是 traceback：You can't divide by zero!

发生错误时，如果程序还有工作没有完成，妥善地处理错误就尤其重要。这种情况经常会出现在要求用户提供输入的程序中；如果程序能够妥善地处理无效输入，就能再提示用户提供有效输入，而不至于崩溃。

程序崩溃可不好，但让用户看到 traceback 也不是好主意。不懂技术的用户会被它们搞糊涂，而且如果用户怀有恶意，他会通过 traceback 获悉你不希望他知道的信息。例如，他将知道你的程序文件的名称，还将看到部分不能正确运行的代码。有时候，训练有素的攻击者可根据这些信息判断出可对你的代码发起什么样的攻击。

通过将可能引发错误的代码放在 try-except 代码块中，可提高这个程序抵御错误的能力。错误是执行除法运算的代码行导致的，因此我们需要将它放到 try-except 代码块中。这个示例还包含一个 else 代码块；依赖于 try 代码块成功执行的代码都应放到 else 代码块中：

try-except-else 代码块的工作原理大致如下：Python 尝试执行 try 代码块中的代码；只有可能引发异常的代码才需要放在 try 语句中。有时候，有一些仅在 try 代码块成功执行时才需要运行的代码；这些代码应放在 else 代码块中。except 代码块告诉 Python，如果它尝试运行 try 代码块中的代码时引发了指定的异常，该怎么办。通过预测可能发生错误的代码，可编写健壮的程序，它们即便面临无效数据或缺少资源，也能继续运行，从而能够抵御无意的用户错误和恶意的攻击。

使用文件时，一种常见的问题是找不到文件：你要查找的文件可能在其他地方、文件名可能不正确或者这个文件根本就不存在。对于所有这些情形，都可使用 try-except 代码块以直观的方式进行处理。

下面来提取童话 Alice in Wonderland 的文本，并尝试计算它包含多少个单词。我们将使用方法 split()，它根据一个字符串创建一个单词列表。下面是对只包含童话名「Alice in Wonderland」的字符串调用方法 split() 的结果：

方法 split() 以空格为分隔符将字符串分拆成多个部分，并将这些部分都存储到一个列表中。结果是一个包含字符串中所有单词的列表，虽然有些单词可能包含标点。为计算 Alice in Wonderland 包含多少个单词，我们将对整篇小说调用 split()，再计算得到的列表包含多少个元素，从而确定整篇童话大致包含多少个单词：

我们把文件 alice.txt 移到了正确的目录中，让 try 代码块能够成功地执行。在 ❶ 处，我们对变量 contents （它现在是一个长长的字符串，包含童话 Alice in Wonderland 的全部文本）调用方法 split()，以生成一个列表，其中包含这部童话中的所有单词。当我们使用 len() 来确定这个列表的长度时，就知道了原始字符串大致包含多少个单词（见❷）。在 ❸ 处，我们打印一条消息，指出文件包含多少个单词。这些代码都放在 else 代码块中，因为仅当 try 代码块成功执行时才执行它们。输出指出了文件 alice.txt 包含多少个单词：

这些代码大都与原来一样，我们只是将它们移到了函数 count_words() 中，并增加了缩进量。修改程序的同时更新注释是个不错的习惯，因此我们将注释改成了文档字符串，并稍微调整了一下措辞（见❶）。现在可以编写一个简单的循环，计算要分析的任何文本包含多少个单词了。为此，我们将要分析的文件的名称存储在一个列表中，然后对列表中的每个文件都调用 count_words()。我们将尝试计算 Alice in Wonderland 、Siddhartha 、Moby Dick 和 Little Women 分别包含多少个单词，它们都不受版权限制。我故意没有将 siddhartha.txt 放到 word_count.py 所在的目录中，让你能够看到这个程序在文件不存在时处理得有多出色：

在这个示例中，使用 try-except 代码块提供了两个重要的优点：避免让用户看到 traceback；让程序能够继续分析能够找到的其他文件。如果不捕获因找不到 siddhartha.txt 而引发的 FileNotFoundError 异常，用户将看到完整的 traceback，而程序将在尝试分析 Siddhartha 后停止运行——根本不分析 Moby Dick 和 Little Women。

在前一个示例中，我们告诉用户有一个文件找不到。但并非每次捕获到异常时都需要告诉用户，有时候你希望程序在发生异常时一声不吭，就像什么都没有发生一样继续运行。要让程序在失败时一声不吭，可像通常那样编写 try 代码块，但在 except 代码块中明确地告诉 Python 什么都不要做。Python 有一个 pass 语句，可在代码块中使用它来让 Python 什么都不要做：

pass 语句还充当了占位符，它提醒你在程序的某个地方什么都没有做，并且以后也许要在这里做些什么。例如，在这个程序中，我们可能决定将找不到的文件的名称写入到文件 missing_files.txt 中。用户看不到这个文件，但我们可以读取这个文件，进而处理所有文件找不到的问题。

在什么情况下该向用户报告错误？在什么情况下又应该在失败时一声不吭呢？如果用户知道要分析哪些文件，他们可能希望在有文件没有分析时出现一条消息，将其中的原因告诉他们。如果用户只想看到结果，而并不知道要分析哪些文件，可能就无需在有些文件不存在时告知他们。向用户显示他不想看到的信息可能会降低程序的可用性。Python 的错误处理结构让你能够细致地控制与用户分享错误信息的程度，要分享多少信息由你决定。

编写得很好且经过详尽测试的代码不容易出现内部错误，如语法或逻辑错误，但只要程序依赖于外部因素，如用户输入、存在指定的文件、有网络链接，就有可能出现异常。凭借经验可判断该在程序的什么地方包含异常处理块，以及出现错误时该向用户提供多少相关的信息。

很多程序都要求用户输入某种信息，如让用户存储游戏首选项或提供要可视化的数据。不管专注的是什么，程序都把用户提供的信息存储在列表和字典等数据结构中。用户关闭程序时，你几乎总是要保存他们提供的信息；一种简单的方式是使用模块 json 来存储数据。

模块 json 让你能够将简单的 Python 数据结构转储到文件中，并在程序再次运行时加载该文件中的数据。你还可以使用 json 在 Python 程序之间分享数据。更重要的是，JSON 数据格式并非 Python 专用的，这让你能够将以 JSON 格式存储的数据与使用其他编程语言的人分享。这是一种轻便格式，很有用，也易于学习。

JSON（JavaScript Object Notation）格式最初是为 JavaScript 开发的，但随后成了一种常见格式，被包括 Python 在内的众多语言采用。

我们来编写一个存储一组数字的简短程序，再编写一个将这些数字读取到内存中的程序。第一个程序将使用 json.dump() 来存储这组数字，而第二个程序将使用 json.load()。

函数 json.dump() 接受两个实参：要存储的数据以及可用于存储数据的文件对象。下面演示了如何使用 json.dump() 来存储数字列表：

对于用户生成的数据，使用 json 保存它们大有裨益，因为如果不以某种方式进行存储，等程序停止运行时用户的信息将丢失。下面来看一个这样的例子：用户首次运行程序时被提示输入自己的名字，这样再次运行程序时就记住他了。

你经常会遇到这样的情况：代码能够正确地运行，但可做进一步的改进——将代码划分为一系列完成具体工作的函数。这样的过程被称为重构。重构让代码更清晰、更易于理解、更容易扩展。

要重构 remember_me.py，可将其大部分逻辑放到一个或多个函数中。remember_me.py 的重点是问候用户，因此我们将其所有代码都放到一个名为 greet_user() 的函数中：

在 remember_me.py 的这个最终版本中，每个函数都执行单一而清晰的任务。我们调用 greet_user()，它打印一条合适的消息：要么欢迎老用户回来，要么问候新用户。为此，它首先调用 get_stored_username()，这个函数只负责获取存储的用户名（如果存储了的话），再在必要时调用 get_new_username()，这个函数只负责获取并存储新用户的用户名。要编写出清晰而易于维护和扩展的代码，这种划分工作必不可少。

## 11. 测试代码

### 1. 逻辑脉络

如何使用模块 unittest 中的工具来为函数和类编写测试。

### 2. 摘录及评论

在本章中，你学习了：如何使用模块 unittest 中的工具来为函数和类编写测试；如何编写继承 unittest.TestCase 的类，以及如何编写测试方法，以核实函数和类的行为符合预期；如何使用方法 setUp() 来根据类高效地创建实例并设置其属性，以便在类的所有测试方法中都可使用它们。

测试是很多初学者都不熟悉的主题。作为初学者，并非必须为你尝试的所有项目编写测试；但参与工作量较大的项目时，你应对自己编写的函数和类的重要行为进行测试。这样你就能够更加确定自己所做的工作不会破坏项目的其他部分，你就能够随心所欲地改进既有代码了。如果不小心破坏了原来的功能，你马上就会知道，从而能够轻松地修复问题。相比于等到不满意的用户报告 bug 后再采取措施，在测试未通过时采取措施要容易得多。

如果你在项目中包含了初步测试，其他程序员将更敬佩你，他们将能够更得心应手地尝试使用你编写的代码，也更愿意与你合作开发项目。如果你要跟其他程序员开发的项目共享代码，就必须证明你编写的代码通过了既有测试，通常还需要为你添加的新行为编写测试。

请通过多开展测试来熟悉代码测试过程。对于自己编写的函数和类，请编写针对其重要行为的测试，但在项目早期，不要试图去编写全覆盖的测试用例，除非有充分的理由这样做。

编写函数或类时，还可为其编写测试。通过测试，可确定代码面对各种输入都能够按要求的那样工作。测试让你信心满满，深信即便有更多的人使用你的程序，它也能正确地工作。在程序中添加新代码时，你也可以对其进行测试，确认它们不会破坏程序既有的行为。程序员都会犯错，因此每个程序员都必须经常测试其代码，在用户发现问题前找出它们。

在本章中，你将学习如何使用 Python 模块 unittest 中的工具来测试代码。你将学习编写测试用例，核实一系列输入都将得到预期的输出。你将看到测试通过了是什么样子，测试未通过又是什么样子，还将知道测试未通过如何有助于改进代码。你将学习如何测试函数和类，并将知道该为项目编写多少个测试。

