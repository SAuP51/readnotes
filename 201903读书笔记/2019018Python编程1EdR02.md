# 2019018Python编程R02

## 记忆时间


## 15 生成数据

### 1. 逻辑脉络

如何用 matplotlib 来作图；如何实现产生随机数；如何使用 pygal 来创建直方图（矢量图）。

### 2. 摘录及评论

在本章中，你学习了：如何生成数据集以及如何对其进行可视化；如何使用 matplotlib 创建简单的图表，以及如何使用散点图来探索随机漫步过程；如何使用 Pygal 来创建直方图，以及如何使用直方图来探索同时掷两个面数不同的骰子的结果。

使用代码生成数据集是一种有趣而强大的方式，可用于模拟和探索现实世界的各种情形。完成后面的数据可视化项目时，请注意可使用代码模拟哪些情形。请研究新闻媒体中的可视化，看看其中是否有图表是以你在这些项目中学到的类似方式生成的。

数据可视化指的是通过可视化表示来探索数据，它与数据挖掘紧密相关，而数据挖掘指的是使用代码来探索数据集的规律和关联。数据集可以是用一行代码就能表示的小型数字列表，也可以是数以吉字节的数据。

漂亮地呈现数据关乎的并非仅仅是漂亮的图片。以引人注目的简洁方式呈现数据，让观看者能够明白其含义，发现数据集中原本未意识到的规律和意义。

所幸即便没有超级计算机，也能够可视化复杂的数据。鉴于 Python 的高效性，使用它在笔记本电脑上就能快速地探索由数百万个数据点组成的数据集。数据点并非必须是数字，利用本书前半部分介绍的基本知识，也可以对非数字数据进行分析。

在基因研究、天气研究、政治经济分析等众多领域，大家都使用 Python 来完成数据密集型工作。数据科学家使用 Python 编写了一系列令人印象深刻的可视化和分析工具，其中很多也可供你使用。最流行的工具之一是 matplotlib，它是一个数学绘图库，我们将使用它来制作简单的图表，如折线图和散点图。然后，我们将基于随机漫步概念生成一个更有趣的数据集——根据一系列随机决策生成的图表。

我们还将使用 Pygal 包，它专注于生成适合在数字设备上显示的图表。通过使用 Pygal，可在用户与图表交互时突出元素以及调整其大小，还可轻松地调整整个图表的尺寸，使其适合在微型智能手表或巨型显示器上显示。我们将使用 Pygal 以各种方式探索掷骰子的结果。

1『

WARNING: The scripts f2py, f2py3 and f2py3.7 are installed in '/Users/Daglas/Library/Python/3.7/bin' which is not on PATH.

Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.

』

安装必要的包后，对安装进行测试。为此，首先使用命令 python 或 python3 启动一个终端会话，再尝试导入 matplotlib：

```
$ python3

>>> import matplotlib

>>>
```

如果没有出现任何错误消息，就说明你的系统安装了 matplotlib。

要查看使用 matplotlib 可制作的各种图表，请访问 http://matplotlib.org/ 的示例画廊。单击画廊中的图表，就可查看用于生成图表的代码。

3『[Matplotlib: Python plotting — Matplotlib 3.1.1 documentation](https://matplotlib.org/)』

在本节中，我们将使用 Python 来生成随机漫步数据，再使用 matplotlib 以引人瞩目的方式将这些数据呈现出来。随机漫步是这样行走得到的路径：每次行走都完全是随机的，没有明确的方向，结果是由一系列随机决策决定的。你可以这样认为，随机漫步就是蚂蚁在晕头转向的情况下，每次都沿随机的方向前行所经过的路径。

在自然界、物理学、生物学、化学和经济领域，随机漫步都有其实际用途。例如，漂浮在水滴上的花粉因不断受到水分子的挤压而在水面上移动。水滴中的分子运动是随机的，因此花粉在水面上的运动路径犹如随机漫步。我们稍后将编写的代码模拟了现实世界的很多情形。

我们首先导入了模块 pyplot 和 RandomWalk 类，然后创建了一个 RandomWalk 实例，并将其存储到 rw 中（见❶），再调用 fill_walk() 。在 ❷ 处，我们将随机漫步包含的 x 和 y 值传递给 scatter() ，并选择了合适的点尺寸。图 15-8 显示了包含 5000 个点的随机漫步图（本节的示意图未包含 matplotlib 查看器部分，但你运行 rw_visual.py 时，依然会看到）。

这些代码模拟一次随机漫步，在 matplotlib 查看器中显示结果，再在不关闭查看器的情况下暂停。如果你关闭查看器，程序将询问你是否要再模拟一次随机漫步。如果你输入 y ，可模拟多次随机漫步：这些随机漫步都在起点附近进行，大多沿特定方向偏离起点，漫步点分布不均匀等。要结束程序，请输入 n 。

1『这里的这个 while 语句，提供了一个实现控制 matplotlib 查看器的实现办法。』

在 ❶ 处，我们使用了 range() 生成了一个数字列表，其中包含的数字个数与漫步包含的点数相同。接下来，我们将这个列表存储在 point_numbers 中，以便后面使用它来设置每个漫步点的颜色。我们将参数 c 设置为 point_numbers ，指定使用颜色映射 Blues ，并传递实参 edgecolor=none 以删除每个点周围的轮廓。最终的随机漫步图从浅蓝色渐变为深蓝色，如图 15-9 所示。

1『这里面涉及到方法希望以后有机会可以弄明白。』

为修改坐标轴，使用了函数 plt.axes() （见❶）来将每条坐标轴的可见性都设置为 False 。随着你越来越多地进行数据可视化，经常会看到这种串接方法的方式。

函数 figure() 用于指定图表的宽度、高度、分辨率和背景色。你需要给形参 figsize 指定一个元组，向 matplotlib 指出绘图窗口的尺寸，单位为英寸。

Python 假定屏幕分辨率为 80 像素/英寸，如果上述代码指定的图表尺寸不合适，可根据需要调整其中的数字。如果你知道自己的系统的分辨率，可使用形参 dpi 向 figure() 传递该分辨率，以有效地利用可用的屏幕空间，如下所示：

	plt.figure(dpi=128, figsize=(10, 6))

在本节中，我们将使用 Python 可视化包 Pygal 来生成可缩放的矢量图形文件。对于需要在尺寸不同的屏幕上显示的图表，这很有用，因为它们将自动缩放，以适合观看者的屏幕。如果你打算以在线方式使用图表，请考虑使用 Pygal 来生成它们，这样它们在任何设备上显示时都会很美观。

在这个项目中，我们将对掷骰子的结果进行分析。掷 6 面的常规骰子时，可能出现的结果为 1~6 点，且出现每种结果的可能性相同。然而，如果同时掷两个骰子，某些点数出现的可能性将比其他点数大。为确定哪些点数出现的可能性最大，我们将生成一个表示掷骰子结果的数据集，并根据结果绘制出一个图形。

在数学领域，常常利用掷骰子来解释各种数据分析，但它在赌场和其他博弈场景中也得到了实际应用，在游戏《大富翁》以及众多角色扮演游戏中亦如此。

要了解使用 Pygal 可创建什么样的图表，请查看图表类型画廊：访问 http://www.pygal.org/ ，单击 Documentation，再单击 Chart types。每个示例都包含源代码，让你知道这些图表是如何生成的。

1『[Pygal — pygal 2.0.0 documentation](http://www.pygal.org/en/stable/)』

1『

创建 Die 类时总是报错：unindent does not match any outer indentation level

怎么也找不出来 die.py 里哪错了，最后重新敲了一遍代码就解决了。

』

为创建条形图，我们创建了一个 pygal.Bar() 实例，并将其存储在 hist 中（见❶）。接下来，我们设置 hist 的属性 title （用于标示直方图的字符串），将掷 D6 骰子的可能结果用作 x 轴的标签（见❷），并给每个轴都添加了标题。在 ❸ 处，我们使用 add() 将一系列值添加到图表中（向它传递要给添加的值指定的标签，还有一个列表，其中包含将出现在图表中的值）。最后，我们将这个图表渲染为一个 SVG 文件，这种文件的扩展名必须为 .svg。要查看生成的直方图，最简单的方式是使用 Web 浏览器。为此，在任何 Web 浏览器中新建一个标签页，再在其中打开文件 die_visual.svg（它位于 die_visual.py 所在的文件夹中）。

注意，Pygal 让这个图表具有交互性：如果你将鼠标指向该图表中的任何条形，将看到与之相关联的数据。在同一个图表中绘制多个数据集时，这项功能显得特别有用。

## 16 下载数据

### 1. 逻辑脉络

csv 和 json 文件的概念，以及如何使用它们；加深学习使用 pygal 库。

### 2. 摘录及评论

在本章中，你学习了：如何使用网上的数据集；如何处理 CSV 和 JSON 文件，以及如何提取你感兴趣的数据；如何使用 matplotlib 来处理以往的天气数据，包括如何使用模块 datetime，以及如何在同一个图表中绘制多个数据系列；如何使用 Pygal 绘制呈现各国数据的世界地图，以及如何设置 Pygal 地图和图表的样式。

有了使用 CSV 和 JSON 文件的经验后，你将能够处理几乎任何要分析的数据。大多数在线数据集都可以以这两种格式中的一种或两种下载。学习使用这两种格式为学习使用其他格式的数据做好了准备。

在本章中，你将从网上下载数据，并对这些数据进行可视化。网上的数据多得难以置信，且大多未经过仔细检查。如果能够对这些数据进行分析，你就能发现别人没有发现的规律和关联。

我们将访问并可视化以两种常见格式存储的数据：CSV 和 JSON。我们将使用 Python 模块 csv 来处理以 CSV（逗号分隔的值）格式存储的天气数据，找出两个不同地区在一段时间内的最高温度和最低温度。然后，我们将使用 matplotlib 根据下载的数据创建一个图表，展示两个不同地区的气温变化：阿拉斯加锡特卡和加利福尼亚死亡谷。在本章的后面，我们将使用模块 json 来访问以 JSON 格式存储的人口数据，并使用 Pygal 绘制一幅按国别划分的人口地图。

阅读本章后，你将能够处理各种类型和格式的数据集，并对如何创建复杂的图表有更深入的认识。要处理各种真实世界的数据集，必须能够访问并可视化各种类型和格式的在线数据。

要在文本文件中存储数据，最简单的方式是将数据作为一系列以逗号分隔的值 （CSV）写入文件。这样的文件称为 CSV 文件。例如，下面是一行 CSV 格式的天气数据：

	2014-1-5,61,44,26,18,7,-1,56,30,9,30.34,30.27,30.15,,,,10,4,,0.00,0,,195

这是阿拉斯加锡特卡 2014 年 1 月 5 日的天气数据，其中包含当天的最高气温和最低气温，还有众多其他数据。CSV 文件对人来说阅读起来比较麻烦，但程序可轻松地提取并处理其中的值，这有助于加快数据分析过程。

导入模块 csv 后，我们将要使用的文件的名称存储在 filename 中。接下来，我们打开这个文件，并将结果文件对象存储在 f 中（见❶）。然后，我们调用 csv.reader() ，并将前面存储的文件对象作为实参传递给它，从而创建一个与该文件相关联的阅读器（reader ）对象（见❷）。我们将这个阅读器对象存储在 reader 中。

模块 csv 包含函数 next() ，调用它并将阅读器对象传递给它时，它将返回文件中的下一行。在前面的代码中，我们只调用了 next() 一次，因此得到的是文件的第一行，其中包含文件头（见❸）。我们将返回的数据存储在 header_row 中。正如你看到的，header_row 包含与天气相关的文件头，指出了每行都包含哪些数据：

reader 处理文件中以逗号分隔的第一行数据，并将每项数据都作为一个元素存储在列表中。文件头 AKDT 表示阿拉斯加时间（Alaska Daylight Time），其位置表明每行的第一个值都是日期或时间。文件头 Max TemperatureF 指出每行的第二个值都是当天的最高华氏温度。可通过阅读其他的文件头来确定文件包含的信息类型。

注意：文件头的格式并非总是一致的，空格和单位可能出现在奇怪的地方。这在原始数据文件中很常见，但不会带来任何问题。

读取该数据时，获得的是一个字符串，因为我们需要想办法将字符串 '2014-7-1' 转换为一个表示相应日期的对象。为创建一个表示 2014 年 7 月 1 日的对象，可使用模块 datetime 中的方法 strptime() 。我们在终端会话中看看 strptime() 的工作原理：

我们首先导入了模块 datetime 中的 datetime 类，然后调用方法 strptime() ，并将包含所需日期的字符串作为第一个实参。第二个实参告诉 Python 如何设置日期的格式。在这个示例中，'%Y-' 让 Python 将字符串中第一个连字符前面的部分视为四位的年份；'%m-' 让 Python 将第二个连字符前面的部分视为表示月份的数字；而 '%d' 让 Python 将字符串的最后一部分视为月份中的一天（1~31）。方法 strptime() 可接受各种实参，并根据它们来决定如何解读日期。表 16-1 列出了其中一些这样的实参。

	dates, highs = [], []

1『原来同时创建 2 个空列表还能这么操作的。』

我们创建了两个空列表，用于存储从文件中提取的日期和最高气温（见❶）。然后，我们将包含日期信息的数据（row[0] ）转换为 datetime 对象（见❷），并将其附加到列表 dates 末尾。在 ❸ 处，我们将日期和最高气温值传递给 plot() 。在 ❹ 处，我们调用了 fig.autofmt_xdate() 来绘制斜的日期标签，以免它们彼此重叠。图 16-2 显示了改进后的图表。

添加两个数据系列后，我们就可以了解每天的气温范围了。下面来给这个图表做最后的修饰，通过着色来呈现每天的气温范围。为此，我们将使用方法 fill_between() ，它接受一个 x 值系列和两个 y 值系列，并填充两个 y 值系列之间的空间：

❶处的实参alpha 指定颜色的透明度。Alpha 值为 0 表示完全透明，1（默认设置）表示完全不透明。通过将alpha 设置为0.5，可让红色和蓝色折线的颜色看起来更浅。

在 ❷ 处，我们向 fill_between() 传递了一个 x 值系列：列表 dates ，还传递了两个 y 值系列：highs 和 lows 。实参 facecolor 指定了填充区域的颜色，我们还将 alpha 设置成了较小的值 0.1，让填充区域将两个数据系列连接起来的同时不分散观察者的注意力。图 16-5 显示了最高气温和最低气温之间的区域被填充的图表。

我们应该能够使用有关任何地方的天气数据来运行 highs_lows.py 中的代码，但有些气象站会偶尔出现故障，未能收集部分或全部其应该收集的数据。缺失数据可能会引发异常，如果不妥善地处理，还可能导致程序崩溃。

其中好像没有记录 2014 年 2 月 16 日的数据，表示最高温度的字符串为空。为解决这种问题，我们在从 CSV 文件中读取值时执行错误检查代码，对分析数据集时可能出现的异常进行处理，如下所示：

对于每一行，我们都尝试从中提取日期、最高气温和最低气温（见❶）。只要缺失其中一项数据，Python 就会引发 ValueError 异常，而我们可这样处理：打印一条错误消息，指出缺失数据的日期（见❷）。打印错误消息后，循环将接着处理下一行。如果获取特定日期的所有数据时没有发生错误，将运行 else 代码块，并将数据附加到相应列表的末尾（见❸）。鉴于我们绘图时使用的是有关另一个地方的信息，我们修改了标题，在图表中指出了这个地方（见❹）。

使用的很多数据集都可能缺失数据、数据格式不正确或数据本身不正确。对于这样的情形，可使用本书前半部分介绍的工具来处理。在这里，我们使用了一个 try-except-else 代码块来处理数据缺失的问题。在有些情况下，需要使用 continue  来跳过一些数据，或者使用 remove() 或 del 将已提取的数据删除。可采用任何管用的方法，只要能进行精确而有意义的可视化就好。

Open Knowledge Foundation（http://data.okfn.org/ ）提供了大量可以免费使用的数据集，这些数据就来自其中一个数据集。

3『[Welcome - Home - DataHub - Frictionless Data](https://datahub.io/)』

16-6 选择你感兴趣的数据：免费的 JSON 格式数据非常丰富，许多著名的国际组织都在积极分享有价值的数据。例如 OpenKnowledgeInternational (https://okfn.org/）上就有许多有趣的 JSON 数据。你也可以用本节的方法获取它们，开启自己的分析项目。

[Home | Open Knowledge Foundation](https://okfn.org/)

16-8 尝试 Python 数据科学工具：虽然 Python 标准库对数据分析的支持相对有限，但是 Python 具有非常完善的数据科学生态系统，有许多易学易用、高效便捷的第三方开源数据分析工具。除了前面介绍的 matplotlik，还有科学计算工具包 [NumPy — NumPy](https://numpy.org/)、[SciPy.org — SciPy.org](https://www.scipy.org/)、快速数据分析工具 [Python Data Analysis Library — pandas: Python Data Analysis Library](https://pandas.pydata.org/)、机器学习工具 [scikit-learn: machine learning in Python — scikit-learn 0.22 documentation](https://scikit-learn.org/stable/) 以及让深度学习开发更简单的 [Home - Keras Documentation](https://keras.io/)，它支持 Tensorflow、CNTK 和 Theano）。如果感兴趣，可以用 Pandas 直接读取 JSON 文件数据，并进行格式转换、数据聚合、时间序列分析，结合 Scikit-learn 可以对收盘价进行回归分析与预测。









## 17 使用 API

### 1. 逻辑脉络


### 2. 摘录及评论

在本章中，你学习了：如何使用 API 来编写独立的程序，它们自动采集所需的数据并对其进行可视化；使用 GitHub API 来探索 GitHub 上星级最高的 Python 项目，还大致地了解了 Hacker News API；如何使用 requests 包来自动执行 GitHub API 调用，以及如何处理调用的结果。我们还简要地介绍了一些 Pygal 设置，使用它们可进一步定制生成的图表的外观。

在本章中，你将学习如何编写一个独立的程序，并对其获取的数据进行可视化。这个程序将使用 Web 应用编程接口 （API）自动请求网站的特定信息而不是整个网页，再对这些信息进行可视化。由于这样编写的程序始终使用最新的数据来生成可视化，因此即便数据瞬息万变，它呈现的信息也都是最新的。

Web API 是网站的一部分，用于与使用非常具体的 URL 请求特定信息的程序交互。这种请求称为 API 调用。请求的数据将以易于处理的格式（如 JSON 或 CSV）返回。依赖于外部数据源的大多数应用程序都依赖于 API 调用，如集成社交媒体网站的应用程序。

本章的可视化将基于来自 GitHub 的信息，这是一个让程序员能够协作开发项目的网站。我们将使用 GitHub 的 API 来请求有关该网站中 Python 项目的信息，然后使用 Pygal 生成交互式可视化，以呈现这些项目的受欢迎程度。

GitHub 的 API 让你能够通过 API 调用来请求各种信息。要知道 API 调用是什么样的，请在浏览器的地址栏中输入如下地址并按回车键：

	https://api.github.com/search/repositories?q=language:python&sort=stars

这个调用返回 GitHub 当前托管了多少个 Python 项目，还有有关最受欢迎的 Python 仓库的信息。下面来仔细研究这个调用。第一部分（https://api.github.com/ ）将请求发送到 GitHub 网站中响应 API 调用的部分；接下来的一部分（search/repositories ）让 API 搜索 GitHub 上的所有仓库。

repositories 后面的问号指出我们要传递一个实参。q 表示查询，而等号让我们能够开始指定查询（q= ）。通过使用 language:python ，我们指出只想获取主要语言为 Python 的仓库的信息。最后一部分（&sort=stars ）指定将项目按其获得的星级进行排序。

从第二行输出可知，编写本书时，GitHub 总共有 713 062 个 Python 项目。"incomplete_results" 的值为 false ，据此我们知道请求是成功的（它并非不完整的）。倘若 GitHub 无法全面处理该 API，它返回的这个值将为 true 。接下来的列表中显示了返回的 "items" ，其中包含 GitHub 上最受欢迎的 Python 项目的详细信息。

requests 包让 Python 程序能够轻松地向网站请求信，息以及检查返回的响应。

在 ❶ 处，我们导入了模块 requests 。在 ❷ 处，我们存储 API 调用的 URL，然后使用 requests 来执行调用（见❸）。我们调用 get() 并将 URL 传递给它，再将响应对象存储在变量 r 中。响应对象包含一个名为 status_code 的属性，它让我们知道请求是否成功了（状态码 200 表示请求成功）。在 ❹ 处，我们打印 status_code ，核实调用是否成功了。这个 API 返回 JSON 格式的信息，因此我们使用方法 json() 将这些信息转换为一个 Python 字典（见❺）。我们将转换得到的字典存储在 response_dict 中。

像这样简单的调用应该会返回完整的结果集，因此完全可以忽略与 'incomplete_results' 相关联的值。但执行更复杂的 API 调用时，程序应检查这个值。
















