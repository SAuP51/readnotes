# 03 深入了解 CPU

第 1 章我们说过，中央处理单元或者 CPU 是计算机的「大脑」，但当时并没有就这个术语多作讨论。这一章我们就来详细探讨一下 CPU，因为它是一台计算机中最重要的组件，而且理解其特性对理解本书后面的内容也至关重要。

中央处理器如何工作？ 它处理什么，怎么处理？直观来讲，CPU 有一个小型指令系统，包含着它能够执行的基本操作。它可以做算术题，加、减、乘、除，跟计算器一样。它可以从 RAM 中取得要操作的数据，然后再把结果保存到 RAM，与很多计算器中的存储操作一样。CPU 还要控制计算机的其他组件，确保鼠标、键盘等外围设备输入的数据得到响应，让信息在屏幕上得以显示，同时还要控制和协调连接到计算机的其他所有器件。

最重要的是，它可以作出决定 —— 尽管是简单的决定：它可以比较数值（这个数比那个数大吗？） 或者比较其他数据（这段信息与那段信息一样吗？），还能根据结果决定接下来做什么。这一条最重要，因为这意味着 CPU 能做的虽然比计算器多不了多少，但它可以在无人看管的情况下完成自己的工作。正如冯·诺依曼所说的：「要让这种机器完全自动化，即让它在计算开始后不再依赖人工操作。」

由于 CPU 能根据它所处理的数据决定下一步做什么，因此它就能自己运行整个系统。虽然其指令系统并不大，或者说并不复杂，但 CPU 每秒可以执行数十亿次运算，所以它能完成极为复杂的处理。

3.1 玩具计算机

为了解释 CPU 如何工作，我们先介绍一台不存在的机器。这是一台编造的或者说「假想的」计算机，它与真正计算机的原理相同，只不过要简单得多。因为这台计算机只存在于纸面上，所以我就可以随意设计它，让它能有助于我们理解计算机的工作机制。我还可以写一个真正的计算机程序，用它模拟我的纸面设计，这样就可以给假想的机器写程序，看看这些程序怎么运行。

我想了一下，就管这个编造的机器叫「玩具」计算机吧，因为它不是真的，但又具有真正计算机的很多特性。实际上，它跟 1960 年代末的小型机差不多是一个水平，某种程度上与冯·诺依曼论文中的例子相近。这个玩具有用来存储指令和数据的 RAM，还有一块额外的存储区叫累加器，其容量足以存储一个数值。累加器类似于计算器的显示屏，保存用户最近输入的数值，或者最近计算的结果。玩具还有一个指令表，只包含 10 个指令，都是前面提到过的基本操作。比如下面几个指令：

GET 从键盘获取数值并放到累加器中 PRINT 打印累加器中的内容 STORE M 把累加器中内容的副本保存到位置 M （累加器的内容不变） LOAD Val 把 Val 加载到累加器，Val 是一个值或值在存储器中的位置（Val 不变） ADD Val 把 Val 与累加器中的内容相加（Val 不变） STOP 停止运行

为了保证最简单，我们规定每个 RAM 位置可以保存一个数值或一条指令（至于如何表示先不说），这样就可以在 RAM 中保存由指令和数据共同组成的程序。运行时，CPU 从 RAM 的第一个位置开始，重复如下简单的循环：

读取 从 RAM 中取得下一条指令 译码 搞明白该指令要做什么 执行 执行指令 返回「读取」

而给这个「玩具」计算机编写程序，就是要写出一组完成相应任务的指令，把它们放到 RAM 中，然后告诉 CPU 去执行这些指令。举个例子，比如 RAM 中正有如下指令（指令在 RAM 中都保存为等价的数值形式）：

GET PRINT STOP

运行程序时，第一条指令会要求用户输入一个数值，第二条指令会把该数值打印出来，而第三条指令告诉处理器停止执行。这个过程似乎很无聊，但却足以说明程序是如何运行的。假如真有这么个「玩具」计算机，这个程序还真能运行哩。巧啦，确实有这种「玩具」计算机，下面就是其中一个在运行时的样子了：

按下 RUN，出现一个对话框：

键入一个数字，按下 OK，结果就这样了：

跟我们期望的一样，程序要求输入数值，打印它，然后停下来。

再看一个复杂些的程序。这个程序多了向 RAM 中存储值，然后再取出的操作。具体来说，程序先把一个数读到累加器中，然后把这个数保存到存储器，再把另一个数读到累加器中（覆盖前一个数），给它加上第一个数（从 RAM 中保存该数的位置取出），打印两个数的和，然后停下来：

GET 取得第一个数并放到累加器中 STORE Mem 把这个数保存到 RAM 中的位置 Mem GET 取得第二个数并放到累加器中 ADD Mem 给它加上第一个数 PRINT 打印两个数的和 STOP Mem － RAM 中的一个位置，保存用户输入的第一个数值

CPU 从程序的起点开始，每次取得一条指令。执行完一条指令后，继续取得并执行下一条指令。

唯一麻烦点儿的地方是要在 RAM 中辟出一个位置，好保存读到的第一个值。但不能把这个值留在累加器中，因为第二个 GET 指令会覆盖它。由于它是数据，而非指令，因此必须把它放在 RAM 中一个不会被当成指令取出来的位置。把数据放到程序末尾，所有指令后面，CPU 就不会把它解释成指令了，因为 STOP 指令会让 CPU 停下来，不会继续读取下一个位置。

还需要一种引用该位置的方法，这样程序中的指令才能在必要时找到它。或许可以把它放在存储器的第七个位置（即第六条指令后面），但这样就要先数一数有多少条指令，很麻烦，而且一旦修改了程序，位置可能也要随之变更。通行的做法是给该数据项起个名字（第 5 章也会讨论），让一个程序负责跟踪记录该数据项在 RAM 中的实际位置，然后用实际的位置代替名字。名字可以任意起，但最好是起一个让人一看就明白相应数据或指令含义的名字。比如，这里的 Mem，其实改为 Firstnum 更好理解。

怎么扩展这个程序，让它能计算三个数的和呢？没错，可以再加一组 STORE、GET 和 ADD 指令（有两个位置可以插入这组指令），但这种方法肯定不能扩展到 1000 个数相加。并且，在事先不知道有多少数的情况下也行不通。

答案是给 CPU 的指令表增加一个新指令，通过它能重用已有的指令序列。这就是 GOTO 指令，有时候也叫「分支」或「跳转」，它告诉 CPU 读取下一条指令时不要从序列中的下一个位置读，而要从它指定的位置读。

使用 GOTO 指令，可以让 CPU 返回到程序的前面，重复执行指令。举一个简单的例子，比如写一个程序随时显示每个输入的值。这个功能正是数据复制程序的核心，也能说明 GOTO 指令的作用。我给这个程序的第一条指令加了个标签，叫 Top（能说明其角色的任何名字都行），而最后一条指令告诉 CPU 再返回到程序的第一条指令：

Top GET 取得一个数并放到累加器中 PRINT 打印出来 GOTO Top 返回 Top，取得另一个数

问题只解决了一半：可以重用指令，但却没办法停止循环。为此，还得再增加一条指令，该指令先测试一个条件，然后决定接下来该做什么，而不是一味往前走。这样的指令被称为「条件分支」指令，或条件跳转、条件转向。现实中，不同的机器在实现该指令时测试的条件会有所不同，但有一种可能是测试某个值是否等于零，如果是则跳到某个位置。那好，我们就给这个「玩具」计算机的指令表添加一个 IFZERO 指令，它会在累加器的值等于零的时候把 CPU 引导到一个指定的位置，否则继续顺序执行下一条指令。下面这个程序就使用了 IFZERO，该程序会在输入值不等于零的情况下不断打印输入的值：

Top GET 取得一个数并放到累加器中 IFZERO Bot 如果累加器的值为零，跳到标签为 Bot 的指令 PRINT 值不是零，打印出来 GOTO Top 返回 Top，取得另一个数 Bot STOP

只要用户不觉得无聊，这个程序就会不断取得数据并打印出来。如果用户输入了零，程序就会跳到 STOP 指令（标签 Bot 代表「bottom」，即「末尾」的意思）并退出。

注意，程序不会打印那个表示终止输入的零。怎么修改一下程序，让它能打印出这个零再停止呢？这个问题不难 —— 答案明摆着 —— 但它却足以揭示一个现象：简单地交换两个指令的位置，就能导致程序的行为与我们的设想出现偏差，或者说会导致程序去做一些与我们希望的完全不同的事。

组合使用 GOTO 和 IFZERO，可以写出在指定条件为真之前可以重复执行指令的程序，而 CPU 也可以根据之前计算的结果改变计算过程。指令表中有了 IFZERO 之后，我们的玩具 CPU 可以执行任何计算。尽管有点难以想象，但这些指令足以应对数字计算机能够完成的任何计算 —— 任何计算都可以分解为能使用基本指令完成的小步骤。关于任务分解的思想，我们会随时随地提到，因为它太重要了。（想一想，既然有了 IFZERO，那严格来讲 GOTO 还有必要吗？能不能用前者来模拟后者呢？）

例如，下面这个程序可以把一大堆数加起来，到输入了零为止。使用特殊的值终止循环输入是一种常见的做法。因为对于求几个数之和的计算，加零没有意义，所以这里使用零很合适。

Top GET 取得一个数 IFZERO Bot 如果这个数是零，转到 Bot ADD Sum 把累计的和与这个数相加 STORE Sum 把结果存储为一个新的累计和 GOTO Top 返回 Top 再取得另一个数 Bot LOAD Sum 把累计和加载到累加器 PRINT 然后打印出来 STOP Sum 0 保存累计和的存储器位置 （程序启动时的初始值为 0）

玩具模拟器对这个程序最后一行的「指令」是这样解读的：给一个存储器位置命名，然后在程序运行前放进去一个值。之所以需要这样做，是因为程序要计算很多数的和，而且累计和的初始值必须从零开始。

怎么检验这个程序，确定它没问题呢？表面上看没有问题，但有些问题很容易被忽视，所以有必要进行系统的测试。注意这里说的是「系统的测试」，并非随便给程序输入几个值。

最简单的测试用例是什么？如果根本没有要相加的数，除了用来终止输入的零，则和应该为零，这就是第一个测试用例。然后要试试只输入一个数，而和就应该是那个数。接下来可以试试两个数，这两个数的和你是知道的，比如 1 加 2 等于 3。此时，基本上就可以确定程序没有问题了。假如你真用心的话，通过一步一步地仔细过几遍指令，就可以在程序上机之前完成对代码的测试。优秀的程序员无论写什么都会自己先做这种检查。

到目前为止，我们一直没有讨论指令和数据在 RAM 中是如何表示的。说一种可能性吧，比如每条指令都需要一个存储器的位置存储其数值代码，而在该指令引用存储器位置或有一个数据值的情况下，还需要另一个紧随其后的位置。也就是说，IFZERO 和 ADD 等指令因为引用了存储器位置，所以要占用两个存储器单元，其中第二个单元中保存的是它引用的位置； 同样假设数据值也要占用一个位置。这是一种简化，但实际情况也差不太多。最后，假设各个指令的数值代码（按它们在前几页中出现的先后顺序）分别为：GET=1、PRINT=2、STORE=3、LOAD=4、ADD=5、STOP=6、GOTO=7、IFZERO=8。

现在，我们来看看前面计算一系列数之和的程序。在程序刚开始运行的时候，RAM 中的内容如下图所示。图中也给出了为三个存储器位置指定的名字，给出了指令以及存储器单元的地址。

前面的玩具模拟器是使用 JavaScript 写的，第 7 章将介绍 JavaScript。扩展这个模拟器很容易，就算你以前从来没见过计算机程序，也可以给它添加一条乘法指令，或者其他的条件分支指令。

3.2 真正的 CPU

CPU 反复执行简单的循环：从存储器中取得下一条指令，该指令正常情况下保存在存储器的下一个位置，但也可以是使用 GOTO 或 IFZERO 指定的位置；对指令进行译码，也就是搞清楚这条指令要干什么，然后为执行该指令做好准备；执行指令，从存储器中取得信息，完成算术或逻辑运算，保存结果，总之是执行与指令匹配的组合操作；然后再从头取得指令，开始下一次循环。真正的处理器也执行同样的「取指令－译码－执行」循环，只不过为了加快处理速度，还会配备精心设计的各种机制。但核心只有循环，与前面重复把数值加起来的例子一样。

真正计算机的指令比我们玩具计算机的多，但性质相同。比如，有更多移动数据的指令，更多完成算术运算及操作不同大小和类型数值的指令，更多比较和分支指令，以及控制计算机其他组件的指令。典型的 CPU 有几十到数百个不同的指令；指令和数据通常要占用多个内存位置，通常为 2 至 8 个字节。真正的处理器有多个累加器，通常是 16 或 32 个，所以可以保存多个中间结果，而且都是速度极快的存储器。真正的程序与我们的玩具示例相比可谓庞大，有的甚至多达数百万条指令。至于如何编写这么大的程序，本书后面有关软件的章节会详细讨论。

计算机体系结构是研究 CPU 与其他计算机组件连接的一门学科。在大学里，它通常是计算机科学和电子工程的交叉领域。

计算机体系结构研究的一个问题是指令集，也就是处理器配备的指令表。是设计较多的指令去处理各式各样的计算，还是设计较少的指令以简化制造并提升速度？体系结构涉及复杂的权衡，要综合考虑功能、速度、复杂性、可编程能力（如果太复杂，程序员将无法利用其功能）、电源消耗及其他问题。用冯·诺依曼的话说：「一般来讲，运算器内在的经济性取决于期望的机器运行速度…… 与期望的简易性或低价位之间的折中。」

CPU 与 RAM 和计算机的其他组件是如何连接的？处理器非常快，通常执行一条指令只需要零点几纳秒。（1 纳秒等于十亿分之一秒，或者 10-9 秒。）相对而言，RAM 则慢得让人难以忍受 —— 从存储器中取得数据或指令大概要花 25 到 50 纳秒。当然，这里的快指的是绝对速度，而慢则是相对于 CPU 而言。假如 CPU 不必等待数据，那它可能早就执行完上百条指令了。

现代计算机会在 CPU 和 RAM 之间使用少量的高速存储器来保存最近使用过的指令和数据，这种高速存储器叫作缓存。如果可以从缓存中找到信息，那么就会比等待 RAM 返回数据快得多。下一节我们会详细介绍缓存及缓存机制。

设计师在设计体系结构的时候也有一套方法，能够让处理器跑得更快。比如，可以把 CPU 设计为交替地取得和执行指令，而同一时刻会有几个指令处于执行过程的不同阶段，这种设计叫做流水线。（与汽车装配线很相似。）结果呢，虽然某个特定的指令仍旧要花同样的时间完成，但其他指令都有机会得到处理，从整体上看完成这些指令则会快很多。另一种方法是并行执行多条互不干扰、互不依赖的指令，就相当于多条平行的汽车装配线。有时候，只要指令的操作不会相互影响，甚至可以不按顺序执行。


另外一种可能是同时运行多个 CPU。今天的笔记本电脑，甚至连手机都已经有多个 CPU 了。英特尔酷睿双核处理器在一块集成电路芯片上集成了两个 CPU（「核心」）。在一块芯片上集成越来越多的处理器已经成为明显的趋势。由于集成电路特征尺寸越来越小，因而可以集成在一块芯片上的晶体管数量必将越来越多，这些晶体管可以构成更多 CPU，也可以构成更多缓存。

处理器应用的领域决定了设计者要权衡哪些要素。很长时间以来，处理器主要的应用领域是桌面计算机，而桌面环境下的电源和物理空间都比较充足。因此，设计者只要专注于让处理器尽可能地快就好了，电源是用之不竭的，而散热只要多加风扇就行。笔记本电脑要求的权衡要素有了明显不同，一方面空间有限，另一方面在不插电的情况下，笔记本要靠沉重又昂贵的电池供电。其他方面条件不变，笔记本处理器必然要相对慢一些，耗电少一些。

手机和其他超轻便设备进一步提高了设计要求，因为尺寸、重量和电源各方面都有了更多限制。此时，单靠小范围调整设计是行不通的。虽然英特尔是台式机和笔记本处理器的主要供应商，但几乎所有的手机都使用「ARM」处理器，因为它耗电更少。ARM 处理器是指获得英国 ARM Holdings 公司许可制造的处理器。

比较不同 CPU 的速度并不是特别有意义。即便是最基本的算术运算，其处理方式也可以完全不同，很难直接比较。比如，同样是计算两个数的和并保存结果，有的处理器需要用三个指令（比如我们的玩具计算机），有的则需要两个，而有的可能只需要一个。有的 CPU 具有并行处理能力，或者说能够同时执行多条指令，从而让这些指令在不同阶段上执行。为了降低处理器的耗电量，牺牲执行速度，甚至根据是不是电池供电动态调整速度都是很常见的。对于某个处理器比另一个处理器「更快」的说法，不必太当真，因为很多情况下都要具体问题具体分析。

3.3 缓存

说到这里，有必要花点时间简单介绍一下缓存，这是一个在计算领域中广泛适用的思想。在 CPU 中，缓存是容量小但速度快的存储器，用于存储最近使用的信息，以避免访问 RAM。通常，CPU 会在短时间内连续多次访问某些数据和指令。例如，加法计算程序循环体中的多条指令，对每个输入值都要执行一遍。如果这些指令存储在缓存中，就不用在每次循环时都从 RAM 读取它们，这会让程序的速度快 50 倍。类似地，把 Sum 存储在数据缓存中也能提高访问速度。

典型的 CPU 有两到三个缓存，容量依次增大，但速度递减，一般称为一级缓存、二级缓存和三级缓存。最大的缓存能存储以兆字节计的数据（我的 Macbook 有 3MB 的二级缓存），大多数 CPU 的指令和数据缓存都是独立的。缓存之所以有用，关键在于最近用过的信息很可能再次被用到，而把它们存储在缓存里就意味着减少对 RAM 的等待。缓存通常会一次性加载一组信息块，比如只请求一个字节，但会加载 RAM 中一段连续的地址。因为相邻的信息也可能被用到，要用的时候它们同样已经在缓存里了，换句话说，对邻近信息的引用也不需要等待。

除了发现性能提升之外，用户是感受不到这种缓存的。但缓存的思想却无处不在，只要你现在用到的东西不久还会用到，或者可能会用到与之邻近的东西，那运用缓存思维就没错。CPU 中的多个累加器本质上也是一种缓存，只不过是高速缓存而已。RAM 也可以作为磁盘的缓存，而 RAM 和磁盘又都可以作为网络数据的缓存。计算机网络经常会利用缓存加速访问远程服务器，而服务器本身也有缓存。

在使用浏览器上网的时候，你可能见过「清空缓存」的字眼。对网页中的图片和其他体积较大的资源，浏览器会在本地保存一份副本，因为再次访问同一网页时，使用本地副本比重新下载速度快。缓存不能无限地增长，因此浏览器会悄悄地删除旧项目，以腾出空间给新的，它还给你提供了删除所有缓存内容的命令。

你自己随时可以检验缓存的效果。比如可以做下面两个实验，一是打开 Word 或 Firefox 等大程序，看看从启动到加载完成并可以使用要花多长时间。然后退出程序，立即重新启动它。正常情况下，第二次启动的速度会明显加快，因为程序的指令还在 RAM 里，而 RAM 正在充当磁盘的缓存。使用其他程序一段时间后，RAM 里会填满该程序的指令和数据，原先的程序就会从缓存中被删除。

二是在谷歌里搜索几个不太常见的单词或短语，注意谷歌查询结果要花多长时间。接着再搜索同样的关键词。返回搜索结果的时间会明显缩短，因为谷歌已经在其服务器上缓存了搜索结果。这个缓存对其他搜索相同关键词的人也有好处，因为缓存在谷歌的服务器上，不在你的机器里。要验证缓存在谷歌服务器上，可以在你搜索完之后，让别人在他们自己的计算机上搜索同样的关键词。虽然不能完全保证，但一般来说第二次搜索速度会快很多。

3.4 其他计算机

人们很容易认为计算机不是 PC 就是 Mac，因为那是我们最常见到的。实际上，还有很多其他类型的计算机。这些计算机无论大小，都具有相同的核心特性，即都能完成逻辑运算，并且都具有类似的体系结构，只不过在设计的时候会不同程度地考虑成本、供电、大小、速度等因素。手机和平板电脑也是计算机，它们运行操作系统并支持更加丰富多样的运算环境。比这还小的系统是嵌入式系统，日常生活里能见到的几乎所有数字设备里都有嵌入式系统，比如数码相机、摄像机、GPS 导航系统、家电、游戏机，等等 。

更大的计算机在很多年前就已经实现多个 CPU 共享内存了。如果能把大任务分解成小任务，而分解后的小任务又可以通过不同 CPU 协作完成，CPU 相互之间不会出现太长的等待，也不会有太多的相互干扰，那么就能以这种方式加快完成大任务。除了在大型系统中广泛应用，这种集成多个处理器的多核芯片在个人计算机中也已经司空见惯，而且未来很可能会普及。

超级计算机往往有大量的处理器和大量的内存，这些处理器本身可能带有一些特殊指令，在处理某种数据时，它们比通用的处理器速度更快。今天的超级计算机通常是高速计算机集群，CPU 仍然是普通的 CPU，并没有什么特殊的硬件。网站 top500.org 每六个月就重新公布一次全世界最快的 500 台计算机。最快速度的纪录不断被打破，几年前还能跻身排行榜前几名的计算机，今天可能已经在榜单上找不到了。2011 年 6 月最快的计算机有 50 多万个 CPU，每秒可以执行 8×1015 次数学运算。

分布式计算指的是很多更加独立的计算机（比如不共享内存），而且地理上更加分散，甚至位于世界的不同地方。这样一来，通信更加成为瓶颈，但却能够实现计算机之间的远距离协作。大规模的 Web 服务，比如搜索引擎、在线商店和社交网络，都是分布式计算系统。在这种系统中，数以千计的计算机协作，可以为海量用户迅速地提供结果。

所有这些计算系统都有相同的基本原理。它们都使用通用处理器，可以通过编程完成无穷无尽种任务。每个处理器都有一个有限的简单指令表，能够完成算术运算、比较数据、基于前置计算结果选择下一条指令。不管物理结构的变化让人多么眼花缭乱，它们的一般体系结构从 1940 年代至今并没有太大的变化。

或许很难想象，这些计算机都具有相同的逻辑功能，可以完成一模一样的计算（暂且不论对速度和内存的要求）。1930 年代，这个结果就已经被几个人分别独立地证明过，其中包括英国数学家艾伦·图灵。对于非专业人员，图灵的手段最容易理解。他描述了一个非常简单的计算机（比我们的玩具计算机还简单），展示了它能够计算任何可以计算的任务。他描述的这种计算机，我们今天叫做图灵机。然后，他展示了如何创建一种图灵机，模拟其他图灵机，这种图灵机现在被称为通用图灵机。写一个模拟通用图灵机的程序很容易，而写一个程序让通用图灵机模拟真实的计算机也是可能的（尽管不容易）。实际上，从能够计算什么的角度讲，所有计算机都是等价的，尽管运行速度明显不可能等价。

第二次世界大战期间，图灵从理论转到实践：他领导开发了用于破译德军情报的计算机。1950 年，他发表了一篇名为「计算机器与智能」（Computing machinery and intelligence）的论文，其中提出一个测试（即今天所谓的图灵测试），人们可以通过该测试来评估计算机是否能表现出人类的智能。想象一下，一台计算机和一个人，通过键盘和显示器与另一个提问者交流。通过问答，提问者能确定哪个是人，哪个是计算机吗？图灵的想法是，如果不能明显地将二者区分开，那么计算机就表现出了智能的行为。

缩写词 CAPTCHA 中包含图灵的名字，这个缩写词代表「Completely Automated Public Turing test to tell Computers and Humans Apart」（用以区分计算机和人的完全自动化的公共图灵测试）。CAPTCHA（可以理解为「验证码」）就是一些扭曲变形的字母，广泛用于验证网站的用户是人而非程序：

CAPTCHA 是一个反向图灵测试，因为它利用了人比计算机更擅长识别文字这一特点，来达到区分人和计算机的目的。

图灵是计算机领域最重要的人物之一，他对人类理解计算做出了重大贡献。计算机科学领域的诺贝尔奖 —— 图灵奖，就是以图灵的名字命名的。后面几章将陆续介绍一些获得过图灵奖的重要计算机发明。

