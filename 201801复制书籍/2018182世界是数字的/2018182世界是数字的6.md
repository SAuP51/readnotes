操作系统提供了硬件和其他软件之间的接口。有了这个接口，硬件就好像能听懂人的话了，而程序员编程因此就会变得简单。用这个圈子里的行话说，操作系统提供了一个平台，在这平台上可以构建应用程序。

操作系统为应用程序定义了一组操作（也叫服务），比如将数据存储至文件或者从文件中取出数据、建立网络连接、获取键盘输入、报告鼠标移动和按钮点击、绘制屏幕，等等。

操作系统以标准化的或者说大家协商一致的方式提供这些服务，而应用程序通过执行一种特殊的指令来请求这些服务，并将控制权移交给操作系统中特定的地址。操作系统根据请求完成计算，然后再将控制权和结果返回给应用程序。操作系统的这些「入口」被称为系统调用（system call），而对这些系统调用的详细说明实际上恰恰解释了操作系统能做什么。系统调用可以直接拿操作系统内部的代码作为入口，也可以是对某个（为相应服务而准备的）库函数的调用。但多数情况下，即便是程序员也不用关心上述区别。正因为如此，谁也说不清楚到底有多少个系统调用，但通常一两百个总是有的。

6.2.2 设备驱动程序

这一节我们讲一讲操作系统中的另一个部件 —— 设备驱动程序。设备驱动程序是一种沟通操作系统与特定硬件设备（如打印机和鼠标）的程序。驱动程序的代码知道怎么让特殊的设备履行自己的职责，比如从特定的鼠标得到移动和按钮信息、让磁盘通过旋转的磁表面读取和写入信息、让打印机在纸上留下记号、让特定的无线网卡发送和接收无线电信号。

就说打印机吧。操作系统只会发出标准的请求，比如「在这个位置上打印这段文本」、「绘制这幅图像」、「移到下一页」、「描述你的能力」、「报告你的状态」，等等。而且，还是以适合所有打印机的标准方式发出这些请求。然而，打印机的能力是有差别的，比如支不支持彩色打印、双面打印，或者不同纸张大小。打印机专属的驱动程序，要负责把操作系统请求转换为特定设备完成相应任务必需的指令。一句话，就是操作系统发送通用的请求，而具体的设备驱动程序负责在各自硬件上落实、执行请求。

驱动程序把操作系统与特定设备独有的性质隔离开来（任何设备，比如各种键盘，都有一些操作系统要用到的基本性质和操作），操作系统通过驱动程序的接口以统一的方式访问相应设备，从而方便在设备之间切换。

通用的操作系统都包含很多驱动程序。例如，Windows 为满足各种潜在用户的需要，在发行时就已经带有各种各样的设备驱动程序。每个设备的制造商都有自己的网站，提供新版本或更新的驱动程序下载。

启动过程中有一个环节就是把当前可用设备的驱动程序加载到运行的系统中。可用的设备越多，加载要花的时间就越长。新设备随时有可能出现。在把外部磁盘插入 USB 插槽后，Windows 会检测到这个新设备，（根据设备驱动程序接口的某个部分）确认它是一个磁盘，然后加载 USB 磁盘驱动程序与这个磁盘通信。Mac OS X 操作系统也一样。一般来说，没有必要不断升级新的驱动程序，因为所有设备的接口都是标准化的，操作系统本身已经包含了必要的代码，而驱动设备的特殊程序也已经包含在设备自身的处理器中。

下面这幅图展示了操作系统、系统调用、驱动程序和应用程序之间的关系。

6.3 其他操作系统

随着各种电子元器件越做越小，价格越来越便宜，一台设备所能集成的电子元器件数量也越来越多。于是，很多设备都具有了很强大的处理能力和很充足的内存空间。正因如此，要说一部数码相机是「一台带镜头的计算机」也不为过。随着处理能力和内存容量的增加，相机的功能也越来越强大。手机不也一样嘛！当然啦，手机和相机现在都已经合二为一了。今天，随便一部手机上的相机所拥有的像素解析度，都远远超出了早期的数码相机。没错，镜头的品质得单说。

总之，这些设备俨然与主流通用计算机一般无二。它们都有强劲的处理器、大容量的内存，以及一些外围设备（比如数码相机上的镜头和显示屏）。它们的用户界面极其精美。它们可以通过网络连接与其他系统通信 （手机使用电话网络和 Wi-Fi，游戏机手柄使用红外线和蓝牙），不少还提供 USB 接口，以支持移动硬盘的临时接入。

随着这种趋势的不断演进，选择市面上现成的操作系统要比自己从头写一个来得更实际。除非用途特殊，否则在 Linux 基础上改一改是成本最低的，关键是 Linux 非常稳定、容易修改、方便移植，而且免费。相对而言，自己开发一个专有系统，或者取得某个商业系统的许可，都会引入巨大开销。当然，改造 Linux 的缺点在于必须把改造后的操作系统部分代码按照 GPL 许可发布，由此可能引发如何保护设备中知识产权的问题。不过，从 Kindle 和 TiVo 的案例来看，似乎也没有什么不能解决的。

6.4 文件系统

文件系统是操作系统的一个组成部分，它能够让硬盘、CD 和 DVD、移动存储设备，以及其他各种存储器等物理存储媒体，变成看起来像是由文件和文件夹组成的层次结构。我们常说计算机有逻辑组织和物理实现两大概念，文件系统就是这两大概念的集中体现。文件系统能够在各种不同的设备上组织和存储信息，但操作系统则为所有这些设备都提供相同的接口。文件系统存储信息的方式以及存储多久，最终甚至会衍生出一些法律问题来。所以说，研究文件系统的另一个目的，就是要理解为什么「删除文件」并不代表其内容会永远消失。

几乎所有人都用过 Windows 的资源管理器或者 Mac OS X 的 Finder，这两个工具都能列出自最顶层（比如 Windows 中的 C 盘）开始的文件系统的层次结构。在这个层次结构里，一个文件夹（folder）可以包含其他文件夹和文件。换句话说，点开一个文件夹，就可以看到更多文件夹和文件。（Unix 系统则一直使用目录（directory）而不是文件夹的概念。）这里的文件夹是一个组织结构的概念，而实际的文档内容、图片、音乐、电子表格、网页等，则保存在文件中。在计算机中，所有这些信息都存储在文件系统内，只要用鼠标点击几下就可以找到。文件系统中不光存储数据，还存储着可以执行的程序（比如浏览器）、代码库、设备驱动程序，以及构成操作系统自身的文件。这些文件的数量大得惊人，就说我这个普普通通的 MacBook 吧，其中存储的文件已经超过了九十万个。

文件系统管理所有这些信息，方便其他程序和操作系统的其他部件读写这些信息。它统筹安排所有的读写操作，确保这些操作有效进行，且不会相互干扰。它记录数据的物理位置，确保它们各就各位，不会让你的电子邮件意外地窜到你的电子表格或纳税申报单里面去。在支持多用户的系统中，还要保证信息的隐私权和安全性，不能让一个用户在未经允许的情况下访问另一个用户的文件。另外，可能还需要限制每个用户有权使用的硬盘空间，也就是所谓的配额管理。

在最低级的层次上，文件系统服务是通过系统调用来提供的。程序员通常要借助代码库来使用这些系统调用，以简化编程过程中常见的文件处理操作。

6.4.1 磁盘文件系统

无论什么样的存储设备，在文件系统中一律只表现为文件夹和文件。从这一点来说，文件系统是把物理实现抽象为逻辑组织的绝佳范例。但它又是怎么做到的呢？

一块 100GB 的硬盘可以存储 1000 亿字节的数据，但这块硬盘上的软件可能会将其看成 1 亿个 1000 字节大的块。（现实中，块的大小应该是 2 的幂，而且每个块还会更大。这里使用十进制是为了便于说明其中的关系。）这样，一个 2500 字节大的文件（比如一封普通的邮件），就需要 3 个这样的块来存储。因为 2 个块存不下，而 3 个块有富余。文件系统不会在同一个块内存储不同文件的信息，因而就免不了有一些浪费。因为存储每个文件的最后一个块不会完全用完（在我们举的这个例子中，最后一个块就会闲置 500 字节）。考虑到简化记录工作所节省的工作量，这点代价还是值得的，更何况磁盘存储器已经那么便宜了。

这个文件所在的文件夹条目中会包含文件的名字、2500 字节的文件大小、创建或修改时间，以及其他细节信息（权限、类型等，取决于操作系统）。所有这些信息都可以通过资源管理器或者 Finder 看到。

这个文件夹条目中还会包含文件在磁盘上的位置信息，也就是 1 亿个块中的哪 3 个块存储着这个文件。管理这些位置信息的方法有很多种。比如，文件夹条目可以包含一组块编号，也可以引用一个自身包含一组块编号的块，或者只包含第一个块的编号，第一个块又包含第二个块的编号，依此类推。下面这幅示意图展示了文件夹引用块列表的大致情况：

存储同一个文件的块在磁盘上不一定连续。事实上，这些块一般都不挨着，至少存储大文件的块是这样的。兆字节级别的文件需要占用上千个块，这些块通常会分散在磁盘的各个地方。尽管从这幅图中看不出来，但文件夹及块列表本身也存储在块中。

文件夹也是一个文件，只不过这个文件中包含着文件夹和文件的位置信息。由于涉及文件内容和组织的信息必须精准、一致，所以文件系统保留了自己管理和维护文件夹内容的权限。用户和软件只能请求文件系统来间接地修改文件夹内容。

没错，文件夹也是文件。从存储方式上讲，它们跟文件没有任何区别。只不过文件系统会全权负责管理文件夹内容，任何应用软件都不能直接修改该内容。除此之外，它们都保存在硬盘上的块中，由相同的机制进行管理。

在应用程序要访问已有的某个文件时，文件系统必须从其顶级层次开始搜索该文件，在相应文件夹里查找文件路径中的每一部分。举个例子，假设要在 Mac 中查找 / Users/bwk/book/book.txt。文件系统首先要在其顶层搜索 Users，然后在该文件夹里搜索 bwk，接着在找到的文件夹里搜索 book，最后再在找到的文件夹里搜索 book.txt。在 Windows 中，这个文件的路径可能是 C:\My Documents\book\book.txt，但搜索过程相似。这是一种化整为零的思路。也就是说，路径中的层次会逐步缩小要搜索的文件或文件夹的范围，同时把其他不相干的部分过滤掉。正因为如此，不同层次中的文件可以使用相同的名字，唯一的要求是完整的路径必须独一无二。实践中，应用程序和操作系统会记住当前的文件夹，因而文件系统不必每次都从顶层开始搜索。而为了加快处理速度，系统还可能会缓存频繁用到的文件夹。

应用程序在创建新文件时会向文件系统发送请求，文件系统会在相应的文件夹中增加一个新条目，包含文件名、日期等项，还有文件大小为零（因为还没有为这个新文件分配磁盘块）。接下来，应用程序要向文件中写入某些数据时（比如向一封邮件中写几句话），文件系统会找到足够多的当前没有使用的或者「空闲」的块来保存相应内容，并把数据复制过去。然后把这些块插入到文件夹的块列表中，最后返回给应用程序。

不难想象，文件系统还要维护一个磁盘上当前未被使用（也就是还没有成为某些文件一部分）的块的列表。每当应用程序请求新磁盘块，它就可以从这些空闲的块中拿出一些来满足请求。这个空闲块的列表同样也保存在文件系统的块中，但只能由操作系统访问，应用是访问不到的。

6.4.2 删除文件

删除文件时，过程恰好相反：文件占用的块会回到空闲列表，而文件夹中该文件的条目会被清除，结果就好像文件被删除了一样。

现实中的情况并不完全如此，而是加入了一些有意思的比喻。当你在 Windows 和 Mac OS X 中删除一个文件时，这个文件会跑到「回收站」或「垃圾桶」里去。「回收站」和「垃圾桶」不过是另外一个文件夹，但具备某些常规文件夹所不具备的属性。正因为如此，才成其为「回收站」嘛。删除文件时，相应的文件夹条目将从当前文件夹被复制到名叫「回收站」或「垃圾桶」的文件夹里，然后会清除掉原来的文件夹条目。但是，这个文件占用的块以及其中的内容没有丝毫变化！从「回收站」里还原文件的过程正好相反，就是把相应条目恢复到它原来所在的文件夹中。

「清空回收站」倒是跟我们本节一开始描述的过程很相似。此时「回收站」或「垃圾桶」里的文件夹条目会被清除，相应的块会真正再添加到空闲块列表中。不管是明确地执行这个操作，还是文件系统因为空闲空间过少而在后台静默地清空，这个过程都将实实在在地发生。

假设是你明确地执行清空操作。那么这个操作首先清除「回收站」文件夹中的条目，然后把其中文件占用的块回写到空闲块列表。但是，这些文件的内容并没有被删除。换句话说，原始文件占用的每个块中的所有字节都会原封不动地呆在原地。除非相应的块从空闲块列表中被「除名」并奉送给某个应用程序，否则这些字节不会被新内容覆盖。

这意味着什么呢？意味着你认为已经删除的信息实际上还保存在硬盘上。如果有人知道怎么读取它们，仍然可以把它们读出来。任何可以不通过文件系统而能够逐块读取硬盘的程序，都可以看到那些被「删除」的内容。

显然，这样有一个潜在的好处。就是在硬盘出问题的情况下，还有可能恢复其中的信息，尽管文件系统可能已经一团糟了。可是不能保证数据真正被删除也有问题。假如你想删除的文件里包含隐私，甚至一些见不得人的东西，你肯定希望它们被删除后永远销声匿迹。对精于此道的坏蛋或者执法机关的专家来说，恢复磁盘中的内容只是小菜一碟。因此，假如你在文件中记录了自己穷凶极恶的想法，或者在妄想症支配下写了很多胡话，那最好使用能够把这些信息从空闲块中彻底擦干净的程序。比如 Mac 中的「安全擦除」选项在释放磁盘块之前，会先用随机生成的比特重写其中的内容。

现实当中的你还应该知道更加保险的做法。因为即使用新信息重写了原有内容，一名训练有素的敌人仍旧可以凭借他掌握的大量资源发现蛛丝马迹。军事级的文件擦除会用随机的 1 和 0 对要释放的块进行多遍重写。更为保险的做法是把整块硬盘放到强磁场里进行消磁。而最保险的做法则是物理上销毁硬盘，这也是保证其中内容彻底销声匿迹的唯一可靠方法。如果你的磁盘一直都在执行自动备份（就像我在上班时使用的计算机一样），或者你的文件保存在网络文件系统中而不是本地硬盘上，那么这些招数恐怕也都不灵光了。

文件夹条目本身也存在类似的问题。删除一个文件时，文件系统会让相应文件夹条目不再指向有效的文件。为此，它可能只会把一个表示「本条目不再使用」的比特位设置为 1。这样在将来需要恢复该文件的原始信息，包括所有未被重新分配的块的内容时，只要把这个比特位重置为 0 就可以了。事实上，1980 年代微软 MS-DOS 中的文件恢复系统采用的就是这种办法。对于待释放的空闲条目，该系统会把相应文件名的第一个字符设置为一个特殊值。这样，如果用户很快又要恢复文件，那么实现起来会简单很多。

知道了文件在被创建人删除后还可能存在很长时间，有助于我们理解一些法律程序，比如当事人坦白和文档保全的意义。在法庭上，这种案例屡见不鲜。有时候，一封陈年邮件就可能影响对被告的量刑，至少会让犯罪嫌疑人的陈述露出马脚。如果这些记录只存在于纸面上，那么徒手将其撕碎就能轻易销毁证据。但数字化记录是会扩散的，还可能通过移动硬盘等媒体藏匿于很多地方。（维基解密 2010 年得到的大批机密外交文件就保存在很多张 CD 中。）明智的人都应该时刻注意自己在邮件里的措辞，甚至应该注意通过计算机发表的任何言论。

6.4.3 其他文件系统

刚才我们讨论的是硬盘驱动器（包括移动硬盘）上的常规文件系统。我们大多数的信息都保存在这些硬盘上，而且我们对它们也非常熟悉。不过，这个文件系统也同样适用于其他媒体。

例如，已经退出历史舞台的软盘，在逻辑上具有同样的层次结构，但细节上有所不同。CD-ROM 和 DVD 同样以文件系统的方式提供访问界面，同样由不同层次的文件夹和文件组成，只不过一般为只读，不能写。固态硬盘通过闪存来模拟常规硬盘，但重量更轻，耗电更省。

USB 闪存盘和 SD（Secure Digital，安全数字式）闪存卡已经无处不在。把它们插入到一台 Windows 计算机中，它们就会像一块新硬盘一样。通过资源管理器可以查看其中的内容，并像在普通硬盘上一样执行读写操作。唯一的区别就是它们容量小一些，有时候速度可能也慢一些。

如果把它们插到一台 Mac 上，它们同样表现为分层的文件系统，可以通过 Finder 浏览，文件也可以拷来拷去。把它们插到 Unix 或 Linux 计算机上也一样，它们还是表现为文件系统。让这些硬件在不同操作系统中看起来具有同样的文件系统和同样的文件夹 / 文件结构的是软件。但在内部，文件组织采用的可能是微软的 FAT 系统，其他文件系统也都模仿该系统。但我们不需要去理会这个，这种抽象是非常完美的。（顺便说一句，FAT 是 File Allocation Table 的简写，即「文件分配表」，不是「肥胖」的意思。所以大家可别误以为微软的实现不好。）

我的第一台数码相机都把照片存在自己内部的文件系统中。为了拷照片，必须用数据线把相机连接到计算机。而我现在这台相机使用的是 SD 闪存卡（就是上面图里的那张），把这张卡从相机里拔出来插到计算机上，就可以上传照片。不仅上传速度比以前快得多，而且也让我摆脱了以前相机厂商开发的那些难用至极的滥软件。熟悉而统一的界面代替了笨拙而专有的方法。显而易见，相机厂商也会因此省不少事，至少不用再为自己的产品开发专门的文件传输软件了。

值得一提的是，同样的思想也体现在网络文件系统上。在学校和公司里，把文件保存到服务器上是非常常见的做法。借助相应的软件，我们访问其他计算机上的文件系统时，就如同访问本地的硬盘一样。同样只要使用资源管理器、Finder 或者其他软件就可以。远端的文件系统可能与本地相同（比如两台 Windows 计算机），也可能不同（比如其中一台是 Mac 或 Linux 计算机）。但与闪存设备一样，软件把它们的差异隐藏了起来，我们看到的永远是与自己本地计算机中常规文件系统一样的界面。

网络文件系统经常用于备份，当然也可以作为主文件存储系统。必要时，可以把旧文件复制到便于存档的媒体上，保存到其他地方，以免发生火灾等事故时毁坏重要资料。有些磁盘系统会依赖一种叫 RAID（Redundant Array Of Independent Disks，独立磁盘冗余阵列）的技术，把数据和错误校验码分别写到多个磁盘上，以便某个磁盘损坏时能够从其他磁盘恢复数据。当然，这种系统也会增加彻底销毁数据的难度。

6.5 应用程序

「应用程序」是一种统称，表示所有在操作系统平台上完成某种任务的软件或程序。应用程序可大可小，可以只完成特定的任务，也可以囊括大量功能。可以是花钱买的，也可以是免费送的。它的代码可以高度保密，也可以开放源码，甚至没有任何限制。

或许可以把应用程序分成两类。一类是小型独立的应用，通常只帮用户做一件事；另一类是大型软件，包含非常多的操作，比如 Word、iTunes 或 Photoshop。

最简单的应用程序是啥样的？好吧，我们以 Unix 中的 date 程序为例，它的作用就是打印当前日期和时间：

$ date Thu Sep 22 19:44:07 EDT 2011

date 程序在所有类 Unix 系统中的行为完全一样。不信？你可以在 Mac 里打开 Terminal（终端）窗口试一试。date 的代码很少，因为它是构建在相应系统调用和库函数基础上的。系统调用为它提供了以内部格式表示的日期和时间，库函数帮它转换格式并打印出来。以下就是实现它的 C 代码，你看短不短：

#include <stdio.h> #include <time.h> int main() { time_t t = time(0); printf("%s", ctime(&t)); return 0; }

Unix 系统有一个列出目录中文件和文件夹的命令，它是 Windows 资源管理器和 Mac OS X Finder 的纯文本版。对文件执行复制、移动等操作的程序，在 Finder 和资源管理器中也都有对应的图形用户界面版。同样，这些程序也使用系统调用来提供文件夹包含内容的基本信息，也依赖于库函数去读、写、格式化和显示信息。

Word 之类的应用程序比浏览文件系统的程序要大得多。但很明显，Word 一定包含某种类似的文件系统程序，以便用户能够打开文件、读取文件内容和保存文档。Word 也包含非常完善的算法，随着文本变化持续更新显示界面的算法就是一例。它还提供精心设计的用户界面，用于显示信息和让用户调整字号、字体、颜色、布局等的各种选项。对这种程序而言，用户界面是至关重要的一部分。Word 以及其他具有巨大商业价值的大型程序都经历了不断改进和功能完善。我还真不知道 Word 有多少行代码，但要说它有几百万行 C 和 C++ 代码应该一点都不奇怪。

另一个大型、免费，有时候甚至是开源的应用程序是浏览器。从某种角度说，浏览器的复杂度甚至更高。只要上过网，你就至少使用过下列浏览器之一：Firefox、Safari、Internet Explorer、Chrome、Opera。相信不少读者也像我一样，用过其中不止一个。第 10 章我们会更详细地介绍 Web 和浏览器如何获取信息。这里我们只关注它是一个多大、多复杂的程序。

从外部来看，浏览器会向 Web 服务器发送请求，从那里取得信息后再把它们显示出来。那它复杂在哪里呢？

首先，浏览器必须处理异步事件。所谓异步事件，就是在非预定时间发生、没有特定次序的事件。举个例子，你点击一个链接，浏览器就会发送一个对相应页面的请求。但发送完请求后，它不能就那么一直等着。它还得准备响应你的其他操作，比如滚动当前页面，或者在你点击「后退」按钮或另外一个链接时中断之前的请求，不管请求的页面是否已经到达。在你调整窗口大小时，它必须不断更新窗口中的内容，或许就因为你在等待新页面期间没事儿干，于是就会随手来回缩放起窗口来。如果页面中包含音频和视频，那它还要负责控制它们。编写异步系统一直是非常困难的，而浏览器就涉及很多异步操作。

浏览器必须支持很多种内容，包括静态文本和具有互动性的程序（可以动态改变网页中包含的内容）。对某些内容的支持可以委托给辅助程序（这是处理 PDF 文档和电影的标准做法），但浏览器本身必须提供相应的机制，以便启动这些辅助程序，为它们发送和接收数据以及请求，还要控制它们。

浏览器必须管理多个标签页或窗口，每个标签页和窗口都可能需要执行前述操作。它要为每个标签页和窗口单独保留一份历史记录，还要保存书签、收藏夹等数据库。它要支持访问本地文件系统，以便上传和下载文件。

浏览器自身还是一个平台，要提供不同层次的扩展接口。比如，要支持 Flash 和 Silverlight 插件、JavaScript 和 Java 虚拟机，以及 Firefox、Safari 和 Chrome 所支持的那些扩展程序。

浏览器既然包含那么多实现复杂功能的代码，其自身以及它所支持的插件、扩展程序免不了会存在一些漏洞，面临被攻击的风险。另外，一些无知、愚昧，甚至白痴用户（本书读者自然不在此列），由于不理解浏览器的原理，不知道可能存在的风险，也会导致浏览器遭受攻击。总之，做浏览器开发确实不容易。

如果现在再回头读一读本节内容，你会不会想到些什么？没错，现在的浏览器非常像操作系统。它要管理资源、控制同时发生的活动，它向多个地方请求和保存资源，并且为其他程序运行提供了一个平台。

多年来的实践表明，把浏览器当成操作系统是可行的。换句话说，浏览器本身就是一个独立的系统，与什么操作系统在控制底层硬件无关。大概十几年前，这种想法已经浮出水面，但当时还存在很多实际的困难。今天，这种可能性已经触手可及。大量服务都可以只通过浏览器界面来访问了（邮件是最明显的例子），而这个趋势还在继续。谷歌已经发布了一个浏览器操作系统，叫 Chrome OS。这个操作系统完全依赖于 Web 服务。为此，谷歌还推出了运行 Chrome OS 的计算机 Chromebook。第 11 章讨论云计算的时候，我们还会再探讨这个话题。

6.6 软件分层

与计算领域的很多其他东西一样，软件也是分层组织的。类似于地质学中的分层，软件中的不同层次可以隔离不同的关注点。在程序员的世界里，分层是解决复杂问题的一个核心思想。

通俗地讲，计算机的最底层是硬件。硬件，除了总线支持在系统运行期间添加和删除设备之外，其他方面几乎可以看成不可变的。

再往上就是所谓的操作系统层了。为了突出其核心地位，通常把这一层称为内核（kernel）。操作系统介于硬件和应用程序之间。无论底层是什么硬件，操作系统都要负责隐藏其特殊性，向应用程序提供统一的接口或界面，这个接口或界面不因硬件的种种差别而变化。在接口设计得当的情况下，同一个操作系统的接口完全可以适用于众多制造商生产的不同类型的 CPU。

Unix 操作系统的接口就是这样的。Unix 可以在各种处理器之上运行，但在任何处理器上都能提供相同的核心服务。事实上，操作系统就是一种通用的商品，底层的硬件除了价格和性能之外，其他方面都影响不大。而且，上层的软件也不依赖于它。把为一种处理器编写的程序移植到另一种处理器上，无非就是小心谨慎地用合适的编译器再编译一遍而已。当然，程序与硬件结合得越紧密，这种转换工作就越难做。无论如何，这种转换对很多程序来说都是可行的。举个大规模转换的例子，苹果公司在 2005 年到 2006 年，用了不到一年时间，就把它们的软件从 IBM 的 PowerPC 处理器转换到了 Intel 处理器上。

对 Windows 来说，问题就没有那么简单了。从 1978 年的 Intel 8086 CPU 开始，Windows 的开发就与 Intel 架构紧密结合，包括后来 Intel 发布的每一款 CPU。（处理器系列一般称为「x86」，是因为 Intel 的处理器很多年都以「86」这个编号结尾，包括 80286、80386、80486 等。）Windows 与 Intel 的结合是如此紧密，以至于这样的系统一度被世人称作「Wintel」。

操作系统再往上的一层是函数库。函数库提供通用的服务，这样一来，程序员就不必各自重复实现这些功能。有些库比较靠近底层，能够完成一些基本功能（完成数学计算，比如开方和求对数，或者像前面 date 命令一样计算日期和时间）。另外一些库的功能更强大（涉及加密、图形处理、压缩等）。图形用户界面上的组件，包括菜单、按钮、复选框、滚动条、选项卡面板等等，都需要编写很多代码。为此，只要把这些代码封装成函数库，任何人就都可以使用它们，而且还能保证统一的行为和外观。这就是为什么大多数 Windows 应用（至少它们的基本图形组件）看起来那么相似的原因。同样的情况在 Mac 上更是如此。如果所有软件开发商都重新发明、重新实现这些功能，那不仅会浪费大量资源，而且五花八门的界面也会让用户感到无所适从。

如前所述，典型的应用程序会使用函数库和操作系统服务，把它们集成到一起实现某种功能。不过，库函数与系统调用之间的区别并不十分明显。某个特定的服务可以作为系统调用实现，也可以借助使用了系统调用的库函数来实现。

有时候，内核、函数库和应用程序之间并不像我说的那么泾渭分明。毕竟，编写及连接软件组件的方式多种多样。例如，内核可以提供少量服务，而依赖上层的库来完成大部分工作。或者，它也可以自己承担大部分任务，而较少地依赖于库。操作系统与应用程序之间并没有清晰的界限。

那该如何区分它们呢？一个简单（但可能不够完美）的方法，就是把任何确保 A 应用程序不会干扰 B 应用程序的代码看成是操作系统的职能。比如，内存管理、文件系统、设备管理和 CPU 管理，这些都是操作系统的职能。内存管理需要决定在程序运行的时候把它们放到内存的什么位置，文件系统需要决定把信息保存到磁盘上的什么位置，设备管理需要确保两个应用程序不会同时占用打印机，也不能在没有协商的情况下就向显示器输出内容。最核心的还是 CPU 管理，因为这是操作系统履行前述各项职能的前提条件。

浏览器不属于操作系统，因为你可以运行任意浏览器，甚至同时运行多个浏览器，都不会干扰共享资源或者控制流程。

听起来好像是可以做到泾渭分明似的，但要是较起真来，比如打起官司来，那可就难说了。美国司法部从 1994 年开始（到 2011 年结束的）对微软的反垄断诉讼，就涉及微软的 Internet Explorer 浏览器到底是操作系统的一部分，还是一个独立应用程序的问题。如果浏览器是操作系统的一部分（按照微软的主张），那么要求微软删除 IE 就是不合理的，而微软要求用户使用 IE 的做法就是正当的。如果浏览器是一个独立的应用程序，那么微软就涉嫌以非法手段强迫用户在非必要情况下使用 IE。当然，这个官司本身要复杂得多，但如何界定浏览器的归属问题确实非常重要。最终诉讼的结果是，法院认定浏览器是一个独立的应用程序，不属于操作系统。用法官托马斯·杰克逊（Thomas Jackson）的话说：「Web 浏览器和操作系统是相互独立的产品。」

第 7 章 学习编程

在我的课上，我会教给学生们一些编程的知识，使用一种叫 JavaScript 的编程语言。生活在信息时代的人，有必要了解一些编程方面的常识。比如，哪怕是非常简单的程序，让它顺顺当当地跑起来都可能要克服难以想象的困难。通过这门课让大家知道如何驾驭计算机，乃至初步品尝到第一次运行程序就顺利通过的美妙感觉，在我看来是一件非常有成就感的事。当然，更理想的情况是在大家将来拥有了足够多的编程经验后，再听别人说编程很容易啦，或者某个程序没有任何错误等等，你会情不自禁地警觉起来。如果你自己折腾一天连 10 行代码都调试不好，那别人要是说能按时交付百万行级的程序，而且没有任何 bug，你相信吗？换个角度说，有点编程常识也能让人明白，其实也不是写什么程序都那么难，大不了请人帮你写呗。

那我们用什么语言来学编程呢？语言实在太多了，可以说不计其数。但是，没有哪门语言是最适合新手学习，或者说我觉得最适合在这样一本通俗读物里教给所有「外行」的。很早以前，我用过微软的 Visual Basic。它既是一门语言，也是一个编程环境。通过它可以方便地写出看起来很专业的 Windows 应用程序。而且，微软的 Office 办公套件以及很多其他办公软件里也都内置了某种 VB 的简化版。因此，会用 VB 就可以在日常工作中增强或更好地控制 Word 和 Excel（当然，弄不好也会为病毒入侵打开便利之门）。

可惜 Visual Basic 已经不再是最好的选择了。尽管微软提供的免费版几乎没有删减任何功能，但比起十几年前，这门语言及其体系实在复杂得太多了。更重要的是，VB 只能在 Windows 系统上运行。而我需要找一个随便在什么平台上都能跑的语言。

为此，我选择了 JavaScript，因为它具有如下优点。首先，它无处不在，所有浏览器都支持它。几乎每一个网页多多少少都有 JavaScript 程序，而且其代码也很容易向别人展示。要是你用它写了一个程序，把它放在自己的网页里就能博得朋友和家人的赞美。其次，这门语言本身比较简单，对学习者的要求很低。当然，这并不意味着它能力弱。事实上，JavaScript 非常强大，可以完成极为复杂的计算任务。很多网页特效的背后都是 JavaScript，包括谷歌的在线办公程序 Google Docs 和其他类似的应用。最后，Twitter、Facebook、Amazon 等等这些世界级的大网站都提供了 JavaScript 的 API。

JavaScript 当然也有缺点。不同浏览器中的 JavaScript 实现并不像我们想象的那样完全一致。换句话说，在一个浏览器中能运行的程序，换一个浏览器可能就运行得不正常。但就本章的学习目标而言，这根本不是问题。做专业开发的前端工程师都有办法解决这个问题。另外，这门语言的某些特性不太好理解，有时候会显得比较怪异。JavaScript 程序通常只能在网页中运行，很少能独立存在。不过也有一些软件支持 JavaScript 程序，比如 Adobe 的 PDF 阅读器。由于它委身于浏览器，因此要学它，一般都得同时学一点 HTML（HTML 是一种描述网页结构的标记语言）。尽管存在这些缺点，JavaScript 仍然非常值得学习。

只要能够理解本章的内容，你就可以学会编程，至少能掌握一些最基本的编程方法。但不管怎样，编程都是极有必要掌握的一种技能。学会了基本的编程方法之后，再学习其他语言也就不会那么难了。如果你希望学得更深入一些，或者找一些其他学习资料，可以上网搜索「JavaScript 教程」。按下回车键，你会看到一大堆结果。

不过，就算你现在不想学编程，不去理解语法甚至干脆跳过这一章也无所谓。不看本章也不会影响对其他章节的阅读和理解。

7.1 编程语言的基本概念

编程语言的某些基本概念是相通的，因为这些概念都是为了表达一系列计算步骤而发明的。任何编程语言都会提供一些手段，用于取得赖以完成计算的输入数据、进行算术计算、在计算期间存储和获取中间值并显示结果、根据之前的计算结果决定下一个计算步骤，以及在计算完成时保存结果。

是语言就有语法，而语法就是一系列规则，根据它们可以判断什么符合语法，什么不符合语法。编程语言对语法规则是锱铢必较的，哪怕有一点点地方违反语法，它都会提出抗议。语言还要有语义，语义规定了语言中所有元素的含义。

理论上讲，一段程序的语法是否正确，以及语法正确的情况下其含义是什么，这些都不应该有歧义。但实际上，就像用自然语言写文章一样，任何歧义都没有的理想状态有时候很难达到。语言的最基本单位通常是字和词，这些字和词本身可能就有歧义，而对它们的不同理解更是司空见惯。因此，实现这些语言规则的时候可能就会有偏差。另外，语言本身也会与时俱进。综上所述，不同浏览器对 JavaScript 的实现多多少少都会存在差异。实际上，即使是同一款浏览器的不同版本，对 JavaScript 的实现也有差异。

JavaScript 这门语言实际上包含三个方面。第一是语言本身，包括让计算机完成算术计算的语句、测试条件，以及重复计算的规则等。第二是 JavaScript 代码库，也就是由别人写好的程序段，你可以在自己的程序里直接使用，而不必再花时间重写。比如数学函数、计算日历的函数，以及搜索和操作文本的函数。第三是访问浏览器和网页的接口，JavaScript 程序通过这些接口可以在其所在的网页中获得用户输入、响应用户动作（如单击按钮或填写表单）、让浏览器显示不同的内容或者切换到其他网页。

7.2 第一个 JavaScript 程序

下面这个 JavaScript 示例可以说是一个小得不能再小的程序了，它的作用就是在页面加载时弹出一个对话框，显示出「Hello, world」。下面就是完整的 HTML 代码（第 10 章在介绍万维网的时候还会再介绍 HTML），但现在我们只关心其中加粗的那一行 JavaScript 代码，它位于 <script> 和 </script> 标签之间。

<html> <body> <script> alert("Hello, world"); </script> </body> </html>

把这 7 行代码放到一个名为 hello.html 的文件里，通过浏览器打开它，就会看到下面几个对话框中的一个：

这些图片分别是 Firefox、Chrome、Safari 和 Opera 中对话框的截图（全都在苹果电脑上）。很明显，这些对话框长得都不一样。尽管它们「长相」上的差异无关紧要，但这些差异却很好地说明了不同浏览器的表现可能会不一样。下面再给出 Windows XP 版本的 Firefox 和 Internet Explorer 中相应对话框的截图，仅为比较：

这个程序的 alert 函数来自辅助与浏览器交互的 JavaScript 库，调用它会弹出一个对话框，对话框将显示位于引号中的文本。顺便说一句，你在写 JavaScript 程序时，必须使用标准的双引号（"），不要使用所谓的「智能引号」（本书后面会介绍）。这也是讲究语法规则的一个例子。另外，也不要使用 Word 等文字处理程序来生成 HTML 文件，而应该使用记事本或 TextEdit 这样的文本编辑器。在保存程序文件时，要把它保存成扩展名为.html 的纯文本文件（也就是没有任何格式信息的文件）。

学会写这个最简单的程序之后，就可以进一步探索更有意思的编程任务了。从现在起，本书不再给出 HTML 标签，只给出位于 <script> 标签间的 JavaScript 代码。

7.3 第二个 JavaScript 程序

我们的第二个小程序会询问用户的名字，然后再显示一句针对用户的问候语：

var username; username = prompt("What's your name?"); alert("Hello, " + username);

这个程序涉及几个新元素和新概念。首先，单词 var 添加或者说声明了一个变量。变量是 RAM 中的一个位置，可以让程序在运行期间存储数据。之所以称它为变量，是因为它的值会随着程序的执行而变化。在高级语言里，声明变量就相当于我们在玩具汇编语言中为一个内存位置起一个名字。打个比方，声明就好比一出戏里的演员表。在这里，我们把这个变量叫做 username。当然也可以给它起别的名字，但 username 让人一看就知道它在程序中扮演什么角色。

其次，这个程序使用了一个 JavaScript 库函数 prompt。prompt 与 alert 类似，都会弹出一个对话框。但不同的是，prompt 能收集用户的输入。用户在对话框中输入的任何内容都会成为 prompt 函数中可以使用的值。这个值通过下面这行代码被赋给了变量 username：

username = prompt("What's your name?");

这里等号 = 的意思是：「完成右边的计算，把计算结果保存在左边的变量里。」这个等号也是语义的一个例子。等号执行的操作叫赋值。大多数编程语言都使用等号来表示赋值，而没有顾及等号在数学中表示相等的含义。换句话说，这里的 = 不表示相等，而表示复制值。

最后，alert 语句

alert("Hello, " + username);

中使用加号 + 把单词 Hello（逗号、空格）和用户输入的名字拼接了起来。在这个上下文里，不少人也会感到困惑，因为 + 一般表示两个数值相加，而非拼接两个字符序列。

运行这个程序，prompt 会显示一个对话框，让用户在里面输入内容：

如果你在里面输入「Joe"，然后单击 OK 按钮，会看到下面的结果：

对这个程序进行简单的扩展，可以分别取得用户的姓和名。至于怎么扩展，那方法可就多了，有兴趣的话你可以亲手试一试。注意，如果你在这里输入的是「My name is Joe」，那么问候语也会变成「Hello, My name is Joe」。想让计算机变得更聪明一点？那就得看你的程序怎么写了。

7.4 循环

还记得第 5 章展示的那个 JavaScript 程序吗？那个程序可以把一系列数值累加起来。不用往前翻了，那个程序的代码如下：

var num, sum; sum = 0; num = prompt("Enter new value, or 0 to end"); while (num != 0) { sum = sum + parseInt(num); num = prompt("Enter new value, or 0 to end"); } alert("Sum = " + sum);

再提醒一下，这个程序会不断读取用户输入，而在用户输入「0」的时候，会弹出对话框显示之前输入的所有数值之和。这个程序里的一些特性前面刚刚介绍过，比如声明、赋值，还有 prompt 函数。其中第一行代码声明了两个后面会用到的变量 num 和 sum。第二行代码是一个赋值语句，把变量 sum 的值设为 0。第三行代码把变量 num 的值设为用户在对话框中输入的值。

这里真正值得讲的是 while 循环，也就是第四行到第七行代码。计算机最擅长一遍又一遍地反复执行一系列指令，而程序员需要想清楚的则是如何通过编程语言来表达这种反复。在玩具语言里，我们添加了 GOTO 指令，用于跳转到程序中的另一个位置，而不是顺序执行下一条指令。还添加了 IFZERO 指令，用于测试一个条件并根据累加器的值决定是否跳转。

这些概念在大多数高级语言里都有，而且被抽象为一个叫做 while 循环的语句。这个循环语句在反复执行一系列指令时更有规律性，也更加有条理。这个程序里的 while 测试了（写在括号中的）一个条件，如果条件为真，则执行花括号 {...} 中所有语句。然后返回，再次测试同一个条件。这个循环一直反复，直至条件为假。此时，接着执行紧跟在右花括号后面的语句。

这个逻辑跟第 3 章使用玩具语言的 IFZERO 和 GOTO 实现的逻辑是不是很像呢？没错，除了不必发明新标签和可以测试任何条件之外，它们是完全一样的。这个程序中测试的是变量 num 是否有一个不等于零的值。因为运算符！= 的含义就是「不等于」，这个运算符和 while 语句都是从 C 语言借鉴来的。

我并没有明确指定这个示例程序中数据的类型。但在内部，计算机会帮我们明确区分 123 这样的数值和 Hello 这样的任意字符串。有些语言要求程序员自己谨慎地表达这种区别，另一些语言则试图猜测程序员的意图。JavaScript 差不多就属于后一类，因此有时候明确知道数据类型以及如何处理相应的值是十分必要的。比如 parseInt 函数吧，它可以把文本内容转换成数值，也就是说它的输入数据可以被当成（123 这样的）整数而非三个十进制数字来看待。如果不用 parseInt，那么 prompt 返回的数据就会被当成文本，而 + 运算符就会把它追加到之前的文本后面。结果将是把用户输入的所有数字逐个拼接起来。这听起来似乎还挺有意思，但却不是我们想要的。

7.5 条件

接下来的这个例子要完成的任务有点不一样，它要从输入的所有数值中找出最大的一个。而这也正是添加另一个控制流语句 if-else 的原因。所有高级语言都有这个语句（可能形式上稍有差异），用于条件判断。实际上，if-else 就是 IFZERO 的通用版本。JavaScript 中的 if-else 语句跟 C 中的一样。

var max, num; max = 0; num = prompt("Enter new value, or 0 to end"); while (num != 0) { if (parseInt(num) > max) { max = num; } num = prompt("Enter new value, or 0 to end"); } alert("Maximum is " + max);

if-else 语句有两种表现形式。一种就是这里所展示的这样，没有 else 子句。此时，只要括号中的条件为真，那么就会执行后面括号 {...} 中的语句。但不管怎样，都会执行紧跟在右花括号后面的语句。另一种形式就是还有一个 else 子句，它也带有一组语句，会在条件为假时执行。无论条件真假，整个 if-else 语句块后面的语句都会执行。

可能你也注意到了，这个示例程序是通过缩进来表示结构的：while 和 if 语句都缩进了。这是一种标准（值得提倡）的做法，能让人一眼就看出 while 和 if 语句都控制着哪些语句。甚至还有一些编程语言要求遵循一致的缩进规则。

把这段程序放到一个网页里就可以测试了。但专业的程序员不必把它放到网页里也能模拟其行为。他们会像计算机一样，认真地推敲每一条语句。如果你也能做到这样（这是确保理解程序的好办法），就可以推断出输入任意值程序都能得出正确的结果。

真的吗？如果输入中包含正数那没问题，但要是输入的都是负数呢？你会发现程序始终会说最大的数是零。

想一想这是为什么。这个程序把到目前为止发现的最大值保存在变量 max 中（就像找出房间里个子最高的人一样）。为了跟后续的数值进行比较，这个变量必须有一个初始值，因此程序一开始（在用户提供任何值之前）就把它设为零。要是用户真的输入了一个大于零的值固然好，就像输入身高一样。可要是用户输入的都是负值（在录入信用卡账单时有这种可能），程序不会输出最大的负值，而是会输出那个终止输入的值。

这个问题容易解决。本章后面会给出一个方案，不过这倒是一个练习的好机会，你也试试吧。

通过这个例子还可以学到编程的另一个重要方面：测试。测试远不止是随机地向程序抛出几个数值那么简单。好的测试人员会绞尽脑汁地想象程序会在什么情况下出错，想象那些「边缘」或「边界」情形，比如根本没有数据或者被零除。好的测试人员会想到输入都是负值的可能性。但问题是，随着程序越写越大，想象出所有测试用例的难度也越来越大，因为用户可能会以任意次序、在任意时间输入任意值。没有完美的解决方案，这时候认真地设计和实现程序就显得很关键。比如从一开始就在程序里添加检测和比较代码，以便在出现问题时，程序自己就可以第一时间捕获。

7.6 库和接口

JavaScript 作为一种扩展机制在高级 Web 应用中扮演着十分重要的角色。Google Maps 就是一个典型的例子，它提供了一个库和一套 API，于是所有地图操作就可以通过 JavaScript 程序（而不仅仅是鼠标点击）来控制了。任何人都可以编写自己的 JavaScript 程序在谷歌提供的地图上显示信息。这套 API 使用起来很方便，比如下面这段代码（当然还得有几行 HTML）

function initialize() { var latlong = new google.maps.LatLng(38.89767967065576, -77.03656196594238); var opts = { zoom: 18, center: latlong, mapTypeId: google.maps.MapTypeId.HYBRID }; var map = new google.maps.Map(document.getElementById("map"),opts); var marker = new google.maps.Marker({ position: latlong, map: map, title: "You are here, more or less" }); }

就可以显示出下面所示的地图，没准本书读者中就有人住在这个叫白宫的地方呢。

第 11 章还会向大家证明，互联网应用发展的趋势是 JavaScript 应用会越来越多，包括地图这种可以编程控制的接口。在被迫公开源代码的环境下，要保护知识产权很难。如果你在使用 JavaScript 编程，就必须自己想办法。任何人都可以通过在网页上单击右键并选择「查看源代码」看到你的源代码。有些 JavaScript 程序经过了混淆处理，可能是开发者有意为之，也可能是为了加快下载速度而被「瘦身」的结果。经过混淆的程序已经非常难破译了，除非碰上那些顽固的死磕分子。

7.7 JavaScript 怎么工作

大家回忆一下第 3 章关于编译器、汇编器和机器指令的内容。JavaScript 程序会以同样的方式被转换成可以执行的形式，但细节方面却有着明显差异。浏览器在遇到网页中的 JavaScript 代码时（比如解析到 <script> 标签时），就会把代码文本移交给 JavaScript 编译器 —— 通常是一个独立的程序或者是浏览器的一个库。编译器处理程序、检测错误，然后将其编译为与「玩具」类似的一个假想机器的汇编语言指令。当然，这套指令系统包含的指令要多得多，而实际上它正是我们上一章讲过的一种虚拟机。这个虚拟机接着会像玩具模拟器一样也运行一个模拟器，执行 JavaScript 程序设定的指令。模拟器与浏览器保持着密切交互，比如用户单击按钮，浏览器马上就会通知模拟器哪个按钮被单击了。在模拟器希望做点什么的时候，比如弹出一个对话框，它就会调用 alert 或 prompt 让浏览器照着去做。

关于 JavaScript，我们这里只能介绍这么多。要是你觉得意犹未尽，可以买本专门讲 JavaScript 的书看一看，其实网上也有很多免费教程，有些教程还可以让你在线编写代码，实时查看结果。编程这件事儿可能会让人纠结郁闷，也能给人带来极大乐趣。你甚至可以靠写代码过日子，而且还能过得不错。任何人都可以成为程序员，但如果你可以做到大处着眼小处着手那就难得了。更难得的是注重细节、一丝不苟，因为只要你稍有疏忽，写出的程序就可能出错，甚至根本无法运行。

对了，本章前面还给大家留了一道练习题呢。下面是一种可能的解法：

num = prompt("Enter new value, or 0 to end"); max = num; while (num != 0) ...

这里把 max 设为用户输入的第一个数值，无论正负，它都是目前为止最大的值。其他代码都不用动，程序就可以处理各种输入（当然，输入的值为零则提前退出），甚至都可以应付用户什么都不输入的情况。如果想让程序响应更妥当，就必须好好地理解和运用 prompt 函数。

软件部分小结

到目前为止，我们已经谈论了不少关于软件的内容。下面就对前几章的要点作个简要总结。

算法。算法就是一系列精确、无歧义的步骤，可以执行某种任务，然后停止。算法描述了不依赖于任何实现的计算过程。这些步骤由定义明确的基本操作或原始操作构成。算法有很多，我们只介绍了基本的搜索和排序算法。

复杂性。算法的复杂性是对算法要执行的工作量的抽象描述。度量的依据是基本操作（如检测数据项、比较数据项），而表述的是计算次数与数据项数的关系。算法的复杂性可以分为几个层次，就我们介绍的几种算法而言，既有对数级算法（数据量加倍，计算次数只加一）也有线性算法（计算次数与数据量成正比，最常见也最容易表达） ，还有指数级算法（数据量加一，计算次数加倍）。复杂性度量的是最坏情况（实际的问题很可能要简单得多），而且描述的是一种渐近性质（只有数据量很大的时候才适用）。

编程。算法是抽象的，而程序是具体的。程序是让计算机完成一个任务的所有步骤的具体描述。程序必须考虑内存和时间的限制、数值的大小和精度，以及偏激和恶意用户。

编程语言。编程语言是表达所有计算步骤的记号库，人们可以籍此轻松写出代码来，而且代码可以被翻译成计算机最终可以执行的二进制形式。翻译方式有很多种，但最常见的是使用编译器，有时候还要用汇编器，把用 C 等语言编写的程序转换成二进制形式，以便在计算机上运行。不同的处理器有不同的指令集和指令形式，因此编译器也会有相应的差异。解释器和虚拟机是模拟真正或假想计算机的程序，可以面向它们编译并运行代码。JavaScript 程序就是面向解释器编译运行的。

库。编写一个在真正计算机上运行的程序要牵扯很多细节，涉及很多常用操作。库以及类似的机制可以提供预制的组件，供程序员在编程时使用。有了库，程序员就可以在既有工作成果基础上开展新工作。今天的编程工作通常都是组织既有组件与编写原创代码并重。组件可能是库函数（比如 JavaScript 程序中用到的那些函数），也可能是像 Google Maps 一样的大型系统，或者是其他 Web 服务。然而，从底层来看，它们都是由程序员使用我们介绍过的语言或没介绍过的类似语言指令编写的。

接口。接口或者 API（应用程序编程接口）是提供服务的软件与使用该服务的软件之间的一种约定。库和组件通过 API 提供服务。操作系统通过自身的系统调用接口让硬件看起来更有章可循，而且可以编程控制。

抽象和虚拟化。使用软件可以隐藏实现的细节或者把实现伪装成其他东西，比如虚拟内存、虚拟机和解释器。

Bug。计算机不懂宽容，因此容易犯错的程序员必须写出某种程度上没有错误的程序来。所有大型程序都有 bug，也就是说有时候会不听使唤。某些 bug 仅仅只是惹人讨厌，比如设计得不好，并不像真正的错误那么严重。（「这不是 bug，而是一个功能」是程序员中流行的说法。）而有些 bug 只有在极端情况下或者罕见的情境中才会出现，往往很难再现，更不用说修复了。但有些 bug 确实严重，甚至会威胁到人身安全。随着软件在关键系统中的应用越来越广，对计算设备中软件责任的认定也变得越来越重要。过去那种「买不买由你，一旦售出概不负责」的说辞应该改一改了。对待软件也应该像对待硬件一样，厂商必须尽到保护用户的合理责任。

根据经验，因为程序是基于既有组件构建的，而原有 bug 都会消灭掉，至少从原理上讲，新程序中的错误应该越来越少。然而，与这些进步因素相对的是随着计算机和语言的发展，系统承载的需求将越来越多样，市场和消费者呼唤新功能带来的压力也会越来越大，于是无法避免的隐患也会层出不穷。总之，bug 将成为我们心中永远的痛。