## 第二部分 软件

好消息是，计算机是一种通用机器，能够执行任何计算。虽然它只有很少的指令，但执行这些指令的速度却极快，而且它能够很大程度上控制自己的运行。

坏消息是，如果没有人告诉它该做什么，它就什么都不会做，而且得事无巨细一五一十地告诉它。计算机是「魔法师的学徒」，能够不知疲倦、分毫不差地执行指令，但下达给它的任务书也必须高度精确。

能够让计算机完成某种任务的指令序列通称软件。软件的「软」与硬件的「硬」相对，寓意看不见，摸不着。硬件是有形的：如果失手把计算机掉在脚上，你会喊疼。软件则没有这个问题。

在接下来的几章中，我们要讨论软件，即如何告诉计算机做什么。第 4 章会概括地谈谈软件，并着重讨论一下算法，它们实际上是诸多焦点任务的理想化解决方案。第 5 章讨论编程和编程语言，我们用它来表达一系列计算步骤。第 6 章介绍主要的软件系统，无论你知道与否，反正每天都在用。本部分最后一章是第 7 章，讲讲 JavaScript 编程。

在此期间，要把这些牢记于心：现代系统越来越多地采用通用硬件（如处理器、内存，以及与外界相连接的接口），同时靠软件来实现特定的行为。人们普遍认为，软件更便宜、更灵活，比硬件更好修改（特别是跟已经出厂的设备比）。例如，如果用一台计算机来控制汽车的动力和刹车，那么防抱死和电子稳定控制显然应该是软件的功能。举一个明显的例子。2010 年 4 月的美国《消费者报告》（Consumer Reports）称丰田雷克萨斯 GX460 车型「不能买：存在安全隐患」，因为其电子稳定控制系统会导致这款 SUV 在急速转弯时车尾过分向外甩，从而可能导致翻车事故。一个月之内，丰田公司就升级软件，修复了这个问题。根本就没有任何机械问题，仅仅是软件最初有些问题。

此外，丰田车主必须到经销商处升级软件，到了那儿可能需要把连接器插到发动机舱中的某个插槽上，或许不是 USB，但思路应该一样。不难想象另一种情景：开车经过经销商的门店即可升级，或者利用智能手机的无线连接也可以升级。当然也不难想象，以开车经过的方式升级也有潜在的问题。

这个例子也提醒我们，计算机是许多关键系统的核心，并且软件控制着这些系统。MRI（核磁共振）和 CT（电脑断层）扫描等医学成像系统，就是用计算机来控制信号，并生成供医生解读的图像（胶片已经被数字图像取代）。现代汽车都有数十个小型计算机，分别负责管理制动和稳定性控制系统，无论哪个出问题，后果都不堪设想。火车、轮船、飞机也概莫能外。最近，一位飞行员朋友跟我说，他的飞机升级了软件系统，自动驾驶仪的操控方式完全变了一个样。航空交通管制系统、辅助导航设备、电网和电话系统也同样如此。基于计算机的投票器曾经有过严重的缺陷。军事系统更是完全依赖于计算机，而全球的金融系统不也一样嘛？「网络战争」指的是对诸如此类的计算机系统的攻击，已经成为一个流行的名词。这些威胁在现实中存在吗？应该说是存在的。例如，2010 年底「超级工厂」（Stuxnet worm）蠕虫病毒攻击了伊朗核电站的铀浓缩离心机，显然不像是偶然事件。

事实表明，只要软件不可靠不耐用，我们就一定会遇到麻烦。而随着人们对软件越来越依赖，潜在的麻烦也只会越来越大。后面我们还会介绍到，很难写出一点问题都没有的软件。逻辑或实现上的任何一点错误或疏忽，都可能导致程序出问题。即使正常使用中不会发生这些问题，也会给敌人留下可乘之机。

## 软件部分小结

到目前为止，我们已经谈论了不少关于软件的内容。下面就对前几章的要点作个简要总结。

算法。算法就是一系列精确、无歧义的步骤，可以执行某种任务，然后停止。算法描述了不依赖于任何实现的计算过程。这些步骤由定义明确的基本操作或原始操作构成。算法有很多，我们只介绍了基本的搜索和排序算法。

复杂性。算法的复杂性是对算法要执行的工作量的抽象描述。度量的依据是基本操作（如检测数据项、比较数据项），而表述的是计算次数与数据项数的关系。算法的复杂性可以分为几个层次，就我们介绍的几种算法而言，既有对数级算法（数据量加倍，计算次数只加一）也有线性算法（计算次数与数据量成正比，最常见也最容易表达） ，还有指数级算法（数据量加一，计算次数加倍）。复杂性度量的是最坏情况（实际的问题很可能要简单得多），而且描述的是一种渐近性质（只有数据量很大的时候才适用）。

编程。算法是抽象的，而程序是具体的。程序是让计算机完成一个任务的所有步骤的具体描述。程序必须考虑内存和时间的限制、数值的大小和精度，以及偏激和恶意用户。

编程语言。编程语言是表达所有计算步骤的记号库，人们可以籍此轻松写出代码来，而且代码可以被翻译成计算机最终可以执行的二进制形式。翻译方式有很多种，但最常见的是使用编译器，有时候还要用汇编器，把用 C 等语言编写的程序转换成二进制形式，以便在计算机上运行。不同的处理器有不同的指令集和指令形式，因此编译器也会有相应的差异。解释器和虚拟机是模拟真正或假想计算机的程序，可以面向它们编译并运行代码。JavaScript 程序就是面向解释器编译运行的。

库。编写一个在真正计算机上运行的程序要牵扯很多细节，涉及很多常用操作。库以及类似的机制可以提供预制的组件，供程序员在编程时使用。有了库，程序员就可以在既有工作成果基础上开展新工作。今天的编程工作通常都是组织既有组件与编写原创代码并重。组件可能是库函数（比如 JavaScript 程序中用到的那些函数），也可能是像 Google Maps 一样的大型系统，或者是其他 Web 服务。然而，从底层来看，它们都是由程序员使用我们介绍过的语言或没介绍过的类似语言指令编写的。

接口。接口或者 API（应用程序编程接口）是提供服务的软件与使用该服务的软件之间的一种约定。库和组件通过 API 提供服务。操作系统通过自身的系统调用接口让硬件看起来更有章可循，而且可以编程控制。

抽象和虚拟化。使用软件可以隐藏实现的细节或者把实现伪装成其他东西，比如虚拟内存、虚拟机和解释器。

Bug。计算机不懂宽容，因此容易犯错的程序员必须写出某种程度上没有错误的程序来。所有大型程序都有 bug，也就是说有时候会不听使唤。某些 bug 仅仅只是惹人讨厌，比如设计得不好，并不像真正的错误那么严重。（「这不是 bug，而是一个功能」是程序员中流行的说法。）而有些 bug 只有在极端情况下或者罕见的情境中才会出现，往往很难再现，更不用说修复了。但有些 bug 确实严重，甚至会威胁到人身安全。随着软件在关键系统中的应用越来越广，对计算设备中软件责任的认定也变得越来越重要。过去那种「买不买由你，一旦售出概不负责」的说辞应该改一改了。对待软件也应该像对待硬件一样，厂商必须尽到保护用户的合理责任。

根据经验，因为程序是基于既有组件构建的，而原有 bug 都会消灭掉，至少从原理上讲，新程序中的错误应该越来越少。然而，与这些进步因素相对的是随着计算机和语言的发展，系统承载的需求将越来越多样，市场和消费者呼唤新功能带来的压力也会越来越大，于是无法避免的隐患也会层出不穷。总之，bug 将成为我们心中永远的痛。

