这可能会导致一些奇怪的情况。几年前，我在美国高速公路上开车，收听到加拿大电台的节目。加拿大采用公制单位，播音员出于好意，想照顾到所有美加的听众，就如此宣布说：「刚才的一小时，华氏度上升了一度，摄氏度没有变化。」

有人要问，为什么用数字而不用模拟呢？我们这个世界可是模拟的呀，而且手表、速度表等等模拟设备也更容易让人一目了然。但不管怎样，很多现代的技术都是数字的，而且我们这本书也是在讲述数字的故事。外部世界的数据 —— 声音、图片、运动、温度，等等一切，在输入端都会尽可能早地转换为数字形式，而在输出端则会尽可能晚地转换回模拟形式。原因就在于数字化的数据容易处理，无论最初来源是什么，数字化数据都可以用多种方式来存储、传输和处理，但模拟信息则不行。第 9 章将会介绍，通过删除冗余和不重要的信息，还可以压缩数字化信息。为了安全和隐私可以对它进行加密，可以将它与其他数据合并，可以复制它而不出错，可以通过互联网把它发送到任何地方，可以将它保存到几乎无限种设备中。而对于模拟信息，上述很多做法是根本行不通的。

与模拟系统相比，数字系统还有另一个优势，就是它更容易扩展。比如说，给模拟天文馆增加一颗新发现的星星，专业人员必须辛苦地做出光照效果来；而在数字天文馆，只要在数据文件里添加一行信息即可。我的数字手表可以连续不断地以百分之一秒显示时间流逝，而要让模拟手表做到这一点可就太难了。不过，模拟系统有时候也有它的优势，像泥版、石雕、羊皮纸、图书和照片等古老的媒体，都经历了数字格式未曾经历过的时间考验。

2.2 模数转换

怎么把模拟信息转换为数字形式？我们还是举几个简单的例子吧，先说照片和音乐，通过它们可以说明一些重要的思想。

把照片转换为数字形式，应该是最容易想象的了。假设我们给自家的小猫拍张照片：

胶卷相机的成像，是通过把胶片感光区曝露给被拍物体反射的光线实现的，胶片上不同区域接收到的不同颜色的光量不同，从而影响胶片上的染料。在胶片显影、印相时，彩色染料数量决定了显示出来的颜色变化。

对数码相机来说，镜头把影像聚焦到一块位于红、绿、蓝滤镜后面的矩形感光器阵列上，感光器由微小的光敏探测器组成。每个探测器存储一定数量的电荷，与落在它上面的光量成正比。这些电荷被转换为数字值，照片的数字表示就是这些表现光强度的数值序列。探测器越小，数量越多，电荷测量的结果就越精细，数字化图像就能越精确地反映原始的影像。

传感器阵列的每个单元都由一组能够捕获红、绿、蓝光的探测器构成，每个单元对应一个像素，即像元。3000×2000 像素的图像，包含 600 万个像元，或 600 万像素，对今天的数码相机而言并不算大。像素的颜色通常由三个值表示，分别代表红、绿、蓝光的强度，因此 600 万像素的图像总共要存储 1800 万个颜色值。屏幕在显示图像时，使用的是红、绿、蓝光三元组的阵列，其亮度与像素亮度一致。如果你用放大镜仔细观察手机或电脑屏幕，很容易看到每个独立的彩色块。

第二个模数转换的例子是声音，尤其是音乐。之所以说音乐是个不错的例子，原因在于以它为代表的数字信息的所有权，第一次引起了社会、经济和法律上的广泛关注。数字音乐与唱片或磁带不同，你可以在自己家的计算机里无限次地复制它，完全免费，而且还可以通过互联网把它复制发送到世界的任何角落，不会有任何音质损失，同样完全免费。唱片业把这当成了严重的威胁，试图通过法律或政治手段阻止数字音乐的拷贝。这场战争远未结束，每天都有小规模的战役打响，因此而对簿公堂和引爆政治辩论俨然成了家常便饭。

什么是声音？音源通过振动或快速运动引起空气压力的波动，人的耳朵把这种压力变化转换为神经活动，经大脑解释之后就形成了「声音」。1870 年代，托马斯·爱迪生制造了一个叫做「留声机」的机器，这台机器能把声波转换为蜡筒上类似的螺旋沟槽，而通过这些沟槽又能再次创造出同样的气压波动来。把声音转换为沟槽就是「录音」，而从沟槽换回到气压波动就是「回放」。爱迪生的发明迅速地得到改进，1940 年代就出现了密纹唱片（long-playing record）或简称 LP，而且至今还在使用（尽管数量已经不多了）。麦克风随着时间推移把变化的声压转换为变化的值并记录下来，然后根据这些值在乙烯基的盘片上压制出与声压一致的螺旋沟槽。播放 LP 时，唱针随着沟槽起伏，其运动轨迹被转换为波动的电流，电流经过放大后驱动扬声器或耳机，通过它们的振动薄膜产生声音。

把空气压力随时间的变化形象地绘制出来并不难。其中压力可以用任何物理方法来表示，在此我们假设用电路中的电压。当然，电流、光的亮度，以及爱迪生发明的留声机中的纯机制装置都没有问题。

图中声波的高度表示声音强度或大小，水平方向的坐标轴表示时间：每秒钟声波的数量就是声调或频率。

假设我们以固定时间间隔连续测量这条曲线的高度（在这里就是电压值），就会得到下图所示的这些垂直线条。

测量得到的数值连接起来与曲线近似，测量越频繁，越准确，结果也就越吻合。测量得到的数值序列是波形的数字化表示，可以存储、复制、操作它们，也可以把它们发送到任何地方。如果有设备把这些数值转换成对应的电压或电流，然后再通过电压或电流驱动音箱或耳机，就能够实现回放。从声波到数值是模数转换，相应的设备叫 A/D 转换器；反过来当然是数模转换，或者叫 D/A。转换过程并不是完美无缺的，两个方向的转换都会损失一点信息。但大多数情况下，这种损失是人所觉察不到的（当然，也有不少唱片发烧友会说 CD 音质不如 LP 好）。

1982 年左右，音频光盘（或 CD）面世，成为最早承载数字声音的产品。今天的读者，恐怕没有谁不认识这个标志：

与 LP 唱片上的模拟沟槽不同，CD 用长长的螺旋状轨道在盘面的一侧记录数值。轨道上任意一个区块的表面要么平滑，要么是一个微小的凹坑。这些下凹或平滑的区块就是用来编码声波的数字值的，每个区块是一位，连续的多位表示二进制编码中的一个数值，二进制的概念我们在下一节再介绍。光盘旋转时，一束激光照射到轨道上，而光电传感器则检测每个区块上反射回来的光量多少。如果光量不多，说明是凹坑；如果反射光很强，说明不是凹坑。标准 CD 编码采样率为每秒 44 100 次，而每次采样获得两个振幅值（立体声的左、右声道），精确度为 65 536（即 216，这并非巧合）分之一。轨道上的每个区块非常非常小，小到只有用显微镜才能看见，一张 CD 的表面上有 60 亿个小区块。（DVD 中的区块更小，由于区块更小，激光束频率更高，DVD 的存储容量近 5GB，而 CD 大约为 700MB。）

音频 CD 的出现几乎让 LP 没有了立足之地，相比之下，CD 的优点实在太多了：落上点灰尘也不用太担心了，更没有磨损一说，而且绝对小巧。但到了我写这本书的时候，LP 开始在某种程度上复苏，流行音乐 CD 的人气则日渐衰退。有朝一日，CD 很可能也会像 LP 一样变成古董，这倒让我很高兴，因为我收藏的音乐全部都是 CD 格式的。我现在完全拥有它们，而它们的存在将比我的生命更久远。CD 还有第二个用途，那就是作为存储、分发软件及数据的介质，不过这个功能已经被 DVD 取代，而 DVD 很可能又会被下载所取代。

声音和图片经常会被压缩，因为这两种媒体包含很多人类根本感知不到的细节。对于音乐，典型的压缩技术是 MP3，大约能把音频文件的体积压缩到原来的十分之一，同时几乎让人感觉不到音质下降。对于图片，最常用的压缩技术是 JPEG（是制定该标准的联合图像专家组 ——Joint Photographic Experts Group 的英文字头），它的压缩率也能达到 10 倍甚至更高。上文提到很多处理对数字信息能做，但对模拟信息却很难（或不可能），压缩就是一个例子。第 9 章我们再进一步探讨压缩。

那电影呢？1870 年代，摄影师埃德沃德·迈布里奇向世人证明，快速连续地显示一系列静态图片能够创造出运动的错觉。今天，电影显示影像的速度是每秒 24 帧，而电视大约是 25 到 30 帧，这个速度足以让人的眼睛把顺序播放的影像感知为动画。而通过组合（并同步）声音和影像，就可以创造出数字电影。而利用压缩技术减少空间占用，则催生了包括 MPEG（代表 Moving Picture Experts Group）在内的标准电影格式。实际上，视频的表示要比单纯的音频表示更复杂，一方面是它本身就复杂，另一方面很大程度上还因为它受到了电视的拖累，而电视在其存在的大部分时间内都是模拟的。模拟电视在世界范围内正逐渐被淘汰，而美国 2009 年已经将广播电视切换成了数字信号。

还有一些信息很方便以数字形式来表示，因为除了想好如何表示它之外，根本不需要做什么转换。比如这本书中的文字、字母、数字和标点符号，我们称为其普通文本。可以为其中每个字母指定一个唯一的数值，如 A 是 1，B 是 2 等等，这不就是一种数字化表示方法嘛。而事实也正是如此，只不过在表示标准中，A 到 Z 用的是 65 到 90，a 到 z 用的是 97 到 122，数字 0 到 9 用的是 48 到 57，而标点符号等其他字符用的是其他数值。这个表示标准叫做 ASCII，即 American Standard Code for Information Interchange（美国信息交换标准代码）。

下面给出了 ASCII 中的部分标准编码，前四行被我省略了，因为其中包含的都是些制表符、空格符等非打印字符。

不同地区有不同的字符集标准，但也有一个世界通用的标准叫 Unicode，它为所有语言的所有字符都规定了一个唯一的数值。这是一个非常庞大的字符集，人类的创造力是无穷无尽的，但在建立自身书写系统方面却很少有规则。目前，Unicode 涵盖的字符远远超过 100 000 个，而且这个数字还在稳步增长。可想而知，Unicode 中的大部分都是包括中文在内的亚洲字符集，但决不限于此。要了解 Unicode 都包含哪些字符集，可以访问 unicode.org，这个站点内容丰富，强烈推荐读者去看一看。

一言以蔽之：数字表示法能够表示上述所有信息，以及任何可以转换为数值的信息。因为只有数值，所以就可以用数字计算机来处理，而且正如第 9 章要介绍的，还可以通过互联网等通用数字网络将它复制到其他计算机上去。

2.3 比特、字节与二进制

「世界上只有 10 种人，理解二进制的和不理解二进制的。」

数字系统用数值来表示所有信息，但使用的却不是我们熟悉的（以 10 为基数的）十进制，这乍一看让人有点纳闷。那使用几进制？使用二进制，也就是逢 2 进 1 的数制。

虽说是人都或多或少懂点数学，但以我的经验来看，人们对数值的理解有时候并不靠谱。这一点从描述（再熟悉不过的）十进制和（多数人不熟悉的）二进制之间的关系就可以看出来。在这一节里，我会尽最大努力讲得通俗易懂，万一你听不懂或者我没讲清楚，你只要不断对自己重复一句话：「跟普通的数一样，只不过是逢 2 而不是逢 10 进 1。」

2.3.1 比特

表示数字信息的最基本单位是比特（bit）。英文 bit 是合并 binary digit（二进制数字）之后造出来的，造这个词的人是统计学家约翰·图基，时间是 1940 年代中期。（图基还在 1958 年发明了单词 software—— 软件。）据说，鼎鼎大名的氢弹之父爱德华·泰勒更喜欢「bigit」这个词，但这个词最终没有流行起来，真是谢天谢地。binary 是指只有两个值的东西（前缀「bi」的意思就是「两个」），事实也的确如此：一个比特就是要么是 0 要么是 1 的一个数，没有其他可能。而十进制中有 0 到 9，共有 10 种可能的值。

只用一个比特，可以表示任何二选一的事物。这种二选一的例子比比皆是：开 / 关、真 / 假、是 / 否、高 / 低、进 / 出、上 / 下、左 / 右、南 / 北、东 / 西、男 / 女，等等。一个比特足以让人确定选择了两个中的哪一个。举个例子，我们可以用 0 表示「关」，用 1 表示「开」，或者反过来，哪个值表示哪个状态都无所谓，只要大家都没有意见就行。这张图是我的打印机的电源开关，由此可见，惯例还是用 0 表示「关」，用 1 表示「开」。

一个比特表示开 / 关、真 / 假之类的二选一的情形没有问题，但我们经常还要面对更多选项，表示更复杂的事物。为此，可以使用一组比特，然后为不同的 0 和 1 的组合赋予不同的含义。比如，可以用两个比特来表示大学四年：新生（00）、大二（01）、大三（10）和毕业班（11）。如果再多考虑一种情况，比如研究生，那两个比特就不够用了，因为两个比特只有 4 种组合，没有第五种可能。但是三个比特没问题，实际上三个比特能表示 8 种不同的情况，这样我们就可以把教师、教工和博士后都包含进来。三个比特的全部组合为：000、001、010、011、100、101、110 和 111。

比特数与它们所能表示的情况数之间有一个关系，很简单：N 个比特能表示 2N 种组合，即 2×2×2…×2（乘 N 次）。据此，就有：

比特数 值数 比特数 值数

1 2 6 64

2 4 7 128

3 8 8 256

4 16 9 512

5 32 10 1 024

对于十进制数呢？其实也有类似的关系：N 个十进制数字，可以表示 10N 种不同的情况（我们称之为「数值」）：

位数 值数 位数 值数

1 10 6 1 000 000

2 100 7 10 000 000

3 1 000 8 100 000 000

4 10 000 9 1 000 000 000

5 100 000 10 10 000 000 000

2.3.2 2 的幂和 10 的幂

由于计算机中的一切都是以二进制形式来处理，因此像大小、容量等概念一般都是用 2 的几次幂来表达的。如果有 N 比特，那么就有 2N 种可能的值，所以知道 2 的幂是多少（比如到 210）是很有用的。但随着数值越来越大，完全记住它们也没有什么必要。好在有一种简便的方法，可以得到它们的近似值：2 的某次幂与 10 的某次幂接近，它们的对应关系严格有序，容易记忆：

（这个对照表最后包含的表示大小的单位叫「拍」或 1015，其英文单词发音不是「皮」而是「拍」。另外，书后附有一个更全的词汇表，列出了更多单位。）随着数值增长，这个近似值的误差也会增大，不过到了 1015 这么大的时候误差也就 12.6%，所以还是可以在很大范围内使用的。经常会有人混淆上述 2 的幂与 10 的幂之间的关系（有时候是想用来支持他们的观点），于是 kilo 或 1K 可能是指 1000，但也可能指 210 即 1024。一般来说，这种混淆导致的误差并不大，因此在涉及很大的比特数时，用 2 和 10 的幂来做心算没什么问题。

说起来可能有点不值当的，但这种差异有时候也会带来麻烦。例如，著名硬盘驱动器制造商美国希捷公司，就曾因为这种差异在加州卷入一场集体诉讼。「原告称希捷公司对存储容量的术语 gigabyte（或 GB），使用的是十进制定义，即 1GB = 109（1 000 000 000）字节，这是在误导消费者，因为计算机操作系统报告硬盘容量时，使用的是 GB 的二进制定义，即 1GB=230（1 073 741 824）字节，相差大约 7%。」我个人并不认为很多消费者被严重误导了，但希捷公司选择了和解，并没有据理力争。

2.3.3 二进制数值

如果每个数字都能按照通常的进位法则来解释，那么一系列比特就可以表示一个数值，只不过此时的基数是 2，而不是 10。0 到 9，共 10 位数字，足以为 10 个项目计数或分配标签。如果数量超过 10，则必须使用更多位数字，比如两位十进制数字可以表示的数值或标签能达到 100 个，即 00 到 99。多于 100 的时候，就要用三位数字，其表示的范围是 1000，即 000 到 999。（根据约定俗成的做法，我们平时不会写出数值前导的零，但这些零是暗含的。另外，我们平时计数也都从 1 而非 0 开始。）

十进制数值实际上是 10 的某次幂之和的简写，比如 1867 就是 1×103+8×102+6×101+7×100，即 1×1000+8×100+6×10+7×1，即 1000+800+6+7。上小学的时候，你把它们叫做个位、十位、百位……。这些概念我们太熟了，熟到根本不用去想。

二进制数也一样，只不过基数是 2，不是 10，而且只涉及 0 和 1 两个数字。比如可以把二进制数 11101 看成 1×24+1×23+1×22+0×21+1×20，用十进制来表示，就是 16+8+4+0+1，即 29。

既然比特序列可以解释为数值，那么自然就有了为项目分配二进制标签的模式：按数值顺序排列。前面我们看到了为新生、大二、大三、大四学生分配的标签 00、01、10、11，它们分别是十进制数值的 0、1、2、3。紧接着的序列是 000、001、010、011、100、101、110、111，也就是十进制数值 0 到 7。

下面我们做个练习，看你理解了多少。我们都熟悉扳着自己的手指从一数到十，要是你用二进制数来数（每个手指，包括大拇指，都代表一位二进制数），最大能数到多少？值的范围有多大？如果你数到 132，发现它的二进制表示是一个似曾相识的手势，那说明我前面讲的你都理解了。

前面我们都看到了，把二进制转换成十进制很容易：只要把相应位置上值为 1 的 2 的对应次幂加起来即可。而把十进制转换成二进制要难一些，但也不太难。就是反复地用 2 除十进制数。每次除完，把余数写下来，要么是 0，要么是 1，然后再用 2 除商。这样反复除下去，直到原来的数被除到等于 0。最后得到的余数的序列，就是相应的二进制数，但顺序相反，所以要倒转一次。

举个例子，把 1867 转换为二进制数的步骤如下：

十进制数 商 余数

1867 933 1

933 466 1

466 233 0

233 116 1

116 58 0

5829 0

29 14 1

14 7 0

7 3 1

3 1 1

1 0 1

反向读取这些位，能得到 111 0100 1011，把相应位上为 1 的 2 的对应次幂加起来可以验算：1024+512+256+64+8+2+1＝1867。

整个过程的每一步都会产生剩余数值的最低有效位（即最右边的位）。其实，把一个很大秒数表示的时间转换成日、时、分、秒的过程与此类似：除以 60 得到分钟（余数是秒），结果除以 60 得到小时（余数是分钟），结果再除以 24 得到天数（余数是小时）。区别在于时间转换使用了不止一个基数，而是先后用到了 60 和 24。

二进制的算术实在太简单了。因为总共才两个数字，加法和乘法表都只有两行两列。

虽然你将来不太可能自己动手做二进制算术，但这两个如此简单的表，其实也说明了为什么相对于十进制算术，执行这种计算的计算机电路要简单得多。

2.3.4 字节

在所有现代计算机中，数据处理及内存组织的基本单位都是 8 个比特。8 比特被称为 1 字节，而字节（byte）这个词是由 IBM 的计算机设计师维尔纳·巴克霍尔兹（Werner Buchholz）在 1956 年发明的。一个字节可以编码 256 个不同的值（28，即 8 个 0 和 1 的所有不同组合），这个值可以是一个 0 到 255 间的整数，也可以是 ASCII 字符集中的一个字符，或者其他什么。通常，为了表示更大或更复杂的数据，需要用到多个字节的字节组。两个字节有 16 比特，也就是 16 位，可以表示 0 到 216-1（65 535）之间的数值。两个字节也可以表示 Unicode 字符集中的一个字符，比如以下字符中的任意一个：

这是两个字符，即「东京」，每个字符占两个字节。四个字节是 32 位，既可以表示「东京」，也可以表示最大直至 232-1 的值，这个最大值大约是 43 亿。用一组字节表示什么都可以，但 CPU 自己特别定义了一些适中的字节组（比如表示不同大小的整数），以及处理这些字节组的指令。

要是你想把一或多个字节表示的数值写出来，那可以用十进制，如果它真是一个数值的话，十进制是最适合人类看的。如果你想看清每一个比特，特别是在不同比特编码不同信息的情况下，那还是二进制更方便。然而，二进制写起来太长了，比十进制格式长三倍还多，因此我们常用另一种替代数制，即十六进制。十六进制的基数是 16，因此也就有 16 个数字（就像十进制有 10 个数字，二进制有 2 个数字一样），分别是 0、1、…、9、A、B、C、D、E、F。每个十六进制数字表示 4 个比特，对于一般的数值，十六进制 0 相当于二进制 0000，依此类推，十六进制 9 相当于二进制 1001。接下去，十六进制 A 相当于二进制 1010（十进制 10），十六进制 B 相当于二进制 1011（十进制 11），依此类推，十六进制 F 相当于二进制 1111（十进制 15）。

除非你是程序员，否则能看到十六进制数的机会并不多。一个例子就是网页中的颜色值。前面说过，计算机中一个像素的颜色值大都使用三个字节来表示，一个表示红色分量，一个表示绿色分量，最后一个表示蓝色分量，这就是所谓的 RGB 编码。红绿蓝三个组分分别用一个字节表示，因此红色分量就有 256 种可能的值，三个组分中的绿色分量也有 256 种可能的值，同样，三个组分中的蓝色分量也有 256 种可能的值。于是一个像素可能的颜色值就是 256×256×256 种，听起来好多啊。我们可以用 2 和 10 的幂来简单估计一下这个数有多大。这个数是 28×28×28，即 224 或 24×220，大约是 16×106，即 1600 万。在描述计算机显示器的情况下，你可能听说过这个数（「超过 1600 万种颜色！」）。

一个深红色的像素可以表示为 FF0000，换句话说，就是红色分量最多，没有绿色和蓝色；而一个鲜蓝色（并非深蓝色），即类似很多网页中链接的颜色，可以表示为 0000CC。黄色是红加绿，因此 FFFF00 就是最深的黄色。阴影的灰色具有等量的红、绿、蓝组分，因此一个中等灰度的像素应该是 808080，也就是红、绿、蓝组分的数量都相等。黑色和白色分别是 000000 和 FFFFFF。

Unicode 编码表就使用十六进制来表示字符：

上面两个字符的十六进制编码为 6771 4EAC。第 8 章将会介绍以十六进制表示的以太网地址，第 10 章则会讨论用十六进制表示 URL 中的特殊字符。

有时候，在某计算机的广告中，我们会看到「64 位」这个说法（「Windows 7 家庭高级版 64 位」）。什么意思呢？计算机在内部操作数据时，是以不同大小的块为单位的，这些块包含数值（32 位和 64 位表示数值比较方便）和地址，而地址也就是信息在 RAM 中的位置。前面所说的 64 位，指就是地址。大约 25 年前，16 位地址升级到了 32 位地址（足够访问 4GB 的 RAM），而现在 32 位又升级到 64 位。我不想预测什么时候会从 64 变成 128，总得过上好一阵子吧，先不必想那么多。

关于比特和字节，我们讨论到现在最重要的是必须知道，一组比特的含义取决于它们的上下文，光看这些比特看不出来。一个字节可以只用 1 个比特来表示男或女，另外 7 个空闲不用，也可以用来保存一个不大的整数，或者一个 #之类的 ASCII 字符，它还可能是另一种书写系统中一个字符的一部分，或者用 2、4 或 8 个字节表示的一个大数的一部分，一张照片或一段音乐的一部分，甚至是供 CPU 执行的一条指令的一部分。

事实上，一个程序的指令就是另一个程序的数据。从网上下载一个新程序，或者从 CD-ROM 或 DVD 中安装该程序时，它就是数据，所有比特将无一例外地被复制一遍。但在运行这个程序时，它的比特会被当成指令，CPU 在处理这些比特时，又会把它们当成数据。

2.4 小结

为什么用二进制而不用十进制？因为制造只有两种状态（如开和关）的物理设备，比制造有十种状态的设备更容易。这种简单的性质在数不清的技术中都得到了利用，比如：电流（流动或不流动）、电压（高或低）、电荷（存在或不存在）、磁性（南或北）、光（亮或暗）、反射率（反光或不反光）。约翰·冯·诺依曼很早就清楚地认识到了这一点，他在 1946 年说过：「我们储存器中最基本的单位自然是采用二进制系统，因为我们不打算度量电荷的不同级别。」

为什么我们要知道或者要关心二进制数呢？这个问题问得好。至少在我的课上，理解另一种不熟悉的数制，相当于做了一次量化推理的练习，而有了这个训练之后，对我们习以为常的十进制的理解也将更深一层。除此之外，另一个意义在于，比特的数量在一定程度上揭示了涉及的空间、时间或者复杂性。再从根本上说，计算机值得我们花时间去理解，而二进制正是其运作的核心所在。

现实生活中也能找到一些与计算机无关的应用二进制的场景，或许是因为人们都认为大小、长短的加倍、减半是一种自然而然的运算。比如，高德纳在《计算机程序设计艺术》中描述了 14 世纪英国的酒器单位，分为 13 个二进制量级：2 吉耳是 1 超品（chopin），2 超品是 1 品脱，2 品脱是 1 夸脱，依此类推，直到 2 百瑞尔（barrel）是 1 豪格海（hogshead），2 豪格海是 1 派普（pipe），2 派普是 1 坦恩（tun）。这些单位中差不多还有一半仍然在英制液体度量体系中使用。当然，其中一些很令人陶醉的词，比如费尔金（firkin）和基尔德坎（kilderki）（2 费尔金是 1 百瑞尔），今天已经很难得见了。

第 3 章 深入了解 CPU

第 1 章我们说过，中央处理单元或者 CPU 是计算机的「大脑」，但当时并没有就这个术语多作讨论。这一章我们就来详细探讨一下 CPU，因为它是一台计算机中最重要的组件，而且理解其特性对理解本书后面的内容也至关重要。

中央处理器如何工作？ 它处理什么，怎么处理？直观来讲，CPU 有一个小型指令系统，包含着它能够执行的基本操作。它可以做算术题，加、减、乘、除，跟计算器一样。它可以从 RAM 中取得要操作的数据，然后再把结果保存到 RAM，与很多计算器中的存储操作一样。CPU 还要控制计算机的其他组件，确保鼠标、键盘等外围设备输入的数据得到响应，让信息在屏幕上得以显示，同时还要控制和协调连接到计算机的其他所有器件。

最重要的是，它可以作出决定 —— 尽管是简单的决定：它可以比较数值（这个数比那个数大吗？） 或者比较其他数据（这段信息与那段信息一样吗？），还能根据结果决定接下来做什么。这一条最重要，因为这意味着 CPU 能做的虽然比计算器多不了多少，但它可以在无人看管的情况下完成自己的工作。正如冯·诺依曼所说的：「要让这种机器完全自动化，即让它在计算开始后不再依赖人工操作。」

由于 CPU 能根据它所处理的数据决定下一步做什么，因此它就能自己运行整个系统。虽然其指令系统并不大，或者说并不复杂，但 CPU 每秒可以执行数十亿次运算，所以它能完成极为复杂的处理。

3.1 玩具计算机

为了解释 CPU 如何工作，我们先介绍一台不存在的机器。这是一台编造的或者说「假想的」计算机，它与真正计算机的原理相同，只不过要简单得多。因为这台计算机只存在于纸面上，所以我就可以随意设计它，让它能有助于我们理解计算机的工作机制。我还可以写一个真正的计算机程序，用它模拟我的纸面设计，这样就可以给假想的机器写程序，看看这些程序怎么运行。

我想了一下，就管这个编造的机器叫「玩具」计算机吧，因为它不是真的，但又具有真正计算机的很多特性。实际上，它跟 1960 年代末的小型机差不多是一个水平，某种程度上与冯·诺依曼论文中的例子相近。这个玩具有用来存储指令和数据的 RAM，还有一块额外的存储区叫累加器，其容量足以存储一个数值。累加器类似于计算器的显示屏，保存用户最近输入的数值，或者最近计算的结果。玩具还有一个指令表，只包含 10 个指令，都是前面提到过的基本操作。比如下面几个指令：

GET 从键盘获取数值并放到累加器中 PRINT 打印累加器中的内容 STORE M 把累加器中内容的副本保存到位置 M （累加器的内容不变） LOAD Val 把 Val 加载到累加器，Val 是一个值或值在存储器中的位置（Val 不变） ADD Val 把 Val 与累加器中的内容相加（Val 不变） STOP 停止运行

为了保证最简单，我们规定每个 RAM 位置可以保存一个数值或一条指令（至于如何表示先不说），这样就可以在 RAM 中保存由指令和数据共同组成的程序。运行时，CPU 从 RAM 的第一个位置开始，重复如下简单的循环：

读取 从 RAM 中取得下一条指令 译码 搞明白该指令要做什么 执行 执行指令 返回「读取」

而给这个「玩具」计算机编写程序，就是要写出一组完成相应任务的指令，把它们放到 RAM 中，然后告诉 CPU 去执行这些指令。举个例子，比如 RAM 中正有如下指令（指令在 RAM 中都保存为等价的数值形式）：

GET PRINT STOP

运行程序时，第一条指令会要求用户输入一个数值，第二条指令会把该数值打印出来，而第三条指令告诉处理器停止执行。这个过程似乎很无聊，但却足以说明程序是如何运行的。假如真有这么个「玩具」计算机，这个程序还真能运行哩。巧啦，确实有这种「玩具」计算机，下面就是其中一个在运行时的样子了：

按下 RUN，出现一个对话框：

键入一个数字，按下 OK，结果就这样了：

跟我们期望的一样，程序要求输入数值，打印它，然后停下来。

再看一个复杂些的程序。这个程序多了向 RAM 中存储值，然后再取出的操作。具体来说，程序先把一个数读到累加器中，然后把这个数保存到存储器，再把另一个数读到累加器中（覆盖前一个数），给它加上第一个数（从 RAM 中保存该数的位置取出），打印两个数的和，然后停下来：

GET 取得第一个数并放到累加器中 STORE Mem 把这个数保存到 RAM 中的位置 Mem GET 取得第二个数并放到累加器中 ADD Mem 给它加上第一个数 PRINT 打印两个数的和 STOP Mem － RAM 中的一个位置，保存用户输入的第一个数值

CPU 从程序的起点开始，每次取得一条指令。执行完一条指令后，继续取得并执行下一条指令。

唯一麻烦点儿的地方是要在 RAM 中辟出一个位置，好保存读到的第一个值。但不能把这个值留在累加器中，因为第二个 GET 指令会覆盖它。由于它是数据，而非指令，因此必须把它放在 RAM 中一个不会被当成指令取出来的位置。把数据放到程序末尾，所有指令后面，CPU 就不会把它解释成指令了，因为 STOP 指令会让 CPU 停下来，不会继续读取下一个位置。

还需要一种引用该位置的方法，这样程序中的指令才能在必要时找到它。或许可以把它放在存储器的第七个位置（即第六条指令后面），但这样就要先数一数有多少条指令，很麻烦，而且一旦修改了程序，位置可能也要随之变更。通行的做法是给该数据项起个名字（第 5 章也会讨论），让一个程序负责跟踪记录该数据项在 RAM 中的实际位置，然后用实际的位置代替名字。名字可以任意起，但最好是起一个让人一看就明白相应数据或指令含义的名字。比如，这里的 Mem，其实改为 Firstnum 更好理解。

怎么扩展这个程序，让它能计算三个数的和呢？没错，可以再加一组 STORE、GET 和 ADD 指令（有两个位置可以插入这组指令），但这种方法肯定不能扩展到 1000 个数相加。并且，在事先不知道有多少数的情况下也行不通。

答案是给 CPU 的指令表增加一个新指令，通过它能重用已有的指令序列。这就是 GOTO 指令，有时候也叫「分支」或「跳转」，它告诉 CPU 读取下一条指令时不要从序列中的下一个位置读，而要从它指定的位置读。

使用 GOTO 指令，可以让 CPU 返回到程序的前面，重复执行指令。举一个简单的例子，比如写一个程序随时显示每个输入的值。这个功能正是数据复制程序的核心，也能说明 GOTO 指令的作用。我给这个程序的第一条指令加了个标签，叫 Top（能说明其角色的任何名字都行），而最后一条指令告诉 CPU 再返回到程序的第一条指令：

Top GET 取得一个数并放到累加器中 PRINT 打印出来 GOTO Top 返回 Top，取得另一个数

问题只解决了一半：可以重用指令，但却没办法停止循环。为此，还得再增加一条指令，该指令先测试一个条件，然后决定接下来该做什么，而不是一味往前走。这样的指令被称为「条件分支」指令，或条件跳转、条件转向。现实中，不同的机器在实现该指令时测试的条件会有所不同，但有一种可能是测试某个值是否等于零，如果是则跳到某个位置。那好，我们就给这个「玩具」计算机的指令表添加一个 IFZERO 指令，它会在累加器的值等于零的时候把 CPU 引导到一个指定的位置，否则继续顺序执行下一条指令。下面这个程序就使用了 IFZERO，该程序会在输入值不等于零的情况下不断打印输入的值：

Top GET 取得一个数并放到累加器中 IFZERO Bot 如果累加器的值为零，跳到标签为 Bot 的指令 PRINT 值不是零，打印出来 GOTO Top 返回 Top，取得另一个数 Bot STOP

只要用户不觉得无聊，这个程序就会不断取得数据并打印出来。如果用户输入了零，程序就会跳到 STOP 指令（标签 Bot 代表「bottom」，即「末尾」的意思）并退出。

注意，程序不会打印那个表示终止输入的零。怎么修改一下程序，让它能打印出这个零再停止呢？这个问题不难 —— 答案明摆着 —— 但它却足以揭示一个现象：简单地交换两个指令的位置，就能导致程序的行为与我们的设想出现偏差，或者说会导致程序去做一些与我们希望的完全不同的事。

组合使用 GOTO 和 IFZERO，可以写出在指定条件为真之前可以重复执行指令的程序，而 CPU 也可以根据之前计算的结果改变计算过程。指令表中有了 IFZERO 之后，我们的玩具 CPU 可以执行任何计算。尽管有点难以想象，但这些指令足以应对数字计算机能够完成的任何计算 —— 任何计算都可以分解为能使用基本指令完成的小步骤。关于任务分解的思想，我们会随时随地提到，因为它太重要了。（想一想，既然有了 IFZERO，那严格来讲 GOTO 还有必要吗？能不能用前者来模拟后者呢？）

例如，下面这个程序可以把一大堆数加起来，到输入了零为止。使用特殊的值终止循环输入是一种常见的做法。因为对于求几个数之和的计算，加零没有意义，所以这里使用零很合适。

Top GET 取得一个数 IFZERO Bot 如果这个数是零，转到 Bot ADD Sum 把累计的和与这个数相加 STORE Sum 把结果存储为一个新的累计和 GOTO Top 返回 Top 再取得另一个数 Bot LOAD Sum 把累计和加载到累加器 PRINT 然后打印出来 STOP Sum 0 保存累计和的存储器位置 （程序启动时的初始值为 0）

玩具模拟器对这个程序最后一行的「指令」是这样解读的：给一个存储器位置命名，然后在程序运行前放进去一个值。之所以需要这样做，是因为程序要计算很多数的和，而且累计和的初始值必须从零开始。

怎么检验这个程序，确定它没问题呢？表面上看没有问题，但有些问题很容易被忽视，所以有必要进行系统的测试。注意这里说的是「系统的测试」，并非随便给程序输入几个值。

最简单的测试用例是什么？如果根本没有要相加的数，除了用来终止输入的零，则和应该为零，这就是第一个测试用例。然后要试试只输入一个数，而和就应该是那个数。接下来可以试试两个数，这两个数的和你是知道的，比如 1 加 2 等于 3。此时，基本上就可以确定程序没有问题了。假如你真用心的话，通过一步一步地仔细过几遍指令，就可以在程序上机之前完成对代码的测试。优秀的程序员无论写什么都会自己先做这种检查。

到目前为止，我们一直没有讨论指令和数据在 RAM 中是如何表示的。说一种可能性吧，比如每条指令都需要一个存储器的位置存储其数值代码，而在该指令引用存储器位置或有一个数据值的情况下，还需要另一个紧随其后的位置。也就是说，IFZERO 和 ADD 等指令因为引用了存储器位置，所以要占用两个存储器单元，其中第二个单元中保存的是它引用的位置； 同样假设数据值也要占用一个位置。这是一种简化，但实际情况也差不太多。最后，假设各个指令的数值代码（按它们在前几页中出现的先后顺序）分别为：GET=1、PRINT=2、STORE=3、LOAD=4、ADD=5、STOP=6、GOTO=7、IFZERO=8。

现在，我们来看看前面计算一系列数之和的程序。在程序刚开始运行的时候，RAM 中的内容如下图所示。图中也给出了为三个存储器位置指定的名字，给出了指令以及存储器单元的地址。

前面的玩具模拟器是使用 JavaScript 写的，第 7 章将介绍 JavaScript。扩展这个模拟器很容易，就算你以前从来没见过计算机程序，也可以给它添加一条乘法指令，或者其他的条件分支指令。

3.2 真正的 CPU

CPU 反复执行简单的循环：从存储器中取得下一条指令，该指令正常情况下保存在存储器的下一个位置，但也可以是使用 GOTO 或 IFZERO 指定的位置；对指令进行译码，也就是搞清楚这条指令要干什么，然后为执行该指令做好准备；执行指令，从存储器中取得信息，完成算术或逻辑运算，保存结果，总之是执行与指令匹配的组合操作；然后再从头取得指令，开始下一次循环。真正的处理器也执行同样的「取指令－译码－执行」循环，只不过为了加快处理速度，还会配备精心设计的各种机制。但核心只有循环，与前面重复把数值加起来的例子一样。

真正计算机的指令比我们玩具计算机的多，但性质相同。比如，有更多移动数据的指令，更多完成算术运算及操作不同大小和类型数值的指令，更多比较和分支指令，以及控制计算机其他组件的指令。典型的 CPU 有几十到数百个不同的指令；指令和数据通常要占用多个内存位置，通常为 2 至 8 个字节。真正的处理器有多个累加器，通常是 16 或 32 个，所以可以保存多个中间结果，而且都是速度极快的存储器。真正的程序与我们的玩具示例相比可谓庞大，有的甚至多达数百万条指令。至于如何编写这么大的程序，本书后面有关软件的章节会详细讨论。

计算机体系结构是研究 CPU 与其他计算机组件连接的一门学科。在大学里，它通常是计算机科学和电子工程的交叉领域。

计算机体系结构研究的一个问题是指令集，也就是处理器配备的指令表。是设计较多的指令去处理各式各样的计算，还是设计较少的指令以简化制造并提升速度？体系结构涉及复杂的权衡，要综合考虑功能、速度、复杂性、可编程能力（如果太复杂，程序员将无法利用其功能）、电源消耗及其他问题。用冯·诺依曼的话说：「一般来讲，运算器内在的经济性取决于期望的机器运行速度…… 与期望的简易性或低价位之间的折中。」

CPU 与 RAM 和计算机的其他组件是如何连接的？处理器非常快，通常执行一条指令只需要零点几纳秒。（1 纳秒等于十亿分之一秒，或者 10-9 秒。）相对而言，RAM 则慢得让人难以忍受 —— 从存储器中取得数据或指令大概要花 25 到 50 纳秒。当然，这里的快指的是绝对速度，而慢则是相对于 CPU 而言。假如 CPU 不必等待数据，那它可能早就执行完上百条指令了。

现代计算机会在 CPU 和 RAM 之间使用少量的高速存储器来保存最近使用过的指令和数据，这种高速存储器叫作缓存。如果可以从缓存中找到信息，那么就会比等待 RAM 返回数据快得多。下一节我们会详细介绍缓存及缓存机制。

设计师在设计体系结构的时候也有一套方法，能够让处理器跑得更快。比如，可以把 CPU 设计为交替地取得和执行指令，而同一时刻会有几个指令处于执行过程的不同阶段，这种设计叫做流水线。（与汽车装配线很相似。）结果呢，虽然某个特定的指令仍旧要花同样的时间完成，但其他指令都有机会得到处理，从整体上看完成这些指令则会快很多。另一种方法是并行执行多条互不干扰、互不依赖的指令，就相当于多条平行的汽车装配线。有时候，只要指令的操作不会相互影响，甚至可以不按顺序执行。

