# 2020084微信小程序开发入门与实践R03.md

## 记忆时间


## 模板

### 1. 逻辑脉络

用自己的话总结主题，梳理逻辑脉络，也就是这本书整个地图里这一章所在的节点。

### 2. 摘录及评论

## 10. 电影

### 1. 逻辑脉络

利用 wx.request 和后端服务交互。使用 wx.request 获取真实的网络数据，并将这些数据「填充」到小程序中；tabBar 控件和嵌套模版的使用。tabBar 在 app.json 里设置，跳转到带 tabBar 的页面，需要用 wx.switchTab 方法。

### 2. 摘录及评论

本章我们编写了一个类似「豆瓣影评」的小功能，所有数据来自于豆瓣开放的 API。通过编写这部分的功能，我们将学习如何使用 wx.request 获取真实的网络数据，并将这些数据「填充」到小程序中。此外，本章中最重要的内容是多层嵌套模板的使用技巧，多层嵌套模板的优势将在本章中得到体现。此外本章还指出了很多小程序的「坑」，希望可以帮助开发者节约宝贵的时间。

电影部分同文章部分属于同一级别，我们在本章的开始部分使用小程序提供的 tab 选项卡来实现电影模块和文章模块的切换。需要注意的是，我们不需要自己编写代码实现 tab 选项卡。小程序提供了现成的 tab 选项卡，我们只需要在 app.json 中配置一些参数即可实现 tab 选项卡的效果。

tab 选项卡的配置是通过 app.jon 文件中的 tabBar 选顼来实现的。在配置 tab 选项卡之前，我们新建一个页面 movie 页面（位于 pages/movie 目录下）。或者直接在 app.json 的 pages 选项下新增 ρages/move/move 并保存，这将直接在 pages/move 目录下新建 movie 页面的 4 个页面文件。接着配置文章和电影页面的 tab 选项卡，代码如下：

黑色加粗部分是新增的代码。tabbar 配置项有以下几个属性：1）color 未选中时的 tab 选项卡文字颜色。2）selectedColor 选中时 tab 选项卡文字颜色。3）backgroundColor，tab 选项卡背景颜色。4）borderstyle，tab 选项卡上边框的颜色，注意它只支持 black 和 white 两个取值，默认是 black。5）list，tab 选项卡列表，是一个数组，接受一组 object 对象，我们在后面会具体给出每个对象的属性。6）position 可选值有 bottom 和 top，默认为 bottom，指定选顼卡位于底部还是顶部。

1『小程序里的对象，对应于 python 里的字典。』

再来具体看看 list 这个数组。list 数组的每一项都是一个 object 对象，每个 object 对象代表一个 tab 选项，最少必须有两个 tab 选项，而最多只能有 5 个 tab 选项。tab 选项卡出现的顺序由数组中 object 的顺序来决定。object 对象包含以下几个属性：1）pagePath，每个 tab 选项的页面路径。注意，用于 pagepath 的路径必须预先已在 app.json 的 pages 中定义。2）text，tab 选项卡上出现的文字。3）iconPath，tab 选项卡上的图片路径，图片大小限制为最大 40KB，建议尺寸为 81x81px。4）selectedlconPath，选中是的图片路径，图片大小限制为最大 40kb，建议尺寸为 81x81 px。

这里要特别注意，对于 pagePath、iconPath 和 selectedlconPath 这几个路径，一定不要以「/」开头。即使它们看起来是绝对路径也不要在路径前面加「/」 。在 pagePath 前面加「/」将导致错误。如果在 iconPath 前加「/」 ，虽然在模拟器中不会出现问题，但将项目在真机上预览时（在开发工具的「项目」里点击「预览」时）开发工具将报如图 10-2 所示的错误。

此时，我们保存并运行代码，会发现页面停留在 welcome 页面，点击「开启小程序之旅」，页面没有反应。如果在 welcome.js 的 navigateTo 中设置了 fail 函数，点击「开启小程序之旅」就将进入 navigateTo 的 fail 函数中。

为什么会出现这样的情况？我们在 4.112 小节中介绍 redirecTo 和 navigateTo 时，提到过这两个方法只能用于不帯 tab 选顼卡的页面。此时要跳转的 post 页面已经被设置成了带选项卡的页面，所以无论使用 redirecTo 还是 navigateTo 都不能成功跳转，必须使用 4.11.2 小节中我们提到的另外一个导航方法 wx.switchTab 方法，才能成功跳转到帯有 tab 选项卡的页面。修改 welcome.js 页面的 onTapJump 方法。

以上代码仅仅是将原先所调用的 wx.NavigateTo 修改成了 wx.switchTab。保存并运行代码，此时再次点击 welcome 页面的「开启小程序之旅」，可以成功打开 post 页面。此时的 post 页面底部出现了ー个 tab 选项卡，如图 10-3 所示。

可以通过点击「文字」和「光影」进行文章和电影页面的切换。需要特别注意的是，wx.redirecTo 和 wx.navigateTo 无法跳转到带有 tab 选项卡的页面；同理，使用 wx.switchTab 也无法跳转到不带 tab 选项卡的页面。它们各司其职，不能滥用。开发者还可以尝试ー下 tab 选项卡在页面上部的布局，将 app.json 中 tabBar 配置下的 position 由 「bottom」修改为「top」，tab 选项卡将出现在页面的上部，如图 10-4 所示。可以看到在上部的 tab 选项卡是不包含 tab 图标的，即使你设置了 tab 的图标也不会出现。

### 10.2 电影页面介绍

电影模块部分总共有以下几个展示模块：1）电影首页展示正在热映、即将上映和豆瓣 top250 三种类型的电影。2）每种电影只展示最前面 3 部。3）每种电影有一个「更多」按钮，点击将打开一个新页面，展示该类型下所有的电影。4）支持电影搜索功能。5）点击任意一部电影都将打开电影详情页面。

开发者可以参考本书彩页中的设计图，直观且详细地了解各个功能模块。所有电影数据均来自于豆瓣电影开放 API，以下是豆瓣电影 API 文档的地址：[豆瓣 Api V2（测试版） | douban-api-docs](https://douban-api-docs.zce.me/)

1『原书的链接失效了，上面的是搜索到的有关豆瓣 API 的信息，API 是数据挖掘里一个重要的数据源。具体技术还要去深入了解。发现豆瓣官方 API 已经关闭了。[zce/douban-api-proxy: 一个豆瓣 API 的反向代理，旨在解决豆瓣屏蔽小程序请求问题（豆瓣接口 403 问题）](https://github.com/zce/douban-api-proxy)』

对于电影页面的编写，我们将大量使用 template 模板，甚至是使用多层次嵌套模板。图 10-5 解释了电影模块中所有页面及模板的结构关系。开发者不需要现在马上看明白上面的结构关系图，只需要在后续章节中时时回顾一下此图即可。箭头中没有标注包含数量的表示只包含个模板。

我们大概解释一下以上关系调用图：电影功能部分总共有 3 个页面，分别是电影首页、更多电影和电影详情页面以及 1 个电影搜索模块（电影搜索不是单独的一个页面，位于电影首页）。以电影首页为例：电影首页由 3 个 movie-list-tpl 模板构成，每个 movie-list-tpl 模板由 n 个 movie-tpl 模板构成，而每个 movie-tpl 模板又包含 1 个 stars-tpl 模板。我们基本可以人以上 3 个示意图中完全解析出模板的嵌套关系：电影首页由 3 个 movie-list-tpl 模板构成，每个 movie-list-tpl 模板又由 3 个 movie-tpl 模板构成，而每个 movie-tpl 模板又包含了 1 个 stars-tρl 模板。从图 10-5 中我们可以看到，嵌套模板的使用可以避免编写重复代码，大量的 wxml 代码将被复用。如果你已经忘记了 template 模板的使用，请回顾一下本书第 5 章的内容。

### 10.3 编写豆瓣星星评分组件：stars-tpl 模板

当点击 tab 选项卡的「光影」选项时将跳转到电影首页。在 10.3-10.5 这 3 节中，我们将连续编写 3 个模板。对于这些模板，我们只需要大概浏览一下它们的骨架结构，对于 {{}} 中所绑定的数据，无须太过关心。当这 3 个模板被编写完成并在电影首页中传入数据调用时自然会明白每个份所绑定的数据意义。

在 10.2 节中，我们分析了电影首页的模板构成。下面我们首先编写电影首页所需要的几个模板，这里从最小的模板（stars-tpl 模板）开始编写。在 movie 目录下新建一个 stars 文件夹，并在该文件夹下新建两个文件：stars-tpl.wxml 和 stars-tpl.wxss。随后在 stars-tpl.wxml 中新增以下代码：

```
<template name="starsTpl">
  <view class="stars-container">
    <view class="stars">
      <block wx:for="{{stars}}" wx:for-item="i">
        <image wx:if="{{i===1}}" src="/images/icon/wx_app_star.png"></image>
        <image wx:elif="{{i===0.5}}" src="/images/icon/wx_app_star@half.png"></image>
        <image wx:else="{{i===0}}" src="/images/icon/wx_app_star@none.png"></image>
      </block>
    </view>
    <text class="star-score">{{score}}</text>
  </view>
</template>
```

stars 模板是需要从外部传入一些数据才可以正常使用的，所以我们现在无法直接预览 stars 模板的效果。stars 模板接收一个数组作为参数，这里先给出接收数组的形式：[1,1,1,0,0] 表示 3 星评价，[1,1,1,1,1] 表示 5 星评价，[1,1,1,0.5,0] 表示 3 星半。注意，模板中 3 个 image 组件的使用技巧在前面的已提过，条件渲染不仅仅可以使用 wx:if 和 wx:else，还可以多层次地使用 if else if else......3 个 image 组件中的 if else 展示了这种多层次条件的用法。

block 标签将循环评分数组，循环一定会执行 5 次，出现 5 颗星星，但会根据数据组中当前位的取值是 1、0.5 还是 0 来决定当前的星星图片是满星、半星还是空星。这样评分组件的星级就实现。同时 {{star}} 还需要绑定一个评分的分数，这个分数也需要由外部传入。接着，我们在 stars-tpl.wxss 中编写 stars 模板的样式。

以上就是 stars-tpl 模板的全部代码，我们暂且放下，接着编写其他模板的代码，最后再将这些模板组装起来。

### 10.4 编写 movie-tpl 模板

接着我们编写电影首页中需要用到的另外一个模板：movie-tpl。模板的示意图请参考图 10-7。在 pages 的 movie 目录下新建一个 single-movie 目录，用来存放 movie-tpl 模板。在 /pages/movie/single-movie 目录下新建两个文件：movie-tpl.wxml 和 movie-tpl.wxss 文件。首先在 movie-tpl.wxml 中编写 movie-tpl 模板的骨架代码：

```
<import src="../stars/stars-tpl.wxml"></import>
<template name="movieTpl">
  <view class="movie-container" catchtap="onMovieTap" data-movie-id="{{movieId}}">
    <image class="movie-img" src="{{coverageUrl}}"></image>
    <text class="movie-title">{{title}}</text>
    <template is="starsTpl" data="{{stars:stars,score:average}}"></template>
  </view>
</template>
```

在以上代码的顶部我们使用 import 引入了在 10.3 节中定义 stars-tpl 模板。Moive-tpl 模板由一张电影海报、电影标题以及 stars-tpl 模板构成。对于整个 movie-tpl 模板，我们在其容器上注册了一个事件 onMovieTap，并绑定了当前电影的 id 号 —— movield。

需要注意的是，stars-Tpl 模板的 data 属性，该属性将 stars 数组和 score 评分传入 stars-Tpl 中（请开发者回顾一下 10.3 节中的 tars-Tpl 定义），那么 movie-tpl 模板中的 stars 数组和 score 评分又是从哪里来的呢？答案依然是从外部传入的。在 10.5 节中编写 movie-list-tpl 时将看到如何传入这两个参数。接着编写 move-tpl 模板的样式。注意，在样式的顶部我们依然需要引入 stars-tpl 模板所使用的样式。

### 10.5 编写 movie-list-tpl 模板

直接被电影首页调用的模板是 movie-list-tpl 模板，movie-list-tpl 模板中引用了 movie-tpl 模板，而 movie-tpl 模板中又引用了 stars-tpl 模板。这就是我们所说的 3 层模板嵌套关系。首先在 pages/movie 目录下新建 movie-list 目录，接着在 movie-list 目录下新建两个文件：movie-list-tpl.wxml 和 movie-list-tpl.wxss 文件。下面编写 movie-list-tpl 模板的骨架。在 movie-list-tpl.wxml 中添加以下代码：

```
<import src="../single-movie/movie-tpl.wxml"></import>
<template name="movieListTpl">
  <view class="movie-list-container">
    <view class="inner-container">
      <view class="movie-head">
        <text class="slogan">{{categoryTitle}}</text>
        <view class="more" catchtap="onMoreTap" data-category="{{categoryTitle}}">
          <text class="more-text">更多</text>
          <image class="more-img" src="/images/icon/wx_app_arrow_right.png"></image>
        </view>
      </view>
      <view class="movies-container">
        <block wx:for="{{movies}}" wx:for-item="movie">
          <template is="movieTpl" data="{{...movie}}"></template>
        </block>
      </view>
    </view>
  </view>
</template>
```

1『上面引入的文件错了，应该是：\<import src="../single-movie/single-movie.wxml">\</import>』

同样，我们在代码的开头部分使用 import 引入 movie-tpl 模板，并在 block 标签中使用 move-tpl 这个模板。注意 template 标签中的 data 属性，我们在这里将 movie-tpl 模板所需要的数据传进去。接着编写 movie-list-tpl 模板的样式。在 movie-list-tpl.wxss 文件中编写以下代码：

注意在代码的开头部分使用 import 引入 movie-tpl 模板所使用的 movie-tpl 模板的样式文件 movie-tpl.wxss。

### 10.6 电影首页的骨架与样式

在我们编写好 3 个 template 组件后，电影首页的骨架编写将变得非常简单，只需要在电影首页中引用 movie-list-tpl 模板即可。

在 movie.wxml 页面中添加以下代码：

```
<import src="movie-list/movie-list-tpl.wxml" />

<view class="container" wx:if="{{containerShow}}">
  <view class="movies-template">
    <template is="movieListTpl" data="{{...inTheaters}}" />
  </view>
  <view class="movies-template">
    <template is="movieListTpl" data="{{...comingSoon}}" />
  </view>
  <view class="movies-template">
    <template is="movieListTpl" data="{{...top250}}"/>
  </view>
</view>
```

注意，在代码开头部分使用 import 引入了 movie-list-tpl 模板。同时在本段代码中使用了 3 次 movie-list-tp 模板，分别代表 inTheaters正在热映、comingSoon 即将上映和 top250 经典电影 3 种类型的电影。接着编写电影首页的样式。在 move.wxss 文件中添加以下代码：

### 10.7 豆瓣电影 API 分析

在编写电影首页的 js 调用豆瓣 API 之前，我们首先应当对豆瓣电影 API 有一个直观的认识和了解。所谓开放 APl，是指某些公司、企业将自己公司所持有的数据、用户数据选择性地开放给开发者调用，让开发者可以使用数据并围绕这些数据构建自己的应用，从而帮助公司、企业完善其平台和生态。

目前，绝大多数的开放 API 都属于 RESTFUl 风格的 APl，比如豆瓣 API、github 开发者 API 等。豆瓣 API（V2 版）就属于这类 API，其 API 权限有 3 种：公开、高级和商务。所有开发者无须申请即可调用公开权限的 APl，但只有部分 API 是公开权限的，一些高级接口无法调用，且公开 API 具有 40 次 / 分钟的访问限制。如果开发者在调试代码时遇到豆瓣返回错误信息，就有可能是因为已经超过允许访问的次数。这个时候唯一的办法就是稍等片刻。高级权限和商务权限需要开发者向豆瓣发邮件申请。

本书中所调用的豆瓣 API 均为公开 API，所以要注意访问频率限制的问题。在 Orange Can 项目中总共使用了以下几个豆瓣电影 API：1）获取正在热映的电影。2）获取即将上映的电影。3）获取豆瓣 top250 电影。4）电影搜索。5）获取电影条目信息（电影详情数据）。以获取豆翔瓣 top250 的 API 地址为例，一个完整的获取豆瓣 top250 电影的 API 地址为：

1『官方接口已关闭。』

在以上 APl 中，我们向豆瓣请求 top250 电影中的前 15 条电影信息。start=0 和 count=15 是查询参数，可根据需求自行调整，但要注意每次加载最多只能获取 20 条数据，count 超过 20 是没有意义。开发者可直接在浏览器中输入以上 URL 地址，豆瓣将返回我们需要的数据，返回数据的类型是 JSON 类型，如图 10-9 所示。关于其他几个 API 接口的使用方法，我们将放在后续实例编码中讲解。


### 10.8 电影首页的 js 编写

电影首页 js 的编码工作主要做以下 3 件事情：1）调用豆瓣 APl 获取电影数据。2）处理豆瓣电影数据。3）绑定豆瓣电影数据。

首先在 app.js 中的 globalData 中加入ー个全局变量 doubanBase，用来记录豆瓣 APl 的基地址。因为所有豆瓣的 API 访问都需要这个基地址，所以我们将它单独放在全局变量中，并在其他需要的地方获取这个全局变量。

```
  // 全局变量
  globalData: {
    userInfo: null,
    doubanBase: "https://api.douban.com",
  }
```

接着编写 move.js 中的代码。首先在 movie.js 中新增 Page 方法，并在 Page 方法的参数中定义 data 初始化数据及页面 onLoad 函数。

1『怪不得不加 page 方法前，进入电影页面显示不出来，console 里显示「onhide: 页面被隐藏」。』

1『上面的 api 替换成 GitHub 的，「https://api.github.com/search/repositories?q=language:python&sort=stars」。』

在 onLoad 函数中，主要拼接了 3 个不同的豆瓣 API，分别用来获取正在热映、即将上映和豆瓣 top250 电影的数据。这 3 个 API 唯一的区别在于 URL 路径中的一小段路径 /v2/movie/key 中的 key 不同:「正在热映」的 key 是 in_theaters，「即将上映」的 key 是 coming_soon，「top250」的 key 是 top250。注意，我们使用 "?start=0&count=3" 指定仅获取每种类型电影的前 3 条数据，因为在我们的业务需求中只需要每种类型的前 3 条数据。

在 data 属性中，预先定义了 3 个对象：inTheaters、comingSoon 和 top250。这 3 个对象将用于数据绑定，开发者可回顾一下代码清单 10-9。在代码清单 10-9 中，分别将这 3 个对象绑定到了 template 模板上。在代码清单 10-12 的末尾部分，调用了 3 次 this.getMovieListData 方法。这个方法的作用就是根据传入的 urI 获取和处理数据。在 10.9 节中，我们将编写这个方法。

### 10.9 wx.request 发送 http/https 请求

目前我们还没有编写 getMovieListData 方法，现在在 movie.js 的页面中添加这个方法。getMovieListData 接受 3 个参数：url、settedKey 和 categoryTitle。url 被用来访问并获取豆瓣电影数据，settedKey 被用来作为不同类型电影数据绑定的 key，categoryTitle 被用来作为电影的分类标题，最终将被显示在 move-list-tpl 的标题上（参考代码清单 10-7）。

getMovieListData 的核心代码是 wx.request 方法的使用，是小程序提供的发送 http 和 https 请求的方法，类似于传统 Javascript 编程中所使用的 ajax 方法。

wx.request(object) 方法用于发送 http / https 请求，并接受服务器返回的请求结果。Object 参数包含以下几个属性用于配置请求参数：1）url，String 类型，开发者服务器接口地址。2）data，Object 或者 String 类型，请求的参数。3）header，Object 类型，设置请求的 header。注意，在 header 中不能设置 referer，因为在小程序中 referer 是一个固定格式的值，格式固定为 https://servicewechat.com/{appid}/{version}/page-frame.html，其中 {appid）为小程序的 appid、{version} 为小程序的版本号，版本号为 0 表示开发版。4）method，String 类型，默认为 GET，有效值为 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT。注意，method 的取值必须大写。

请求参数：5）dataType，String 类型，默认为 json。如果设置了 dataType 为 json，就会尝试对响应的数据做一次 JSON.parse。6）success，Function 类型，收到开发者服务成功返回的回调函数。函数会被传入一个 res 参数开发者可通过 res.data 来获取服务器返回的内容。7）fail，Function 类型，接口调用失败的回调函数。8）Complete，Function 类型，接口调用结束的回调函数（调用成功、失败都会执行）。

开发者可能注意到，在代码清单 10-13 中，我们在设置 header 的 content-type 时给出了一个奇怪的参数值：json。既没有给出常见的 application/json, 也没有直接省略掉 content-type 这个选项（官方文档中明确指出 content-type 的默认值是 "application/json")。原因是以下几个选项都无法正确调用豆瓣 API：1）不设置 content-type；2）content-type: 'application/json'；3）content-type:''。

在目前的 13040 版本中，如果将 content-type 设置为以上几个取值，那么豆瓣 API 将返回如图 10-10 所示的错误信息。经过反复调试发现，content-type 可以被指定为任意不为空的字符串：1）content-type:'json'；2）content-type:'xxxxxx'；3）content-type:'appli'。只要 content-type 不为空或者是 application/json, 就可以正确调用豆辦 API 并获取到豆瓣的返回数据。为了让 content-type 看起来合理一些，在 Orange Can 项目中ー律使用 content-type:json 的形式作为 content-type 的取值。

对于 wx.request，还有以下几个注意事项：1）url 中不能有端口。2）wx.requeste 的默认超时时间和最大超时时间都是 60s。3）wx.request 的最大并发数是 5。

3『

[RequestTask | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html)

```
wx.request({
  url: 'test.php', //仅为示例，并非真实的接口地址
  data: {
    x: '',
    y: ''
  },
  header: {
    'content-type': 'application/json' // 默认值
  },
  success (res) {
    console.log(res.data)
  }
})
```

』


1『

一些公开 api：[public-apis/public-apis: A collective list of free APIs for use in software and web development.](https://github.com/public-apis/public-apis)

https://autocomplete.clearbit.com/v1/companies/suggest?query=segment

https://api.github.com/search/repositories?q=language:python&sort=stars

报错：https://api.github.com 不在以下 request 合法域名列表中。

需要进小程序账号里，在开发者设置里，服务器域名里添加 request 合法域名。但添加的域名一定要是备案过的，否则不行。

』

### 10.10 设置 wx.request 的超时时间

很多开发者可能想知道如何在小程序中设置超时时间，答案是在 app.json 文件中配置这个超时时间。在 app.json 中除了我们之前讲到的 pages、window、tabBar 等常用的配置项外，还有一个 networkTimeout 配置项。networkTimeout 配置项用来配置各类网络请求的超时时间：1）request，wx.request 的超时时间，单位为毫秒，默认值为 60000。2）connectSocket，wx.connectSocket 的超时时间，单位为毫秒，默认值为 60000。3）uploadFile，wx.uploadFile 的超时时间，单位为毫秒，默认值为 60000。4）downloadFile，wx.downloadFile 的超时时间，单位为毫秒，默认值为 60000。

我们可以在 app.json 中添加以下代码来设置各类请求的超时时间；当然，如果目前位置只使用 wx.request 请求，只设置 request 这个配置项也是可以的。如果服务器在 20 秒内没有响应，那么 wx.request，将进入 fali 函数。

### 10.11 处理返回的电影数据

在代码清单 10-13 中，我们使用 wx.request 来获取豆瓣 APl 所提供的电影数据。需要注意的是，wx.request 是一个异步方法，且小程序只提供了异步发送 http / https 请求的方法，没有同步版本。所以，不要尝试使用以下方法来获取 wx.request 的返回值：

    var result=wx.request(object)

对于同步的方法，可以使用以上方式来获取返回结果；但对于异步方法，只能在异步方法所提供的回调函数中进行返回结果的处理。比如在 wx.request 中，就只能在 wx.request 所提供的 success 回调函数中处理豆瓣的返回结果。回顾一下代码清单 10-13，在 success 回调函数中，我们使用 res.data 来获取豆瓣 API 的返回结果，接着调用了一个 processDoubanData 方法来处理豆瓣 API 的返回数据，从豆瓣加载回来的数据格式如图 10-11 所示。开发者可自行使用 Postman 或者 Fiddler 来调用豆瓣 API 查看返回的数据格式。目前，我们还没有实现 processDoubanData，下面来编写这个函数。

这个函数接收 3 个参数，第一个参数 moviesDouban，就是我们从豆瓣获取来的电影数据，processDoubanData 的主要功能就是处理 moviesDouban；第二个、第三个参数在之前已经解释过，这里只是简单地传入到 processDoubanData 中，在最后才绑定到 setData 方法中。

for 循环将遍历所有豆瓣电影的数据，并将豆瓣的数据格式转化成我们需要的命名格式，temp 就是一个临时保存转化后电影数据的变量。最后将所有豆瓣电影数据处理完后调用 js 的 Aray.push 方法将 temp 加入 movies 数组中，最终形成我们需要的电影数据数组。

在 for 循环中处理豆瓣电影数据时，调用了一个 util.convertToStarsArray 方法将豆瓣的评分格式转化成我们需要的数组格式一一形如 [1,1,0,0,0] 的形式（开发者可回顾一下 10.3 节）。豆瓣 API 返回的关于评分的数据格式为 50（表示 5 星）、35（表示 3 星半）、00 (0 星或者还没有星级），util.convertToStarsArray 的任务就是将这些 50、35、00 等星级的简写形式转化成 [1,1,1,1,1]、[1,1,1,0.5,0] 和 [0,0,0,0,0] 等需要的数组形式，以方便 stars-tpl 模板使用。

在 util.js 中加入一个 util.convertToStarsArray 函数。记住，util 是一个模块，添加完方法后需要使用 module.exports 输出。随后，要想在 movie.js 中引用 util，还需要在 move.js 顶部引用 util 模块。完成以上代码的补充后，我们才能够在 movie.js 中调用 util.convertToStarsArray(subject.rating.stars) 方法。

### 10.12 绑定处理后的电影数据

在代码清单 10-15 的最后我们使用了以下代码进行数据绑定：

```
    var readyData = {};
    readyData[settedKey] = {
      categoryTitle: categoryTitle,
      movies: movies
    }
    this.setData(readyData);
```

这是一种动态设置数据绑定 key 的方法。由于我们并不知道当前处理的数据是哪一种电影类型（inTheaters、comingSoon、top250），因此将当前所处理的电影数据类型通过 settedKey 一路传递到 processDoubanData 方法中，并通过 readyData[settedKey] 生成一个包含 settedKey 的 Javascript 对象。

假设当前处理的数据是 inTheaters 类型，那么以上代码在最终调用 this.setData(readyData) 时相当于以下形式：

```
this.setData({
    inTheaters:{
        categoryTitle: '正在热映',
        movies: movies
    }
})
```

如果当前处理的数据是 comingSoon 类型，那么以上代码在最终调用 this.setData 时相当于以下形式；这样的写法实际上考验的是开发者对 Javascript 动态属性的理解。此时，保存并运行代码，电影首页显示如图 10-12 所示的样式。如果数据没有正确加载，请参考下节的内容。

### 10.13 http 和 https 在小程序中的使用说明

为了保证数据的安全性，小程序中强制要求使用 https 且所访问的 https 地址必须在小程序的后台账号中被加入到可信域名中。图 10-13 是小程序开发账号的 https 可信域名配置的示意图。该配置项位于小程序账号的「设置」→「开发设置」选项中。理论上，小程序是不允许使用 http 请求来获取数据的，也不允许访问未在可信域名列表中配置的 https 地址。以上限制的前提条件是：在真机上。

如果是在客户端的开发工具中，有以下几种方法可以不需要遵守以上两个规则。

第一种方法。如果在创建小程序项目时选取的是无 appid（必须拥有小程序账号才可以获得），那么开发工具不会限制你访问 https，更不会比对可信域名列表。这种方法的缺点就是：当你偶尔想真机预览下小程序时，还需要重新新建项目并填入 appid。

第二种方法。如果在创建小程序项目时填入了 appid 那么默认情況下小程序将强制你使用 https 且会将你所访问的 https 地址与可信域名列表做比对。如果你试图在一个配置了 appid 的小程序项目客户端开发工具中访问 http 地址，那么开发工具会报错，如图 10-14 所示。无论你使用 http 或者使用不在可信域名列表里的 https 地址都将提示图 10-14 所示的错误（可信域名列表不能够设置 http，所以试图访问 http 地址一样会提示不在可信域名列表中）。解决的办法是，在可信域名列表中配置你要访问的 https 域名。

第三种方法。小程序在开发工具侧边栏的「项目」选项卡中提供了「开发环境不校验请求域名以及 TLS 版本」的选项，勾选这个选项你可以随意在开发工具中使用 http 或者未加入 https 可信列表的 https 地址。

1『解决之前「域名不合法」的问题。获取了 github 接口里的信息。』

以下是一些建议：1）如果你没有 appid，那么只能选择无 appid。2）如果你有 appid，那么建议在新建项目时填写这个 appid，并在开发期间勾选「开发环境不校验请求域名以及 TLS 版本」，待正式发布或者需要真机预览时再去小程序账号中配置你所使用的 https 地址。如果项目中没有使用网络请求，那么真机预览时也不需要配置 https 的可信域名列表。3）如果你在 Orange Can 项目中遇到无法访问的问题，可以参考上面所描述的内容。

### 10.14 跳转到更多电影页面

之前，我们完成了电影首页的编写。电影首页总共展现了 3 种类型的电影，共 9 部。如果我们需要査看每种类型的全部电影，就需要编写「更多电影」这个页面。「更多电影」是通过点击电影首页的「更多」按钮来打开新页面的，如图 10-15 所示。首先新建 more-movie 页面。在 app.jon 文件的 pages 数组下新增 more-movie 页面的路径，如下代码所示：

添加以上代码后保存项目，将自动生成 more-movie 页面的 4 个页面文件。我们首先实现跳转到 more-movie 页面的代码。通过图 10-15 可以看到，「更多」按钮是位于 movie-list-tpl 模板中的。我们回顾一下 movie-list-tpl.wxml 中的代码。

在 movie-list-tpl.wxml 中的 \<view class="more"> 标签上，我们已经注册了ー个 onMoreTap 事件，且在这个标签上也已经绑定了一个 data 数据：data-category="{{categoryTitle}}"。实现跳转到 more-movie 页面的关键就在于实现这个 onMoreTap 函数，并在 onMoreTap 函数中使用 wx.navigateTo 方法跳转到 more-movie 页面中去。同时，我们还必须将 categoryTitle 这个变量同时传递到 more-movie 页面里去，从而使 more-movie 页面能够准确地加载「更多」的电影数据。

在 movie.js 中新增以下代码，以实现 onMoreTap 方法。开发者可能会觉得奇怪，「更多」按钮是位于 movie-ilst-tpl 模板中的，但应这个按钮的 js 方法却要写在另外一个页面的 js 文件 movie.js 中。这确实是非常奇怪也难以理解的。关于这个问题，我们已经在前面的内容中讲解过：小程序只实现了模板化，而没有实现组件化，模板是不具备运行 Javascript 代码能力的。所以，我们只能将模板的业务逻辑编写在其他页面的 js 文件中，再将处理好的业务数据传递到模板中。

```
  // 跳转到更多页面
  onMoreTap: function (event) {
    var category = event.currentTarget.dataset.category;
    wx.navigateTo({
      url: "more-movie/more-movie?category=" + category
    })
  },
```

### 10.15 编写 movie-grid-tpl 模板

如同我们在实现电影首页页面时所做的，我们首先来编写「更多电影」页面所需要的模板 movie-grid-tpl 模板。图 10-16 展示了 movie-grid-tpl 模板的实际效果图。这个模板将像「九宫格」一样放入很多的电影（真实的数据远不止 9 部电影），以展示更多电影的效果。在 /pages/move 下新建一个 movie-grid 目录，并在目录下新建 movie-grid-tpl.wxml 和 movie-grid-tpl.wxss 文件。我们首先来编写 movie-grid-tpl 模板的骨架。在 movie-grid-tpl.wxml 文件中加入以下代码：

```
<import src="../single-movie/single-movie.wxml" />
<template name="movieGridTpl">
  <view class="grid-container">
    <block wx:for="{{movies}}" wx:for-item="movie" wx:key="movieId">
      <view class="single-view-container">
        <template is="movieTpl" data="{{...movie}}" />
      </view>
    </block>
  </view>
</template>
```

我们可以看到 movie-grid-tpl 的骨架代码非常简单。为什么这么几句代码就可以实现复杂的「九宫格」效果。模板再次发挥了巨大的复用作用。很明显 movie-grid-tpl 仅仅起到的是组织布局的作用，而核心的骨架代码已经被封装在了 movie-tpl 模板中。我们在 movie-grid-tpl 中的 block 标签中循环调用 movie-tpl 模板，以实现显示多部电影的目的。

在之前编写的 movie-list-tpl 里，我们已经使用过了 movie-tpl，这里再次使用 movie-tpl 就体现了模板的优势，它避免了我们重复编写 wxml 代码。笔者认为用好模板将大大简化代码，提高代码的可阋读性与可维护性。接着编写 movie-grid-tpl 模板的样式代码。在 movie-grid-tpl.wxss 文件中加入以下样式代码；同样要注意引入 move-tpl.wxss 文件。

### 10.16 编写「更多电影」页面

在编写完 more-movie 页面所需要的核心 template 模板后，我们来编写 more-move.wxml 文件。令人吃惊的是，你几乎不需要编写任何代码，只需要在 more-movie.wxml 页面中引入 movie-grid-tpl 模板即可。在 more-movie.wxml 页面中加入以下代码：

```
<import src="../movie-grid/movie-grid-tpl.wxml" />
<template is="movieGridTpl" data="{{movies}}" />
```

接着编写 more-movie 页面的样式。在 more-movie.wxss 文件中加入以下代码：

```
@import "../movie-grid/movie-grid-tpl.wxss";
```

几乎不需要编写代码，我们就完成了 more-movie 页面的骨架和样式代码的编写工作。接着我们还需要编写 more-movie 页面的 js 代码。more-movie 页面的 js 代码所需要完成的工作几乎同 move 电影首页的 js 代码相同。依然遵守着获取数据 → 处理数据 → 绑定数据的步骤。实际上，获取数据 → 处理数据 → 绑定数据的流程几乎是小程序 js 文件编写的通用思路与步骤。在 more-movie 页面中添加以下代码：

首先，我们在 data 中设置 movies 绑定变量的初始化值。movies 变量将最终被用作 wxml 的数据绑定变量。接着，在 onLoad 函数中接收由 movie 电影首页传递过来的 category 分类。根据分类的不同拼接不同数据访问 APl 的地址。这里我们没有在 API 的 URL 后面附带 start 和 count 参数，如果不附带这两个参数，那么默认将一次加载 20 条电影数据。

为了避免反复编写 wx.requestl 的复杂结构，我们在 util 模块中编写了ー个 http 方法，作为所有豆辦 API 调用的公共方法，当我们需要访问豆瓣 API 时，不需要重复调用 wx.request 方法，只需要调用这个封装好的 http 方法即可。util.http 方法接收两个参数：第一个参数是需要访问的 API 地址；第二个参数是一个回调函数，用来处理豆瓣 API 的返回结果。

processDoubanData 方法同 move 电影首页中的 processDoubanData 类似，都是用来处理豆瓣的返回数据，并在处理完成后将处理的数据进行绑定。由于在 more-movie 页面中我们已经明确了电影类型，因止此 processDoubanData 的编写简単了很多，只需要明确处理「正在热映」「即将上映」和「top250」3 种类型中的一种即可。下面来看看 utilhttp 方法是如何编写的。在 util.js 文件中加入 http 方法。

1『还是要提醒下，封装完方法后记得在最下面的输出 module 里把该方法输出。』

将所有调用豆瓣 API 的操作封装成一个函数的好处是，一旦调用操作和流程发生变化，只需要修改这个函数即可。比如，header 的 content-type 支持 application/json 取值，无须在多处修改，只需要修改 util.http 方法即可。编写完 http 方法后，记得使用 module.exports 方法将 http 方法暴露出去，以供其他页面 / 模块访问。保存并运行项目，再次点击「更多」按钮，页面将从 movie 电影首页跳转到 more-movie（更多电影）页面，且 more-movie 页面正确地呈现出 20 部电影，如图 10-17 所示。

### 10.17 实现页面下拉刷新的「三部曲」

下拉刷新是 APP 上经典的一个动作。本节我们将学习如何在小程序中实现下拉刷新数据的功能。在小程序中，不需要自己实现下拉刷新代码编写。小程序已经为我们准备好了下拉刷新的相关配置和 API。

实现一个页面的下拉刷新操作需要分为 3 步：1）步骤 01 在页面的 json 文件中配置 enablePulLDownRefresh 选项，打开下拉刷新开关。2）步骤 02 在页面的 js 文件中编写 enablePulLDownRefresh 函数，完成自己的下拉刷新逻辑。3）步骤 03 编写完下拉刷新逻辑代码后，主动调用 wx.stopPulLDownRefresh 函数停止当前页面的下拉刷新。我们首先来完成第一步。在 more-movie.json 文件中加入以下代码：

当在 more-movie.json 中加入以上代码后，more-movie 页面的下拉刷新就开启了。此时下拉 more-movie 页面将出现下拉效果。由于下拉刷新的等待标示默认是白色，因此你无法明显地看到下拉刷新的等待状态标示。我们可以修改等待标示的默认颜色，在 more-movie.json 文件中添加一个配置项。

```
{
  "usingComponents": {},
  "enablePullDownRefresh": true,
  "backgroundTextStyle": "dark"
}
```

这样当再次下拉刷新 more-movie 页面时，我们将看到等待标示，如图 10-18 所示。当然，你也可以在 app.json 的 window 配置项中配置 backgroundTextStyle:"dark" 选项，这将导致所有页面的下拉刷新等待标示都变成 dark。同理，你也可以在 app.json 的 window 配置项中配置 enablePulldownRefresh:true 选项，这将导致所有页面都开启下拉刷新。

接着我们来完成第二步。当页面打开下拉刷新开关后，每当用户下拉页面都将触发执行页面的 enablePulldownRefresh 函数。这就是小程序给我们编写下拉刷新逻辑的函数。在 more-movie.js 文件中编写 enablePulldownRefresh 函数。（备注，参考项目里的源码这段不一样）

```
  onPullDownRefresh: function (event) {
    var refreshUrl = this.data.requestUrl + "?star=0&count=20";
    util.http(refreshUrl, this.processDoubanData);
  },
```

整个函数的代码非常简单，仅仅是再一次访问了豆瓣 API 并重新获取了最新的第 1 到第 20 条数据。注意，在函数中我们获取当前豆瓣 APl 的 URL 地址时使用了 this.data.requestUrl（这个变量是在 onLoad 函数中保存下来的）。所以，我们修改一下 more-movie 页面的 onLoad 函数，在 onLoad 函数中将当前访问的 URL 地址记录一下。

编写完以上代码后，我们可以反复尝试下拉刷新 more-move 页面。当然，从 UI 上是无法直接看到刷新效果的，因为豆瓣的电影数据不可能更新得非常频繁。我们可以尝试打开 Network 面板，观察一下每次下拉刷新后是否有向豆瓣发送请求，如果有请求发向豆瓣，就说明 onPulldownRefresh 函数成功触发了。图 10-19 所示的示意图显示了 3 次下拉刷新 more-movie 页面后 Network 面板的请求发送情况。

最后，我们来完成下拉刷新「三部曲」中的第三步，主动停住页面刷新状态。停住页面刷新状态非常简单，在合适的时机调用 wx.stopPulLDownRefresh 方法即可。

我们需要考虑的是在什么时候调用 wx.stopPulLDownRefresh()。当然应该是在处理完豆瓣返回数据并再次调用 this.setData 重新绑定数据后调用 wx.stopPulLDownRefresh() 函数。在 more-movie.js 页面的 processDoubanData 方法中调用 wx.stopPullDownRefresh() 即可。完成以上代码后，more-move 页面的下拉刷新操作就全部完成了。下拉刷新三部曲是笔者总结的编写下拉刷新功能时的常见思维步骤，以供开发者参考。

1『牢记下拉三部曲。』

### 10.18 在模拟器中可执行下拉刷新但在真机中无法执行下拉刷新的常见错误

在开启下拉刷新开关时，我们需要在页面的 json 文件中设置 enablePullDownRefresh 选项为 true。如果不小心将 enablePullDownRefresh 选项设置成了字符串 "true"，而非 Boolean 类型的 true，就将导致在模拟器中可执行下拉刷新但在真机上（仅测试 iOS 系统）无法执行下拉刷新的现象。虽然官方文档明确地指出 enablePullDownRefresh 配置选顼的值类型是 Boolean，但真机行为同开发工具中行为不一致显然是不能接受的，这将增加测试成本，并有可能引起严重的 bug。

### 10.19 json 中的 backgroundColor 配置的是哪里的颜色

官方文档中对 backgroundColor 这个配置项的解释是「配置窗口的背景色」，但这个文档中并没有明确解释窗口是什么、处于小程序的哪个部位。很多开发者都尝试设置 backgroundColor，但均无法看到设置效果，这会让人误以为这个配置选项是无效的，造成这个误解的主要原因是开发工具模拟器中的小程序和真机上小程序在执行下拉动作时有一些区别。

开发工具模拟器中的小程序是无法向下拉动的（如果不设置下拉刷新），但在真机上，无论你是否设置下拉刷新，导航栏以下的页面部分都可以向下拉动。拉动后，在导航栏和页面中间会有块儿「空白」，backgroundColor 可以设置这块儿空白的颜色。在模拟器中，可以通过设置下拉刷新看到这块儿区域。我们可以做一个测试来看看效果，在 more-movie.json 文件中增加一个 backgroundColor 配置选项。

```
{
  "usingComponents": {},
  "enablePullDownRefresh": true,
  "backgroundTextStyle": "dark",
  "backgroundaColor": "black"
}
```

增加以上配置选项后，再次下拉刷新 more-movie.js 页面，我们将看到如图 10-20 所示的刷新效果。注意图中框起来的页面部分。这个部分的颜色将变成我们在 more-movie.json 文件中设置的 backgroundColor 颜色：黑色。

真机上的小程序存在一个问题，当配置导航栏颜色后，由于在真机上，即使不设置页面的下拉刷新，也会存在一个下拉的动作，露出一块儿白色的区域。这块儿白色的区域非常难看，我们可以通过设置页面的 backgroundColor 属性来配置这块儿区域的颜色。首先在 app.json 中配置全局的窗口背景颜色。

```
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#4A6141",
    "navigationBarTitleText": "大龙的书屋",
    "navigationBarTextStyle": "black",
    "backgroundColor": "#4A6141"
  },
```

接着，将 welcome 页面的窗口颜色单独配置。通过以上设置将使小程序在真机上，即使下拉页面，也不会出现「空白」。

```
{
  "navigationBarBackgroundColor": "#ECC0A8",
  "backgroundColor": "#ECC0A8"
}
```

### 10.20 实现上滑加载更多数据

上滑加载更多数据又是另一个经典的 APP 操作。在本节中，我们将在小程序的 more-movie 页面中实现这个经典的操作。目前的 more-movie 页面只能显示最多 20 条数据，因为豆瓣 API 最多只允许我们一次加载 20 条数据，若想显示更多的电影数据，则需要实现分步加载。在传统的 Web 网页上，我们通常是通过分页来实现显示更多数据。在移动端，更常见的操作是不考虑页码，通过不断地上滑页面来实现加载更多数据。

实现上滑加载更多的关键点在于何时触发「加载更多」这个操作。很明显，当页面「触底时」就可以执行「加载更多」这个操作了。小程序在页面的 Page 中提供了ー个 onReachBottom 函数。onReachBottom 将在每次页面上滑触底后触发执行。所以，我们只需要编写小程序提供的 onReachBottom 函数即可实现 more-movie 页面的上滑加载更多数据的功能。在 more-movie.js 页面中新增 onReachBottom 函数。

```
  // 实现上滑加载更多操作
  onReachBottom: function (event) {
    var totalCount = this.data.movies.length;
    //拼接下一组数据的URL
    var nextUrl = this.data.requestUrl + "?start=" + totalCount + "&count=20";
    util.http(nextUrl, this.processDoubanData)
    //显示loading状态
    wx.showNavigationBarLoading();
  },
```

以上代码是实现上滑加载更多操作的核心代码。在 onReachBottom 函数中，我们拼接了一个 nextUrl 作为取下一组电影数据的 URL。start 指定起始电影的条数，该数值等于当前页面已经绑定的电影条目条数，count 指定了最多取 20 条（当然不指定 count 也是可以的，因为默认最多取 20 条）。

现在的问题是，我们如何知道当前已经显示了多少条电影条目呢？此时，我们需要调整下思路。我们将 this.data.movies 这个数组视作一个保存当前页面所有电影数据的数组。每当新增加 20 条数据后，我们都需要将新增的 20 条数据追加到这个 this.data.movies 数组中。

数据可以通过合并的形式追加到 this.data.movies 数组中，那么如何将新增的电影数据在 UI 上追加到已显示的电影后面呢？回顾一下我们在关于文章评论的 7.16 节中是如何将新的评论追加到已存在评论后面的。再次强调，要使用数据绑定的思维，而不要使用习惯的 DOM 思维来考虑问题。没有追加，只有重新绑定和渲染整个 this.data.movies 数组。所以，我们要做的就是将新加载的电影数据与已存在的电影数据合并在一起，并更新 this.data.movies。修改 more-movie.js 文件中的 processDoubanData 函数。

1『这里的 this 应指向 Page() 对象。』

黑色加粗部分标记出了新增以及修改的代码。加粗部分代码将每次新增加的电影数据同已存在的电影数据合并在一起，并再次使用 this.setData 进行数据更新。this.setData 在做数据更新的同时也更新了 this.data.movies 这个变量，以确保 this.data.movies 变量永远记录的是当前页面的全部电影数据。

还有一个小问题是我们要考虑的，即当 more-movie 页面多次加载数据后如何处理下拉刷新这个操作。假设我们已经加载了 5 次共 100 条电影数据，那么此时去下拉刷新 more-movie 页面，理论上应该更新全部的 100 条数据，但是对于豆瓣电影没有必要这样处理。我们简化一下处理流程。无论 more-move 页面有多少条电影数据，每当执行下拉刷新操作时都清空所有已存在的电影数据，重新加载最新的前 20 条数据。根据以上思路，修改 onPullDownRefresh 函数。

```
  onPullDownRefresh: function (event) {
    var refreshUrl = this.data.requestUrl +
      "?star=0&count=20";

    //刷新页面后将页面所有初始化参数恢复到初始值
    this.data.movies = [];
    util.http(refreshUrl, this.processDoubanData);
    //显示loading状态
    wx.showNavigationBarLoading();
  },
```

黑色加粗部分为新增加的代码。当下拉刷新触发 onPullDownRefresh 函数后将 this.data.movies 清空。完成以上代码后，现在每当我们在 more-movie 页面上滑触底后页面都将触发 onReachBottom 事件，从而实现加载更多电影数据。

1『新增代码解答了之前「源码不一致」的疑惑。』

3『

javascript 语言中 this 关键字的用法，this 代表着当前的对象，它在程序中随着执行的上下文随时会变化。var that=this 用法的一个例子：[微信小程序开发日记：重要的var that=this - 简书](https://www.jianshu.com/p/1ab0b8c4c078)。

[深入理解 JavaScript 中的 this 关键字 - Rain Man - 博客园](https://www.cnblogs.com/rainman/archive/2009/05/03/1448392.html)

在 JavaScript 中 this 变量是一个令人难以摸清的关键字，this 可谓是非常强大，充分了解 this 的相关知识有助于我们在编写面向对象的 JavaScript 程序时能够游刃有余。结论：this 所指的就是直至包含 this 指针的上层对象。调用形式是普通函数，this 指向全局对象 window；调用形式是对象的方法，this 指向该对象；调用形式是构造函数，this 指向新构造的对象。

1、一般用处。对于 this 变量最要的是能够理清 this 所引用的对象到底是哪一个，也许很多资料上都有自己的解释，但有些概念讲的偏繁杂。而我的理解是：首先分析 this 所在的函数是当做哪个对象的方法调用的，则该对象就是 this 所引用的对象。

```
var obj = {};
obj.x = 100;
obj.y = function() { alert( this.x ); };
obj.y();    //弹出 100
```

这段代码非常容易理解，当执行 obj.y() 时，函数是作为对象 obj 的方法调用的，因此函数体内的 this 指向的是 obj 对象，所以会弹出 100。

```
var checkThis = function() {
    alert( this.x); 
};
var x = 'this is a property of window';

var obj = {};
obj.x = 100;
obj.y = function(){ alert( this.x ); };

var obj2 = obj.y;

obj.y();   //弹出 100
checkThis();    //弹出 'this is a property of window
obj2();    //弹出 'this is a property of window
```

这里为什么会弹出 'this is a property of window'，可能有些让人迷惑。在 JavaScript 的变量作用域里有一条规则「全局变量都是 window 对象的属性」。当执行 checkThis() 时相当于 window.checkThis()，因此，此时 checkThis 函数体内的 this 关键字的指向变成了 window 对象，而又因为 window 对象又一个 x 属性（ 'this is a property of window'），所以会弹出 'this is a property of window'。上面的两个示例都是比较容易理解的，因为只要判断出当前函数是作为哪个对象的方法调用（被哪个对象调用）的，就可以很容易的判断出当前 this 变量的指向。

1（obj2();  为什么显示那个结果没弄明白。）

2、this.x 与 apply()、call()。通过 call 和 apply 可以重新定义函数的执行环境，即 this 的指向，这对于一些应用当中是十分常用的。

```
function changeStyle( type , value ){
    this.style[type] = value;
}

var one = document.getElementById( 'one' ); 
changeStyle.call(one , 'fontSize' , '100px'); //正确用法
changeStyle('fontSize' , '300px');  //出现错误，因为此时 changeStyle 中 this 引用的是 window 对象，而 window 并无 style 属性。
```

注意 changeStyle.call() 中有三个参数，第一个参数用于指定该函数将被哪个对象所调用。这里指定了 one，也就意味着，changeStyle 函数将被 one 调用，因此函数体内 this 指向是 one 对象。而第二个和第三个参数对应的是 changeStyle 函数里的 type 和 value 两个形参。最终我们看到的效果是 Dom 元素 one 的字体变成了 20px。

```
function changeStyle( type , value ){
    this.style[ type ] = value;
}

var one = document.getElementById( 'one' ); 
changeStyle.apply( one , ['fontSize' , '100px' ]); //正确用法
changeStyle('fontSize' , '300px');  //出现错误，原因同示例三
```

apply 的用法和 call 大致相同，只有一点区别，apply 只接受两个参数，第一个参数和 call 相同，第二个参数必须是一个数组，数组中的元素对应的就是函数的形参。

3、无意义（诡异）的 this 用处。

```
var obj = {
    x : 100,
    y : function(){
        setTimeout(
            function(){ alert(this.x); }    //这里的 this 指向的是 window 对象，并不是我们期待的 obj，所以会弹出 undefined
         , 2000);
    }
};

obj.y();
```

如何达到预期的效果：

```
var obj = {
    x : 100,
    y : function(){
        var that = this;
        setTimeout(
            function(){ alert(that.x); }
         , 2000);
    }
};

obj.y();    //弹出100
```

4、事件监听函数中的 this。

```
var one = document.getElementById( 'one' );
one.onclick = function(){
    alert( this.innerHTML );    //this 指向的是 one 元素，这点十分简单。
};
```

以上可以归纳为：this 所指的就是直至包含 this 指针的上层对象。

』

### 10.21 动态设置导航栏 loading 图标

我们在前面实现了 more-movie 页面的下拉刷新电影数据与上滑加载更多电影数据的操作，但是整个加载数据的过程体验并不是那么好，总觉得缺少了点什么。拿上滑加载更多电影数据来看，从触发加载数据到数据显示，整个过程没有等待提示，当数据加载完成后「突然」就显示了出来。虽然我们建议目前的小程序不要使用太多的特效，但是必要的等待提示是用户最基本的心理预期，还是可以加上的。

在前面的章节中，我们学习过 wx.showToast 提示。wx.showToast 将在页面的中间位置显示一个模态或者非模态（showToast 的 mask 属性决定是模态还是非模态）的提示框。笔者认为，对于 loading 状态提醒，用这种置于页面中心位置的侵入式提醒体验并不好。Loading 并不需要很强的信息通知，用户不需要阅读文字，只需要能够感觉到正在加载即可，所以使用「侵入式」的 wx.showToast 并不是太合适。我们希望有一个「非侵入式」的 loading 状态提醒，只让用户从心理上感觉到页面正在加载即可。

小程序提供的一个 API 方法 wx.showNavigationBarLoading() 非常适合用于 loading 状态提醒。通常来说，wx.showNavigationBarLoading 和 wx.hideNavigationBarLoading 是成对出现的。一个负责显示 loading 状态图标，一个负责隐藏 loading 状态图标。图 10-21 显示了导航栏 loading，状态图标的效果。

考虑一下，我们需要在 more-movie 页面的哪些操作中调用 wx.showNavigationBarLoading 显示 loading 状态图标，又需要在什么地方调用 wx.hideNavigationBarLoading 隐藏状态图标。基本上，每次去豆瓣取数据时就应该显示 loading 状态，当数据处理完豆瓣电影数据并使用 this.setData 更新电影数据后应该调用 wx.hideNavigationBarLoading 方法隐藏 loading 状态。

具体到 more-movie 页面，我们可以在 onload 初始化加载电影数据时、onReachBottom 滑动加载更多电影数据时以及 onPullDownRefresh 下拉刷新电影数据时调用 wx.showNavigationBarLoading 显示 loading 状态图标，而在 processDoubanData 中处理完豆瓣数据后调用 wx.hideNavigationBarLoading 隐藏状态图标。在以上几方法中分别添加 wx.showNavigationBarLoading 与 wx.hideNavigationBarLoading 方法。

```
  onPullDownRefresh: function (event) {
    var refreshUrl = this.data.requestUrl +
      "?star=0&count=20";

    //刷新页面后将页面所有初始化参数恢复到初始值
    this.data.movies = [];
    util.http(refreshUrl, this.processDoubanData);
    //显示loading状态
    wx.showNavigationBarLoading();
  },
```

添加完以上代码后，开发者注意观察一下当正在加载数据时和数据加载完成后导航栏 loading 图标的显示和隐藏效果。这里要特別说明以下 3 点：

第一，下拉刷新时可以不使用导航栏的 loading 状态图标，因为下拉刷新本身在页面的窗体部分就有一个 loading 状态图标，如图 10-18 所示。

第二，在以上代码中，我们没有考虑数据加载失败的情况。如果数据加载失败，程序就无法进入 processDoubanData 方法中，从而导致无法执行 wx.hideNavigationBarLoading 方法，导航栏的 loading 图标一直显示。Orange Can 只是一个示例项目，如果完全模拟真实项目，需要写太多同小程序无关的代码，所以建议开发者在真实的项目中注意容错处理。「永远不要相信外部环境」是每个开发者要时刻牢记于心的真理。开发者可以尝试将隐藏 loading 图标的代码放在 wx.request 请求的 complete 函数中，这样无论数据加载是否成功都将隐藏 loading 图标。

2『永远不要相信外部环境，这句话的细节是什么。做一张金句卡片。』

第三，在 lonload 数中调用 wx.showNavigationBarLoading 函数设置页面导航栏是有风险的，原因我们已在 6.9.2 小节中解释过。当前版本没有问题，并不代表未来版本不会有问题，何况在 onReady 页面生命周期之后再操作界面元素是官方文档中明确说明的。所以建议开发者最好还是在页面的 onReady 函数中动态设置导航栏 loading 状态，同官方文档的要求保持一致。下面给出在 more-movie 页面的 onReady 函数中设置 loading 状态的代码，开发者可自行选择是否使用以下代码，毕竟在 130400 版本中在 onLoad 函数中设置 loading 状态也是没有问题的。

```
  /**
   * 生命周期函数--监听页面初次渲染完成
   */
  onReady: function () {
    wx.setNavigationBarTitle({
      title: this.data.navigateTitle
    });
    wx.showNavigationBarLoading()
  },
```

从设置 loading 状态标示这个小示例中我们应该能体会到小程序到底简单在什么地方。你无须过多考虑 loading 应该怎么去提示，小程序已经帮你「安排」好了。虽然这些固化的 API 让程序显得很没有个性，但是小程序的特性就是用完即走。有时候牺牲一些个性化与美观度，换来更高的开发效率与更低的开发成本是值得开发者考虑的。当然，如果你不满意小程序的 loading，完全可以自行编码来实现自己理想的 loading 状态机制。

### 10.22 电影搜索

在本节中，我们将实现电影搜索功能。电影搜索的效果图，如图 10-22 所示。我们并没有选择使用一个新的页面来编写电影搜索的功能，电影搜索位于 movie 电影首页。当激活搜索时，电影首页的资讯面板信息被隐藏，电影搜索面板被显示；相反，当退出电影搜索时电影搜索面板被隐藏，而电影资讯面板将被显示。

下面我们在电影首页中实现这个显示与隐藏的效果。在 move.wxml 中添加并修改以下代码：

```
<import src="movie-list/movie-list-tpl.wxml" />
<import src="movie-grid/movie-grid-tpl.wxml" />

<view class="search">
  <icon type="search" class="search-img" size="13" color="#405f80"></icon>
  <input type="text" placeholder="乘风破浪、西游伏妖篇" 
  placeholder-class="placeholder" bindfocus="onBindFocus" value="{{inputValue}}"
  bindconfirm="onBindConfirm"/>
  <image wx:if="{{searchPanelShow}}" src="/images/icon/wx_app_xx.png" class="xx-img" catchtap="onCancelImgTap"></image>
</view>

<view class="container" wx:if="{{containerShow}}">
  <view class="movies-template">
    <template is="movieListTpl" data="{{...inTheaters}}" />
  </view>
  <view class="movies-template">
    <template is="movieListTpl" data="{{...comingSoon}}" />
  </view>
  <view class="movies-template">
    <template is="movieListTpl" data="{{...top250}}"/>
  </view>
</view>

<view class="search-panel" wx:if="{{searchPanelShow}}">
    <template is="movieGridTpl" data="{{...searchResult}}"/>
</view>
```

首先我们添加了一个 \<view class="search"> 容器，在该容器的内部实现了一个 inpute 的搜索栏， placeholder 属性设置了 input 的默认占位文字；placeholder-class 属性指定了 placeholder 样式类的类名，该样式将在随后被添加到 move.wxss 文件中。bindfocus 事件将实现鼠标或者手指激活 input 时显示搜索面板，bindconfirm 事件将实现提交搜索信息的功能。xx-img 将实现点击后关闭（隐藏）搜索面板。

同时，在 \<view class="container" wx:if="{{containerShow}}"> 这个电影资讯面板上增加一个属性 wx:if="{{containerShow}}"，这个属性也是用来控制电影资讯面板显隐状态的标识位。

最后，我们增加了一个 \<view class="search-panel" wx:if="{{searchPanelShow}}">。这个面板就是电影搜索面板，主要用来显示搜索结果。可以看到，在电影搜索面板中并没有编写任何代码，我们再一次地使用了 move-grid-tpl 模板。所以，我们在代码的顶部再次引用了 movie-grid-tp 模板。

添加完电影搜索的骨架代码后，我们来编写电影搜索的样式。在 move.wxss 文件中添加以下同电影搜索相关的样式：

记得在代码的顶部引用 move-grid-tpl 模板的样式。当编写完以上代码后，保存并运行项目，发现电影首页的电影内容「消失」了。由于我们没有正确地在 movie 页面的 js 文件中设置搜索面板同电影资讯面板的显隐控制变量，因此电影资讯面板默认被隐藏了。下面在 movie.js 的 data 变量中设置 searchPanelShow 与 containerShow 的默认值。


```
  /**
   * 页面的初始数据
   */
  data: {
    inTheaters: {},
    comingSoon: {},
    top250: {},
    containerShow: true,
    searchPanelShow: false,
    searchResult: {},
  },
```

黑色加粗部分是新增代码。除了设置「containerShow: true」让电影资讯面板显示、「searchPanelShow: false」让搜索面板隐藏外，我们顺便将搜索结果的初始化变量 searchResult 也加入 data 変量中。此时保存并运行代码，将出现如图 10-23 所示的效果。

以上代码实现了搜索面板与电影面板的初始化状态。现在，当用户激活 inpu 搜索栏准备输入关键字开始搜索时，我们需要显示搜索面板并隐藏电影资讯面板。已经注册在 input 组件上的 onBindfocus 事件将实现这个显隐切换效果。在 movie.js 中添加 onBindfocus 事件响应函数。

```
  // 切换面板
  onBindFocus: function (event) {
    this.setData({
      containerShow: false,
      searchPanelShow: true
    })
  },

```

当用户激活 input 组件后将执行 onBindfocus 函数。这将隐藏电影资讯面板，并显示搜索面板，准备接受用户输入，如图 10-24 所示。用户通过点击图 10-24 中 input 搜索框右侧的 X 图片，可以关闭搜索面板并再次打开电影资讯面板。在 move.js 中添加点击 X 图片的事件响应函数 onCancelImgTap。

```
  // 隐藏搜索代码
  onCancelImgTap: function (event) {
    this.setData({
      containerShow: true,
      searchPanelShow: false,
      searchResult: {},
      inputValue: ''
    }
    )
  },
```

在上述代码中，我们除了切换两个面板的显隐状态外，同时清空搜索结果 searchResult，保证下次再次进入搜索面板时，搜索面板不会记录上一次的搜索结果。将 inputValue 的值设置为空字符串将保证 input 组件所记录的用户输入值也一并被清空。

需要注意的是，input 组件的输入文本是无法设置字体的，因为在小程序中 input 组件是一个 native 组件，字体必须使用系统字体，所以无法设置 font-family。在真机上运行时，它也将被设置为真机系統的默认字体。

当用户输入关键字并按键盘上的「回车」或者点击真机上的「完成」后，小程序将触发 input 的 bindconfrn 事件，并执行已经注册在 input 上的事件响应函数 onBindConfrn。在 movie.js 文件中添加 onBindConfrn 事件响应函数：

```
  // 响应搜索事件
  onBindConfirm: function (event) {
    var keyWord = event.detail.value;
    var searchUrl = app.globalData.doubanBase +
      "/v2/movie/search?q=" + keyWord;
    this.getMovieListData(searchUrl, "searchResult", "");
  },

```

onBindConfirm 的代码非常简单，首先获取到用户的输入值 keyWord，这个值稍后将被附加到豆辧电影搜索 API 的 URL 地址中。豆瓣电影的搜索 API 地址为 /v2/movie/ search?q={keyword}，我们只需要将获取到的 keyWord 附加在 APl 地址中并调用 this.getMovieListData 方法即可。this.getMovieListData 方法早在编写 movie 页面的电影数据显示时已经编写好，这里只需要调用即可。this.getMovieListData 接收 3 个参数，searchUrl 是豆瓣 API 的数据访问地址，"searchResult" 指定将处理完毕的豆瓣数据绑定到 searchResult 变量上，以提供给 wxml 显示数据。

    <template is="movieGridTpl" data="{{...searchResult}}"/>

### 10.23 电影详情页面

下面我们来编写电影详情页面。先思考一下电影详情页面的入口在哪里。任何一个显示电影封面（见图 10-25）的地方都应该能够点击进入到电影详情页面，这些入口遍布在电影首页、电影搜素、更多电影等多个地方。好在我们是使用 template 模板构建的电影页面结构体系，所有的电影单体元素都集中在 movie-tpl 这个 template 模板里。也就是说，只需要在 move-tpl 模板上注册相应的点击事件即可。

在 10.4 节中，我们已经在代码清单 10-5 中注册了 move-tpl 的点击事件 onMovieTap。现在要做的就是在每个包含 move-tpl 的页面中编写 onMovieTap 事件响应函数，并在事件响应函数中将页面跳转到 move-detail 页面。

首先，新建 move-detail 页面并注册这个页面。在 app.json 的 pages 数组下注册 move-detail 页面。保存后开发工具将自动在 pages/movie/ movie-detail 目录下新建 move-detail 页面的 4 个页面文件。在以下两个使用过 move-tpl 模板的页面 js 文件中编写 onMovieTap 事件响应函数：movie.js 和 more-movle.js。

```
  // 跳转到详细页的事件函数
  onMovieTap: function (event) {
    var movieId = event.currentTarget.dataset.movieId;
    wx.navigateTo({
      url: "movie-detail/movie-detail?id=" + movieId
    })
  },
```

```
  onMovieTap: function (event) {
    var movieId = event.currentTarget.dataset.movieId;
    wx.navigateTo({
      url: '../movie-detail/movie-detail?id=' + movieId
    })
  },
```

注意以上两段代码所设置的 wx.navigateTo 的 urI 参数值是不同的。我们同时还将所点击电影的 id 号附加在 url 中，传递到 move-detail 页面中。movie-detail 只有知道电影的 id 号才能够正确地加载电影详情数据。

从以上两段代码，我们也可以再次看出小程序模板的缺陷：模板不能运行自己的业务逻辑代码。onMovieTap 的业务逻辑本应当属于模板自身的业务逻辑，但由于模板不可以运行 js 代码，因此只能将本属于模板的业务逻辑编写在调用模板的页面 js 代码中。在 Orange Can 项目中，我们幸运地只在两个页面引用了 move-tpl 模板，但如果有十几个地方引用了 move-tpl 模板，就不得不在这十几个地方一次编写上述代码。

当然，可以将模板的业务代码编写成一个类似于 url 一样的模块，并在其他页面里引用这个模块，但 onMovieTap 里的代码终究还是属于 movie-tpl 的，无论放在什么地方都不如放在模板自己的业务逻辑文件中。编写完以上代码后，无论是在 movie 页面、more-movie 页面还是是在电影搜索的结果页面上，点击任意电影都将跳转到 movie-detaile 电影详情页面。接下来，我们需要编写 movie-detail 电影详情页面的骨架与样式。电影详情页面的效果如图 10-26 所示。

### 10.24 电影详情页面的骨架和样式

本节我们开始着手编写 move-detail 电影详情页面的骨架与样式代码。在 move-detail.wxml 文件中添加以下代码：

注意，在 move-detail 页面中我们同样使用了 stars-tpl 模板，记得在代码的顶部引入这个模板文件。

骨架代码中并没有什么新鲜的知识，唯一值得关注的是我们使用了一个 scroll-view 组件。这组件用于横向展示多张演员图片，这些演员图片会「突破」手机尺寸的限制，在横向出现滚动条。图 10-27 展示了 scroll-view 的横向滚动效果图。scroll-view  组件的 scroll-x 和 scroll-y 分别设置组件的横向和纵向是否出现滚动条，如果想使用横向 scroll-view，就请设置 scroll-x="true"。

scroll-view 组件的横向排布要注意以下几个要点：1）如果 scroll-view 下排列的多个子元素是块级元素（比如 view），就直接对 scroll-view 设置 display:flex 和 flex-direction:row，不会使子元素自动成为水平排列。如果不使用 scrol-view 而将容器元素换成 view，那么设置 display:flex 和 flex-direction:row 是可以使子元素自动成水平排列的。2）如果想让 scroll-view 下的 view 元素水平排列，一种可行的方法是将子元素 view 设置为 inline-block 或者 inline-flex。3）子元素有可能会出现换行的情况，需要在容器上设置 white-space:nowrap。

我们会在后面的章节中详细讲解 scroll-view 的一些高级用法，现在我们只需要掌握这些 scroll-view 的简单用法即可。这里顺便提一下，scroll-view 中的 bindscrolltolower 事件也可以用来实现加载更多数据（类似于 Page 页面的 onReachBottom）。当 scroll-view 滚动到底部或者右边时将触发这个事件，实现原理请参考 more-movie 页面的 onReachBottom 函数。

实际上 Orange Can 项目最初在编写 more-movie 页面加载更多数据时也是使用的 scroll-view 的 bindscrolltolowerg 事件，但微信在 130400 版本更改了一些规则，官方文档中是这样描述的：在滚动 scroll-view 时会阻止页面回弹，所以在 scroll-view 中滚动是无法触发 onPullDownRefresh 的。

在 130400 版本之前，scroll-view 的滚动同 onPullDownRefresh 下拉刷新事件是不冲突的，但版本更新后若使用 scroll-view 则在 scroll-viev 组件中下拉页面是无法触发 onPullDownRefresh 函数的。正是基于这个原因，笔者最后没有使用 scrolll-view 来实现 move-grid-tpl 模板，而是改为使用普通的 view，并使用 Page 的 onReachBottom 函数实现了加载更多数据的功能。

除此之外，scroll-view 还有以下几个需要注意的地方：1）请勿在 scroll-view 中使用 textarea、map、canvas、video 组件。2）scroll-into-view 的优先级高于 scroll-top。3）在滚动 scroll-view 时会阻止页面回弹，所以在 scroll-view 中滚动是无法触发 onPullDownRefresh 的。4）若要使用下拉刷新，请使用页面的滚动，而不是 scroll-view，这样也能通过点击顶部状态栏回到页面顶部（经过测试发现，必须点击手机的状态栏而非小程序的导航栏才能返回页面顶部。请在豆瓣 top250 的「更多电影」页面测试此特性），如图 10-28 所示。

关于 scroll 的更详细介绍和高级用法请参考 13.2 节，本节我们仅使用 scroll-view 的基本功能。接着编写 movie-detail 页面的样式。将以下代码添加到 move-detail.wxss 文件中：

同样记得在代码的顶部引入 stars-tpl 模板的样式文件。-webkit-filter:blur(20px) 实现了图片模糊的效果。由于现在并没有编写页面的逻辑文件，因此我们暂时无法看到页面的显示效果。

### 10.25 编写电影详情页面的业务逻辑代码

现在编写 move-detail 电影详情页面的业务逻辑代码在 movie-detail.js 文件中添加以下代码：

整个代码逻辑非常简单，仅仅是获取数据并处理数据。豆瓣 API 获取电影详情数据的 URL 为 /v2/movie/subject/{subjectID}。需要注意的是，豆瓣的许多电影由于年代久远而导致数据有所缺失，这会造成很多「空值」情况。有些空值只会让数据无法显示，但程序不会报错；有些空值则会直接导致程序终端运行。对于第二种空值，我们一定要做容错处理。

导致程序终端的空值多是由于对象是 null 而我们却尝试去读取空对象的属性，这样的行为导致程序报错，无法继续运行。如果是字符串 null，那么绑定一个空字符串程序是不会报错的。豆瓣电影的数据结构非常复杂，无法一次将所有的属性都做容错处理，所以建议遇到错误时再回头编写容错代码。比如上述代码中对 directors 的属性处理就属于容错性处理。在以上代码中，又调用了两个 util 函数：util.convertToCastString 和 util.convertToCastInfos。现在在 util 模块中编写这两个函数。

1『bug 是永远消除不完的，一定要有管理 bug 的思维。』

### 10.27 设置电影页面的导航栏标题

所有配置或者是动态设置导航栏标题的方法在之前的章节中已详细讲解过，本节就不赘述了。下面直接给出配置代码。

首先，配置 movie 电影首页的导航栏标题，在 movie.json 文件中新增以下代码；接着，设置 more-movie 更多电影页面的导航栏标题。在 more-move.js 页面中添加以下代码，以保证 more-move 页面的导航栏标题被设置为当前电影的电影分类。将 category 电影类型暂时保存在 data 变量中，再在 more-movie.js 的 onReady 函数中读取这个变量并动态设置导航栏标题。最后，我们还需要将电影详情页面的导航栏标题动态设置为当前显示电影的电影标题。在 move-detail.js 文件的 processDoubanData 中新增一小段代码。编写完以上代码后，3 个电影页面的导航栏标题就全部设置完成了。

## 11. 设置

### 1. 逻辑脉络

小程序中众多的 APl，这些 API 包括获取用户基本信息、获取系统信息、获取网络状态、获取当前位置信息与速度信息、使用做信内置地图查看当前位置、使用监听罗盘数据接口制作一个建议的指南针、经典小功能摇一摇、二维码扫描以及下载文档并预览文档等。

### 2. 摘录及评论

### 11.1 设置页面

一个项目是不可能将小程序全部功能都使用到的，所以我们特意在 Orange Can 顼目增加了一个「设置」页面。这个页面将集成很多零散的小程序功能，比如获取用户微信信息、系统信息、网络状态、指南针、获取当前位置、摇一摇、扫描二维码等功能。不同于文章和电影页面，「设置」页面的功能类似于小程序 API 的示例集合，虽然没有实际意义，但是对于了解和学习这些 API 的使用方法有极大帮助。

首先，在 app.json 的 pages 数组下新建 setting（设置）页面的路径。setting 同 post 和 movie 一样，也属于 tab 选项栏中的一项，将 setting 页面加入到 tab 选项卡中。这样，Orange Can 项目的 tab 选项卡将有 3 个选项：post、move 和 setting。来看看 setting 页面的效果图，如图 11-1 所示。顶部显示当前用户的微信头像、微信昵称等信息；下面紧跟着的分别是缓存面板、设备面板、APl 面板以及其他杂项面板。每个面板下包含若干种小程序常用功能，点击可执行或演示相应的功能。下面编写 setting 页面的骨架结构。

我们没有直接将每个面板的子项内容编码在 wxml 文件中。由于每个面板下的子项较多，且有可能经常添加子项，因此没有直接将子项「硬编码」在 wxml 文件中，而是选用了一种「配置式」的编写方法。每个项目下的子项内容都将在 js 文件中「配置」，然后通过数据绑定和列表渲染动态的填充到 wxml 中。目前，由于我们还没有编写 setting 的 js 文件，列表渲染的各个数组都是「空值」状态，因此 setting 页面不会显示任何内容。接着，编写 setting 页面的样式，在 setting.wxss 文件中加入以下代码：

最后，编写 setting.js 文件，在 js 里加入我们的配置。以上代码在 setting.js 的 data 变量下加入了 4 个数组，分别对应 wxml 中的缓存面板数组、设备面板数组、API 面板数组以及其他杂项面板数组。每个数组子项都包含 iconurl、title 和 tap 三个属性。iconurl 代表子项图标的图片路径，title 代表子项的标题名，tap 是点击子项后所执行函数的函数名。

这样，如果以后我们想新增一个子项，只需要在 js 文件中增加配置即可。编写完以上代码后，保存并运行项目，setting 页面将呈现如图 11-2 所示的效果。顺便在 setting.json 文件中加入导航栏标题的配置。

### 11.2 获取用户基本信息

目前 setting 页面的顶部还是空白的，我们需要在小程序中获取用户的基本资料，并显示在 setting 页面的顶部。小程序提供了ー个 wx.getUserInfo(OBJECT) 方法来获取用户的信息。用户信息分为用户基本信息和用户 openId、Unionld。基本信息是明文的，而 openId 和 Unionld 是加密数据。这两种类型的数据都由 wx.getUserInfo(OBJECT) 方法返回。

用户基本信息包括以下 7 项：1）avatarUrl 用户微信头像的 URL 地址。2）City 城市。3）country 国家。4）gender 性别，1 表示男，2 表示女，0 表示未知。5）language 语言区域。6）nickname 昵称。7）province：省份。

在小程序中，用户的基本信息可以轻易获得，他们是明文的、不加密的。但 openId 和 Unionld 是加密的。什么是 openId 和 Unionld 呢？可以将 openId 和 Unionld 理解为用户在微信应用中的 id 号。他们的区别是：openId 只代表用户在某个徽信应用下的 id 号；而 Unionid 是跨应用的，同一用户在同一开发者的多个应用里，Unionld 是唯一的。

官方文档对于 Unionid 的描述非常清楚：如果开发者拥有多个移动应用、网站应用和公众账号（包括小程序），可通过 Unionid 区分用户的唯一性，因为只要是同一个微信开放平台账号下的移动应用、网站应用和公众账号（包括小程序），用户的 Unionid 就是唯一的。换句话说，同用户在同一个微信开放平台下的不同应用中，Unionld 是相同的。所以，openId 不能跨应用，如果要在多应用间统一用户身份，请使用 Unionld。这里要注意，在小程序中使用 Unionld 首先需要前往微信开放平台绑定小程序。详情请参考官方文档。

在小程序中获取用户的基本信息是非常简单的，但想拿到 openId 和 Unionid 却不是那么容易。本节先来学习如何获取用户的基本信息，获取加密信息在后面的章节中讲解。下面来看 wx.getUserInfo(OBJECT) 方法的使用。wx.getUserInfo(OBJECT) 的 OBJECT 参数有 3 个回调函数：success、fail 和 complete。在这 3 个回调函数中，重点介绍 success。

success 方法的返回值有以下 5 个：1）userInfo，用户基本信息对象，不包含 openId 等敏感信息。2）rawData，不包含敏感信息的基本信息字符串，通常用来计算签名，防止从微信返回的用户信息被簒改。3）signature，使用 sha1(rawData+ sessionkey) 得到字符串，用于校验用户信息。4）encryptedData，包括敏感数据在内的完整用户信息的加密数据。5）iv，加密算法的初始向量。

如果不是非常了解微信的加解密及身份认证机制，建议开发者先不要太过于纠结 signature、encryptedData、iv 这 3 个返回值，目前还不需要使用这 3 个参数。在后面的章节中会具体讲解这 3 个返回值的概念以及使用方法，本节只需要使用 userInfo 返回值。

现在，我们在 Orange Can 项目中获取用户的明文信息。首先，在 app.js 文件中的 globalData 对象下新增一个全局变量 g_userInfo，用来记录用户的基本信息。当我们需要在其他页面使用用户信息时，读取这个全局变量即可。

解释一下上述代码。为了避免每次启动小程序时都要在做信服务器中加载用户的基本信息，我们将用户信息保存到缓存中。这样，每次启动小程序时先去看看缓存有没有数据，如果没有，就调用 wx.getUserInfo 获取用户信息并保存到缓存和全局变量 g_userInfo 中；如果有，就直接将用户信息保存到全局变量 g_userInfo 里。

田心的开发者可能注意到，我们并不是直接调用 wx.getUserInfo(OBJECT) 方法，而是先调用 wx.login，在 wx.login 调用成功后再继续调用 wx.getUserInfo。之所以在 wx.login 调用成功后才调用 wx.getUserInfo，是因为官方文档明确指出了获取用户信息需要先调用 wx.login。同时，在官方的示例项目中也是先调用 wx.login。至于 wx.login 有什么作用，我们会在后面的章节中讲到，开发者可「依葫芦画瓢」，照做即可。

事实上，如果你只想获取用户的明文基本信息，那么不调用 wx.login，直接调用 wx.getUserInfo 也可以获取用户信息。所以，是否在调用 wx.getUserInfo 前调用 wx.login 请开发者自行決定。当第一次运行以上代码并调用 wx.getUserInfo(OBJECT) 时，小程序会弹出如图 11-3 所示的提示窗口，让用户选择是否授权获取用户的基本信息。用户点击「允许」后，才会执行 wx.getUserInfo 的 success 回调函数，如果点击「拒绝」，将执行 fail 回调函数。

有些开发者在测试时可能永远不会弹出这个授权窗口。因为如果当前项目没有 appld，那么用户信息是由微信模拟的信息，并没有进行真实的获取用户信息流程，所以不会出现这个窗口，且开发工具会有一个警告提示，如图 11-4 所示。

当然，这个用户数据也是真实的用户数据，因为你在使用开发工具时必须扫描二维码登录，这样开发工具就能知道你的微信身份，自然可以模拟返回你的用户数据。但模拟数据相比于真实的用户数据缺少 3 个属性，即 signature、encrypteddata 和 iv。也就是说，模拟数据只有明文信息而没有加密信息。

将用户信息保存到缓存中有一个缺点，就是没办法实时更新用户信息（比如用户更改了自己的微信资料），但这是具体业务的问题，需要开发者在实际项目编写中灵活处理。现在，可以在 setting 页面中通过访问 g_userInfo 全局变量获取并显示用户的基本信息，需要在 setting 页面的 onLoad 方法中添加以下代码。注意，在使用全局变量前，需要先调用 getapp() 方法获取小程序的 App 对象。保存并运行代码，setting 页面将正确显示用户的头像、昵称等信息。

1『

按作者的源码发现无法获取用户的基本信息，那么微信新版里的获取方法应该更新成了自动生成的那个 wx.getSetting 方法，它返回的是一个全局变量 userInfo。将作者的源码删掉，setting.js 里调用的数据改为 userInfo 即可显示用户的信息。

```
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function () {
    this.setData({
      userInfo: app.globalData.userInfo
    })
  },
```

』

### 11.3 数据缓存的异步操作

为了可以在真机上清除数据缓存，我们在设置里增加一个清除数据缓存的选顼。当用户点击这个选项时，首先会弹出一个 modal 模态窗口，如果用户点击「确定」，就可以清除用户的数据缓存。在 5.8.2 小节中，我们提到过所有缓存类 API 除了有一组同步方法外，还有一组异步方法。在本小节中，尝试使用异步的 wx.clearStorage 方法清除用户的数据缓存。setting 页面有许多选项需要使用 modal 窗口让用户确认操作，所以我们在 setting.js 文件中添加个显示 modal 的公共方法。

showModal 方法只是对 MINA 框架提供的 wx.showModal做了一次封装，设置了通用的颜色。showModal 方法还接收了一个回调函数 callback，用户点「确定」后执行这个回调函数。接着编写清除数据缓存的事件响应函数。从 data 中的 cache 配置来看，清除数据缓存的的事件响应函数为 clearCache。下面在 setting.js 文件中新增一个 clearCache 方法。

显然，异步缓存操作方法在写法上比同步要麻烦一些。要注意的是，以上只是一个简单的异步函数操作示例，所以看起来并不是那么「烦琐」，但在真实的项目中，往往有着非常复杂的业务逻辑。在 js 中，异步非常容易形成所谓的「回调地狱」，也就是在回调函数中连续嵌套调用回调函数，这会让代码的可阅读性変得非常糟糕。异步函数又一直存在着难以调试的问题。

关于同步和异步的选择，需要根据实际情况来決定，笔者的建议是优选选择同步方法。当同步方法的体验和效率太差或者同步方法无法解決问题时再考虑使用异步方法。至此，完成了 setting 页面的第一个小功能。

### 11.4 获取系统信息

系统信息的显示需要新建一个 device 子页面。下面在 app.json 文件的 pages 数组下新增 device 页面的路径。当我们点击「系统信息」时，setting 页面要跳转到 device 子页面，需要在 setting.js 中新增一个「系统信息」的点击事件响应函数。

```
  //显示系统信息
  showSystemInfo: function () {
    wx.navigateTo({
      url: 'device/device'
    });
  },
```

点击「系统信息」后，页面将跳转到 device 子页面。下面来编写 device 子页面的骨架和样式。在 device.wxml 和 device.wxss 中分别加入骨架代码和样式代码。MINA 框架所提供的获取系统信息的 API 是 wx.getSystemInfo 以及 wx.getSystemInfoSync 方法。前者是同步方法，后者是异步方法。选择同步还是异步，请根据自己的实际情况来考虑。

以下是 wx.getSystemInfo 方法可以获取的系统信息：1）model：手机型号。2）pixeRatio：设备像素比。3）windowWidth：窗口宽度。4）windowHeight：窗口高度。5）language：微信设置的语言。6）version：微信版本号。7）system：操作系统版本。8）platform：客户端平台。wx.getSystemInfo 的使用非常简单，在 device.js 文件中新增以下代码：

保存并运行代码，点击「系统信息」后将打开如图 11-5 所示的 device（系统信息）页面。要注意的是，在开发工具中以上信息多是模拟器模拟的参数。可以尝试在开发工具中调整当前机型，比如图 11-6 显示了当选择机型为 Nexus 6 时的系统信息。

### 11.5 获取网络状态

MINA 框架提供了 wx.getNetworkType 作为获取当前网络状态的接口。获取网络状态是一个异步方法，方法回调函数中可以接收一个 res 参数，使用 res.networkType 可以获得当前移动设备的网络状态。网络状态的可能取值有 6 种：2g、3g、4g、Wifi、none、unknown。在 setting.js 文件中添加以下事件响应函数：

```
  //网络状态
  showNetWork: function () {
    var that = this;
    wx.getNetworkType({
      success: function (res) {
        var networkType = res.networkType
        that.showModal('网络状态', '您当前的网络：' + networkType);
      }
    })
  },
```

要注意的是，在开发工具中网络状态是由开发者自己设定的，如图 11-7 所示。

## 12. 开放接口

### 1. 逻辑脉络

12、微信开放接口。详细地介绍用户登录、用户信息校验、解析用户加密数据获取 openId、模板消息以及最重要的微信支付。

### 2. 摘录及评论

本章我们将学习微信开放接口。毫不夸张地说，微信的开放接口是微信类产品最有价值的一部分。没有微信开放接口，小程序的价值将大打折扣。即使你不是一个微信开发者或者你的小程序无须使用微信开放接口，但理解微信开放接口的设计原理对提升架构方面的知识也很有好处。关于开放接口这块儿，微信官方文档写得并不够详尽，本章将详细地介绍用户登录、用户信息校验、解析用户加密数据获取 openId、模板消息以及最重要的微信支付。

### 12.1 准备工作

调用微信小程序的开放接口要求开发者必须拥有小程序账号。拥有小程序账号的开发者拥有一个 appld，如果你的 Orange Can 现在没有 appld，请将 appld 加入 Orange Can 项目中。目前小程序开发工具没有提供加入 appld 的快捷方式，所以请开发者新建一个带有 appld 的项目并将目录指向 Orange Can 的文件目录。

本章内容需要使用小程序的 appSecret，小程序的 appld 和 appSecret 均可以在小程序账户的「设置」→「开发设置」→「开发者 ID」中获得。本章要实现的功能还需要调用服务器接口。本书中的服务器代码均采用 PHP 编写，并部署在本地的 Apache 服务器中。本章会给出所有 PHP 示例代码，你也可以下载我们提供的 PHP 示例代码，并部署在本地或网络服务器上。以下 url 地址是用户登录接口的示例地址：

http://localhost:8080/wxopen/wxlogin.php

1『把作者的源码放到 XAMPP 里的 htdocs 文件夹里，然后通过端口访问：http://192.168.64.2/2020084wxserver/wxLogin.php。』

注意，如果在项目中填写了 appld 且服务器在本地，那么调用本地 http 接口时一定要勾选「项目」中的「开发环境不校验请求域名以及 TLS 版本」，否则无法访问服务器。

为了简化代码，本章的代码（小程序和 PHP 中的代码）都没有做过多异常处理，只能作为演示功能的示例代码。Orange Can 并不是真实的项目，请各位开发者以理解功能原理为主要目的。如果要开发自己的真实项目，请考虑各种调用失败的情况并加强安全性。

注意，本章的代码依然用于 setting 页面，每个功能都将作为 setting 页面的一个子项，本章 setting 相关的子项配置已经在 11.1 的代码清单 11-5 中添加完毕。同时，本章大多数代码的运行结果与之前的章节不同，之前的章节我们都会使用 UI 效果展示运行结果，而本章大部分示例代码都将以 console.log 的方式输出到控制台中，请开发者自行在「Console」面板中査看代码的运行结果。

### 12.2 用户登录

用户登录是小程序中获取用户加密信息、使用模板消息、客服消息、微信支付等接口的先决条件。只有用户在小程序中登录了，我们才能获取用户在当前小程序中的 openId 以及本次登录会话的 session_key。openId 是使用一系列微信小程序开放接口的必要参数。关于 openId 的相关内容我们在 11.2 节中已经具体讲解过，这里就不再赘述。

首先，我们要了解什么是微信小程序登录，有什么作用？微信小程序登录是为了让开发者的服务器获取用户的 openId 以及 session_key 的令牌。请不要将微信小程序的用户登录理解为传统意义上的登录。虽然从大的方向上讲，登录都是为了确认用户的身份、拿到用户的唯一身份标识，但是微信小程序的登录流程和传统的账号密码流程不太一样。当你进入小程序后，不需要输入任何账号密码，开发者服务器就可以获取你的 openId 标识。微信小程序的登录流程远比传统的账号密码登录要复杂。

微信小程序提供了 wx.login(OBJECT) 方法用于用户登录。wx.login 方法的主要目的是拿到用户的 openId 和用户本次登录的 session_key。openId 是用户对于当前小程序的身份标识，类似于我们自己产品里的用户 id 号，只不过在微信里有自己的用户账户体系，你可以使用这个 openId 作为用户的身份标识。当然，也可以建立一套自己的用户标识，不过当你需要调用微信开放接口（比如支付、发送模板消息）时，还是必须知道用户的 openId。session_key 是本次用户登录的会话密钥，通常用来对用户的通信数据进行加解密。

到目前为止，如果对于 openId 和 session_key 的概念还很模糊，不知道这两者的用处，没有关系，在后面的小节中我们将陆续讲解和使用这两个参数。在本小节中，首先要在开发者服务器拿到 openId 和 session_key。微信开放 API 中有很多概念不是那么好理解，必须用实例代码进行演示讲解。图 12-1 所示为获取 openId 和 session_key 的流程图。这张图非常重要，可能你现在还看不明白在阅读本小节后面的内容时可时时回顾一下。

要获取 session_key 和 openId，首先需要在小程序中调用 wx.login，并获取 code；随后将 code 发送到开发者服务器，并同 appid 和 appsecret 一起发送到微信服务器，微信服务器会返回我们需要的 session_key 和 openId。

下面编写具体的代码，实现上述流程并最终拿到 session_key 和 openid。首先，在 /pages/setting/open-api 下新建 login 目录及 login 页面的 4 个文件用来演示用户登录的代码和效果。在 app.jon 文件的 pages 数组下新增 login 页面。接着，在 login.wxml 中增加一个 button 按钮。

```
<!--pages/setting/open-api/login/login.wxml-->
<button class="btn" type="primary" loading="{{loading}}" disabled="{{disabled}}" bindtap="onTap">
  用户登录
</button>
```

1『上面是微信自动生成的按钮代码。』

在 button 按钮上注册了ー个事件 onTap，后面将在 onTap 函数中调用 wx.login(OBJECT) 方法。在 setting.js 文件中添加 login 事件响应函数，点击 setting 页面的「用户登录」选项后，将跳转到 login 页面。

```
  login: function () {
    wx.navigateTo({
      url: '/pages/setting/open-api/login/login'
    });
  },
```

做完以上准备工作后，点击 setting 页面的「用户登录」子项，将跳转到如图 12-2 所示的页面。下面编写 login 页面的按钮响应时间 onTap。在 login.js 中添加 onTap 事件响应函数。

1『

书里的代码，控制台显示返回信息：code:001Yx0ra27sjFJ0u9hpa2I30ra2Yx0rC

然后找了下官方文档：[wx.login(Object object) | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html)，根据文档改进的代码如下。经验证也能返回 code。

』

用户在 login 页面点击「用户登录」后，将执行 onTap 函数。我们在 onTap 函数中调用了 wx.login 方法，这个方法没有参数，只有回调函数。success 回调函数是当微信服务器成功返回结果时调用的函数。

先来看 success 回调函数返回参数的参数说明：1）errMsg，错误消息。2）code，开发者需要将 code，发送到开发者服务器后台，使用 code 换取 session_key。3）api，将 code 换成 openId 和 session_key。重点是返回值 code。code 是一把钥匙，是得到 openId 和 session_key 的关键。code 有效期只有 5 分钟，如果在 5 分钟之内还没有用 code 换取 openId 和 session-key，那么就不能再使用了。

可不可以直接在小程序内部用 code 去微信服务器换取 openId 和 session_key 呢？理论上是可以的，但这完全没有意义。无论出于安全性还是实用性，都应该将 code 发送到开发者服务器由开发者服务器获取 openId 和 Session_key。

所以，我们在 wx.login 的 success 回调函数中再次发起了一个 wx.request 请求，将 code 发送到了本地服务器中。在编写服务器 PHP 代码前，首先来学习如何使用 code 调用微信服务器获取 openId 和 session_key。微信提供了一个 https 接口用于 code 换取 openId 以及 Session_key。接口地址如下：[auth.code2Session | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html)。

需要以下 4 个参数才能正确调用该接口：1）appid，小程序唯一标识。2）secret，小程序的 app secret。3）js_code，登录时获取的 code。4）grant_type 填写为 authorization_code。

appid 和 secret 均来自于微信小程序账号，是 2 个固定的字符串；js_code 是我们在小程序客户端调用 wx.login 时返回的 code；grant_typel 固定为 authorization_code 即可。下面编写服务端代码。先给出服务器 PHP 代码的目录示意图，如图 12-3 所示。

首先，编写一个 PHP 的类 WXLogin，位于 wxLoginClass.php 中，wxLoginClass.php 文件位于根目录的 class 目录下。WXLogin 主要负责用 code 换取 openId 和 session-key。

以上代码需要 PHP 开启 curl 支持。在代码中，我们 include 了一个 config.php 的配置文件，config.php 文件位于根目录下，该配置文件主要用于存放小程序的 appid 以及 appsecret。

请开发者自行将 appiah 和 appsecret 替换为自己的 appid 和 secret。看到 config.php 中的代码后，开发者可能就会明白为什么不能在小程序客户端中换取 openId 和 session_key。因为调用换取接口需要敏感数据 appid 和 appsecret，特别是 secret，一定不可以放在客户端中。

有了 config.php 和 wxLoginClass.php，就可以编写 wxlogin.php 接口文件了，该文件位于根目录下；接口代码很简单，接收小程序客户端传来的 code 值，并通过 WXLogin 类调用微信服务器，最终拿到 openId 和 session_key。

要特别注意，以上代码为了演示效果，所以将拿到的 openId 以及 session_key 返回到了客户端。但在真实的项目中，将 session_key 和 openId 返回客户端是极其危险的，也完全没有必要。因为需要使用 session_key 和 openld 的场景都会被放置在服务器进行，所以将这两个参数返回小程序中没有任何意义，反而会增加数据泄露的风险。

以上完成了用户登录的全部服务器端代码。运行客户端小程序，点击 login 页面的「用户登录」按钮后，console 的显示结果如图 12-4 所示结果。

1『

发现无法获取 openId 和 session_key。可能是 PHP 没开启 curl 支持，查找了方法：[PHP 开启 cURL 功能 - CSDN博客](https://blog.csdn.net/u010596115/article/details/53173427)。在 XAMPP 里，/Users/Daglas/.bitnami/stackman/machines/xampp/volumes/root/etc/php.ini，即挂起的 lampp 盘的根目录下的 etc 文件夹里，搜 php_curl.dll 把其前面的分号 ; 去掉，然后重启服务器 Apache。验证是够开始后直接写一个 php 文件，打印语句「phpinfo();」看看结果即可。

发现还是解决不了问题，然后尝试用作者书里的 wx.login() 代码，运行成功，说明自己参看官方文档修改的代码有问题，具体什么问题待确认。

』

注意，除了 openId 和 session_key，服务器还返回了ー个 expires_in 参数。这个参数的数值官方并没有在文档中提到，笔者猜测这个数值是 session_key 的失效时间戳，单位推测为秒，换算为天是 30 天。由于失效期太长，目前没有验证过，所以以上结论仅是推测（在开发工具目前的最新版本中，这个过期时间已被更改为 7200，单位未知，推测单位是秒，也就是 2 小时）。

session_key 肯定是有失效期的。要注意的是，在 session_key 的有效期内，开发者最好不要重复调用 wx.login 接口、不断用 code 换取 session_key，而应该将 session_key 保存在服务器中。等到 session_key 失效后，再重新获取新的 session_key。

那么如何知道 session_key 是否已经过期呢？小程序提供了ー个 wx.checkSession(OBJECT) 用来校验 session_key 是否过期。只有在 session_key 确实过期后，才会再次调用 wx.login。当然，Orange Can 是一个示例项目，并不会在服务器记录 session_key，所以每次操作都会重新调用 wx.login 接口换取新的 session_key。wx.checkSession 的使用非常简单，下面直接给出示例代码。

这里还要注意，wx.login 得到的 code 只能使用一次，一旦你使用 code 换取了 openid 和 session_key，这个 code 就会马上失效，不能再次使用。当然，如果 5 分钟内这个 code 还没有被使用，那么也会失效。虽然我们拿到了 openId 和 session_key，但并没有使用。拿到 openId 和 session_key 是用户登录要做的事情，其作用会在后续章节中逐步介绍。












