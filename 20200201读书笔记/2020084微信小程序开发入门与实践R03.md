# 2020084微信小程序开发入门与实践R03.md

## 记忆时间


## 模板

### 1. 逻辑脉络

用自己的话总结主题，梳理逻辑脉络，也就是这本书整个地图里这一章所在的节点。

### 2. 摘录及评论

## 10. 电影

### 1. 逻辑脉络

利用 wx.request 和后端服务交互。使用 wx.request 获取真实的网络数据，并将这些数据「填充」到小程序中；tabBar 控件和嵌套模版的使用。tabBar 在 app.json 里设置，跳转到带 tabBar 的页面，需要用 wx.switchTab 方法。

### 2. 摘录及评论

本章我们编写了一个类似「豆瓣影评」的小功能，所有数据来自于豆瓣开放的 API。通过编写这部分的功能，我们将学习如何使用 wx.request 获取真实的网络数据，并将这些数据「填充」到小程序中。此外，本章中最重要的内容是多层嵌套模板的使用技巧，多层嵌套模板的优势将在本章中得到体现。此外本章还指出了很多小程序的「坑」，希望可以帮助开发者节约宝贵的时间。

电影部分同文章部分属于同一级别，我们在本章的开始部分使用小程序提供的 tab 选项卡来实现电影模块和文章模块的切换。需要注意的是，我们不需要自己编写代码实现 tab 选项卡。小程序提供了现成的 tab 选项卡，我们只需要在 app.json 中配置一些参数即可实现 tab 选项卡的效果。

tab 选项卡的配置是通过 app.jon 文件中的 tabBar 选顼来实现的。在配置 tab 选项卡之前，我们新建一个页面 movie 页面（位于 pages/movie 目录下）。或者直接在 app.json 的 pages 选项下新增 ρages/move/move 并保存，这将直接在 pages/move 目录下新建 movie 页面的 4 个页面文件。接着配置文章和电影页面的 tab 选项卡，代码如下：

黑色加粗部分是新增的代码。tabbar 配置项有以下几个属性：1）color 未选中时的 tab 选项卡文字颜色。2）selectedColor 选中时 tab 选项卡文字颜色。3）backgroundColor，tab 选项卡背景颜色。4）borderstyle，tab 选项卡上边框的颜色，注意它只支持 black 和 white 两个取值，默认是 black。5）list，tab 选项卡列表，是一个数组，接受一组 object 对象，我们在后面会具体给出每个对象的属性。6）position 可选值有 bottom 和 top，默认为 bottom，指定选顼卡位于底部还是顶部。

1『小程序里的对象，对应于 python 里的字典。』

再来具体看看 list 这个数组。list 数组的每一项都是一个 object 对象，每个 object 对象代表一个 tab 选项，最少必须有两个 tab 选项，而最多只能有 5 个 tab 选项。tab 选项卡出现的顺序由数组中 object 的顺序来决定。object 对象包含以下几个属性：1）pagePath，每个 tab 选项的页面路径。注意，用于 pagepath 的路径必须预先已在 app.json 的 pages 中定义。2）text，tab 选项卡上出现的文字。3）iconPath，tab 选项卡上的图片路径，图片大小限制为最大 40KB，建议尺寸为 81x81px。4）selectedlconPath，选中是的图片路径，图片大小限制为最大 40kb，建议尺寸为 81x81 px。

这里要特别注意，对于 pagePath、iconPath 和 selectedlconPath 这几个路径，一定不要以「/」开头。即使它们看起来是绝对路径也不要在路径前面加「/」 。在 pagePath 前面加「/」将导致错误。如果在 iconPath 前加「/」 ，虽然在模拟器中不会出现问题，但将项目在真机上预览时（在开发工具的「项目」里点击「预览」时）开发工具将报如图 10-2 所示的错误。

此时，我们保存并运行代码，会发现页面停留在 welcome 页面，点击「开启小程序之旅」，页面没有反应。如果在 welcome.js 的 navigateTo 中设置了 fail 函数，点击「开启小程序之旅」就将进入 navigateTo 的 fail 函数中。

为什么会出现这样的情况？我们在 4.112 小节中介绍 redirecTo 和 navigateTo 时，提到过这两个方法只能用于不帯 tab 选顼卡的页面。此时要跳转的 post 页面已经被设置成了带选项卡的页面，所以无论使用 redirecTo 还是 navigateTo 都不能成功跳转，必须使用 4.11.2 小节中我们提到的另外一个导航方法 wx.switchTab 方法，才能成功跳转到帯有 tab 选项卡的页面。修改 welcome.js 页面的 onTapJump 方法。

以上代码仅仅是将原先所调用的 wx.NavigateTo 修改成了 wx.switchTab。保存并运行代码，此时再次点击 welcome 页面的「开启小程序之旅」，可以成功打开 post 页面。此时的 post 页面底部出现了ー个 tab 选项卡，如图 10-3 所示。

可以通过点击「文字」和「光影」进行文章和电影页面的切换。需要特别注意的是，wx.redirecTo 和 wx.navigateTo 无法跳转到带有 tab 选项卡的页面；同理，使用 wx.switchTab 也无法跳转到不带 tab 选项卡的页面。它们各司其职，不能滥用。开发者还可以尝试ー下 tab 选项卡在页面上部的布局，将 app.json 中 tabBar 配置下的 position 由 「bottom」修改为「top」，tab 选项卡将出现在页面的上部，如图 10-4 所示。可以看到在上部的 tab 选项卡是不包含 tab 图标的，即使你设置了 tab 的图标也不会出现。

### 10.2 电影页面介绍

电影模块部分总共有以下几个展示模块：1）电影首页展示正在热映、即将上映和豆瓣 top250 三种类型的电影。2）每种电影只展示最前面 3 部。3）每种电影有一个「更多」按钮，点击将打开一个新页面，展示该类型下所有的电影。4）支持电影搜索功能。5）点击任意一部电影都将打开电影详情页面。

开发者可以参考本书彩页中的设计图，直观且详细地了解各个功能模块。所有电影数据均来自于豆瓣电影开放 API，以下是豆瓣电影 API 文档的地址：[豆瓣 Api V2（测试版） | douban-api-docs](https://douban-api-docs.zce.me/)

1『原书的链接失效了，上面的是搜索到的有关豆瓣 API 的信息，API 是数据挖掘里一个重要的数据源。具体技术还要去深入了解。发现豆瓣官方 API 已经关闭了。[zce/douban-api-proxy: 一个豆瓣 API 的反向代理，旨在解决豆瓣屏蔽小程序请求问题（豆瓣接口 403 问题）](https://github.com/zce/douban-api-proxy)』

对于电影页面的编写，我们将大量使用 template 模板，甚至是使用多层次嵌套模板。图 10-5 解释了电影模块中所有页面及模板的结构关系。开发者不需要现在马上看明白上面的结构关系图，只需要在后续章节中时时回顾一下此图即可。箭头中没有标注包含数量的表示只包含个模板。

我们大概解释一下以上关系调用图：电影功能部分总共有 3 个页面，分别是电影首页、更多电影和电影详情页面以及 1 个电影搜索模块（电影搜索不是单独的一个页面，位于电影首页）。以电影首页为例：电影首页由 3 个 movie-list-tpl 模板构成，每个 movie-list-tpl 模板由 n 个 movie-tpl 模板构成，而每个 movie-tpl 模板又包含 1 个 stars-tpl 模板。我们基本可以人以上 3 个示意图中完全解析出模板的嵌套关系：电影首页由 3 个 movie-list-tpl 模板构成，每个 movie-list-tpl 模板又由 3 个 movie-tpl 模板构成，而每个 movie-tpl 模板又包含了 1 个 stars-tρl 模板。从图 10-5 中我们可以看到，嵌套模板的使用可以避免编写重复代码，大量的 wxml 代码将被复用。如果你已经忘记了 template 模板的使用，请回顾一下本书第 5 章的内容。

### 10.3 编写豆瓣星星评分组件：stars-tpl 模板

当点击 tab 选项卡的「光影」选项时将跳转到电影首页。在 10.3-10.5 这 3 节中，我们将连续编写 3 个模板。对于这些模板，我们只需要大概浏览一下它们的骨架结构，对于 {{}} 中所绑定的数据，无须太过关心。当这 3 个模板被编写完成并在电影首页中传入数据调用时自然会明白每个份所绑定的数据意义。

在 10.2 节中，我们分析了电影首页的模板构成。下面我们首先编写电影首页所需要的几个模板，这里从最小的模板（stars-tpl 模板）开始编写。在 movie 目录下新建一个 stars 文件夹，并在该文件夹下新建两个文件：stars-tpl.wxml 和 stars-tpl.wxss。随后在 stars-tpl.wxml 中新增以下代码：

```
<template name="starsTpl">
  <view class="stars-container">
    <view class="stars">
      <block wx:for="{{stars}}" wx:for-item="i">
        <image wx:if="{{i===1}}" src="/images/icon/wx_app_star.png"></image>
        <image wx:elif="{{i===0.5}}" src="/images/icon/wx_app_star@half.png"></image>
        <image wx:else="{{i===0}}" src="/images/icon/wx_app_star@none.png"></image>
      </block>
    </view>
    <text class="star-score">{{score}}</text>
  </view>
</template>
```

stars 模板是需要从外部传入一些数据才可以正常使用的，所以我们现在无法直接预览 stars 模板的效果。stars 模板接收一个数组作为参数，这里先给出接收数组的形式：[1,1,1,0,0] 表示 3 星评价，[1,1,1,1,1] 表示 5 星评价，[1,1,1,0.5,0] 表示 3 星半。注意，模板中 3 个 image 组件的使用技巧在前面的已提过，条件渲染不仅仅可以使用 wx:if 和 wx:else，还可以多层次地使用 if else if else......3 个 image 组件中的 if else 展示了这种多层次条件的用法。

block 标签将循环评分数组，循环一定会执行 5 次，出现 5 颗星星，但会根据数据组中当前位的取值是 1、0.5 还是 0 来决定当前的星星图片是满星、半星还是空星。这样评分组件的星级就实现。同时 {{star}} 还需要绑定一个评分的分数，这个分数也需要由外部传入。接着，我们在 stars-tpl.wxss 中编写 stars 模板的样式。

以上就是 stars-tpl 模板的全部代码，我们暂且放下，接着编写其他模板的代码，最后再将这些模板组装起来。

### 10.4 编写 movie-tpl 模板

接着我们编写电影首页中需要用到的另外一个模板：movie-tpl。模板的示意图请参考图 10-7。在 pages 的 movie 目录下新建一个 single-movie 目录，用来存放 movie-tpl 模板。在 /pages/movie/single-movie 目录下新建两个文件：movie-tpl.wxml 和 movie-tpl.wxss 文件。首先在 movie-tpl.wxml 中编写 movie-tpl 模板的骨架代码：

```
<import src="../stars/stars-tpl.wxml"></import>
<template name="movieTpl">
  <view class="movie-container" catchtap="onMovieTap" data-movie-id="{{movieId}}">
    <image class="movie-img" src="{{coverageUrl}}"></image>
    <text class="movie-title">{{title}}</text>
    <template is="starsTpl" data="{{stars:stars,score:average}}"></template>
  </view>
</template>
```

在以上代码的顶部我们使用 import 引入了在 10.3 节中定义 stars-tpl 模板。Moive-tpl 模板由一张电影海报、电影标题以及 stars-tpl 模板构成。对于整个 movie-tpl 模板，我们在其容器上注册了一个事件 onMovieTap，并绑定了当前电影的 id 号 —— movield。

需要注意的是，stars-Tpl 模板的 data 属性，该属性将 stars 数组和 score 评分传入 stars-Tpl 中（请开发者回顾一下 10.3 节中的 tars-Tpl 定义），那么 movie-tpl 模板中的 stars 数组和 score 评分又是从哪里来的呢？答案依然是从外部传入的。在 10.5 节中编写 movie-list-tpl 时将看到如何传入这两个参数。接着编写 move-tpl 模板的样式。注意，在样式的顶部我们依然需要引入 stars-tpl 模板所使用的样式。

### 10.5 编写 movie-list-tpl 模板

直接被电影首页调用的模板是 movie-list-tpl 模板，movie-list-tpl 模板中引用了 movie-tpl 模板，而 movie-tpl 模板中又引用了 stars-tpl 模板。这就是我们所说的 3 层模板嵌套关系。首先在 pages/movie 目录下新建 movie-list 目录，接着在 movie-list 目录下新建两个文件：movie-list-tpl.wxml 和 movie-list-tpl.wxss 文件。下面编写 movie-list-tpl 模板的骨架。在 movie-list-tpl.wxml 中添加以下代码：

```
<import src="../single-movie/movie-tpl.wxml"></import>
<template name="movieListTpl">
  <view class="movie-list-container">
    <view class="inner-container">
      <view class="movie-head">
        <text class="slogan">{{categoryTitle}}</text>
        <view class="more" catchtap="onMoreTap" data-category="{{categoryTitle}}">
          <text class="more-text">更多</text>
          <image class="more-img" src="/images/icon/wx_app_arrow_right.png"></image>
        </view>
      </view>
      <view class="movies-container">
        <block wx:for="{{movies}}" wx:for-item="movie">
          <template is="movieTpl" data="{{...movie}}"></template>
        </block>
      </view>
    </view>
  </view>
</template>
```

1『上面引入的文件错了，应该是：\<import src="../single-movie/single-movie.wxml">\</import>』

同样，我们在代码的开头部分使用 import 引入 movie-tpl 模板，并在 block 标签中使用 move-tpl 这个模板。注意 template 标签中的 data 属性，我们在这里将 movie-tpl 模板所需要的数据传进去。接着编写 movie-list-tpl 模板的样式。在 movie-list-tpl.wxss 文件中编写以下代码：

注意在代码的开头部分使用 import 引入 movie-tpl 模板所使用的 movie-tpl 模板的样式文件 movie-tpl.wxss。

### 10.6 电影首页的骨架与样式

在我们编写好 3 个 template 组件后，电影首页的骨架编写将变得非常简单，只需要在电影首页中引用 movie-list-tpl 模板即可。

在 movie.wxml 页面中添加以下代码：

```
<import src="movie-list/movie-list-tpl.wxml" />

<view class="container" wx:if="{{containerShow}}">
  <view class="movies-template">
    <template is="movieListTpl" data="{{...inTheaters}}" />
  </view>
  <view class="movies-template">
    <template is="movieListTpl" data="{{...comingSoon}}" />
  </view>
  <view class="movies-template">
    <template is="movieListTpl" data="{{...top250}}"/>
  </view>
</view>
```

注意，在代码开头部分使用 import 引入了 movie-list-tpl 模板。同时在本段代码中使用了 3 次 movie-list-tp 模板，分别代表 inTheaters正在热映、comingSoon 即将上映和 top250 经典电影 3 种类型的电影。接着编写电影首页的样式。在 move.wxss 文件中添加以下代码：

### 10.7 豆瓣电影 API 分析

在编写电影首页的 js 调用豆瓣 API 之前，我们首先应当对豆瓣电影 API 有一个直观的认识和了解。所谓开放 APl，是指某些公司、企业将自己公司所持有的数据、用户数据选择性地开放给开发者调用，让开发者可以使用数据并围绕这些数据构建自己的应用，从而帮助公司、企业完善其平台和生态。

目前，绝大多数的开放 API 都属于 RESTFUl 风格的 APl，比如豆瓣 API、github 开发者 API 等。豆瓣 API（V2 版）就属于这类 API，其 API 权限有 3 种：公开、高级和商务。所有开发者无须申请即可调用公开权限的 APl，但只有部分 API 是公开权限的，一些高级接口无法调用，且公开 API 具有 40 次 / 分钟的访问限制。如果开发者在调试代码时遇到豆瓣返回错误信息，就有可能是因为已经超过允许访问的次数。这个时候唯一的办法就是稍等片刻。高级权限和商务权限需要开发者向豆瓣发邮件申请。

本书中所调用的豆瓣 API 均为公开 API，所以要注意访问频率限制的问题。在 Orange Can 项目中总共使用了以下几个豆瓣电影 API：1）获取正在热映的电影。2）获取即将上映的电影。3）获取豆瓣 top250 电影。4）电影搜索。5）获取电影条目信息（电影详情数据）。以获取豆翔瓣 top250 的 API 地址为例，一个完整的获取豆瓣 top250 电影的 API 地址为：

1『官方接口已关闭。』

在以上 APl 中，我们向豆瓣请求 top250 电影中的前 15 条电影信息。start=0 和 count=15 是查询参数，可根据需求自行调整，但要注意每次加载最多只能获取 20 条数据，count 超过 20 是没有意义。开发者可直接在浏览器中输入以上 URL 地址，豆瓣将返回我们需要的数据，返回数据的类型是 JSON 类型，如图 10-9 所示。关于其他几个 API 接口的使用方法，我们将放在后续实例编码中讲解。


### 10.8 电影首页的 js 编写

电影首页 js 的编码工作主要做以下 3 件事情：1）调用豆瓣 APl 获取电影数据。2）处理豆瓣电影数据。3）绑定豆瓣电影数据。

首先在 app.js 中的 globalData 中加入ー个全局变量 doubanBase，用来记录豆瓣 APl 的基地址。因为所有豆瓣的 API 访问都需要这个基地址，所以我们将它单独放在全局变量中，并在其他需要的地方获取这个全局变量。

```
  // 全局变量
  globalData: {
    userInfo: null,
    doubanBase: "https://api.douban.com",
  }
```

接着编写 move.js 中的代码。首先在 movie.js 中新增 Page 方法，并在 Page 方法的参数中定义 data 初始化数据及页面 onLoad 函数。

1『怪不得不加 page 方法前，进入电影页面显示不出来，console 里显示「onhide: 页面被隐藏」。』

1『上面的 api 替换成 GitHub 的，「https://api.github.com/search/repositories?q=language:python&sort=stars」。』

在 onLoad 函数中，主要拼接了 3 个不同的豆瓣 API，分别用来获取正在热映、即将上映和豆瓣 top250 电影的数据。这 3 个 API 唯一的区别在于 URL 路径中的一小段路径 /v2/movie/key 中的 key 不同:「正在热映」的 key 是 in_theaters，「即将上映」的 key 是 coming_soon，「top250」的 key 是 top250。注意，我们使用 "?start=0&count=3" 指定仅获取每种类型电影的前 3 条数据，因为在我们的业务需求中只需要每种类型的前 3 条数据。

在 data 属性中，预先定义了 3 个对象：inTheaters、comingSoon 和 top250。这 3 个对象将用于数据绑定，开发者可回顾一下代码清单 10-9。在代码清单 10-9 中，分别将这 3 个对象绑定到了 template 模板上。在代码清单 10-12 的末尾部分，调用了 3 次 this.getMovieListData 方法。这个方法的作用就是根据传入的 urI 获取和处理数据。在 10.9 节中，我们将编写这个方法。

### 10.9 wx.request 发送 http/https 请求

目前我们还没有编写 getMovieListData 方法，现在在 movie.js 的页面中添加这个方法。getMovieListData 接受 3 个参数：url、settedKey 和 categoryTitle。url 被用来访问并获取豆瓣电影数据，settedKey 被用来作为不同类型电影数据绑定的 key，categoryTitle 被用来作为电影的分类标题，最终将被显示在 move-list-tpl 的标题上（参考代码清单 10-7）。

getMovieListData 的核心代码是 wx.request 方法的使用，是小程序提供的发送 http 和 https 请求的方法，类似于传统 Javascript 编程中所使用的 ajax 方法。

wx.request(object) 方法用于发送 http / https 请求，并接受服务器返回的请求结果。Object 参数包含以下几个属性用于配置请求参数：1）url，String 类型，开发者服务器接口地址。2）data，Object 或者 String 类型，请求的参数。3）header，Object 类型，设置请求的 header。注意，在 header 中不能设置 referer，因为在小程序中 referer 是一个固定格式的值，格式固定为 https://servicewechat.com/{appid}/{version}/page-frame.html，其中 {appid）为小程序的 appid、{version} 为小程序的版本号，版本号为 0 表示开发版。4）method，String 类型，默认为 GET，有效值为 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT。注意，method 的取值必须大写。

请求参数：5）dataType，String 类型，默认为 json。如果设置了 dataType 为 json，就会尝试对响应的数据做一次 JSON.parse。6）success，Function 类型，收到开发者服务成功返回的回调函数。函数会被传入一个 res 参数开发者可通过 res.data 来获取服务器返回的内容。7）fail，Function 类型，接口调用失败的回调函数。8）Complete，Function 类型，接口调用结束的回调函数（调用成功、失败都会执行）。

开发者可能注意到，在代码清单 10-13 中，我们在设置 header 的 content-type 时给出了一个奇怪的参数值：json。既没有给出常见的 application/json, 也没有直接省略掉 content-type 这个选项（官方文档中明确指出 content-type 的默认值是 "application/json")。原因是以下几个选项都无法正确调用豆瓣 API：1）不设置 content-type；2）content-type: 'application/json'；3）content-type:''。

在目前的 13040 版本中，如果将 content-type 设置为以上几个取值，那么豆瓣 API 将返回如图 10-10 所示的错误信息。经过反复调试发现，content-type 可以被指定为任意不为空的字符串：1）content-type:'json'；2）content-type:'xxxxxx'；3）content-type:'appli'。只要 content-type 不为空或者是 application/json, 就可以正确调用豆辦 API 并获取到豆瓣的返回数据。为了让 content-type 看起来合理一些，在 Orange Can 项目中ー律使用 content-type:json 的形式作为 content-type 的取值。

对于 wx.request，还有以下几个注意事项：1）url 中不能有端口。2）wx.requeste 的默认超时时间和最大超时时间都是 60s。3）wx.request 的最大并发数是 5。

3『

[RequestTask | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html)

```
wx.request({
  url: 'test.php', //仅为示例，并非真实的接口地址
  data: {
    x: '',
    y: ''
  },
  header: {
    'content-type': 'application/json' // 默认值
  },
  success (res) {
    console.log(res.data)
  }
})
```

』


1『

一些公开 api：[public-apis/public-apis: A collective list of free APIs for use in software and web development.](https://github.com/public-apis/public-apis)

https://autocomplete.clearbit.com/v1/companies/suggest?query=segment

https://api.github.com/search/repositories?q=language:python&sort=stars

报错：https://api.github.com 不在以下 request 合法域名列表中。

需要进小程序账号里，在开发者设置里，服务器域名里添加 request 合法域名。但添加的域名一定要是备案过的，否则不行。

』

### 10.10 设置 wx.request 的超时时间

很多开发者可能想知道如何在小程序中设置超时时间，答案是在 app.json 文件中配置这个超时时间。在 app.json 中除了我们之前讲到的 pages、window、tabBar 等常用的配置项外，还有一个 networkTimeout 配置项。networkTimeout 配置项用来配置各类网络请求的超时时间：1）request，wx.request 的超时时间，单位为毫秒，默认值为 60000。2）connectSocket，wx.connectSocket 的超时时间，单位为毫秒，默认值为 60000。3）uploadFile，wx.uploadFile 的超时时间，单位为毫秒，默认值为 60000。4）downloadFile，wx.downloadFile 的超时时间，单位为毫秒，默认值为 60000。

我们可以在 app.json 中添加以下代码来设置各类请求的超时时间；当然，如果目前位置只使用 wx.request 请求，只设置 request 这个配置项也是可以的。如果服务器在 20 秒内没有响应，那么 wx.request，将进入 fali 函数。

### 10.11 处理返回的电影数据

在代码清单 10-13 中，我们使用 wx.request 来获取豆瓣 APl 所提供的电影数据。需要注意的是，wx.request 是一个异步方法，且小程序只提供了异步发送 http / https 请求的方法，没有同步版本。所以，不要尝试使用以下方法来获取 wx.request 的返回值：

    var result=wx.request(object)

对于同步的方法，可以使用以上方式来获取返回结果；但对于异步方法，只能在异步方法所提供的回调函数中进行返回结果的处理。比如在 wx.request 中，就只能在 wx.request 所提供的 success 回调函数中处理豆瓣的返回结果。回顾一下代码清单 10-13，在 success 回调函数中，我们使用 res.data 来获取豆瓣 API 的返回结果，接着调用了一个 processDoubanData 方法来处理豆瓣 API 的返回数据，从豆瓣加载回来的数据格式如图 10-11 所示。开发者可自行使用 Postman 或者 Fiddler 来调用豆瓣 API 查看返回的数据格式。目前，我们还没有实现 processDoubanData，下面来编写这个函数。

这个函数接收 3 个参数，第一个参数 moviesDouban，就是我们从豆瓣获取来的电影数据，processDoubanData 的主要功能就是处理 moviesDouban；第二个、第三个参数在之前已经解释过，这里只是简单地传入到 processDoubanData 中，在最后才绑定到 setData 方法中。

for 循环将遍历所有豆瓣电影的数据，并将豆瓣的数据格式转化成我们需要的命名格式，temp 就是一个临时保存转化后电影数据的变量。最后将所有豆瓣电影数据处理完后调用 js 的 Aray.push 方法将 temp 加入 movies 数组中，最终形成我们需要的电影数据数组。

在 for 循环中处理豆瓣电影数据时，调用了一个 util.convertToStarsArray 方法将豆瓣的评分格式转化成我们需要的数组格式一一形如 [1,1,0,0,0] 的形式（开发者可回顾一下 10.3 节）。豆瓣 API 返回的关于评分的数据格式为 50（表示 5 星）、35（表示 3 星半）、00 (0 星或者还没有星级），util.convertToStarsArray 的任务就是将这些 50、35、00 等星级的简写形式转化成 [1,1,1,1,1]、[1,1,1,0.5,0] 和 [0,0,0,0,0] 等需要的数组形式，以方便 stars-tpl 模板使用。

在 util.js 中加入一个 util.convertToStarsArray 函数。记住，util 是一个模块，添加完方法后需要使用 module.exports 输出。随后，要想在 movie.js 中引用 util，还需要在 move.js 顶部引用 util 模块。完成以上代码的补充后，我们才能够在 movie.js 中调用 util.convertToStarsArray(subject.rating.stars) 方法。

### 10.12 绑定处理后的电影数据

在代码清单 10-15 的最后我们使用了以下代码进行数据绑定：

```
    var readyData = {};
    readyData[settedKey] = {
      categoryTitle: categoryTitle,
      movies: movies
    }
    this.setData(readyData);
```

这是一种动态设置数据绑定 key 的方法。由于我们并不知道当前处理的数据是哪一种电影类型（inTheaters、comingSoon、top250），因此将当前所处理的电影数据类型通过 settedKey 一路传递到 processDoubanData 方法中，并通过 readyData[settedKey] 生成一个包含 settedKey 的 Javascript 对象。

假设当前处理的数据是 inTheaters 类型，那么以上代码在最终调用 this.setData(readyData) 时相当于以下形式：

```
this.setData({
    inTheaters:{
        categoryTitle: '正在热映',
        movies: movies
    }
})
```

如果当前处理的数据是 comingSoon 类型，那么以上代码在最终调用 this.setData 时相当于以下形式；这样的写法实际上考验的是开发者对 Javascript 动态属性的理解。此时，保存并运行代码，电影首页显示如图 10-12 所示的样式。如果数据没有正确加载，请参考下节的内容。

### 10.13 http 和 https 在小程序中的使用说明

为了保证数据的安全性，小程序中强制要求使用 https 且所访问的 https 地址必须在小程序的后台账号中被加入到可信域名中。图 10-13 是小程序开发账号的 https 可信域名配置的示意图。该配置项位于小程序账号的「设置」→「开发设置」选项中。理论上，小程序是不允许使用 http 请求来获取数据的，也不允许访问未在可信域名列表中配置的 https 地址。以上限制的前提条件是：在真机上。

如果是在客户端的开发工具中，有以下几种方法可以不需要遵守以上两个规则。

第一种方法。如果在创建小程序项目时选取的是无 appid（必须拥有小程序账号才可以获得），那么开发工具不会限制你访问 https，更不会比对可信域名列表。这种方法的缺点就是：当你偶尔想真机预览下小程序时，还需要重新新建项目并填入 appid。

第二种方法。如果在创建小程序项目时填入了 appid 那么默认情況下小程序将强制你使用 https 且会将你所访问的 https 地址与可信域名列表做比对。如果你试图在一个配置了 appid 的小程序项目客户端开发工具中访问 http 地址，那么开发工具会报错，如图 10-14 所示。无论你使用 http 或者使用不在可信域名列表里的 https 地址都将提示图 10-14 所示的错误（可信域名列表不能够设置 http，所以试图访问 http 地址一样会提示不在可信域名列表中）。解决的办法是，在可信域名列表中配置你要访问的 https 域名。

第三种方法。小程序在开发工具侧边栏的「项目」选项卡中提供了「开发环境不校验请求域名以及 TLS 版本」的选项，勾选这个选项你可以随意在开发工具中使用 http 或者未加入 https 可信列表的 https 地址。

1『解决之前「域名不合法」的问题。获取了 github 接口里的信息。』

以下是一些建议：1）如果你没有 appid，那么只能选择无 appid。2）如果你有 appid，那么建议在新建项目时填写这个 appid，并在开发期间勾选「开发环境不校验请求域名以及 TLS 版本」，待正式发布或者需要真机预览时再去小程序账号中配置你所使用的 https 地址。如果项目中没有使用网络请求，那么真机预览时也不需要配置 https 的可信域名列表。3）如果你在 Orange Can 项目中遇到无法访问的问题，可以参考上面所描述的内容。

### 10.14 跳转到更多电影页面

之前，我们完成了电影首页的编写。电影首页总共展现了 3 种类型的电影，共 9 部。如果我们需要査看每种类型的全部电影，就需要编写「更多电影」这个页面。「更多电影」是通过点击电影首页的「更多」按钮来打开新页面的，如图 10-15 所示。首先新建 more-movie 页面。在 app.jon 文件的 pages 数组下新增 more-movie 页面的路径，如下代码所示：

添加以上代码后保存项目，将自动生成 more-movie 页面的 4 个页面文件。我们首先实现跳转到 more-movie 页面的代码。通过图 10-15 可以看到，「更多」按钮是位于 movie-list-tpl 模板中的。我们回顾一下 movie-list-tpl.wxml 中的代码。

在 movie-list-tpl.wxml 中的 \<view class="more"> 标签上，我们已经注册了ー个 onMoreTap 事件，且在这个标签上也已经绑定了一个 data 数据：data-category="{{categoryTitle}}"。实现跳转到 more-movie 页面的关键就在于实现这个 onMoreTap 函数，并在 onMoreTap 函数中使用 wx.navigateTo 方法跳转到 more-movie 页面中去。同时，我们还必须将 categoryTitle 这个变量同时传递到 more-movie 页面里去，从而使 more-movie 页面能够准确地加载「更多」的电影数据。

在 movie.js 中新增以下代码，以实现 onMoreTap 方法。开发者可能会觉得奇怪，「更多」按钮是位于 movie-ilst-tpl 模板中的，但应这个按钮的 js 方法却要写在另外一个页面的 js 文件 movie.js 中。这确实是非常奇怪也难以理解的。关于这个问题，我们已经在前面的内容中讲解过：小程序只实现了模板化，而没有实现组件化，模板是不具备运行 Javascript 代码能力的。所以，我们只能将模板的业务逻辑编写在其他页面的 js 文件中，再将处理好的业务数据传递到模板中。

```
  // 跳转到更多页面
  onMoreTap: function (event) {
    var category = event.currentTarget.dataset.category;
    wx.navigateTo({
      url: "more-movie/more-movie?category=" + category
    })
  },
```

### 10.15 编写 movie-grid-tpl 模板

如同我们在实现电影首页页面时所做的，我们首先来编写「更多电影」页面所需要的模板 movie-grid-tpl 模板。图 10-16 展示了 movie-grid-tpl 模板的实际效果图。这个模板将像「九宫格」一样放入很多的电影（真实的数据远不止 9 部电影），以展示更多电影的效果。在 /pages/move 下新建一个 movie-grid 目录，并在目录下新建 movie-grid-tpl.wxml 和 movie-grid-tpl.wxss 文件。我们首先来编写 movie-grid-tpl 模板的骨架。在 movie-grid-tpl.wxml 文件中加入以下代码：

```
<import src="../single-movie/single-movie.wxml" />
<template name="movieGridTpl">
  <view class="grid-container">
    <block wx:for="{{movies}}" wx:for-item="movie" wx:key="movieId">
      <view class="single-view-container">
        <template is="movieTpl" data="{{...movie}}" />
      </view>
    </block>
  </view>
</template>
```

我们可以看到 movie-grid-tpl 的骨架代码非常简单。为什么这么几句代码就可以实现复杂的「九宫格」效果。模板再次发挥了巨大的复用作用。很明显 movie-grid-tpl 仅仅起到的是组织布局的作用，而核心的骨架代码已经被封装在了 movie-tpl 模板中。我们在 movie-grid-tpl 中的 block 标签中循环调用 movie-tpl 模板，以实现显示多部电影的目的。

在之前编写的 movie-list-tpl 里，我们已经使用过了 movie-tpl，这里再次使用 movie-tpl 就体现了模板的优势，它避免了我们重复编写 wxml 代码。笔者认为用好模板将大大简化代码，提高代码的可阋读性与可维护性。接着编写 movie-grid-tpl 模板的样式代码。在 movie-grid-tpl.wxss 文件中加入以下样式代码；同样要注意引入 move-tpl.wxss 文件。

### 10.16 编写「更多电影」页面

在编写完 more-movie 页面所需要的核心 template 模板后，我们来编写 more-move.wxml 文件。令人吃惊的是，你几乎不需要编写任何代码，只需要在 more-movie.wxml 页面中引入 movie-grid-tpl 模板即可。在 more-movie.wxml 页面中加入以下代码：

```
<import src="../movie-grid/movie-grid-tpl.wxml" />
<template is="movieGridTpl" data="{{movies}}" />
```

接着编写 more-movie 页面的样式。在 more-movie.wxss 文件中加入以下代码：

```
@import "../movie-grid/movie-grid-tpl.wxss";
```

几乎不需要编写代码，我们就完成了 more-movie 页面的骨架和样式代码的编写工作。接着我们还需要编写 more-movie 页面的 js 代码。more-movie 页面的 js 代码所需要完成的工作几乎同 move 电影首页的 js 代码相同。依然遵守着获取数据 → 处理数据 → 绑定数据的步骤。实际上，获取数据 → 处理数据 → 绑定数据的流程几乎是小程序 js 文件编写的通用思路与步骤。在 more-movie 页面中添加以下代码：

首先，我们在 data 中设置 movies 绑定变量的初始化值。movies 变量将最终被用作 wxml 的数据绑定变量。接着，在 onLoad 函数中接收由 movie 电影首页传递过来的 category 分类。根据分类的不同拼接不同数据访问 APl 的地址。这里我们没有在 API 的 URL 后面附带 start 和 count 参数，如果不附带这两个参数，那么默认将一次加载 20 条电影数据。

为了避免反复编写 wx.requestl 的复杂结构，我们在 util 模块中编写了ー个 http 方法，作为所有豆辦 API 调用的公共方法，当我们需要访问豆瓣 API 时，不需要重复调用 wx.request 方法，只需要调用这个封装好的 http 方法即可。util.http 方法接收两个参数：第一个参数是需要访问的 API 地址；第二个参数是一个回调函数，用来处理豆瓣 API 的返回结果。

processDoubanData 方法同 move 电影首页中的 processDoubanData 类似，都是用来处理豆瓣的返回数据，并在处理完成后将处理的数据进行绑定。由于在 more-movie 页面中我们已经明确了电影类型，因止此 processDoubanData 的编写简単了很多，只需要明确处理「正在热映」「即将上映」和「top250」3 种类型中的一种即可。下面来看看 utilhttp 方法是如何编写的。在 util.js 文件中加入 http 方法。

1『还是要提醒下，封装完方法后记得在最下面的输出 module 里把该方法输出。』

将所有调用豆瓣 API 的操作封装成一个函数的好处是，一旦调用操作和流程发生变化，只需要修改这个函数即可。比如，header 的 content-type 支持 application/json 取值，无须在多处修改，只需要修改 util.http 方法即可。编写完 http 方法后，记得使用 module.exports 方法将 http 方法暴露出去，以供其他页面 / 模块访问。保存并运行项目，再次点击「更多」按钮，页面将从 movie 电影首页跳转到 more-movie（更多电影）页面，且 more-movie 页面正确地呈现出 20 部电影，如图 10-17 所示。

### 10.17 实现页面下拉刷新的「三部曲」

下拉刷新是 APP 上经典的一个动作。本节我们将学习如何在小程序中实现下拉刷新数据的功能。在小程序中，不需要自己实现下拉刷新代码编写。小程序已经为我们准备好了下拉刷新的相关配置和 API。

实现一个页面的下拉刷新操作需要分为 3 步：1）步骤 01 在页面的 json 文件中配置 enablePulLDownRefresh 选项，打开下拉刷新开关。2）步骤 02 在页面的 js 文件中编写 enablePulLDownRefresh 函数，完成自己的下拉刷新逻辑。3）步骤 03 编写完下拉刷新逻辑代码后，主动调用 wx.stopPulLDownRefresh 函数停止当前页面的下拉刷新。我们首先来完成第一步。在 more-movie.json 文件中加入以下代码：

当在 more-movie.json 中加入以上代码后，more-movie 页面的下拉刷新就开启了。此时下拉 more-movie 页面将出现下拉效果。由于下拉刷新的等待标示默认是白色，因此你无法明显地看到下拉刷新的等待状态标示。我们可以修改等待标示的默认颜色，在 more-movie.json 文件中添加一个配置项。

```
{
  "usingComponents": {},
  "enablePullDownRefresh": true,
  "backgroundTextStyle": "dark"
}
```

这样当再次下拉刷新 more-movie 页面时，我们将看到等待标示，如图 10-18 所示。当然，你也可以在 app.json 的 window 配置项中配置 backgroundTextStyle:"dark" 选项，这将导致所有页面的下拉刷新等待标示都变成 dark。同理，你也可以在 app.json 的 window 配置项中配置 enablePulldownRefresh:true 选项，这将导致所有页面都开启下拉刷新。

接着我们来完成第二步。当页面打开下拉刷新开关后，每当用户下拉页面都将触发执行页面的 enablePulldownRefresh 函数。这就是小程序给我们编写下拉刷新逻辑的函数。在 more-movie.js 文件中编写 enablePulldownRefresh 函数。（备注，参考项目里的源码这段不一样）

```
  onPullDownRefresh: function (event) {
    var refreshUrl = this.data.requestUrl + "?star=0&count=20";
    util.http(refreshUrl, this.processDoubanData);
  },
```

整个函数的代码非常简单，仅仅是再一次访问了豆瓣 API 并重新获取了最新的第 1 到第 20 条数据。注意，在函数中我们获取当前豆瓣 APl 的 URL 地址时使用了 this.data.requestUrl（这个变量是在 onLoad 函数中保存下来的）。所以，我们修改一下 more-movie 页面的 onLoad 函数，在 onLoad 函数中将当前访问的 URL 地址记录一下。

编写完以上代码后，我们可以反复尝试下拉刷新 more-move 页面。当然，从 UI 上是无法直接看到刷新效果的，因为豆瓣的电影数据不可能更新得非常频繁。我们可以尝试打开 Network 面板，观察一下每次下拉刷新后是否有向豆瓣发送请求，如果有请求发向豆瓣，就说明 onPulldownRefresh 函数成功触发了。图 10-19 所示的示意图显示了 3 次下拉刷新 more-movie 页面后 Network 面板的请求发送情况。

最后，我们来完成下拉刷新「三部曲」中的第三步，主动停住页面刷新状态。停住页面刷新状态非常简单，在合适的时机调用 wx.stopPulLDownRefresh 方法即可。

我们需要考虑的是在什么时候调用 wx.stopPulLDownRefresh()。当然应该是在处理完豆瓣返回数据并再次调用 this.setData 重新绑定数据后调用 wx.stopPulLDownRefresh() 函数。在 more-movie.js 页面的 processDoubanData 方法中调用 wx.stopPullDownRefresh() 即可。完成以上代码后，more-move 页面的下拉刷新操作就全部完成了。下拉刷新三部曲是笔者总结的编写下拉刷新功能时的常见思维步骤，以供开发者参考。

1『牢记下拉三部曲。』

### 10.18 在模拟器中可执行下拉刷新但在真机中无法执行下拉刷新的常见错误

在开启下拉刷新开关时，我们需要在页面的 json 文件中设置 enablePullDownRefresh 选项为 true。如果不小心将 enablePullDownRefresh 选项设置成了字符串 "true"，而非 Boolean 类型的 true，就将导致在模拟器中可执行下拉刷新但在真机上（仅测试 iOS 系统）无法执行下拉刷新的现象。虽然官方文档明确地指出 enablePullDownRefresh 配置选顼的值类型是 Boolean，但真机行为同开发工具中行为不一致显然是不能接受的，这将增加测试成本，并有可能引起严重的 bug。


















