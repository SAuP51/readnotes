# 2020153Laravel框架关键技术解析R01

## 记忆时间

## 卡片

### 0101. 主题卡——

这本书的主题核心，就是最大的反常识卡，并且注意时间脉络。

### 0201. 术语卡——

根据反常识，再补充三个证据——就产生三张术语卡。

例子。

### 0202. 术语卡——

### 0203. 术语卡——

### 0301. 人名卡——

根据这些证据和案例，找出源头和提出术语的人是谁——产生一张人名卡，并且分析他为什么牛，有哪些作品，生平经历是什么。

维基百科链接：有的话。

#### 01. 基本信息

用一句话描述你对这个大牛的印象。

#### 02. 贡献及著作

### 0401. 金句卡——

最后根据他写的非常震撼的话语——产生一张金句卡。

### 0501. 行动卡——

行动卡是能够指导自己的行动的卡。

### 0601. 任意卡——

最后还有一张任意卡，记录个人阅读感想。

本书以 Laravel 5.1 版本为基础，从框架技术角度介绍 Laravel 构建的原理，从源代码层次介绍 Laravel 功能的应用。通过本书的学习，读者能够了解 Laravel 框架实现的方方面面，完成基于该框架的定制化应用程序开发。本书第 1 章到第 4 章主要介绍了与 Laravel 框架学习相关的基础部分，读者可以深入了解该框架的设计思想，学习环境搭建，了解 PHP 语法知识和 HTTP 协议；第 5 章到第 14 章分别从某个方面介绍 Laravel 框架是如何构建和使用的，包括程序的生命周期、服务容器和数据库等，同时也将其中的一些构建技术剥离开，使读者可以学习该框架的构建技术和思想，如设计模式的内容；第 15 章是一个简单的实例，将前面的学习内容串联起来并在实践中应用，使读者学会使用该框架定制化地设计应用程序。本书既适合想了解 Laravel 框架构建技术的读者，也适合想深入了解 Laravel 框架的读者。

## 前言

1、Laravel 框架。Laravel 框架是通过 PHP 编程语言编写的，而 PHP 编程语言因为其混乱的设计和不优雅的风格有时被认为设计得很糟糕，但是它也有自身的优势，就是专为 Web 开发而生，简单高效是它的法宝，这里的高效不是指它运行的速度快，而是同样的一个任务用它完成的速度快。有统计表明，同样的任务，用 PHP 开发的时间是用 Java 开发的时间的一半左右，因此也诞生了大量用 PHP 编写的 Web 框架（如 Symfony、CodeIgniter、Yii Framework 等）和内容管理系统（如 drupal、Joomla、WordPress 等），通过这些资源可以更加快速地构建 Web 应用。

前面提到，PHP 编程语言设计得不是很优美，所以很多用 PHP 编写的框架也比较混乱，而 Laravel 框架开发的宗旨就是为 Web 艺术家创造的 PHP 框架，用糟糕的编程语言设计优雅的框架这一点非常难，但是 Laravel 做到了，对于用户的请求，它就像流水线作业一样，通过一道道工序处理用户的请求，然后返回处理的结果。在这个过程中，用户可以很容易地增加、修改、删除其中的工序，实现定制化。能够做到这些，我想主要是因为开发者在设计期间采用了组件化开发、依赖注入、接口编程等技术，组件化开发使得整个框架像搭积木一样构建起来，因此就可以非常容易地添加、删减功能，体现了编程技术中的易复用、可扩展等特性，依赖注入、接口编程使得模块间的耦合非常低，如果想将某个模块替换自己新设计的模块，只需要满足接口规范就不会对其他模块产生影响，这体现了编程技术中的易维护特性。总之，通过学习 Laravel 框架，不仅可以掌握 Web 开发的方方面面，最重要的是能够学到构建一个优秀框架的思想和方法。

2、适合的读者。撰写本书的初衷是我在学习 Laravel 框架的过程中看到中文的资料很少，英文资料大多是如何应用该框架，而这些知识不足以支持你创建一个定制化的应用，于是，我花了大量的时间在阅读该框架的源码上，走过了盲人摸象的过程，最后才看到了 Laravel 框架的真面目，这个过程其实是非常低效的。所以，我希望能写一本这样的书，使得以后学习该框架的人能够少走弯路，节省出更多的时间去做更有意义的事。

本书重点介绍了 Laravel 框架构建的关键技术，即组件化开发和使用的相关设计模式，所以本书适合想了解框架构建技术的读者。同时，本书是从源码层次分析该框架实现的几个方面，通过这些源码读者能了解实现的细节，从而很容易实现对该框架的定制和修改，并非只是简单的应用，通过掌握该框架的几个重要方面，读者能够在整体上把握 Laravel 框架实现的过程，所以本书适合想深入了解 Laravel 框架的读者。但是本书并没有提供太多的应用实例，也没有将 Laravel 框架的所有功能进行全部介绍，所以并不适合想快速学习 Laravel 框架应用的读者。

## 0101. 组件化开发与 composer 使用

在「敏捷开发」、「不要重复发明轮子」等软件开发思想盛行的当今社会，项目开发中以框架为基础进行二次开发已经成为首选的开发方式，而选取框架的优劣不仅决定了开发的速度，更决定了后期扩展的能力。每一种编程语言都有它的适用范围，其中，PHP 编程语言作为针对 Web 开发量身定制的脚本语言被广泛用于服务器端程序开发，因此也产生了许许多多的 PHP 框架，最著名的有 Laravel、Symfony2、CodeIgniter、Yii2 等，而每年一度的 SitePoint 框架人气调查为这些框架的受欢迎程度提供了数据支持，Laravel 框架已经多年以高出一大截的优势排在第一的位置。

Laravel 框架之所以优秀是和它的设计理念分不开的，在 Laravel 官网的首页会看到这样一句介绍的话 —— 为 Web 艺术家创造的 PHP 框架。是的，Laravel 框架的设计理念就是艺术，但设计一个艺术性的框架是离不开那些优秀的设计方法的，这些设计方法虽然算不上创新的方法，但在 Laravel 框架中却得到了恰当的应用，将这些优秀的设计思想和设计方法完美地融合在一起进而产生了 Laravel 的艺术性。如果说哪些设计思想和设计方法是该框架应用比较突出的，笔者觉得至少要包括组件化开发、IoC 容器技术、分布式应用架构设计这三部分内容。对于后两项技术将在后续章节中逐步谈及，本章主要讲解组件化开发思想和 composer 工具的使用。

### 1.1 组件化开发

组件化开发思想其实在面向过程编程中就已经在使用了，特别对于一些大型的项目，如果不使用组件化的开发思想是很难保证快速开发的。后来面向对象编程思想逐渐流行，由于面向对象本身就隐含着组件化的思想，很多软件项目都是以类为单位进行封装的，所以在一段时间内组件化开发的思想被淡化。但随着软件项目的大型化，开源文化的流行，特别是「不要重复发明轮子」等开源思想的影响，组件化开发再次爆发出强大的力量。在开源文化流行之前，大型项目都是以公司这种集中形式开发的，而相应的代码也很少能够被其他人员重复利用，所以组件化开发并不是必需的。但是，开源文化流行之后，直接利用别人的成果快速构建项目成为一种新的开发模式，而组件化开发方法是这种开发模式的基础。目前，大多数语言都支持组件化开发，特别是开源的编程语言在这方面支持更好，如 Ruby、Java、Python 等。

组件化开发的目的就是能够快速使用已有的程序模块构建项目，甚至可以快速更换项目中的相应模块而不需要修改系统中其他部分的代码，这就需要所有的代码按照一定的规范和接口来实现。首先介绍 PHP-FIG（PHP Framework Interop Group，PHP 框架互动群），它的作用就是制定一系列 PHP 开发的规范即 PSR 编码规范标准，程序员在开发 PHP 程序时共同遵守这个标准，依据此标准开发的组件可以很容易地组合到一起，也可以很方便地被别人使用，也就实现了组件化的管理和开发。读者可以在网站 www.php-fig.org 中找到相关介绍。目前 PSR 标准主要包含 PSR-0～PSR-4 文档，其中最主要的是 PSR-0 和 PSR-4，这两个文档主要制定了 Autoloader 标准即代码自动加载标准，后面章节还会详细介绍这部分内容。

在 Laravel 框架中很多组件也不是重新开发的，而是使用已经存在的其他组件或框架的部分，如 Laravel 底层就使用了很多 Symfony 框架中的组件。在使用 Laravel 框架的过程中，如果对一些组件不满意，可以使用其他开源的组件进行替代或修改，而且几乎不用修改框架中的其他部分代码就能保证各模块间协调工作，这就是规范和接口的威力。

### 1.2 composer 使用

上一节介绍了组件化开发的优秀特性，那么如何实现组件化开发呢？这里就需要借助一个工具即组件管理工具。在组件化开发中，组件管理工具是必不可少的，因为全世界有大量的组件，如果没有统一的管理工具，只靠人的经验去查找使用，就无法做到统一的管理和控制。不同编程语言的组件化管理工具是不同的，如 PHP 的组件化管理工具是 composer、Ruby 的组件化管理工具是 gem、Java 的组件化管理工具是 maven、Python 的组件化管理工具是 pip 等。下面介绍如何使用 composer 工具实现组件化开发。

#### 1.2.1 composer 安装

不同的操作系统安装 composer 的方式有些不同，这里主要介绍 Windows 系统和 Linux 系统的 composer 安装，首先介绍 Windows 系统中 composer 的安装。

#### 1.2.2 组件安装

在完成 composer 工具的安装后，就可以通过组件化的方式创建项目了。如果需要在项目中添加一个日志的模块，如何才能获取关于该模块的信息呢？composer 官方网址提供了组件资源库即 packagist，可以通过官网的 packagist 选项直接进入，或者直接通过网址「[Packagist](https://packagist.org/)」进入，在资源库中可以浏览或搜索相关的资源包，如需要一个日志的资源包，可以通过关键字「log」来搜索。假设项目中选择使用一个名为 monolog 的组件来完成日志功能，则需要在项目根目录下创建一个名为「composer.json」的文件，在该文件中记录所需要的组件名及版本，相应的格式如下：

```json
{ "name": "glow/model-test", "require": { "monolog/monolog": "1.0.*" } }
```

这里包含两个标签，其中「name」标签表示本项目的名称，「glow」是公司名，而「model-test」是项目名称。这个标签不是必需的，但是如果想将自己的项目作为一个资源包发布就需要这个名字，使得其他人可以通过该名称下载这个组件。「require」标签表示需要的资源包，其中「monolog/monolog」为资源包的名称，「1.0.\*」为版本号，这里的版本号可以通过几种方式约束，分别是确切版本号（如 1.1.1）、范围版本号（如 >=1.1、<2.3 等）、通配符版本号（如 1.0.*，用于匹配 >=1.0 并且 <1.1 的版本）和赋值运算版本号（如 ～1.0，用于匹配 >=1.0 并且 < 2.0 的版本）。

创建完 composer.json 文件后，通过 cmd 命令窗口进入到项目的根目录，如果在安装 composer 时选择安装了「Shell Menus」选项，则可以在项目的根目录中单击鼠标右键并选择「use composer here」选项，在命令窗口中输入命令「composer install」，接着 composer 会检查 composer.json 文件中的组件名称及版本，将它下载到当前目录的 vendor 文件夹下，如果当前目录下没有 vendor 文件夹，将会自动创建一个。对于上面实例，创建的目录结构为「vendor\monolog\monolog」。

在完成组件下载后，会在当前目录下创建一个名为「composer.lock」的锁文件，该文件将记录当前项目依赖组件的确切版本号，当执行「composer install」命令时会首先查看该文件中的版本，如果存在则下载该文件中指定的版本。这点对于分布式开发非常有用，不同开发人员只需要上传 compsoer.lock 文件到版本库，其他人通过该文件就可以下载相同版本的组件，实现程序的版本统一。如果某组件有了更新的版本，需要更新组件，可以通过「composer update」命令实现。如果这部分内容还不能很好的理解，不要紧，后面将会有一个实例让读者亲手实践，那时就会掌握并理解这些命令的用法。

#### 1.2.3 自动加载

通过 composer 的 install 命令除了可以下载组件以外，还会在 vendor 目录下提供一个自动加载文件，只需要在项目中通过「require 'vendor/autoload.php';」语句引入这个文件，在使用下载的组件时就可以实现自动加载了。如上一小节的实例中，下载了 monolog 组件，就可以通过「\$myLog = new \monolog\Logger（'wangshuo'）」语句直接使用组件中的类库，而 autoload 文件会自动加载相应的类文件。

实现文件自动加载需要有相应的规范进行约束，其中包括 PSR-0、PSR-4、classmap 和 files 四种规范形式，其中 PSR-4 是目前推荐使用的规范。这四种规范形式本质上是定义了一个命名空间到实际文件的映射关系，通过这个映射关系，可以利用命名空间类精确定位到相应文件的具体路径，进而实现「autoload」自动加载功能。首先介绍 PSR-0 和 PSR-4 规范，这两种规范相似。在 composer.json 文件中可以直接添加 autoload 字段实现命名空间到目录的映射，如 Laravel 框架中 APP 命名空间下类的自动加载设置如下：

```json
{ "autoload": { "psr-4": { "App\\" : "app/" } "psr-0": { "Bpp\\" : "bpp/" } } }
```

这里根据 PSR-0 和 PSR-4 规范定义了两个映射关系，即命名空间「App\\」对应目录「app/」和命名空间「Bpp\\」对应目录「bpp/」。在 PSR-4 规范下，假设创建一个 app/User.php 文件，则该文件需要包含 App\User 类，也就是说当使用「\$user = new \App\User()」语句实例化 App\User 类时，autoload 会根据定义的 PSR-4 规范到目录 app / 下查找 User.php 文件；在 PSR-0 规范下，则需要创建一个 bpp/Bpp/User.php 文件，而该文件中包含 Bpp\User 类。这里的区别就在于 PSR-4 规范的目录不需要添加命名空间「App」，而 PSR-0 规范的目录需要添加命名空间「Bpp」。

对于 classmap 会扫描指定目录中所有的.php 和.inc 文件，并加载到 vendor/composer/autoload_classmap.php 文件中，在该文件中会实现一个具体类与文件映射的关联数组，也可以直接精确指定一个文件。通过 classmap 可以生成不遵循 PSR-0 和 PSR-4 规范的自动加载类库。对于下面的实例，就会搜索 database 目录下的所有.php 文件和.inc 文件，并记录类名与文件的对应关系。

```json
{ "autoload": { "classmap": [ "database" ] } }
```

对于在每次程序执行时都需要载入的文件，可以通过 files 规范实现自动加载，通常经常使用的函数库文件就使用这种载入方式，例如下面的实例每次都会加载。

```json
{ "autoload": { "files": [ "src/Illuminate/Foundation/helpers.php", "src/Illuminate/Support/helpers.php" ] } }
```

#### 1.2.4 composer 命令行简介

在前面的介绍中已经接触到一些 composer 命令，表 1.1 对常用的命令进行了简单的归纳，如果需要更加详细地了解可以参看 composer 官网。

```
composer list 获取帮助信息

composer init 以交互方式填写 composer.json 文件信息

composer install 从当前目录读取 composer.json 文件，处理依赖关系，并安装到 verdor 目录下

composer update 获取依赖的最新版本，升级 composer.lock 文件

composer require 添加新的依赖包到 composer.json 文件中并执行更新

composer search 在当前项目中搜索依赖包

composer show 列举所有可用的资源包

composer validate 检测 composer.json 文件是否有效

composer self-update 将 composer 工具更新到最新版本

composer create-project 基于 composer 创建一个新的项目

composer dump-autoload 在添加新的类和目录映射时更新 autoloader
```

