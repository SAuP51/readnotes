## 记忆时间

## 卡片

### 0101. 反常识卡——

这本书的主题核心，就是最大的反常识卡，并且注意时间脉络。

#### 01. 常识

#### 02. 反常识

#### 03. 知识来源

比如提出者，如何演化成型的；书或专栏具体出现的地方。

#### 04. 例子

### 0201. 术语卡——

根据反常识，再补充三个证据——就产生三张术语卡。

例子。

### 0202. 术语卡——

### 0203. 术语卡——

### 0301. 人名卡——

根据这些证据和案例，找出源头和提出术语的人是谁——产生一张人名卡，并且分析他为什么牛，有哪些作品，生平经历是什么。

维基百科链接：有的话。

#### 01. 出生日期

用一句话描述你对这个大牛的印象。

#### 02. 贡献及经历

#### 03. 论文及书籍

#### 04. 演讲汇总

找一个他的 TED 演讲，有的话。

### 0401. 金句卡——

最后根据他写的非常震撼的话语——产生一张金句卡。

### 0501. 行动卡——

行动卡是能够指导自己的行动的卡。

### 0601. 任意卡——

最后还有一张任意卡，记录个人阅读感想。

[codeyu/orange-can-step-by-step: 微信小程序开发入门与实践](https://github.com/codeyu/orange-can-step-by-step)

## 06. 文章详情页面

### 1. 逻辑脉络

详情页面的编码工作，不同页面间参数的传递技巧，页面跳转的方法、动态设置导航栏标题等，以及如何解决元素的垂直居中。

### 2. 摘录及评论

### 6.1 跳转到文章详情页面

首先新建文章详情页面。在 app.json 的 pages 数组下新增页面路径：

"pages/post/post-detail/post-detail"

保存后，开发工具会自动生成 post-detail 页面的 4 个文件。首先要实现的是从 post 文章页面通过点击跳转到 post-detail 详情页面。

在 post.wxml 中的 block 代码块里注册一个事件。

```
  // 跳转到列表详细页面
  onTapToDetail(event){
    wx.navigateTo({
      url: 'post-detai/post-detail',
      success: (result)=>{
        
      },
      fail: ()=>{},
      complete: ()=>{}
    });
  },
```

以上代码仅仅在 template 上增加了一个 catchtap。接着，在 post.js 中编写这个事件的响应函数 onTapToDetail。

添加完 onTapToDetail 函数后，保存运行，并在文章列表页面点击任意一篇文章。没有任何反应，页面也没有跳转。为什么会这样？

### 6.2 不要在 template 上注册事件

看起来似乎是事件函数并没有响应。此时我们可以在 wxml 面板中看一下现在页面的骨架结构，如图 6-1 所示。

是的，注册事件的 template 消失了。在前面章节中我们讲过，template 标签仅仅是一个占位符，在编译后会被 template 的模板内容替换。所以，在 template 上注册事件是无效的。那么在 block 标签上注册可以吗？来试试，将 catchtape 的事件注册到 lblock 标签上。

同样不可以，因为 block 也会在编译后「消失」。

那么，我们只有在 template 的外部增加一个 view，将 template 给包裏起来，并将 catchtap 事件注册到 vew 组件上。保存后，点击 5 篇文章中的任意一篇，就可以正确地跳转到 post-detail 文章详情页面了。

```
  <block wx:for="{{postList}}" wx:for-item="item" wx:for-index="idx">
    <view catchtap="onTapToDetail">
      <template is="postItemTpl" data="{{...item}}"/>
    </view>
  </block>
```

1『用 catchtap 或者 catch:tap 都可以。』

### 6.3 页面间传递参数的 3 种方式

我们实现了从文章列表页面跳转到文章详情页面。要正确展示文章详情页面的内容，首先需要将文章的 id 号由 post 页面传递到 post-detail 页面，这样，post-detail 页面才能知晓它要显示哪篇文章。这涉及页面间的参数传递与通信。目前，在 MINA 框架中有以下几种参数传递方式：1）使用全局变量（关于全局变量，本书后面的章节中会讲到）。2）使用缓存。3）通过页面导航 url 的 query 参数传递。

基本上参数的传递只有以上 3 种方式，其他的比如像事件信号的传参方式（一个页面 emit 发送信号，一个页面 on 监听信号，这种在 AngularJS 里很常见的传参方式，小程序是不能天然支持的），其实都是这些基本思路的变种。

全局变量我们将在后面讲到，至于缓存的传参方式，开发者在学习完缓存后应该很容易想到。其实，使用缓存数据库存储 data.js 初始化数据，又在 post.js 中读取缓存数据，这其买就是页面间的参数传递。仔细想想，是不是这样？1）和 2）两种都涉及全局变量，笔者个人不推荐这种污染全局的传参方式，而且我们的需求仅仅是两个页面间传递参数，完全不需要干抗全局。所以，选用方法 3 来做页面间的参数传递。

组件的自定义属性。再来整理下思路。要将 postId 由 post 页面传递到 post-detail 页面，首先需要在 post.js 中获取到 postId，随后再将 postId 附加到代码清单 6-2 中的 wx.navigateTo 的 url 中。要想在 post.js 中获取到 postId，就必须知道当前点击的文章是哪一篇文章。我们首先将 postId 绑定到每一篇文章的 wxml 中，使 postId 成为文章 wxml 的一个属性。注意，postId 已在 5.13 小节中加入到 data.js 文件里。绑定 postId 的方法很简单，就如同绑定文章的 date、title 等属性一样。post.js 文件的代码无须任何改动，只需要对 post.wxml 文件做一下改动即可。

以上代码中，我们在 view 里增加了一个属性 data-post-id="{{item.postId}}"，先来看看以上代码有什么效果。保存并运行代码后，打开调试中的「wxml」这个面板，文章页面的骨架如图 6-2 所示。从图 6-2 中可以很明显地看到，每篇文章的 id 号都被绑定在了该文章的 view 容器上，剩下的工作就是，如何在 post.js 中获取当前点击的文章的 id 号。

通过 dataset 获取组件自定义属性修改。修改 文post.js 文件中的 onTapToDetail 函数如下：

```
  onTapToDetail(event){
    var postId = event.currentTarget.dataset.postId;
    console.log(postId);
    wx.navigateTo({
      url: 'post-detail/post-detail?id='+postId,
      success: (result)=>{
        
      },
      fail: ()=>{},
      complete: ()=>{}
    });
  },
```

上述代码中，我们通过 event.currentTarget.dataset.postId，这段代码成功地拿到了当前文章的 postId。event 事件对象是由 MINA 框架在调用 onTapToDetail 函数时传递的参数。在 event 事件对象中，有一个 currentTarget 代表事件绑定的当前组件。

重点是 dataset 对象，dataset 对象里包含当前组件中所有属性名以 data-开头的自定义属性值。我们在代码清单 6-5 中的 view 上绑定了 data-post-id，所以通过 dataset.postId 将可以拿到当前组件的 postId。

组件自定义属性名有以下规则：1）必须以 data-开头。2）多个单词由连字符「-」链接。3）单词中最好不要有大写字母，如果有大写字母，除单词第一个字母外，其余大写字母将被转化成小写。4）在 js 中获取自定义属性值时，多个单词将被转化驼峰命名。

看起来很复杂，但举几个例子就非常清楚了，如表 6-1 所示。在获取到 postId 后，我们将 postId 附加在导航 url 的 query 参数中：url: 'post-detail/post-detail?id='+postId

获取页面参数值。再来看看如何在 post-detail 页面中获取 postId，在 post-detail.js。文件中添加以下代码：

```
  onLoad: function (options) {
    var postId = options.id;

  },
```

接受 post 页面传递参数的方法是通过 post-detail 页面 onLoad 函数里的 options 参数来获取。options 参数是由框架传递的。注意，这里 options.id 中的「id」必须同代码清单 6-6 中 navigateTo 中 url 的 query 参数名称保持致。比如，在 query 参数中使用的是 name=postId，则这里要相应地使用 options.id。

### 6.4 编译时设置初始化页面及参数

现在我们主要的代码编辑工作集中在 post-detail 这个页面。但每当保存刷新小程序后，项目都将从欢迎页面启动。我们不得不依次点击启动页面、文列表，才能进入到文章详情页面以预览文章详情的效果，这相当的麻烦。当然可以按照 4.1 小节中的方法，将 post-detail 页面设置为 app.json 中 pages 数组的第一项，但 post-detail 还需要传入ー个 postId 的参数才可以正确地运行，且手动来回更改 pages 数组非常麻烦。

小程序在 122100 版本中增加了编译选项，在此版本中，官方提供了一个「自定义编译」功能，可用于定义小程序的启动页面，如图 6-3 所示。122100 版本后，「编译」这里变成了两个选项，请仔细查看。上面一个图标是默认编译，下面的图标是自定义编译，点击下面的图片将弹出如图 6-4 所示的界面。

启动页面一栏中将路径设置为 post-detail 页面的启动路径：pages/post/post-detail/post-detail，页面自定义参数类似于 url 中的 query 参数，设置 id=2 将可以在页面中通过 onLoad 函数中的 options.id 获取到这个值。设置完成后，必须勾选【使用以上条件编译】这个选项。

保存刷新页面，项目将直接进入 post-detail 页面，不再出现 welcome 启动页。同时，我们发现，以这种方式打开的 post-detail 页面无法再返回到 post 页面，因为不是通过 post 页面导航到 post-detail 顶面的。可以通过「&」连接多个页面参数，比如 id=2&name="MR.L"，同时将两个参数传递到 post-detaill 页面中。有了以上功能，就可以非常方便地调试 post-detail 页面。如果想恢复默认的启动页，只需去掉【使用以上条件编译】选项即可。

### 6.5 读取文章详情数据

现在，我们已经在文章详情页面中拿到了文章的 postId，接下来需要根据这个 postId 去缓存数据库中读取文章详细数据，并将数据用于构建文章详情页面。所有对于缓存数据库的操作，我们都会放在 DBPost 这个对象中，在 DBPost.js 中增加和修改部分代码。注意，以上代码只标注出了相关修改和增加代码，并非全部代码。首先修改 constructor 构造函数，增加一个构造参数 postId，并将 postId 保存到 this 变量中。接着增加一个方法 getPostItemById() 用于获取指定 id 号的文章数据。

```
class DBPost {
  // 构造函数里的传入参数从原来的 url 改成 postId
  constructor(postId) {
    this.storageKeyName = 'postList';
    this.postId=postId;
  }

  // 得到全部文章信息
  getAllPostData() {
    var res = wx.getStorageSync(this.storageKeyName);
    if (!res){
      res = require('../data/data.js').postList;
      this.execSetStorageSync(res);
    }
    return res;
  }

  // 本地缓存，保存/更新
  execSetStorageSync(data) {
    wx.getStorageSync(this.storageKeyName, data);
  }

  //获取指定id号的文章数据
  getPostItemById() {
    var postsData = this.getAllPostData();
    var len = postsData.length;
    for (var i=0;i<len;i++) {
      if (postsData[i].postId == this.postId) {
        return {
          // 当前文章在缓存数据库中的序号
          index: i,
          data: postsData[i]
        }
      }
    }
  }

};

export {DBPost}
```

DBPost.js 修改完毕后，我们尝试在 post-detail.js 中获取指定 id 号的文章数据，并使用 this.setData 绑定该数据。

```
  onLoad: function(options) {
    var postId = options.id;
    this.dbPost = new DBPost(postId);
    this.postData = this.dbPost.getPostItemById().data;
    this.setData({
      post: this.postData
    });
  },
```

1『之前把上面的代码写进 post.js 里了，导致错误，找了很久才发现这个错误。』

注意上述代码中，在使用 new 实例化 DBPost 后，将 dbPost 这个对象保存在了变量 this 中，这样以后如果要再次使用 DBPost，则不需要再重新实例化这个对象，只需要使用 this.dbPost 即可弓用这个对象。

### 6.6 文章 id 号的数据流向图

我们来疏理一下，post-detail.js 是如何从初始化数据中拿到文章 id 号，并最终通过 id 号来获取到文章详情数据的，参见图 6-5 所示。文章 id 号最初是存在于 data.js 中的，通过一系列的事件操作，它最终会被传递到 post-detail.js 中。一旦 post-detail.js 拿到文章的 id 号，该页面就可以根据 id 号来获取文章详情数据了。

1『数据的流向很清晰：data.js 里初始化数据进入缓存，post.js 从缓存里读取数据，post.js 绑定数据到 post.wxml 里，post.wxml 里通过 catchtap 事件回到 post.js 里，在 post.js 里通过导航 URL 到 post-detail.js，post-detail.js 使用  id 号读取数据到缓存，缓存数据里筛选出文章详细数据回 post-detail.js 然后给与展现。』

### 6.7 编写文章详情页面

在代码清单 6-9 中，我们获取了文章的 postId，并通过 DBPost 查询到了该文章的相关数据，随后我们用 this.setData 函数做了文章数据的数据绑定。下面，我们来编写文章详情页面的骨架和样式。在 post-detail.wxml 中加入以下页面骨架代码：

```
<view class="container">
  <image class="head-image" src="{{isPlayingMusic?post.music.coverImg:post.postImg}}"></image>
  <image catchtap="onMusicTap" class="music" 
  src="{{isPlayingMusic?'/images/icon/wx_app_music_stop.png':'/images/icon/wx_app_music_start.png'}}">
  </image>
  <text class="title">{{post.title}}</text>
  <view class="author-date">
    <view class="author-box">
      <image class="avatar" src="{{post.avatar}}"></image>
      <text class="author">{{post.author}}</text>
    </view>
    <text class="date">{{post.dateTime}}</text>
  </view>
  <text class="detail">{{post.detail}}</text>
</view>
```

还是要注意代码中 {{}} 中的数据绑定语法一定要正确，否则无法读取数据。保存并运行代码，post-detail 页面将显示这些文章数据，但整个页面的样式是错乱的，因为还没有编写 post-detail 页面的 wxss 文件。保存并刷新页面后，文章详情页面将正确地显示出来，如图 6-6 所示。

### 6.8 垂直居中问题的经典解决方法

我们在编写 CSS 时，很多时候都会面临如何将两个元素垂直居中对齐的问题。比如在代码清单 6-11 中如何将作者名称（author）和作者头像（avatar）垂直居中对齐。我们在 3.4 小节中学习了 flex，这里就来看看如何使用们 flex 解決这个问题。

```
.author-box {
  display:flex;
  flex-direction: row;
  align-items: center;
}

.avatar {
  height: 50rpx;
  width: 50rpx;
}

.author {
  font-weight: 300;
  margin-left: 20rpx;
  color: #666;
}
```

以上代码摘自 post-detail.wxss。解决思路如下：将 avatar 和 author 用一个容器包裹起来（author-box），使用 display:flex 将该容器设置为们 flex 盒子模型，使用 flex-direction: row 指定 flex 的方向为 row。关键的代码是 align-items: center，这将使 flex 盒子里的元素在交叉轴方向上居中。在本例中主轴是水平方向（因为设置了 flex-direction 为 row），所以交叉轴是垂直方向，align-items: center 将控制垂直方向居中。关于 flex 及轴的概念已经在 3.4 小节中详细讲解过，开发者可自行回顾一下关于主轴和交叉轴的概念。

开发者可以对比一下，welcome 页面中是如何使头像、文字和按钮这 3 个元素水平居中的。welcome 页面中设置了 flex-direction: column，所以主轴是垂直方向，align-items: center 将控制水平方向上的居中。小程序对于 Tex 的支持相当完善，建议多使用 flex 进行元素布局。

1『flex 框架很重要。』

### 6.9 动态设置导航栏标题

使用两种方法分别设置 post 页面和 post-detail 页面的导航栏文字。

使用配置文件配置导航栏标题。第一种方法是使用 app.json 或者页面的 json 文件来配置导航栏标题。如果是在 app.json 中进行配置，则它是全局行为，项目所有的页面将显示同一个标题；而如果是在页面的 json 文件中配置标题，则只会影响当前配置页面。我们之前在 app.json 的 window 属性中通过设置 navigationBarbackgroundColor 实现了指定导航栏的颜色。window 还有以下 2 个属性用于配置导航栏文本：1）navigationBarTextStyle 指定导航栏标题文字的颜色，只支持 black/white，默认值为 black。2）navigationBarTitleText 指定导航栏标题文字。在 app.json 中对 window 属性增加以上两个配置项，代码如下：

```
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#ecc0a8",
    "navigationBarTitleText": "大龙的书屋",
    "navigationBarTextStyle": "black"
  },
```

保存运行后可以看到，所有页面的导航栏都增加了「文字」这两个字，它的颜色为白色。这并不是我们想要的，我们希望不同页面显示不同的导航栏标题。下面来解决这个问题。我们之前讲过，window 这个配置项既可以在 app.json 中配置，也可以在 window 中配置（其他配置项只能在 app.json 中配置）。

使用 wx.setNavigationBarTitle(Object) 设置导航条。在某些情况下，我们希望导航栏的文字可以根据页面内容的不同而有所変化。比如在文章详情页面中，我们希望导航栏可以实时显示当前文章的标题，不同的文章显示不同的标题文字。来看看如何实现这个功能。小程序提供了 wx.setNavigationBarTitle(Object) 来动态设置导航栏标题。小程序官方文档中指出，页面的导航栏标题必须在页面生命周期的 onReady 之后来设置，否则无效。原文如下：对界面的设置如 wx.setNavigationBarTitle 请在 onReady 之后设置。我们遵照官方文档的说明，在 post-detail.js 中加入以下代码：

```
  onReady: function () {
    wx.setNavigationBarTitle({
      title: this.postData.title,
      success: (result)=>{
        
      },
      fail: ()=>{},
      complete: ()=>{}
    });
  }
```

按照文档的描述，我们在页面生命周期函数 onReady 中调用了 wx.setNavigationBarTitle(Object) 方法。它接收一个 object 参数，其中 title 属性被设置为当前文章的标题。保存运行代码，发现页面的导航栏文字变成了文章的标题。这里需要指出，在 122100 版本之前，wx.setNavigationBarTitle(Object) 方法确实只能在页面的 onReady 函数里设置。如果尝试在页面的 onLoad、onShow 函数里调用 wx.setNavigationBarTitle(Object) 方法，文章的标题将出现一闪而过的情况。这种情况是符合官方文档说明的：「对界面的设置如 wx.setNavigationBarTitle 请在 onReady 之后设置」。因为 onReady 在 onShow 发生之后才触发，onShow 将标题设置完毕后，onReady 会重新渲染页面并覆盖导航栏的标题，这就是我们说的「一闪而过」的情况。

但在最新的 130400 版本里，无论是在页面的 onLoad 或者 onShow 函数中调用 wx.setNavigationBarTitle(Object) 方法，都可以成功地设置导航栏标题，并不会出现一闪而过的情况。但无论如何，还是建议开发者按照官方文档所描述的，在 onReady 函数里进行界面的设置操作，以免官方在未来再次改动底层的运行机制时造成代码无法运行。

## 07. 收藏、评论、点赞与计数功能

### 1. 逻辑脉络

通过实现收藏、评论、点赞与计数功能，来学习使用小程序的交互反馈组件、缓存的应用、图片选择和预览、屏蔽关键字、录音、拍照以及播放录音等功能。

1）组件条件渲染 wx:if, wx:elif 和 wx:else，其中 wx:if 和 wx:elif 的值为条件变量，wx:else 不需要设置值。根据条件值是否为 true 判断应该显示哪个组件。2）交互式反馈 API：wx.showToast、wx.hideToast、wx.showModal 和 wx.showActionSheet。3）善用本地缓存。4）控制 UI 元素的显示与隐藏的另一种方式是使用 hidden 属性。它的值也是 bool 类型的变量。和 wx:if 用法比较：在需要频繁切换的情景用 hidden 更好；在运行时条件不大可能改变时用 wx:if 更好。5）input 组件的用法。官方教程：input 组件。6）敏感操作需要获得用户主动授权。一定要处理用户拒绝授权的场景。

3『[input | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/component/input.html)』

### 2. 摘录及评论

本章通过编写几乎所有内容型应用都会附带的「评论」「点赞」「读计数」「收藏」等功能，来学习使用小程序的交互反馈组件、缓存的应用、图片选择和预览、屏蔽关键字、录音、拍照以及播放录音等功能。

### 7.1 收藏、评论、点赞、计数功能准备工作

我们先来编写收藏、评论和点赞的功能按钮。阅读计数是一项被动功能，无须用户有意识地主动触发。在 post-detail.wxml 中新增一段工具栏代码。

```
<view class="tool">
  <view class="tool-item" catchtap="onUpTap" data-post-id="{{post.postId}}">
     <image animation="{{animationUp}}" wx:if="{{post.upStatus}}" src="/images/icon/wx_app_liked.png" />
     <image animation="{{animationUp}}" wx:else src="/images/icon/wx_app_like.png" />
    <text>{{post.upNum}}</text>
  </view>
  <view class="tool-item comment" catchtap="onCommentTap" data-post-id="{{post.postId}}">
    <image src="/images/icon/wx_app_message.png"></image>
    <text>{{post.commentNum}}</text>
  </view>
  <view class="tool-item" catchtap="onCollectionTap" data-post-id="{{post.postId}}">
    <image wx:if="{{post.collectionStatus}}" src="/images/icon/wx_app_collected.png" />
    <image wx:else src="/images/icon/wx_app_collect.png" />
    <text>{{post.collectionNum}}</text>
  </view>
</view>
```

黑色加粗部分为新增代码。在 post-detail.wxml 页面的 container 中添加了一段 \<view class="tool"> 的相关代码。该代码实现了收藏、评论和点赞 3 个功能按钮。每个功能按钮都绑定了对应的点击事件，注意 view 组件上的 catchtap 属性。除此之外，我们还在每个功能按钮上使用 data-post-id 绑定了当前文章的 id。post.upNum、post.commentNum 和 post.collectionNum 等数据已经在 5.13 小节中全部添加到了 data.js 文件中，接着编写 3 个功能按钮的样式。保存刷新后，3 个功能按钮将出现在 post- detail 页面的正下方，如图 7-1 所示。

```
/*点赞和评论*/
.tool{
  height: 64rpx;
  margin: 20rpx 28rpx 20rpx 0;
  display: flex;
  justify-content: center;
}
.tool-item{
  align-items: center;
  margin-right: 30rpx;
  display: flex;
}

.tool-item image{
  height: 30rpx;
  width:30rpx;
  margin-right: 10rpx;
}

.comment image{
  transform: scale(.85);
}
```

### 7.2 文章收藏功能

我们首先来实现文章收藏功能。文章收藏功能需要记录两个变量值：1）自己是否收藏了文章。如果自己收藏了，那么需要将收藏的图片更换为已收藏。2）所有用户收藏文章的总数量。需要注意的是，由于我们的数据库只在本地，无法多次收藏同篇文章，所以收藏数量永远只能在初始数量的基础上 +1 或者 -1, 分别对应取消收藏和点击收藏两种状态。但在真实的项目中，这个收藏数量却是要受到所有用户取消、收藏文章动作影响的。同样的情况也会出现在「文章点赞」这个功能里。

当页面从 post 跳转到 post-detail 时，我们就需要知道该文章是否已被用户收藏。在 data.js 中，我们使用 collectionStatus 这个属性表示文章是否已被收藏，这个变量的类型是 Boolean。那么如何根据 collectionStatus 这个变量的取值来动态切换收藏图标呢？熟悉传统 Web 开发的读者很容易想到用 jQuery 获取 image 标签，再动态地设置 image 的 src 属性。再次强调，小程序没有 DOM，一切都是数据绑定，请抛弃 DOM 的思维方式。

条件渲染：wx:if 与 wx:else。collectionStatus，只有两种取值：true 或者 false。我们需要做的是，当 collectionStatus 为 false 时，显示图 7-2 未收藏状态的图标，而当 collectionStatus 为 true 时，显示图 7-3 收藏状态的图标。以上需求是不是就是编程中非常经典的 if else？如果 wxml 组件也像 js 代码一样有 if else 就可以解决动态显示收藏图片的问题。下面来看看如何实现这个功能。小程序提供了 wx:if 与 wx:else 来实现条件渲染。当变量为 true 时，执行 wx:if，否则将执行 wx:else。修改收藏按钮的 wxml 代码如下：

```
<view class="tool-item" catchtap="onCollectionTap" data-post-id="{{post.postId}}">
<image wx:if="{{post.collectionStatus}}" src="/images/icon/wx_app_collected.png" />
<image wx:else src="/images/icon/wx_app_collect.png" />
<text>{{post.collectionNum}}</text>
</view>
```

上述代码中我们添加了两个 images 组件，分别是收藏和未收藏图片。这两个 image 组件各有一个 wx:if 和 wx:else 属性。当 post.collectionStatus 为 true 时将显示 wx_app_collected.png 图片而当 post.collectionStatus 为 false 时将显示 wx_app_collect.png 图片。由于我们已经在 data.js 文件中将部分文章的收藏状态设置为 true，因此保存并运行项目，发现所有 collectionStatus 为 true 的文章，其收藏图片都将显示 wx_app_collected.png，如图 7-4 所示。

wx:if 与 wx:else 的条件渲染在小程序中被大量使用，不仅仅被用来做图片的更换，还可以用来控制元素的显示和隐藏。wx:if 可以被单独使用，并不一定要同 wx:else 一起使用。除此之外，条件渲染还可以做多级别的 if else，如代码清单 7-4 的示例代码所示。

如果变量 length 的取值大于 5，那么将显示数字 1。如果变量 length 的取值大于 2 且小于等于 5，那么将显示数字 2。以上条件都不满足，就显示数字 3。你还可以添加更多的 elif 分支，以实现更多级别的条件判断。

实现收藏点击功能。在 7.2.1 小节中，我们仅仅是在 post-detail 页面加载时读取了该文章对于当前用户是否为收藏状态，并正确地设置和显示了这个状态。在这个小节中，我们将实现用户点击图片进行文章的收藏和取消收藏功能。首先我们继续完善 DBPost 这个数据库操作类。在 DBPost 类中添加一个方法，用以处理文章的收藏操作。该方法中调用了 DBPost 类的 updatePostData 方法，这个方法我们还没有编写。在 DBPost 类中添加 updatePostData 方法。该方法是处理点赞、评论、收藏、阅读的核心方法。

1『数据库操作类 DBPost 的概念很重要，一定要有做一个操作类作为接口来预数据库（缓存）交互。』

```
  //更新本地的点赞、评论信息、收藏、阅读量
  updatePostData(action, newComment) {
    const itemData = this.getPostItemById();
    let postData = itemData.data;
    let allPostData = this.getAllPostData();
    switch (action) {
      case "collect":
        if (!postData.collectionStatus) {
          postData.collectionStatus = true;
          postData.collectionNum++;
        } else {
          postData.collectionStatus = false;
          postData.collectionNum--;
        }
        break;
      case "up":
        if (!postData.upStatus) {
          postData.upStatus = true;
          postData.upNum++;
        } else {
          postData.upStatus = false;
          postData.upNum--;
        }
        break;
      case "comment":
        postData.comments.push(newComment);
        postData.commentNum++;
        break;
      case "reading":
        postData.readingNum++;
        break;
      default:
        break;
    }
    allPostData[itemData.index] = postData;
    this.execSetStorageSync(allPostData);
    return postData;
  }

  collect() {
    return this.updatePostData('collect');
  }

  up() {
    return this.updatePostData('up');
  }
```

我们目前仅处理 collect 这一种操作，后续我们将继续在代码清单 7-6 的 switch case 中添加评论、读数、点赞等处理分支。这样，DBPost 就具备了处理文章收藏的能力。当用户点击收藏按钮后，在点击事件函数中调用 DBPost 的 collect 方法即可。处理文章收藏动作的事件函数是 onCollectionTap，这个事件函数已在代码清单 7-1 中被注册在了收藏功能按钮上。我们只需要在 post-detail.js 中编写这个方法即可。

```
  onCollectionTap: function (event) {
    var newData = this.dbPost.collect();
    // 重新绑定数据。注意，不要将整个newData全部作为setData的参数，
    // 应当有选择的更新部分数据

    this.setData({
      'post.collectionStatus': newData.collectionStatus,
      'post.collectionNum': newData.collectionNum
    })

    // 交互反馈
    wx.showToast({
      title: newData.collectionStatus ? "收藏成功" : "取消成功",
      duration: 1000,
      icon: "success",
      mask: true
    })
  },
```

1『开始的时候无法取消收藏，后来发现 DBPost 类里没有添加 collect() 方法，书里的源码没有提到这点。』


交互反馈 wx:showToast。现在，我们已经实现了文章的收藏与取消收藏功能，但收藏功能的体验并不好，用户在收藏和取消收藏后没有任何交互反馈提示。小程序提供了一些交互反馈 API 来帮助开发者处理交互相关的问题。目前，小程序提供了以下 4 个交互反馈 API：wx:showToast、wx.hideToast、wx:showModal、wx:showActionSheet。

我们选用 wx:showToast 来制作文章收藏功能的交互反馈。其中，object 参数的 title 属性用于设置提醒消息的内容；duration 设置提醒的自动消失时间，最长 10000 毫秒，默认值为 1500 毫秒；icon 可以设置一个小图标，其取值只能是 success 和 loading; mask 指定是否显示透明的蒙层，以防止触摸穿透，默认值为 false。mask 主要用来防止用户连续点击收藏按钮。开发者可执行尝试将 mask 设置为 true 和 false 时的不 同效果：当 mask 为 true 时连续点击收藏图标，图标不会连续做出收藏 / 取消收藏的响应；当 mask 为 false 时，就会不停地响应用户的点击操作。showToast 的效果如图 7-5 所示。

1『实现了收藏成功和取消收藏 2 个状态的来回切换，不过只是跳出来的显示消息，图标没有实现来回切换，下面的点赞功能一样，待解决。』

### 7.3 文章点赞功能

文章点赞功能的实现思路同收藏几乎是一样的。首先在 DBPost.js 中增加点赞的方法。接着在 DBPost 的 updatePostData 方法中处理当 case 为 up 时的情况。下面给出 updatePostData 的全部代码。黑色加粗部分为新增代码。代码清单 7-10 同代码清单 7-6 相比，仅仅增加了 case 为 'up' 时的这段代码。很明显，我们可以看到处理点赞的逻辑同处理收藏时的逻辑几乎一样：改变 upStatus 的状态，并对 upNum 这个计数变量做相应的增减操作。

我们编写完 DBPost 中关于点赞的接口后，接着编写 post-detail.js，和 post-detail.wxml 中关于点赞的相关代码。onUpTap 方法响应用户点赞的动作。当用户点击点赞按钮后，onUpTap 方法将调用 DBPost 的 up 方法并将返回的最新数据使用 this.setData 更新。类似于收藏功能，我们还需要使用条件渲染 wx:if 改写 wxml 中的点赞按钮。

以上代码将在 post.upStatus 为 true 时显示 wx_app_liked.png，当 post.upStatus 为 false 时显示 wx_app_like.png。在编写完以上代码后，保存运行项目，点击点赞按钮，图片会不断切换，点赞数也将相应地 +1 或者 -1。很多开发者可能还不太习惯使用数据绑定的方式来做样式、状态的切换，但数据绑定的写法确实非常简化、方便。我们只需要在 js 中改变各类变量的状态和值，前端组件就会响应我们的操作，动态地做出变化。

### 7.4 本地缓存的重要性及应用举例

提供本地的 key&value 缓存机制是小程序的一大特点，善用本地鍰存将可以极大地改善客户端的体验与服务器的性能。前几个小节中，我们大量地使用了本地缓存来模拟服务器的数据库。这样做一方面是因为我们并没有真实的服务器，必须依靠客户端的缓存能力来记录数据；另一方面是因为即使在真实的项目中我们拥有自己的远程服务器，也依然需要在客户端管理本地缓存。

举个例子，如果我们要实现一个城市列表插件，就必然要获取全国所有城市的信息。全国大概有 600 多个城市，这么大的数据量难道每次打开这个插件都要去服务器取城市数据吗？这些城市的数据相对非常稳定，并不会频繁变化，每次都去服务器加载是对流量和服务器性能的严重消耗。所以，最好的解決方案就是将城市数据保存在本地缓存中，而不是每次都去服务器请求数据。

在一个高性能的产品中，缓存的重要性是不言而喻的。建议开发者将本地缓存视作一个本地的 key&value 数据库，并封装一些类和公共方法，提供给项目中的各个调用方。最好不要让 getStorage、setStorage 等方法充斥在项目的每一个角落。Orange Can 项目中的 DBPost 类就是一个不错的示例，它实现了对缓存的良好管理，并向调用方提供了一系列可读性非常强的 API。建议开发者参考 DBPost 并将这种思路应用到自己的项目中。

1『这节缓存（本地数据库）的讲解启发很大。』

### 7.5 支持文字、图片、拍照、语音上传的文章评论

文章评论不仅可以发表文字，还可以上传图片和语音。评论页面将使用一个全新的 post-comment 页面，它属于 post-detail 的子页面。我们将通过点击评论功能按钮跳转到 post-comment 页面。

首先，在 app.json 的 pages 数组下注册 post-comment 页面。保存后将自动在项目里创建 post-comment 目录以及页面的 4 种类型文件。post-comment 将作为 post-detail 的子页面。在 post.js 中添加以下代码：

```
  // 跳转到评论页面
    onCommentTap:function(event) {
    var id = event.currentTarget.dataset.postId;
    wx.navigateTo({
      url: 'post-comment/post-comment?id='+id,
      success: (result)=>{
        
      },
      fail: ()=>{},
      complete: ()=>{}
    });
  },
```

以上代码将携带当前文章的 id 号并跳转到 post-comment 页面。

1『发现无需额外设置即可跳转，原以为还需在 post.wxml 里的组件里设置属性才能跳转。』

### 7.6 文章评论页面的实现步骤与思路

构建文章评论页面的思路分为两部分：1）加载并显示当前文章已存在的评论。2）实现添加新评论的功能。

这个思路不是做特定功能的思路，而是一种适用于大部分前端功能的通用思路，就像我们在 post-detail 页面中去编写点赞、收藏等功能时一样，先显示点赞和收藏的数量、状态，再考虑实现点赞和收藏的操作功能。我们来按照以下步骤逐步构建整个文章评论模块的相关页面和功能：1）在 post-comment.js 中获取并绑定文章评论数据。2）编写 post-comment 页面的 wxml 和 wxss 显示文章评论数据。3）编写添加新评论的功能。

### 7.7 获取并绑定文章评论数据

我们在 data.js 中《从童年呼嘯而过的火车》这篇文章下面模拟了 4 条评论数据（comments 数组）。按照 7.6 节中分析的思路，首先应当从缓存数据库中读取这 4 条数据并将数据绑定到框架中。首先在 post-comment.js 中增加以下代码：

以上代码引入了 DBPost 缓存数据库操作类，同时在 onLoad 函数里接收由 post-detial.js 传递过来的 postId。接着实例化 DBPost，再调用 DBPost 的 getCommentData 方法得到评论数据，最后使用 this.setData 将评论数据绑定到框架中。很明显，我们的 DBPost 中缺少 getCommentData 方法，现在来编写这个方法。在 DBPost.js 中新增以下代码：

在 getCommentData 这个方法中，我们还调用了 compareWithTime 和 util.GetDiffTime 这两个方法。compareWithTime 用于将评论按照时间降序排列，保证最新的评论在最上方 uti.GetDiffTime 将评论的时间戳转化为「多少分钟前，多少小时前，昨天，月日」等格式。下面我们来实现这两个方法。在  DBPost.js 中添加 compareWithTime 方法，代码如下：

接着实现 util.GetDiffTime 方法。这个方法属于公共方法，我们新建一个 util 文件，将所有的公共方法都放置到这个 util 文件中。在根目录下新建文件夹 util，在 util 文件夹下新建 util.js 文件并在该文件中新增以下代码：

1『新版开发工具里自动建了公共方法文件夹 utils，注意名称后面多了个 s，可以直接用自建的。』

上述 GetDiffTime 方法中调用了 Date 的 format 方法。继续添加 format 这个方法。需要注意的是，format 方法被添加在了 Date 的原型链上，这样所有 Date 类型的变量都将自动拥有 format 这个方法。

不需要深入研究上面这段代码，只需要知道它的作用即可。最后，在 util.js 的末尾添加以下代码；这样 util.js 这个模块就编写完成了。为了在 DBPost.js 中引用这个模块，我们需要在 DBPost.js 中使用 require 来引用 util 模块。

```
var util = require('../utils/util.js')
```

编写完以上代码后，DBPost 的 getCommentData 就完成了。现在，在 post-comment.js 的 onLoad 方法里就可以正确获取文章的评论数据。开发者可自行在代码清单 7-15 中使用 console.log (comments）来验证一下是否能够正确获取到文章评论。需要注意的是，我们仅仅在《从童年呼嘯而过的火车》这篇文章里设置了 4 条评论数据，其他文章是没有评论数据的。开发者可根据自身的需求修改 data.js 中的初始化数据。注意，修改完 data.js 后一定要用开发工具清除一下缓存，并重新运行项目，之后更改才能生效。

1『也就是在 post-comment.js 文件中使用语句 console.log (comments）验证，这个办法好，不用先写 post-comment.wxml 就直接在工作台上看结果；缓冲里的数据修改后记得一定要清除一下缓存。』

图 7-6 是输出的《从童年呼嘯而过的火车》这篇文章的 comments 变量。Comments 数组中包含了 4 个 Object 对象，每一个对象代表着一条评论。我们的评论支持文本、图片和录音 3 种类型。开发者可以对比一下图 7-6 中的 content 属性，在该属性下，img 数组是评论中的图片；txt 是评论中的文本；而 audio 是评论中的音频。注意，img 是数组，txt 是字符串，而 audio 是对象。

对于一条评论，有以下几条规则：1）图片类型评论最多只能包含 3 张图片。2）音频类型评论只能包含一条音频。3）一条评论可以同时包含文字和图片。4）音频类型评论不能包含文字和图片。这样，我们就完成了获取并绑定文章评论数据这个步骤。在下一节中，我们将编写 post-comment 页面的 wxml 和 wxss 文件来显示这些已绑定的数据。

### 7.8 显示文章评论数据

读取到文章评论数据后，我们需要编写 post-comment 页面的 wxml 和 wxss 文件以显示这些数据。在 post-comment.wxml 中增加以下代码：

整个代码里所用到的知识点都已经在前面的内容中讲到过，每条评论都会对 3 种类型的评论做处理。我们重点来看看上述代码中的几个 wx:if 条件渲染。

    <view class="comment-txt" wx:if="{{item.content.txt}}">

这里的 wx:if 将判断 item.content.txt 有没有值，如果没有，那么整个 view 都不会显示；如果有，就将显示文字评论。

    <view class="comment-voice" wx:if="{{item.content.audio && item.content.audio.url}}">

这里的 wx:if 将判断 audio 是不是空值，如果不是空值接着判断 audio 这个对象的 url 有没有值，只有满足这两个条件才会显示音频评论。

    <view class="comment-img" wx:if="{{item.content.img.length!=0}}">

这里的 wx:if 将判断 img 这个数组是不是空，如果不是空，就将显示多张图片。

正如我们之前提到的，wx:if 的应用是非常灵活的，开发者应当理解这种用法。post-comment 的 wxml 编写完后，接着来添加评论列表的样式。

以上代码中有部分样式使用了 position:absolute，这是为了后面编写新增评论的功能而准备的。保存运行代码，post-comment！将显示如图 7-7 所示的界面。如果此时我们尝试去点击第二条评论的语言播放，就会发现它并没有效果，原因是初始化数据中的语音给的是一个假的 urI。这里只是为了展现语音评论的显示效果，在后面的章节中我们将真实地新增和旙放语音评论。

### 7.9 实现图片预览

在 7.8 节中，我们所有的图片都以固定尺寸显示，并将 image 的 mode 设置为了 aspectFill。本节我们将为图片添加预览功能。

无须自己编写图片预览插件，小程序已经为我们提供好了图片预览的接口 wx.previewlmage(object)。它有以下两个重要属性：1）current 当前显示图片的链接，不填则默认为 urls 的第一张。2）urls 需要预览的图片链接列表，类型为数组。

这里要注意的是，urls 是一个数组，可以支持多张图片。它实际上类似于一个相册，可以左右滑动查看多张图片。修改 post-comment.wxml 中 class="comment-img" 这个 view 组件内容。

```
<view class="comment-img" wx:if="{{item.content.img.length!=0}}">
<block wx:key="comment-{{idx}}" wx:for="{{item.content.img}}" wx:for-item="img" wx:for-index="imgIdx">
  <image src="{{img}}" mode="aspectFill" catchtap='previewImg' data-comment-idx="{{idx}}" data-img-idx="{{imgIdx}}"></image>
</block>
</view>
```

以上代码在原有代码的基础上增加了以下属性：1）在每一张 image 图片上注册一个事件 catchtap="previewImg"，用来相应点击图片的操作。2）在 block 标签上新增 wx:for-index="imgIdx"，用以定义图片序号。3）在每一张 image 图片上绑定了ー个自定义属性：data-comment-idx="{{idx}}"，用来绑定当前评论在评论数组中的序号，并在 previewImg 方法中获取这个序号。

接着在 post-comment.js 中实现 previewImg 这个方法。

```
  // 预览图片
  previewImg:function(event){
    // 获取评论号
    var commentIdx = event.currentTarget.dataset.commentIdx,
      imgIdx = event.currentTarget.dataset.imgIdx,
      imgs = this.data.comments[commentIdx].content.img;
      wx.previewImage({
        urls: imgs,
        current:imgs[imgIdx]
      })
```

注意 wx.previewImage 的用法，它接收一个 object 对象，对象的 urls 数组定义了一组需要预览的图片 url；而 current 定义了当前展示的图片 url。完成以上代码后，保存刷新项目。这时，我们会发现点击评论中的某一张图片后会打开图片预览窗口，但图片并不会显示出来。

wx.previewImage 在当前 130400 版本中有以下几个情况会造成无法预览图片：1）wx.previewImage 只能预览位于网络中的图片，而无法预览本地图片。我们初始化数据中的图片是位于本地的，所以无法预览。开发者可以将 data.js。文件中的文章评论图片地址更换为以 http 开头的网络地址；2）除了网络地址和本地地址，还有一种地址是小程序的临时文件地址，对于这样的临时文件地址，同样在模拟器中无法预览，但在真机中却可以预览。关于临时文件地址，我们将在后面学习 wx.chooselmage 方法时看到。

注意，在目前的 130400 版本中，本地文件既无法在模拟器中预览，也无法在真机中预览；临时地址文件无法在模拟器中预览，却可以在真机中预览。130400 版本的下ー个版本已经放出了 beta 测试版，官方文档在版本说明中指出有可能会修复 wx.previewImage 不支持 localld 的问题。经下载测试版测试，开发工具中可以预览来自临时文件地址的图片，但依然不可以预览本地图片。总体来说，这些怪异的现象对我们开发小程序影响不大，因为在真实项目中评论显示的图片都来自于服务器，所以无论是在模拟器中还是在真机中都可以预览。

## 7.10 实现提交评论的界面

在前几节中我们完成了评论的显示功能。在这一节中我们将实现如何提交一条文本类型的评论。提交评论的功能区域如图 7-8 所示。点击提交功能区域最左侧的声音图标将可以由发送文本切换到发送语音，点击右边的加号图标将可以选择图片和拍照。我们一步步地完成以上各项功能。

2『化工 101 上实现提交评论的功能。』

首先需要完成的是文本类型评论的提交功能。在 post-comment.wxml 文件中新增一段代码，以显示评论区域。接着编写 post-comment 页面的样式，在 post-comment.wxss 文件中新增以下样式；保存后，可以看到评论框的大致模样。当然，我们还没有为评论框编写任何逻辑代码，此时开发工具有可能会报错。需要注意的是，代码清单 7-27 中的部分样式在代码清单 7-26 中并未全部用到，但我们在后续的代码中将会使用到。下面我们来对 wxml 里的新增代码关键部分做一些解释：

    <view hidden="{{useKeyboardFlag}}" class="input-item"> 表示录音输入框。

    <view hidden="{{!useKeyboardFlag}}" class="input-item"> 表示键盘输入框。

以上两个评论框由 useKeyboardFlag 这个 Boolean 变量来控制显示或者隐藏。useKeyboardFlag 变量将由 catchtap="switchInputType" 这个事件来控制。

catchtouchstart="recordStart" 和 catchtouchend="recordEnd" 将开启录音和结束录音。

    <input class="input keyboard-input"> 实现文字内容的录入。

关于 Input 组件的使用，我们将在后面详细介绍。

catchtap="sendMoreMsg" 将实现向内容中添加图片和拍照选择框的功能。

catchtap="submitComment" 将实现评论内容的最终发送功能。

### 7.11 wx:if 与 hidden 控制元素显示和隐藏

在小程序中，最常用的显示 / 隐藏 UI 元素的方法有两种：一种是之前我们介绍的 wx:if，另外一种是 hidden。我们特别在代码清单 7-26 中使用了 hidden 这种方式来控制元素的显示和隐藏效果。

在代码清单 7-26 中，注意以下两段代码。

```
<view hidden="{{useKeyboardFlag}}" class="input-item">
<view hidden="{{!useKeyboardFlag}}" class="input-item">
```

hidden 的使用方式与 wx:if 类似，都是通过一个状态变量来控制元素的显示和隐藏。

当 useKeyboardFlag 为 true 时，第 1 个 view(hidden={usekeyboardflag}) 将被隐藏，而第 2 个 view(hidden={!usekeyboardflag}) 将被显示。当 useKeyboardFlag 为 false 时，则第 1 个 view 被显示，第 2 个 vew 被隐藏。

那么 wx:if 和 hidden 之间有什么异同吗？wx:if 的切换和渲染机制较为复杂。当 wx:if 进行切换时，MINA 框架有一个局部渲染的过程，它确保条件块在切换时销毀或重新渲染。同时 wx:if 也是惰性的，如果初始渲染条件为 false，那么框架什么也不做，在条件第一次变成真的时候才开始局部渲染。相比之下，hidden 就简单得多了，组件始终会被渲染，只是简单地控制显示与隐藏。一般来说，wx:if 有更高的切换消耗，而 hidden 有更高的初始渲染消耗。因此，在要频繁切換的情景下用 hidden 更好，在运行时条件不大可能改变时用 wx:if 较好。

### 7.12 实现文字评论框和语音评论框的切换

编写完页面的 wxml 和 wxss 文件后，我们来继续编写这些组件的业务逻辑。首先实现「按住说话」和「说点什么吧...」这两个组件的切换效果。之前我们提到过，实现语音和文字评论框切换的效果关键是控制 useKeyboardFlag 这个变量。

1『js 文件对应于 JavaScript，是定义行为的，是业务逻辑，要有这个概念。』

```
  // 切换语音和键盘输入
  switchInputType:function(event) {
    this.setData({
      useKeyboardFlag: !this.data.useKeyboardFlag
    })
  }
```

在 post-comment.js 文件的 Page (object）方法的 data 属性下新増一个 useKeyboardFlag 变量作为初始化的数据绑定变量。useKeyboardFlag 初始值为 true 将导致评论框默认显示为键盘类型的输入框。接着编写 switchInputType 方法来切换 useKeyboardFlag 这个控制变量。此时，点击评论框最左侧的小图标将可以实现语音评论框和文字评论框的相互切换效果。接着实现发送文字评论的功能。在实现发送文字评论功能之前，我们需要学习一个非常重要的组件：Input 组件。

### 7.13 input 组件

input 组件是最为重要的数据输入组件，比如我们这里要输入用户的评论信息时就需要用到这个组件。input 组件目前拥有以下若干属性：1）value String 类型，设置 input 输入框的初始内容。2）type String 类型，input 组件目前有 4 种类型，即 text、number、idcard、digit，默认是 text 类型。3）password Boolean 类型，如果设置为 true，就会用 * 号来遮蔽输入，默认为 False。

4）placeholder String 类型，输入框为空时的占位符。所谓占位符，就是当输入框内没有任何用户输入时默认显示的文字，比如 post-comment 页面文字输入框中默认显示的「说点什么吧...」。5）placeholder-style String 类型，指定 placeholder 的样式。可以将 placeholder 的样式编写在这里，形如组件中的 style 属性一样，只不过 placeholder-style 属性专门用来编写 placeholder 样式，而非编写整个 input 的样式。比如你可以这样写：placeholder-style="color:#333B; font-size:24rpx"。6）placeholder-class String 类型，如果你不想在组件的标签上写样式，就可以使用这个属性来指定一个已编写好的 CSS 类名，如同标签的 class 属性一样使用。

7）disabled Boolean 类型，用于设置是否禁用 input 组件，默认值为 false。8）maxlength Number 类型，最大输入长度。设置为 -1 的时候不限制最大长度，认值为 140。9）cursor-spacing Number 类型，指定光标与键盘的距离，单位是 px。取 input 距离底部的距离和 cursor-spacing 指定的距离的最小值作为光标与键盘的距离，默认值为 0。10）focus Boolean 类型，自动获取焦点并拉起键盘，默认值为 false。如果某个页面的 input 组件包含这个 focus 属性，且将其值设置为 true，那么当进入这个页面后光标将自动定位到 input 中，且会自动拉起输入键盘。

以上是 input 的所有属性。接下来我们看看 input 组件的 4 个事件，这 4 个事件才是 input 组件的重点和难点：1）bindinput。2）bindfocus。3）bindblur。4）bindconfirm。

注意以上事件和我们常用的 catch、bind 开头的通用事件是有区别的。它们是由 MINA 框架直接指定的，不需要在事件名称前再添加 catch 和 bind，干万不要写成 bindbindinput 或者 catchbindinput。此外，以上 4 个事件都属于非冒泡事件，这是它们和 catch、bind 等通用前缀事件的重要区别。形如 catchtap 等事件通常都是冒泡事件。

首先来看看 bindinput。bindinput 事件较为特殊，具有以下几个特点：1）当用户输入字符时触发。2）每当用户输入或者删除一个字符时，bindinput 事件都会触发一次。3）可以在事件响应函数中使用 return 返回一个字符或者字符串，该字符串将替换 input 输入框的显示文本。4）它非常适合用来做「即时搜索」的功能。

bindfocus，当 input 组件获取焦点时触发。我们将在本书后面的电影部分看到这个事件的用法。bindblur，当 input 组件失去焦点时触发。bindconfirm，122100 版本新增事件，专门用来响应真机上点击键盘「完成」按钮的事件。input 输入值都是在事件对应的响应函数中使用 event.detail.value 来获取的。

### 7.14 bindinput 事件

考虑到一些特殊的输入法键盘或者用户的习惯，我们除了支持点击真机键盘上的「完成」按钮发送文字评论外，还实现了一个小程序里的「发送」按钮。我们先来实现自定义的「发送」按钮。实现自定义发送评论功能的第一步就是能够在 js 中获取 input 的 value 输入值。我们使用 bindinput 事件来获取 inpute 的输入值。在 post-comment.js 文件中新增以下代码：

```
  // 获取用户输入
  bindCommentInput:function(event) {
    var val = event.detail.value;
    console.log(val);
    this.data.keyboardInputValue = val;
  }
```

1『又被书里的源码坑了，最后一行句法里应该有赋值 =，书里没有。』

使用事件的 event 对象下的 detail.value 来获取 input 的输入值，并将这个值保存在 this.data 中。除此之外，我们在代码中加入了一段 console.log(val），一起来看看 bindinput 事件是如何响应用户输入的。在 Input 输入框中不断输入任意字母，比如 q，再不断地删除 q。在 onsale 面板中将看到如图 7-9 所示的输出。可以看到，每次输入一个 q 都会触发 bindinput 事件，并 console 出当前的 input 值；每次删除一个字符 q 同样会触发 bindinput 事件，并输出当前的 input 值。

### 7.15 屏蔽评论关键字

bindinput 还有一个有意思的特性，就是在事件响应函数中可以 return ー个值来代替当前的输入值，并显示在 input 中。下面一起来看一下效果。将 bindCommentInput 函数内部的代码临时更改为以上代码（请注意在测试完毕后还原成之前的代码）。保存代码后，在 input 组件中不断地输入字符「q」，input 组件将显示如图 7-10 所示的内容。很明显，每次输入 q 后都会被更改为 q+。这个 return 的机制非常适合用来过滤关键字。如果不想让用户输入 「qq」「微信号」等关键字，就可以用这种方式强制过滤掉。我们以屏蔽「qq」这个关键字为例来看看如何实现屏蔽关键字。

以上代码实现了当用户输入「qq」时，自动被替换成「*」。注意，最后 return 的是一个 object 对象，该对象的 value 表示要替换的文本值，而 cursor 表示光标所处的位置。其实我们不需要关心 cursor 光标的位置，以上代码只是为了告诉开发者可以控制光标的位置。如果只想屏蔽掉关键字，只需要以下几行代码：

```
  // 获取用户输入
  bindCommentInput:function(event) {
    var value = event.detail.value;
    return value.replace(/qq/g, '*')
  }
```

当用户在 input 中连续输入两个 q 后，屏蔽关键字的效果如图 7-11 听示。

### 7.16 实现自定义发送按钮

在实现自定义发送按钮功能之前，请将 bindCommentInput 函数恢复成代码清单 7-30 中的代码。在代码清单 7-30 中，我们成功地获取了用户的输入，并将输入文本保存到了 this.data 变量中。发送按钮的事件响应函数是 submitComment。在 post-comment.js 的 Page 函数中添加以下代码：

submitComment 中首先构建了一条新的评论 newData。需要注意的是，newData 中硬编码了当前用户的用户名，头像分别是「青石」和「avatar-3.png」。当组装完这个 newData 的评论对象后，我们还需要经过以下 4 个步骤：步骤 1 —— 将 newData 保存到缓存数据库，以便下次打开评论页面时可以显示这条 newData；步骤 2 —— 显示评论发表成功的提示；步骤 3 —— 将当前发表的评论添加到评论列表中，并显示这条新添加的评论；步骤 4 —— 清空 input 组件，准备接收下一条评论。以上 4 个步骤分别对应着代码清单 7-34 中最未尾的 4 个方法调用。

首先来完成步骤 1。在 DBPost 中新增 newComment 方法，用来保存新评论到缓存数据库中。该方法内部再一次调用了 this.updatePostData 方法。我们来修改一下 updatePostData 方法，让其能够支持新增评论。完整的 updatePostData 如下：

相比之前的 updatePostData 方法，我们为该方法新増了一个参数 newComment，用以接收新的评论数据；接着在 case 中新增了ー个 case "comment" 分支，用来处理新增评论。这样步骤 1 就完成了。接着我们来编写步骤 2：显示评论发表成功的提示。在 post-comment.js 中新增 showCommitSuccessToast 方法：

以上代码将完成步骤 2，继续来编写步骤 3：将当前发表的评论添加到评论列表中。在拥有 DOM 节点的对象中，比如在传统网页中，如果我们想插入一条评论，需要新增一个 DOM 节点，并将这个 DOM 节点 insert 插入到 DOM 数组中。在小程序中，我们没有 DOM，也只有一种方式可以操作数据，即数据绑定。不存在「新增一个 DOM，再将 DOM 节点插入到 DOM 对象数组中」这样的思路。

如果我们需要在已有的 n 条评论中插入一条评论，并在 UI 中显示这 n+1 条评论，我们只能将这 n+1 条评论全部重新做数据绑定。我们在实际项目中会有大量插入元素的需求，请开发者牢记这个思路。在 post-comment.js 的 Page 方法中新增以下方法：

1『小程序里实现「将当前发表的评论添加到评论列表中」，通过数据重新绑定的这个思路很重要。』

以上方法重新去缓存数据库中加载全部的评论并再次使用 this.setData 将全部评论进行数据绑定。最后完成步骤 4：清空 input 组件，准备接收下一条评论。清空 input 组件的方法很简单，将 input 的 value 属性重置为空字符串即可。在 post-comment.js 的 Page 方法中添加以下代码：

resetAllDefaultStatus 方法重新绑定了 keyboardInputValue，将其值设置为空字符串。注意 keyboardInputValue 在之前的代码中已经被绑定到了 input 组件的 value 属性上了。完成以上 4 个步骤后保存并运行代码。先在输入框中输入一段文字，再点击右侧的发送按钮，条评论就会出现在评论列表中，且这条评论位于评论列表的顶部。

1『记得清楚缓存，不然评价无法更新显示到页面上。』

### 7.17 同时支持模拟器回车、真机点击「完成」发送评论

到目前为止，我们已经实现了自定义发送按钮发送评论的功能。我们再来实现在模拟器中以敲击键盘回车发送评论和在真机中点击键盘「完成」发送评论的功能。

如果想在模拟器中买现回车发送评论消息的功能，可以使用以下几个 input 事件：binchang、bindblur 和 bindconfirm。binchang 在早期版本中是有的，但官方在后来的文档中去掉了这个事件，截至 130400 版本，binchang 依然有效。虽然它依然有效，但是不建议使用官方文档未明确说明的事件。bindblur 可以触发回车的原理是，点击回车后，input 组件将失去焦点，从而触发 bindblur 事件。bindconfirm 可以在真机上响应键盘的「完成」点击事件，同时也可以在模拟器中响应键盘的「回车」敲击事件。

拿 bindconfirm 举例，修改 input 组件为如下代码：

```
<input class="input keyboard-input"  value="{{keyboardInputValue}}" bindconfirm="submitComment" bindinput="bindCommentInput" placeholder="说点什么吧……" />
```

我们仅仅在 input 组件上新增了ー个 bindconfirm 事件，这个事件的响应函数与自定义发送按钮所向应的事件函数相同，同样都是 submit Comment。这样就可以同时实现自定义发送按钮发送评论、模拟器回车发送评论和真机上点击「完成」发送评论的功能。

开发者还可以依次将 bindconfirm 更换为 bindblur 和 binchang，看一下它们的效果。虽然以上 3 个事件都可以实现回车的效果，但建议使用 bindconfirm 事件作为 input 的「确定」事件。

1『验证了，bindconfirm 和 bindblur，在模拟器上可以直接按「回车」发送消息，但 binchang 不行。』

### 7.18 图片与拍照评论的界面实现

我们接着实现图片和拍照评论。先来实现以下效果：当点击 + 号按钮后，出现选择图片和拍照的界面，如图 7-12 所示。首先在 post-comment.wxml 中添加图 7-12 所示的骨架代码。对应的 CSS 代码已在代码清单 7-27 中添加完毕，不需要再次编写。

这段代码的开头部分有一段 \<view class="send-more-box" hidden="{{!sendMoreMsgFlag}}">。sendMoreMsgFlag 变量将控制整个面板的显示和隐藏。默认状态下它是隐藏的，所以我们首先在 post-comment.js 的 Page 方法 data 属性下设置 sendMoreMsgFlag 的初始状态。

sendMoreMsgFlag 的状态被我们设置成了 false。这样在默认状态下图片与拍照面板是不会显示的。事实上，即使我们不在 data 下面设置 sendMoreMsgFlag，面板依然不显示，因为如果找不到这个变量，默认这个变量的取值就是 false。为了代码的可读性，建议开发者将变量明确地在 data 属性中标注出来。这样的习惯应该成为我们开发小程序的一个小小约定。keyboardInputValue 变量也是基于这个原因而设置了一个空的字符串。keyboardInputValue 是之前控制 input 组件初始值的变量，我们在代码清单 7-39 中使用了这个変量，开发者可自行回顾。

1『「keyboardInputValue: '',」之前不明白这行代码的意义，上面的解释解答了，为了代码的可读性。』

接着实现 sendMoreMsgFlag 方法，它将切换 sendMoreMsgFlag 变量，以实现面板的切换和隐藏。sendMoreMsgFlag 方法已经被我们在代码清単 7-26 中注册到了以下图片的 catchtap 事件上。在 post-comment.js 的 Page 中新增 sendMoreMsgFlag 方法。

```
  // 显示照片、拍照等按钮
  sendMoreMsg:function(){
    this.setData({
      sendMoreMsgFlag:!this.data.sendMoreMsgFlag
    })
  },
```

成以上代码后，我们再次点击 + 号图标，拍照面板将动态地显示和隐藏。








