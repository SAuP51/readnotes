## 记忆时间

## 卡片

### 0101. 反常识卡——

这本书的主题核心，就是最大的反常识卡，并且注意时间脉络。

#### 01. 常识

#### 02. 反常识

#### 03. 知识来源

比如提出者，如何演化成型的；书或专栏具体出现的地方。

#### 04. 例子

### 0201. 术语卡——

根据反常识，再补充三个证据——就产生三张术语卡。

例子。

### 0202. 术语卡——

### 0203. 术语卡——

### 0301. 人名卡——

根据这些证据和案例，找出源头和提出术语的人是谁——产生一张人名卡，并且分析他为什么牛，有哪些作品，生平经历是什么。

维基百科链接：有的话。

#### 01. 出生日期

用一句话描述你对这个大牛的印象。

#### 02. 贡献及经历

#### 03. 论文及书籍

#### 04. 演讲汇总

找一个他的 TED 演讲，有的话。

### 0401. 金句卡——

最后根据他写的非常震撼的话语——产生一张金句卡。

### 0501. 行动卡——

行动卡是能够指导自己的行动的卡。

### 0601. 任意卡——

最后还有一张任意卡，记录个人阅读感想。

[codeyu/orange-can-step-by-step: 微信小程序开发入门与实践](https://github.com/codeyu/orange-can-step-by-step)

## 06. 文章详情页面

### 1. 逻辑脉络

详情页面的编码工作，不同页面间参数的传递技巧，页面跳转的方法、动态设置导航栏标题等，以及如何解决元素的垂直居中。

### 2. 摘录及评论

### 6.1 跳转到文章详情页面

首先新建文章详情页面。在 app.json 的 pages 数组下新增页面路径：

"pages/post/post-detail/post-detail"

保存后，开发工具会自动生成 post-detail 页面的 4 个文件。首先要实现的是从 post 文章页面通过点击跳转到 post-detail 详情页面。

在 post.wxml 中的 block 代码块里注册一个事件。

```
  // 跳转到列表详细页面
  onTapToDetail(event){
    wx.navigateTo({
      url: 'post-detai/post-detail',
      success: (result)=>{
        
      },
      fail: ()=>{},
      complete: ()=>{}
    });
  },
```

以上代码仅仅在 template 上增加了一个 catchtap。接着，在 post.js 中编写这个事件的响应函数 onTapToDetail。

添加完 onTapToDetail 函数后，保存运行，并在文章列表页面点击任意一篇文章。没有任何反应，页面也没有跳转。为什么会这样？

### 6.2 不要在 template 上注册事件

看起来似乎是事件函数并没有响应。此时我们可以在 wxml 面板中看一下现在页面的骨架结构，如图 6-1 所示。

是的，注册事件的 template 消失了。在前面章节中我们讲过，template 标签仅仅是一个占位符，在编译后会被 template 的模板内容替换。所以，在 template 上注册事件是无效的。那么在 block 标签上注册可以吗？来试试，将 catchtape 的事件注册到 lblock 标签上。

同样不可以，因为 block 也会在编译后「消失」。

那么，我们只有在 template 的外部增加一个 view，将 template 给包裏起来，并将 catchtap 事件注册到 vew 组件上。保存后，点击 5 篇文章中的任意一篇，就可以正确地跳转到 post-detail 文章详情页面了。

```
  <block wx:for="{{postList}}" wx:for-item="item" wx:for-index="idx">
    <view catchtap="onTapToDetail">
      <template is="postItemTpl" data="{{...item}}"/>
    </view>
  </block>
```

1『用 catchtap 或者 catch:tap 都可以。』

### 6.3 页面间传递参数的 3 种方式

我们实现了从文章列表页面跳转到文章详情页面。要正确展示文章详情页面的内容，首先需要将文章的 id 号由 post 页面传递到 post-detail 页面，这样，post-detail 页面才能知晓它要显示哪篇文章。这涉及页面间的参数传递与通信。目前，在 MINA 框架中有以下几种参数传递方式：1）使用全局变量（关于全局变量，本书后面的章节中会讲到）。2）使用缓存。3）通过页面导航 url 的 query 参数传递。

基本上参数的传递只有以上 3 种方式，其他的比如像事件信号的传参方式（一个页面 emit 发送信号，一个页面 on 监听信号，这种在 AngularJS 里很常见的传参方式，小程序是不能天然支持的），其实都是这些基本思路的变种。

全局变量我们将在后面讲到，至于缓存的传参方式，开发者在学习完缓存后应该很容易想到。其实，使用缓存数据库存储 data.js 初始化数据，又在 post.js 中读取缓存数据，这其买就是页面间的参数传递。仔细想想，是不是这样？1）和 2）两种都涉及全局变量，笔者个人不推荐这种污染全局的传参方式，而且我们的需求仅仅是两个页面间传递参数，完全不需要干抗全局。所以，选用方法 3 来做页面间的参数传递。

组件的自定义属性。再来整理下思路。要将 postId 由 post 页面传递到 post-detail 页面，首先需要在 post.js 中获取到 postId，随后再将 postId 附加到代码清单 6-2 中的 wx.navigateTo 的 url 中。要想在 post.js 中获取到 postId，就必须知道当前点击的文章是哪一篇文章。我们首先将 postId 绑定到每一篇文章的 wxml 中，使 postId 成为文章 wxml 的一个属性。注意，postId 已在 5.13 小节中加入到 data.js 文件里。绑定 postId 的方法很简单，就如同绑定文章的 date、title 等属性一样。post.js 文件的代码无须任何改动，只需要对 post.wxml 文件做一下改动即可。

以上代码中，我们在 view 里增加了一个属性 data-post-id="{{item.postId}}"，先来看看以上代码有什么效果。保存并运行代码后，打开调试中的「wxml」这个面板，文章页面的骨架如图 6-2 所示。从图 6-2 中可以很明显地看到，每篇文章的 id 号都被绑定在了该文章的 view 容器上，剩下的工作就是，如何在 post.js 中获取当前点击的文章的 id 号。

通过 dataset 获取组件自定义属性修改。修改 文post.js 文件中的 onTapToDetail 函数如下：

```
  onTapToDetail(event){
    var postId = event.currentTarget.dataset.postId;
    console.log(postId);
    wx.navigateTo({
      url: 'post-detail/post-detail?id='+postId,
      success: (result)=>{
        
      },
      fail: ()=>{},
      complete: ()=>{}
    });
  },
```

上述代码中，我们通过 event.currentTarget.dataset.postId，这段代码成功地拿到了当前文章的 postId。event 事件对象是由 MINA 框架在调用 onTapToDetail 函数时传递的参数。在 event 事件对象中，有一个 currentTarget 代表事件绑定的当前组件。

重点是 dataset 对象，dataset 对象里包含当前组件中所有属性名以 data-开头的自定义属性值。我们在代码清单 6-5 中的 view 上绑定了 data-post-id，所以通过 dataset.postId 将可以拿到当前组件的 postId。

组件自定义属性名有以下规则：1）必须以 data-开头。2）多个单词由连字符「-」链接。3）单词中最好不要有大写字母，如果有大写字母，除单词第一个字母外，其余大写字母将被转化成小写。4）在 js 中获取自定义属性值时，多个单词将被转化驼峰命名。

看起来很复杂，但举几个例子就非常清楚了，如表 6-1 所示。在获取到 postId 后，我们将 postId 附加在导航 url 的 query 参数中：url: 'post-detail/post-detail?id='+postId

获取页面参数值。再来看看如何在 post-detail 页面中获取 postId，在 post-detail.js。文件中添加以下代码：

```
  onLoad: function (options) {
    var postId = options.id;

  },
```

接受 post 页面传递参数的方法是通过 post-detail 页面 onLoad 函数里的 options 参数来获取。options 参数是由框架传递的。注意，这里 options.id 中的「id」必须同代码清单 6-6 中 navigateTo 中 url 的 query 参数名称保持致。比如，在 query 参数中使用的是 name=postId，则这里要相应地使用 options.id。

### 6.4 编译时设置初始化页面及参数

现在我们主要的代码编辑工作集中在 post-detail 这个页面。但每当保存刷新小程序后，项目都将从欢迎页面启动。我们不得不依次点击启动页面、文列表，才能进入到文章详情页面以预览文章详情的效果，这相当的麻烦。当然可以按照 4.1 小节中的方法，将 post-detail 页面设置为 app.json 中 pages 数组的第一项，但 post-detail 还需要传入ー个 postId 的参数才可以正确地运行，且手动来回更改 pages 数组非常麻烦。

小程序在 122100 版本中增加了编译选项，在此版本中，官方提供了一个「自定义编译」功能，可用于定义小程序的启动页面，如图 6-3 所示。122100 版本后，「编译」这里变成了两个选项，请仔细查看。上面一个图标是默认编译，下面的图标是自定义编译，点击下面的图片将弹出如图 6-4 所示的界面。

启动页面一栏中将路径设置为 post-detail 页面的启动路径：pages/post/post-detail/post-detail，页面自定义参数类似于 url 中的 query 参数，设置 id=2 将可以在页面中通过 onLoad 函数中的 options.id 获取到这个值。设置完成后，必须勾选【使用以上条件编译】这个选项。

保存刷新页面，项目将直接进入 post-detail 页面，不再出现 welcome 启动页。同时，我们发现，以这种方式打开的 post-detail 页面无法再返回到 post 页面，因为不是通过 post 页面导航到 post-detail 顶面的。可以通过「&」连接多个页面参数，比如 id=2&name="MR.L"，同时将两个参数传递到 post-detaill 页面中。有了以上功能，就可以非常方便地调试 post-detail 页面。如果想恢复默认的启动页，只需去掉【使用以上条件编译】选项即可。

### 6.5 读取文章详情数据

现在，我们已经在文章详情页面中拿到了文章的 postId，接下来需要根据这个 postId 去缓存数据库中读取文章详细数据，并将数据用于构建文章详情页面。所有对于缓存数据库的操作，我们都会放在 DBPost 这个对象中，在 DBPost.js 中增加和修改部分代码。注意，以上代码只标注出了相关修改和增加代码，并非全部代码。首先修改 constructor 构造函数，增加一个构造参数 postId，并将 postId 保存到 this 变量中。接着增加一个方法 getPostItemById() 用于获取指定 id 号的文章数据。

```
class DBPost {
  // 构造函数里的传入参数从原来的 url 改成 postId
  constructor(postId) {
    this.storageKeyName = 'postList';
    this.postId=postId;
  }

  // 得到全部文章信息
  getAllPostData() {
    var res = wx.getStorageSync(this.storageKeyName);
    if (!res){
      res = require('../data/data.js').postList;
      this.execSetStorageSync(res);
    }
    return res;
  }

  // 本地缓存，保存/更新
  execSetStorageSync(data) {
    wx.getStorageSync(this.storageKeyName, data);
  }

  //获取指定id号的文章数据
  getPostItemById() {
    var postsData = this.getAllPostData();
    var len = postsData.length;
    for (var i=0;i<len;i++) {
      if (postsData[i].postId == this.postId) {
        return {
          // 当前文章在缓存数据库中的序号
          index: i,
          data: postsData[i]
        }
      }
    }
  }

};

export {DBPost}
```

DBPost.js 修改完毕后，我们尝试在 post-detail.js 中获取指定 id 号的文章数据，并使用 this.setData 绑定该数据。

```
  onLoad: function(options) {
    var postId = options.id;
    this.dbPost = new DBPost(postId);
    this.postData = this.dbPost.getPostItemById().data;
    this.setData({
      post: this.postData
    });
  },
```

1『之前把上面的代码写进 post.js 里了，导致错误，找了很久才发现这个错误。』

注意上述代码中，在使用 new 实例化 DBPost 后，将 dbPost 这个对象保存在了变量 this 中，这样以后如果要再次使用 DBPost，则不需要再重新实例化这个对象，只需要使用 this.dbPost 即可弓用这个对象。

### 6.6 文章 id 号的数据流向图

我们来疏理一下，post-detail.js 是如何从初始化数据中拿到文章 id 号，并最终通过 id 号来获取到文章详情数据的，参见图 6-5 所示。文章 id 号最初是存在于 data.js 中的，通过一系列的事件操作，它最终会被传递到 post-detail.js 中。一旦 post-detail.js 拿到文章的 id 号，该页面就可以根据 id 号来获取文章详情数据了。

1『数据的流向很清晰：data.js 里初始化数据进入缓存，post.js 从缓存里读取数据，post.js 绑定数据到 post.wxml 里，post.wxml 里通过 catchtap 事件回到 post.js 里，在 post.js 里通过导航 URL 到 post-detail.js，post-detail.js 使用  id 号读取数据到缓存，缓存数据里筛选出文章详细数据回 post-detail.js 然后给与展现。』

### 6.7 编写文章详情页面

在代码清单 6-9 中，我们获取了文章的 postId，并通过 DBPost 查询到了该文章的相关数据，随后我们用 this.setData 函数做了文章数据的数据绑定。下面，我们来编写文章详情页面的骨架和样式。在 post-detail.wxml 中加入以下页面骨架代码：

```
<view class="container">
  <image class="head-image" src="{{isPlayingMusic?post.music.coverImg:post.postImg}}"></image>
  <image catchtap="onMusicTap" class="music" 
  src="{{isPlayingMusic?'/images/icon/wx_app_music_stop.png':'/images/icon/wx_app_music_start.png'}}">
  </image>
  <text class="title">{{post.title}}</text>
  <view class="author-date">
    <view class="author-box">
      <image class="avatar" src="{{post.avatar}}"></image>
      <text class="author">{{post.author}}</text>
    </view>
    <text class="date">{{post.dateTime}}</text>
  </view>
  <text class="detail">{{post.detail}}</text>
</view>
```

还是要注意代码中 {{}} 中的数据绑定语法一定要正确，否则无法读取数据。保存并运行代码，post-detail 页面将显示这些文章数据，但整个页面的样式是错乱的，因为还没有编写 post-detail 页面的 wxss 文件。保存并刷新页面后，文章详情页面将正确地显示出来，如图 6-6 所示。

### 6.8 垂直居中问题的经典解决方法

我们在编写 CSS 时，很多时候都会面临如何将两个元素垂直居中对齐的问题。比如在代码清单 6-11 中如何将作者名称（author）和作者头像（avatar）垂直居中对齐。我们在 3.4 小节中学习了 flex，这里就来看看如何使用们 flex 解決这个问题。

```
.author-box {
  display:flex;
  flex-direction: row;
  align-items: center;
}

.avatar {
  height: 50rpx;
  width: 50rpx;
}

.author {
  font-weight: 300;
  margin-left: 20rpx;
  color: #666;
}
```

以上代码摘自 post-detail.wxss。解决思路如下：将 avatar 和 author 用一个容器包裹起来（author-box），使用 display:flex 将该容器设置为们 flex 盒子模型，使用 flex-direction: row 指定 flex 的方向为 row。关键的代码是 align-items: center，这将使 flex 盒子里的元素在交叉轴方向上居中。在本例中主轴是水平方向（因为设置了 flex-direction 为 row），所以交叉轴是垂直方向，align-items: center 将控制垂直方向居中。关于 flex 及轴的概念已经在 3.4 小节中详细讲解过，开发者可自行回顾一下关于主轴和交叉轴的概念。

开发者可以对比一下，welcome 页面中是如何使头像、文字和按钮这 3 个元素水平居中的。welcome 页面中设置了 flex-direction: column，所以主轴是垂直方向，align-items: center 将控制水平方向上的居中。小程序对于 Tex 的支持相当完善，建议多使用 flex 进行元素布局。

1『flex 框架很重要。』

### 6.9 动态设置导航栏标题

使用两种方法分别设置 post 页面和 post-detail 页面的导航栏文字。

使用配置文件配置导航栏标题。第一种方法是使用 app.json 或者页面的 json 文件来配置导航栏标题。如果是在 app.json 中进行配置，则它是全局行为，项目所有的页面将显示同一个标题；而如果是在页面的 json 文件中配置标题，则只会影响当前配置页面。我们之前在 app.json 的 window 属性中通过设置 navigationBarbackgroundColor 实现了指定导航栏的颜色。window 还有以下 2 个属性用于配置导航栏文本：1）navigationBarTextStyle 指定导航栏标题文字的颜色，只支持 black/white，默认值为 black。2）navigationBarTitleText 指定导航栏标题文字。在 app.json 中对 window 属性增加以上两个配置项，代码如下：

```
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#ecc0a8",
    "navigationBarTitleText": "大龙的书屋",
    "navigationBarTextStyle": "black"
  },
```

保存运行后可以看到，所有页面的导航栏都增加了「文字」这两个字，它的颜色为白色。这并不是我们想要的，我们希望不同页面显示不同的导航栏标题。下面来解决这个问题。我们之前讲过，window 这个配置项既可以在 app.json 中配置，也可以在 window 中配置（其他配置项只能在 app.json 中配置）。

使用 wx.setNavigationBarTitle(Object) 设置导航条。在某些情况下，我们希望导航栏的文字可以根据页面内容的不同而有所変化。比如在文章详情页面中，我们希望导航栏可以实时显示当前文章的标题，不同的文章显示不同的标题文字。来看看如何实现这个功能。小程序提供了 wx.setNavigationBarTitle(Object) 来动态设置导航栏标题。小程序官方文档中指出，页面的导航栏标题必须在页面生命周期的 onReady 之后来设置，否则无效。原文如下：对界面的设置如 wx.setNavigationBarTitle 请在 onReady 之后设置。我们遵照官方文档的说明，在 post-detail.js 中加入以下代码：

```
  onReady: function () {
    wx.setNavigationBarTitle({
      title: this.postData.title,
      success: (result)=>{
        
      },
      fail: ()=>{},
      complete: ()=>{}
    });
  }
```

按照文档的描述，我们在页面生命周期函数 onReady 中调用了 wx.setNavigationBarTitle(Object) 方法。它接收一个 object 参数，其中 title 属性被设置为当前文章的标题。保存运行代码，发现页面的导航栏文字变成了文章的标题。这里需要指出，在 122100 版本之前，wx.setNavigationBarTitle(Object) 方法确实只能在页面的 onReady 函数里设置。如果尝试在页面的 onLoad、onShow 函数里调用 wx.setNavigationBarTitle(Object) 方法，文章的标题将出现一闪而过的情况。这种情况是符合官方文档说明的：「对界面的设置如 wx.setNavigationBarTitle 请在 onReady 之后设置」。因为 onReady 在 onShow 发生之后才触发，onShow 将标题设置完毕后，onReady 会重新渲染页面并覆盖导航栏的标题，这就是我们说的「一闪而过」的情况。

但在最新的 130400 版本里，无论是在页面的 onLoad 或者 onShow 函数中调用 wx.setNavigationBarTitle(Object) 方法，都可以成功地设置导航栏标题，并不会出现一闪而过的情况。但无论如何，还是建议开发者按照官方文档所描述的，在 onReady 函数里进行界面的设置操作，以免官方在未来再次改动底层的运行机制时造成代码无法运行。

## 07. 收藏、评论、点赞与计数功能

### 1. 逻辑脉络

通过实现收藏、评论、点赞与计数功能，来学习使用小程序的交互反馈组件、缓存的应用、图片选择和预览、屏蔽关键字、录音、拍照以及播放录音等功能。

1）组件条件渲染 wx:if, wx:elif 和 wx:else，其中 wx:if 和 wx:elif 的值为条件变量，wx:else 不需要设置值。根据条件值是否为 true 判断应该显示哪个组件。2）交互式反馈 API：wx.showToast、wx.hideToast、wx.showModal 和 wx.showActionSheet。3）善用本地缓存。4）控制 UI 元素的显示与隐藏的另一种方式是使用 hidden 属性。它的值也是 bool 类型的变量。和 wx:if 用法比较：在需要频繁切换的情景用 hidden 更好；在运行时条件不大可能改变时用 wx:if 更好。5）input 组件的用法。官方教程：input 组件。6）敏感操作需要获得用户主动授权。一定要处理用户拒绝授权的场景。

3『[input | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/component/input.html)』

### 2. 摘录及评论

本章通过编写几乎所有内容型应用都会附带的「评论」「点赞」「读计数」「收藏」等功能，来学习使用小程序的交互反馈组件、缓存的应用、图片选择和预览、屏蔽关键字、录音、拍照以及播放录音等功能。

### 7.1 收藏、评论、点赞、计数功能准备工作

我们先来编写收藏、评论和点赞的功能按钮。阅读计数是一项被动功能，无须用户有意识地主动触发。在 post-detail.wxml 中新增一段工具栏代码。

```
<view class="tool">
  <view class="tool-item" catchtap="onUpTap" data-post-id="{{post.postId}}">
     <image animation="{{animationUp}}" wx:if="{{post.upStatus}}" src="/images/icon/wx_app_liked.png" />
     <image animation="{{animationUp}}" wx:else src="/images/icon/wx_app_like.png" />
    <text>{{post.upNum}}</text>
  </view>
  <view class="tool-item comment" catchtap="onCommentTap" data-post-id="{{post.postId}}">
    <image src="/images/icon/wx_app_message.png"></image>
    <text>{{post.commentNum}}</text>
  </view>
  <view class="tool-item" catchtap="onCollectionTap" data-post-id="{{post.postId}}">
    <image wx:if="{{post.collectionStatus}}" src="/images/icon/wx_app_collected.png" />
    <image wx:else src="/images/icon/wx_app_collect.png" />
    <text>{{post.collectionNum}}</text>
  </view>
</view>
```

黑色加粗部分为新增代码。在 post-detail.wxml 页面的 container 中添加了一段 \<view class="tool"> 的相关代码。该代码实现了收藏、评论和点赞 3 个功能按钮。每个功能按钮都绑定了对应的点击事件，注意 view 组件上的 catchtap 属性。除此之外，我们还在每个功能按钮上使用 data-post-id 绑定了当前文章的 id。post.upNum、post.commentNum 和 post.collectionNum 等数据已经在 5.13 小节中全部添加到了 data.js 文件中，接着编写 3 个功能按钮的样式。保存刷新后，3 个功能按钮将出现在 post- detail 页面的正下方，如图 7-1 所示。

```
/*点赞和评论*/
.tool{
  height: 64rpx;
  margin: 20rpx 28rpx 20rpx 0;
  display: flex;
  justify-content: center;
}
.tool-item{
  align-items: center;
  margin-right: 30rpx;
  display: flex;
}

.tool-item image{
  height: 30rpx;
  width:30rpx;
  margin-right: 10rpx;
}

.comment image{
  transform: scale(.85);
}
```

### 7.2 文章收藏功能

我们首先来实现文章收藏功能。文章收藏功能需要记录两个变量值：1）自己是否收藏了文章。如果自己收藏了，那么需要将收藏的图片更换为已收藏。2）所有用户收藏文章的总数量。需要注意的是，由于我们的数据库只在本地，无法多次收藏同篇文章，所以收藏数量永远只能在初始数量的基础上 +1 或者 -1, 分别对应取消收藏和点击收藏两种状态。但在真实的项目中，这个收藏数量却是要受到所有用户取消、收藏文章动作影响的。同样的情况也会出现在「文章点赞」这个功能里。

当页面从 post 跳转到 post-detail 时，我们就需要知道该文章是否已被用户收藏。在 data.js 中，我们使用 collectionStatus 这个属性表示文章是否已被收藏，这个变量的类型是 Boolean。那么如何根据 collectionStatus 这个变量的取值来动态切换收藏图标呢？熟悉传统 Web 开发的读者很容易想到用 jQuery 获取 image 标签，再动态地设置 image 的 src 属性。再次强调，小程序没有 DOM，一切都是数据绑定，请抛弃 DOM 的思维方式。

条件渲染：wx:if 与 wx:else。collectionStatus，只有两种取值：true 或者 false。我们需要做的是，当 collectionStatus 为 false 时，显示图 7-2 未收藏状态的图标，而当 collectionStatus 为 true 时，显示图 7-3 收藏状态的图标。以上需求是不是就是编程中非常经典的 if else？如果 wxml 组件也像 js 代码一样有 if else 就可以解决动态显示收藏图片的问题。下面来看看如何实现这个功能。小程序提供了 wx:if 与 wx:else 来实现条件渲染。当变量为 true 时，执行 wx:if，否则将执行 wx:else。修改收藏按钮的 wxml 代码如下：

```
<view class="tool-item" catchtap="onCollectionTap" data-post-id="{{post.postId}}">
<image wx:if="{{post.collectionStatus}}" src="/images/icon/wx_app_collected.png" />
<image wx:else src="/images/icon/wx_app_collect.png" />
<text>{{post.collectionNum}}</text>
</view>
```

上述代码中我们添加了两个 images 组件，分别是收藏和未收藏图片。这两个 image 组件各有一个 wx:if 和 wx:else 属性。当 post.collectionStatus 为 true 时将显示 wx_app_collected.png 图片而当 post.collectionStatus 为 false 时将显示 wx_app_collect.png 图片。由于我们已经在 data.js 文件中将部分文章的收藏状态设置为 true，因此保存并运行项目，发现所有 collectionStatus 为 true 的文章，其收藏图片都将显示 wx_app_collected.png，如图 7-4 所示。

wx:if 与 wx:else 的条件渲染在小程序中被大量使用，不仅仅被用来做图片的更换，还可以用来控制元素的显示和隐藏。wx:if 可以被单独使用，并不一定要同 wx:else 一起使用。除此之外，条件渲染还可以做多级别的 if else，如代码清单 7-4 的示例代码所示。

如果变量 length 的取值大于 5，那么将显示数字 1。如果变量 length 的取值大于 2 且小于等于 5，那么将显示数字 2。以上条件都不满足，就显示数字 3。你还可以添加更多的 elif 分支，以实现更多级别的条件判断。

实现收藏点击功能。在 7.2.1 小节中，我们仅仅是在 post-detail 页面加载时读取了该文章对于当前用户是否为收藏状态，并正确地设置和显示了这个状态。在这个小节中，我们将实现用户点击图片进行文章的收藏和取消收藏功能。首先我们继续完善 DBPost 这个数据库操作类。在 DBPost 类中添加一个方法，用以处理文章的收藏操作。该方法中调用了 DBPost 类的 updatePostData 方法，这个方法我们还没有编写。在 DBPost 类中添加 updatePostData 方法。该方法是处理点赞、评论、收藏、阅读的核心方法。

1『数据库操作类 DBPost 的概念很重要，一定要有做一个操作类作为接口来预数据库（缓存）交互。』

```
  //更新本地的点赞、评论信息、收藏、阅读量
  updatePostData(action, newComment) {
    const itemData = this.getPostItemById();
    let postData = itemData.data;
    let allPostData = this.getAllPostData();
    switch (action) {
      case "collect":
        if (!postData.collectionStatus) {
          postData.collectionStatus = true;
          postData.collectionNum++;
        } else {
          postData.collectionStatus = false;
          postData.collectionNum--;
        }
        break;
      case "up":
        if (!postData.upStatus) {
          postData.upStatus = true;
          postData.upNum++;
        } else {
          postData.upStatus = false;
          postData.upNum--;
        }
        break;
      case "comment":
        postData.comments.push(newComment);
        postData.commentNum++;
        break;
      case "reading":
        postData.readingNum++;
        break;
      default:
        break;
    }
    allPostData[itemData.index] = postData;
    this.execSetStorageSync(allPostData);
    return postData;
  }

  collect() {
    return this.updatePostData('collect');
  }

  up() {
    return this.updatePostData('up');
  }
```

我们目前仅处理 collect 这一种操作，后续我们将继续在代码清单 7-6 的 switch case 中添加评论、读数、点赞等处理分支。这样，DBPost 就具备了处理文章收藏的能力。当用户点击收藏按钮后，在点击事件函数中调用 DBPost 的 collect 方法即可。处理文章收藏动作的事件函数是 onCollectionTap，这个事件函数已在代码清单 7-1 中被注册在了收藏功能按钮上。我们只需要在 post-detail.js 中编写这个方法即可。

```
  onCollectionTap: function (event) {
    var newData = this.dbPost.collect();
    // 重新绑定数据。注意，不要将整个newData全部作为setData的参数，
    // 应当有选择的更新部分数据

    this.setData({
      'post.collectionStatus': newData.collectionStatus,
      'post.collectionNum': newData.collectionNum
    })

    // 交互反馈
    wx.showToast({
      title: newData.collectionStatus ? "收藏成功" : "取消成功",
      duration: 1000,
      icon: "success",
      mask: true
    })
  },
```

1『开始的时候无法取消收藏，后来发现 DBPost 类里没有添加 collect() 方法，书里的源码没有提到这点。』


交互反馈 wx:showToast。现在，我们已经实现了文章的收藏与取消收藏功能，但收藏功能的体验并不好，用户在收藏和取消收藏后没有任何交互反馈提示。小程序提供了一些交互反馈 API 来帮助开发者处理交互相关的问题。目前，小程序提供了以下 4 个交互反馈 API：wx:showToast、wx.hideToast、wx:showModal、wx:showActionSheet。

我们选用 wx:showToast 来制作文章收藏功能的交互反馈。其中，object 参数的 title 属性用于设置提醒消息的内容；duration 设置提醒的自动消失时间，最长 10000 毫秒，默认值为 1500 毫秒；icon 可以设置一个小图标，其取值只能是 success 和 loading; mask 指定是否显示透明的蒙层，以防止触摸穿透，默认值为 false。mask 主要用来防止用户连续点击收藏按钮。开发者可执行尝试将 mask 设置为 true 和 false 时的不 同效果：当 mask 为 true 时连续点击收藏图标，图标不会连续做出收藏 / 取消收藏的响应；当 mask 为 false 时，就会不停地响应用户的点击操作。showToast 的效果如图 7-5 所示。

1『实现了收藏成功和取消收藏 2 个状态的来回切换，不过只是跳出来的显示消息，图标没有实现来回切换，下面的点赞功能一样，待解决。』

### 7.3 文章点赞功能

文章点赞功能的实现思路同收藏几乎是一样的。首先在 DBPost.js 中增加点赞的方法。接着在 DBPost 的 updatePostData 方法中处理当 case 为 up 时的情况。下面给出 updatePostData 的全部代码。黑色加粗部分为新增代码。代码清单 7-10 同代码清单 7-6 相比，仅仅增加了 case 为 'up' 时的这段代码。很明显，我们可以看到处理点赞的逻辑同处理收藏时的逻辑几乎一样：改变 upStatus 的状态，并对 upNum 这个计数变量做相应的增减操作。

我们编写完 DBPost 中关于点赞的接口后，接着编写 post-detail.js，和 post-detail.wxml 中关于点赞的相关代码。onUpTap 方法响应用户点赞的动作。当用户点击点赞按钮后，onUpTap 方法将调用 DBPost 的 up 方法并将返回的最新数据使用 this.setData 更新。类似于收藏功能，我们还需要使用条件渲染 wx:if 改写 wxml 中的点赞按钮。

以上代码将在 post.upStatus 为 true 时显示 wx_app_liked.png，当 post.upStatus 为 false 时显示 wx_app_like.png。在编写完以上代码后，保存运行项目，点击点赞按钮，图片会不断切换，点赞数也将相应地 +1 或者 -1。很多开发者可能还不太习惯使用数据绑定的方式来做样式、状态的切换，但数据绑定的写法确实非常简化、方便。我们只需要在 js 中改变各类变量的状态和值，前端组件就会响应我们的操作，动态地做出变化。

### 7.4 本地缓存的重要性及应用举例

提供本地的 key&value 缓存机制是小程序的一大特点，善用本地鍰存将可以极大地改善客户端的体验与服务器的性能。前几个小节中，我们大量地使用了本地缓存来模拟服务器的数据库。这样做一方面是因为我们并没有真实的服务器，必须依靠客户端的缓存能力来记录数据；另一方面是因为即使在真实的项目中我们拥有自己的远程服务器，也依然需要在客户端管理本地缓存。

举个例子，如果我们要实现一个城市列表插件，就必然要获取全国所有城市的信息。全国大概有 600 多个城市，这么大的数据量难道每次打开这个插件都要去服务器取城市数据吗？这些城市的数据相对非常稳定，并不会频繁变化，每次都去服务器加载是对流量和服务器性能的严重消耗。所以，最好的解決方案就是将城市数据保存在本地缓存中，而不是每次都去服务器请求数据。

在一个高性能的产品中，缓存的重要性是不言而喻的。建议开发者将本地缓存视作一个本地的 key&value 数据库，并封装一些类和公共方法，提供给项目中的各个调用方。最好不要让 getStorage、setStorage 等方法充斥在项目的每一个角落。Orange Can 项目中的 DBPost 类就是一个不错的示例，它实现了对缓存的良好管理，并向调用方提供了一系列可读性非常强的 API。建议开发者参考 DBPost 并将这种思路应用到自己的项目中。

1『这节缓存（本地数据库）的讲解启发很大。』

### 7.5 支持文字、图片、拍照、语音上传的文章评论

文章评论不仅可以发表文字，还可以上传图片和语音。评论页面将使用一个全新的 post-comment 页面，它属于 post-detail 的子页面。我们将通过点击评论功能按钮跳转到 post-comment 页面。

首先，在 app.json 的 pages 数组下注册 post-comment 页面。保存后将自动在项目里创建 post-comment 目录以及页面的 4 种类型文件。post-comment 将作为 post-detail 的子页面。在 post.js 中添加以下代码：

```
  // 跳转到评论页面
    onCommentTap:function(event) {
    var id = event.currentTarget.dataset.postId;
    wx.navigateTo({
      url: 'post-comment/post-comment?id='+id,
      success: (result)=>{
        
      },
      fail: ()=>{},
      complete: ()=>{}
    });
  },
```

以上代码将携带当前文章的 id 号并跳转到 post-comment 页面。

1『发现无需额外设置即可跳转，原以为还需在 post.wxml 里的组件里设置属性才能跳转。』



























