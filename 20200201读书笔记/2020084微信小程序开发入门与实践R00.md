## 记忆时间

## 卡片

### 0101. 反常识卡——

这本书的主题核心，就是最大的反常识卡，并且注意时间脉络。

#### 01. 常识

#### 02. 反常识

#### 03. 知识来源

比如提出者，如何演化成型的；书或专栏具体出现的地方。

#### 04. 例子

### 0201. 术语卡——

根据反常识，再补充三个证据——就产生三张术语卡。

例子。

### 0202. 术语卡——

### 0203. 术语卡——

### 0301. 人名卡——

根据这些证据和案例，找出源头和提出术语的人是谁——产生一张人名卡，并且分析他为什么牛，有哪些作品，生平经历是什么。

维基百科链接：有的话。

#### 01. 出生日期

用一句话描述你对这个大牛的印象。

#### 02. 贡献及经历

#### 03. 论文及书籍

#### 04. 演讲汇总

找一个他的 TED 演讲，有的话。

### 0401. 金句卡——

最后根据他写的非常震撼的话语——产生一张金句卡。

### 0501. 行动卡——

行动卡是能够指导自己的行动的卡。

### 0601. 任意卡——

最后还有一张任意卡，记录个人阅读感想。

## 模板

### 1. 逻辑脉络

用自己的话总结主题，梳理逻辑脉络，也就是这本书整个地图里这一章所在的节点。

### 2. 摘录及评论

1『自己的观点』

2『行动指南』

3『与其他知识的连接』

## 总体

本书主要围绕 Orange Can 项目展开一系列编码工作，用几近真实的项目介绍小程序的各个 AP、组件用法，并附带一些小程序开发的经验、技巧以及常见的误区说明。整个 Orange Can 项目分为三部分：文章阅读、电影资讯以及设置。文章阅读包括文章列表、文章详情以及评论通过编写文章阅读功能的代码，读者将学会 Swiper 组件的裁剪模式、image 组件的裁剪模式、缓存的使用技巧、列表渲染、数据绑定、模板、音乐播放、录音、分享等知识。除此之外，读者将对小程序页面的生命周期有一个大致了解。学习完这部分内容，读者将可以轻松做出一个内容型小程序应用。电影资讯功能主要介绍如何调用服务器数据及 template 模板的使用技巧。设置页面功能包含大量功能示例，包括获取硬件设备信息、罗盘与重力感应的应用、扫描二维码、用户登录、用户信息校验、解析用户加密数据、获取用户 openid、发送模板消息、微信支付等功能。本书还提供部分服务器的 PHP 代码，主要供用户登录、校验、解析加密数据、模板消息、微信支付等功能调用。本书内容丰富、注重实战，讲解通俗易懂。适合小程序开发人员、培训机构和企业内部培训使用。

什么是小程序？小程序在内测的时候，微信之父张小龙曾写了这样一段文字：「小程序是一种不需要下载、安装即可使用的应用，它实现了触手可及的梦想，用户扫一扫或搜一下就能打开应用，实现了用完即走的理念，用户不用安装太多应用，应用随处可用，但又无须安装卸载」。

有些人说：「轰轰烈烈的小程序其实也就真正火了一天。」2016 年，小程序预热，张小龙第一次提前一年高调把小程序拿出来讲（当时还叫应用号），被媒体炒得沸沸扬扬。一年后，上线的当天刷爆朋友圈和微信群。一周以后，当初轰轰烈烈的小程序并没有带来想象中的轰动，很少见到讨论它的内容。上线オ 4 天「罗辑思维」就宣布撒出，「今日头条」的小程序暂停了又恢复，剧情变化得太快，让人看不清小程序的前景，于是「小程序已死，张小龙或走下神坛」的论调随处可见。

但真的是这样的么？我认为还言之过早。第一批尝鲜小程序的开发者大多是互联网 App 的开发者，已经习惯了从平台获取流量的思路，在日活跃用户 7 亿的微信平台上推出新产品，大家都想占据先机，获取用户和流量。然而小程序不提供入口，不提供推荐，分享也不能分享到朋友圈。这无疑让早期抱着「蹭」流量目的的小程序开发厂商大失所望。

小程序适合的是场景化、服务型的产品。张小龙在演讲中清楚地描述了他想象中小程序应用的典型场景：在汽车站购买车票的时候扫码购票，无须在售票窗口排队；等公交时扫码启动程序，查询一下一辆车到达的时间。「摩拜」单车的小程序就是一个很好的基于场景化的应用。当你在马路上走累了看到一辆「摩拜」单车时，可直接通过微信的「扫一扫」扫描「摩拜」单车上的二维码，进入摩拜小程序页面，轻松解锁身边的「摩拜」单车开始使用，而不用从 App Store 里下载一个几十兆的 App 安装。

在我看来，小程序是张小龙对未来应用程序形态的希望。如今 App 实在是太多了，正如 2009 年 Phone 广告语所说「there's an app for that」。2016 年 6 月，IOS Appt 已经超过 200 万个，几乎做到了「there is an app for just about anything」。作为ー个智能手机的重度使用者，我的 Phone 手机里安装的 App 超过了 400 多个，很多 App 需要通过搜索找到后启动，但是常用的不超过 20 个，每天都使用的不超过 10 个。很难想象 5 年后、10 年后的应用程序还是这种形态，最好的状态莫过于当我有需要的时候它出现，解決我的需求之后它消失，大概就是张小龙所谓的「触手可及、用完即走」吧。

小程序不论后面的发展怎么样，都是微信团队对于未来应用形态的一种探索和尝试。难怪张小龙在小程序内测的时候在朋友圈晒了一张图，并配文说「程序猿的一小步，程序的一大步」。作为开发者，要时刻保持学习，保持对技术的敏感、对变革的敏感，只有这样在未来才不会掉队。遇到一个问题，先用最简单粗暴的方式解決，然后分析这个方案的优缺点，再找出更优秀的解決方案，通过不断「重构」，漸进式地加入对知识的理解。学会这种思维方式之后，在自身技术成长的道路上必将终身受用。

直到 2016 年 12 月 28 日微信公开课上，张小龙终于用一连串「没有」告诉了所有媒体和开发者，你们都是错的。小程序并不是你们想的那样：我说它只是用完即走的服务，那它就一定是用完即走的服务，不会帯有很强的媒体属性；我说没有应用市场，那官方就没有应用市场；我说扫一扫、搜一下就能打开小程序，那就没有第三种途径可以触及小程序。在当时，这些「没有」确实让很多开发者大吃一惊。

现在的小程序已初步具备了线上线下同步的維形。微信绕了一大圏儿，最终还是回归到了线上线下结合这个互联网运营的经典套路。此次推出新特性的意图也较为明显线下开疆拓土，线上现固固有优势和辅助线下发展。至于开发者到底是重线上还是重线下，或是二者结合，这就在于开发者的抉择了。反正线上线下都给了开发者，那就自己看着办吧。但以现在线上产品的完备程度来看，留给新产品的空间已经很小了。尝试着将目光投向线下也许是一个不错的选择，转变ー下思维也许会有一片新天地。

以前我们的思维是线下什么不方便，那就把线下移植到线上。比如交水电费不方便，那就线上交；火车飞机出行购票不方便，那就线上买。这些服务亳无疑问是互联网发展的必然衍生物。可还有很多活动是线上做不了的，或者说很多线下活动如果放在线上，就会变得索然无味。比如看电影，如果线上能代替线下，为什么还有那么多人购买电影票去看大荧幕？因为电影是一门光与影结合的艺术，需要环境和氛围的辅助才能体会光、影、音结合的美妙和震撼；再比如朋友聚会、同学聚会，大家在线上用微信视频一起聊个天行吗？这自然不行，因为感觉不到位。我们无法脱离线下，却又被线下的不方便所困扰。

在我看来，线上线下结合是一个必然趋势，微信希望的也是从线下挖掘新的流量与场景。线上的服务虽然很方便，但场景有限，人不可能纯粹地活在线上环境里，我们依然有大量线下活动。目前，互联网所能提供的服务品质和服务种类其实已经达到了一个极限，在科技没有革命性进步的情况下，还想从线上有所突破是不太现实的。看似 AI、物联网、VR 很火热，但它们离真正的普及还有很长一段路要走。当然，哪天人类的科技真能发展到像电影《星际穿越》中所描绘的智能、多维的层级，这就另当别论了。目前来看，线下的活动场景和机会还是挺多的，只不过还没有被充分挖掘。

所以，不要太过于执着于线上，换一种思路，挖掘一下线下的场景，也许是创业的一个突破口。线下有太多小程序非常适合的场景，拥有巨大的想象空间。虽然现在有不少 H5 服务于线下场景（如很多餐饮业提供的排号及点餐服务），但无论是从体验还是产品闭环上，都远远不及小程序。这点希望开发者能够去思考一下，不要强行用固化的思维看待小程序。这和技术无关，只和场景有关。

那么原生 App、H5 和小程序该如何抉择？至少从目前来看，如果只是一个纯粹的单一的线上小程序，相比于原生 App 还是有一定的劣势的，但在微信将小程序与公众号做了「强绑定」后，小程序的应用又变得非常的多元化，它们之间不再是「非此即彼」了；而在对比 H5 页面时，小程序的体验（使用体验与服务体验）还是要略有优势的，毕竟小程序是一个体系，但缺点是没有 H5 开放和自由，H5 依然是最佳的粘合剂，很适合嵌入到各个种类的产品与应用中。

无论创业者选择 App 还是小程序，或者二者齐头并进，都应当把做好产品放在第一位。不是说选择不重要，而是过分在意选择载体而忽略了本质，多少有些舍本逐末。回归产品本质，解決用户的问题也许才是每个开发者应该斟酌和思量的事情。对于小程序，更多时候我只是一个看客，它发展得好与不好对我而言没有太大影响。它发展得好，我这本书就有一定价值和意义，它发展得不好，未来这本书就如废纸一般，被读者丢弃在角落，蒙上一层厚厚的灰尘。我只是一个普通的开发者，这本书的内容也主要是讲解和技术本身相关的知识。它不是一本运营手册，仅仅是一本技术书籍，无论小程序未来发展如何，读者都可以从这本书里获取一些有用的知识。平台是多变的，但技术思维是相通的。

抛开繁杂的因素，仅从开发体验上讲，我非常喜欢小程序的灵巧。下载源代码后，不用配环境，只需要一个开发工具就能跑起小程序，这在现在越来越复杂的开发平台中是不多见的。也许小程序以后专业用来做原型代替 Axure 也不是不可能。此外，小程序非常适合开发者去践行自己的想法，以前移动端的开发成本太高，有很多想法因此都无法实现。但现在有了小程序就不同了，完全可以快速编写一个 MVP 产品，然后迅速投向市场去试错，再逐步送代、完善，最终考虑是否要推出自己的原生 App。

也许未来真的像张小龙所言，处处都是二维码；也可能未来的小程序就像历史上无数被技术更迭的浪潮所淹没的语言和平台一样，通于无形。可谁又能预测未来呢？互联网每天都有新贵诞生，也有王者陨落，成与败都在弹指之间，这在互联网的世界里是再平常不过的事情。对于一个寄生于超级 App 的平台而言更是如此，一切都是未知数。但无论如何，小程序这种即用即走的理念确实是现今主流 App 所缺失的。世界和科技总在不断变迁和进步，小程序这种形态的应用能否打破现在移动端的格局，我们目前还不得而知，但我相信这种理念确实值得认真思考一下，至于移动端的未来，还是交给时间吧。

本书的特点与特色。如果能让读者身临其境地开发一个几近真实的项目，在不知不觉中就可以学会小程序开发，那该多好。庆幸的是，小程序不是一门语言，它不需要像 Java、Python、Javascript 等基础语言教学一样罗列一个个基础语法，它最好的学习方式就是本书的「实践式」学习。因此，本书将用一个较为完整的「案例项目」把小程序的各个知识点「串接」起来，一边做项目，一边学习小程序的开发。做完一个项目就可以入门小程序是本书的目的。

我喜欢这种「实践式」学习所带来的「代入感」（如果你玩过各类角色扮演游戏，你就明白什么是代入感），跟着本书一步步 coding，你不仅收获了知识，更是直接完成了一个像模像样的小程序，这种成就感是学习编程最大的动力。即使你是一个基础较好的开发者，只看官方的文档也能学会小程序的开发，我依然建议你认真阅读本书，因为本书将为你节约大量「试错」时间。

本书在很多时候并没有直接给出一个问题的最优解決方案，而是首先给出一个看似很蠢的思路来解決问题。因为这是我们最直接的思维，也是最简单的解決方案。通过分析这个解決方案有什么缺点，最后给出一个更加优秀的解決问题的建议。我想，这符合我们编程里「重构」的概念。相比于直接给出最优解（事实上编程里很难有最优解，只是相对「优秀」），渐进式的解決问题更加能让读者体会到优秀解决方案的优势，避免对知识的生搬硬套。

我一直认为，本书的编写思路也是程序员自学的思路，由点及面、由具体到抽象。在工作中遇到了问题，想办法解决问题，查阅资料学习这个问题的相关知识点，最后把这些知识点总结、归纳，形成自己的知识体系，这是一个通用的学习「套路」。编程的各类语言、框架太多了，技术发展的速度也快得惊人，即使类似功能的框架也多达十几个，我们很难像学习经典数学、基础物理学、现代经济学这样先学习理论再付诸实践。Coder 有时就要有这种直面未知的勇气：先解决再学习，管它三七ニ十。

本书虽然定位于入门，但其中不乏一些小程序的进阶知识，这主要体现在微信开放接口上。学习微信开放接口不仅需要你拥有前端的知识，更要有一定的服务器编程经验，否则你很难理解为什么微信要这么设计开放接口的调用流程？为什么需要这么复杂的签名与令牌体系？

退一步讲，不理解也没关系，遇到类似问题和功能时，你知道怎么去解決即可。在编程里，我们不理解的东西太多了，谁能保证我们将做过的项目、产品每一个细节都理解得清清楚楚、明明白白？有时候记住怎么去做，比为什么这么做更加重要。理解清楚只是一个相对的概念，没人能够准确定义理解到什么程度才能称为「理解清楚」，也没有人能够说明深入到什么程度才算是「深入学习」。所以，有选择地学习原理，把更多精力放在解决问题上，我认为是一个正确的选择。

如果不考虑服务器，小程序开发只需要开发者具有 Javascript 和 CSS 相关知识即可。有很多文章说，开发者开发小程序还需要掌握 Vue、Angularjs，这有些强人所难了。小程序确实有很多和 Vue、Angularjs 相似的地方，这主要体现在数据绑定上。但 Vue 和 Angularjs 远比微信小程序要复杂得多，为了开发一个简单的小程序，学习远比这个简单的东西复杂多倍的框架实在没有必要。

从先来后到的角度看，Vue、Angularjs 等经典 MM 框架确实先于小程序出现，且小程序借鉴了许多这些 MVM 框架中的经典思想。但对于既没有开发过小程序，也没有任何 Angularjs、Vue 经验的开发者，这个先来后到的理念对你没有任何意义。反正都不会，自然是优先学习简单的，再进阶复杂的框架。如果你是一个 iOS 和 Android 转型过来的开发者，完全没有必要理会 Vue 和 Angularjs，小程序开发中的很多思想相信你在自己的 iOS 和 Android 领域已有体会。

如果你只是为了开发小程序前端部分，更没有必要学习 Nodejs。前端是前端，服务器是服务器，我们能把一端做到极致就已经非常了不起了。如果你想一个人开发一个完整的小程序，那服务器语言也没有规定必须是 Nodejs。选择一个你喜欢的服务器语言，PHP、Nodejs、Python、Java、C#、Ruby 都是可以的。

小程序开发需要掌握什么，在我看来是一个伪命题。小程序应该成为零基础入门开发者学习前端的首选开发平台（以学习与实践为目的），因为它足够简单，又同现在的主流 MVVM 框架非常类似，学习曲线很平滑。它应该成为入门其他更复杂、功能更强大的框架的「垫脚石」。

对于一个传统的 Web 开发者，在编写小程序时只需要注意以下两点：1）小程序中没有 DOM，请放弃「首先获取 DOM，再操作 DOM」的思维。2）替代 DOM 操作的方法是「数据绑定」。控制组件显示隐藏、切换 CSS 样式、控制滚动条，这些很容易用 DOM 思维思考常见功能在小程序中都是通过「数据绑定」实现的。如果你想将代码写得更加优美和简洁，那么补充一些 ES6 和 LESS 的知识就更好了。

小程序开发难吗？说小程序是所有开发框架 / 平台里最简单的可能略微有些夸张，但说小程序是目前所有主流移动开发技术中最简单的亳不夸张。这种简单来自于两个方面：

第一，编写小程序只需要掌握 Javascript 和 CSS 两门语言。前端最难的是有太多 Web 前端框架、类库需要学习。但是，小程序里的 Javascript 是「裸奔」的，我们在 Web 开发中常用的各类框架 / 类库在小程序中统统无法使用。jquery、Zepto、Angularjs、Hightcharts、Echarts，这些 Web 前端学习中的一座座大山，小程序已经全部「干掉了」——小程序运行在一个 JSCore 中，它本身不支持 Web 中的 window 及 DOM 对象。有些 Javascript 库还是可以使用的，但真的没有必要了，小程序已经提供了简单的架构和内置的特性避免使用这些框架。例如，小程序默认使用 babel 将开发者代码所使用的 ES6 语法转换成三端都能很好支持的 ES5 代码，帮助开发者解决环境不同所带来的开发问题。你所需要掌握的是 Javascript 和 CSS，原则上讲，不再需要学习各类框架和库了。这无疑减轻了很多初学者的负担。

第二，小程序本身就是为轻量级应用所设计的平台，无论是开发工具、设计规范、API 设计，无不散发出一种「大道至简」的气息。你只需要从官方下载一个开发工具即可立即开始开发小程序，没有复杂的安装环境，没有复杂的目录结构，也没有复杂的打包、部署流程。小程序很多近似死板的规范无疑让开发者減少了很多工作量（不给你选择，自然简单）。关于对于开发者的约束，这个仁者见仁、智者见智，有人喜欢它的简单，也有人憎恨它的「不自由」。

我甚至认为小程序完全可以成为那些完全没有编程经验又想进入前端开发领域的人最好的入门平台。完全可以从小程序入手，通过小程序平滑的学习曲线，在熟悉编程逻辑后，再反向学习 Web 前端庞大的知识体系，从而进入这个行业。

本书中所描述的知识与小程序的行为都只在 130400 版本中测试和验证，无法保证以后小程序会不会更改这些行为。事实上，从最开始的内测版本到现在的 130400 版本，小程序不仅调整 APl，甚至经常会更改一些 MINA 框架的运行机制和行为，这将导致原本可以正常运行的代码突然变得有问题，需要重新调整。

虽然无法保证书籍中的代码和 API 完全不会变更，但我会通过微信公众号、知乎专栏等方式同读者交流，保持对书籍的网络更新。同时，也会持续维护 Drange Can 示例项目的源代码，保证项目能够正确、稳定的运行。截止本书出版之前，小程序最新版本为 0.14.140900。从 130400 到 140900 的版本更迭中，没有再出现因版本更新而造成的问题，项目代码运行良好。可以看到，小程序从 1 月 9 号正式开放后，APl 日趋成熟，基本能够保持稳定。

本书与官方文档的区别。本书并不想成为官方开发文档的「搬运工」，除了一些非常必要的地方会引用官方文档的说明，本书几乎不会大段复制官方文档。本书更多使用官方 API 文档完成一个项目，对官方文档的主要内容做详细的补充说明，并附带对文档内容的经验性总结。官方的 API 文档通常定位于工具类的速查手册而非教程。当然对于开发功底深厚的开发者，只靠开发文档也可以完成一个小程序项目，但通常需要耗费较长时间。开发文档只会告诉开发者有哪些能力，但这些能力如何使用还需要开发者自己探索。本书可以告诉开发者如何使用官方 API 完成我们自己的业务逻辑，并在这个过程中逐步熟悉官方 APl，从而达到入门小程序并自己开发一个小程序的目的。除此之外，目前来说，小程序的开发还是有不少「坑」的。本书尝试为开发者提前把这些「坑」踩踩，填实了，以帮助开发者集中精力开发业务，减少浪费在小程序 bug 上的时间。

总体的建议是，对于 Orange Can 顼目的文章和电影部分，应该一步步跟着书籍逐步实现这两个核心功能；而对于「设置」页面，结合源代码「看懂」本书中的内容即可。此外，对于 Orange Can 项目的 CSS 样式，建议开发者不要完全照搬本书的 CSS 样式，每个人编写 CSS 样式的思路干差万别，本书无法保证所有 CSS 样式都是有意义的，少部分 CSS 样式是为了「防御性」而编写的。重点是小程序相关的知识点和 Javascript 代码。

3『

源码下载地址：[TaleLin/orange-can: 《微信小程序开发入门与实践》第二版源代码](https://github.com/TaleLin/orange-can)

作者博客：[林间有风](http://7yue.pro/)

[小程序交流专区 | 微信开放社区](https://developers.weixin.qq.com/community/develop/mixflow)

[微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)

』

## 01. 微信小程序简介

### 1. 逻辑脉络

用自己的话总结主题，梳理逻辑脉络，也就是这本书整个地图里这一章所在的节点。

### 2. 摘录及评论

小程序无论从技术上还是从理念上都不是一个新事物：从技术上讲，它借用了 React Nativep 的一些概念，定义了一套微信自有的组件并根据运行环境的不同（PC、iOS、 Android）将这些组件编译 / 转化为对应平台的可运行组件；从理念上讲，百度早年的「轻应用」、QQ 右下角的「应用宝」还有支付宝里的各类小服务，早已是小程序的维形。

我们要清楚地认识到，能不能做和合不合适做是两个概念，这取決于小程序版本的各类应用相比原生 App 到底有哪些优势。可能是成本上有优势，可能是推广上有优势，也可能是同微信原生功能结合有优势，这需要开发者均衡考虑。本书还是以官方所谓的「用完即走的轻服务」为基本出发点进行论述。

「简单的」、「低频的」、「对性能要求不高的」应用适合用小程序来开发。小程序特别适合做线下的场景化应用，官方的一切措施都是为了将小程序导向线下。

「简单」是指应用本身的业务逻辑并不复杂，比如外卖应用「饿了么」，业务逻辑就非常简单：挑选想吃的菜肴，下单、付款；再比如在线购买电影票应用「猫眼」，就是为用户提供在线购买电影票的服务，整个服务的时间是短暂的，「买完即走」。还有各类 O2O 家政服务、打车类应用、天气预报类应用，都符合「简单」这个特性。相反，一些游戏类、社交类、视频直播类应用则业务相对复杂很多，用户在应用里停留的时间也会较长，这类应用就不太符合「简单」这个特性。对于业务复杂的应用，小程序无论从性能上和体验上都没有办法满足这类应用。

「低频」是小程序使用场景的第二个特点。如果某种应用的使用频度很高，比如社交类的 QQ，金融类的支付宝、招商银行，社区类的百度贴吧、知乎等，由于使用的频度较高，以 iOS 或者 Android 的形式提供给用户会更好。当你使用小程序时，需要先打开微信再进入小程序，这对于高频的应用并不是太方便。小程序目前来看，还是适合做一些如手机充值、电影购票这类使用频度不高的服务。举个例子，当你正在微信中聊天，突然想起手机没话费了，那么就「顺手」点开小程序为你的手机充值。但是，如果你经常需要特意地去寻找某类应用，又长期需要这类应用，那么还是以原生 App 的形式提供给用户比较好，用户为这类应用去下载、安装和管理这个应用的系列操作是值得的。

「对性能要求不高」是因为小程序寄生于微信这个原生 App 中，又受限于 Web 技术的性能制约，注定它无法去开发对性能、体验要求很高的应用，比如「保卫萝ト」、「阴阳师」等这类游戏应用。此外，小程序还处于发展初期，没有太好的技术和工具去支持这类复杂度较高的游戏（没有类似于 Unity3D 这样的专业游戏开发工具）。

首先，从技术上来讲，目前 App 的主流开发方式有三种：Web App、Native App 和 Hybrid App。

1、Web App。在微信「发现」里面有一个《购物」入口，点击进去打开的是京东的移动购物页面，这个页面实际上就是一个 Web App。支付宝的众多小服务也是 Web App，还有「海底捞」在微信中的排号应用，这类 App 其实就是我们经常在 PC 上浏览的网页，只不过加入了响应式的设计让它适合在移动端显示和运行，所采用的技术依然是 Javascript CSS 和 HTML。相对于其他两种 App，Web App 具有开发简单、高效，更新灵活、跨平台，大量的网页应用稍作调整即可放在移动端运行。但缺点与优点并存，Web App 性体验极差（对，是极差），无法使用照相机、系统通知、本地缓存等原生特性。

2、Native App。也称为原生 App。这种 App 不是采用 Javascript、CSS 及 HTML 开发，而是使用 Objective-C (iOS）或者 Java (Android）开发。微信、支付宝、斗鱼 TV 等都属于这类 App，是目前主流的开发方式。Native App 具有性能、体验非常良好，组件支持完善、接口丰富等特点。但 Native App 最大的缺点在于，不能跨平台，有多少个平台就要开发多少个版本，现在主要有 iOS 和 Android 两个主流平台，还好 Windows Phone 已没了踪影。

3、Hybrid App。也称为混合式 App。Hybrid Appa 看上去像一个 Native App，但实质上 Native 技术在这里只是作为一个容器，将 Web App 包裹了起来，在容器内部实质上运行的还是网页。Hybrid App 更像是 Web Apps 与 Native Appa 的混合体。与纯粹的 Web App 相比，Hybrid App 会有一部分访问原生组件（相机、加速器）的能力。事实上，目前主流的应用中，纯粹的原生 App 很少，绝大多数都属于混合式 App。比如，我们常见的京东、淘宝等电商类 App，由于商品及业务变化非常频繁，需要经常调整，所以这类 App 的主要页面都是采用 Web 技术来构建，只是用 Native 包装了ー下。那我们如何界定，哪些 App 属于「原生」，哪些 App 属于「混合」呢？答案是：看 Web 页面在 App 中所占的比例，如果绝大多数页面都采用 Web 技术构建，那么我们称为混合式 App；而如果只有少数页面采用 Web 技术，我们称为原生应用。举个例子，今日头条这类新闻应用中绝大多数页面都采用原生技术实现，笔者倾向于称它为 Native App；而对于淘宝、京东等 App，笔者更倾向于是 Hybrid App。Hybrid App 具有接近于 Native App 的体验、开发效率高、跨平台等特性。

有一些开发者认为微信服务号里的网页应用也属于 Hybrid App，这种说法也不无道理。因为这些网页应用也属于微信这个 Native 应用的一部分，同样运行在微信内置的浏览器中，但这是个 App 所有者的问题。对于微信，确实是 Native Appi 中加入了部分「网页」，具有 Hybrid App 的特点。但我们上面讲到，目前主流 App 里很少有纯粹的 Native App，是不是算作 Hybrid App，应该看 Web 页面在 App 中的所占比例。微信是一个以社交为主要业务的 App，微信中的绝大多数核心社交与聊天功能都是原生的，所以我们还是称微信为 Native App。但是，对于服务号应用的开发者，微信并不是开发者开发的，开发者只拥有其服务号。而且服务号应用所用到的所有技术都只局限在 Web 技术里，从这一点来讲，服务号的应用应该归属于 Web App 的范畴。

此外，我们说 Hybrid App 具有一部分可以访问原生设备组件的能力。微信的 JS-SDK 确实提供了一些如拍照、录音、扫一扫等功能的接口，但相比于其他 Hybrid App 能调用的原生功能，实在是有限。从这个角度来讲，也应该将这些服务号的应用归属到 Web App 中。其实，到底归属于什么并不重要。互联网技术中的概念层出不穷，对很多事物的定义本来就不是很明确。这里用一些篇幅解释 3 种主流类型的 App，是希望大家在对比小程序和其他类型 App 时，能有一个较完整的知识背景。

那么小程序属于以上 3 种的哪一种？严格意义上来说，它不属于以上 3 种中的任何一种，在实现技术上小程序同传统的 Hybrid 还是有很大的不同的。小程序采用 Javascript 和 CSS 这类常见的 Web 技术开发，但它又不使用 HTML，它同 Web 没有直接的联系。小程序实际上是将一系列自己定义的组件编译成了对应平台（iOS、Android、PC）的相应可运行组件，以提高运行性能。如果一定要将小程序归并到以上 3 类 App 中，可能 Hybrid Appe 更合适：非原生，但使用到了 Web 技术（Javascript 和 CSS）。

相比于 Native App，小程序具有 hybrid App 的一些优势：1）跨平台（对于 iOS 和 Android 两个平台只需要开发一套程序）。2）具备接近于 Native Appe 的体验（注意只是接近）。3）对原生组件有访问能力。4）具备缓存能力。5）上手容易，开发逻辑较为简单。

但是，世间没有完美的事物，计算机世界里也没有完美的技术，你以为的优势在另一方面却成了缺点。我们一起来看下：

1）小程序为了简化复杂性，做了一些 UI 上的设计规范，确实方便了很多对要求不高的应用。但这也限制了那些对 UI 要求极高的产品发挥。

2）小程序很遗憾地不支持现有的 HTML DOM 结构，而是自己给出了一系列的组件，造就了一个封闭的开发环境，这直接导致了现有的经典 Javascript 框架、类库都无法使用。小程序现在的生态几乎是荒芜一片，等待着开发者们去耕耘（挑战与机遇并存，正因为没有，才有机会）。如果你想用小程序实现一组图形来展现股票或者天气的曲线，目前来看，相当烦琐。你无法使用经典的 echart 或者 highchart，你只能自己用 Canvas 来一点点地绘制。

3）截止到笔者编写本书时，小程序还不支持 WebView，这是相当头疼的一个问题。现在很多新闻类型的应用，都是将文章数据静态化成 HTML 存储在服务器或者是 CDN 中，然后再利用 WebView 直接加载这个 HTML 来显示。不支持 WebView 直接导致了很多内容型应用没办法加载已存在的大量 HTML 页面。内容型应用现在大量的静态化页面需要被转化（已有一些第三方的组件实现了 HTML 转 WXML，基本思路是用正则表达式替换 HTML，但效果并不能让人满意）。至于微信会不会官方支持，这个很难抉择。不支持 Webview 对现在的静态化 HTML 页面是致命的打击；但兼容 Webview 就意味着在小程序里你还可以运行 Web App，而 Web App 很难去监管，性能体验也不够好，这对于小程序的发展是不利的。也许开放一个只解析 CSS 不允许运行 Javascript 的 Webview 可能是个不错的选择，微信如何平衡这个问题，我们拭目以待。

4）小程序只实现了模板化并没有实现自定义组件，这是最令人不满意的地方。如果我们想实现个自定义逻辑的组件，通常希望把这个组件的标签、样式以及业务逻辑打包在一起，然后可以放在项目中多个地方使用。外部客户端调用组件时，只需要传入组件所需要的参数，由组件自己来完成数据获取、转化、绑定并和层通信等操作。但小程序里的 template 只能将标签和样式（WXML 和 WXSS 文件）提取出来作为一个「模板」，却无法把组件的业务逻辑（js 文件）放在起。也就是说，组件的业务逻辑不能够写在组件的模块儿中，只能写在「调用」组件的业务代码中，这就无法很好地复用组件的业务代码。原因我们会在后面讲到模板「template」时再来详细讲解。

小程序会淘汰原生 App 吗？不会。连 Hybrid App 都无法撼动 Native App 的地位，又何况小程序本身只是 Hybrid App 的一个子集，运行在微信这个 Native App 之下呢？除了 Hybrid App 本身与 Native 技术的差距，微信对小程序还附加了诸多限制，比如安装包大小不能超过 1MB，不能做直播类和游戏类应用等。小程序的定位也非常明确 一一 做低频和业务逻辑不复杂的应用，原生 App 与小程序之间更多地将是一种互补的关系，绝对谈不上取代。

预计小程序将是 MVP 产品的践行地，是一个快速试错和调整产品思路的平台；同时绝大多数的产品也将推出自己的小程序，将全部或部分功能移植到小程序上占领更多的入口。一个平台是否流行，真的不取决于技术本身是否优秀，更多的时候开发者需要一个「理由」，无论是技术上还是商业上的理由，而微信海量的用户、全新的应用市场就是微信给开发者的一个理由。公正的评价，小程序确实在技术上无创新，但也的确具备巨大的商业价值。

相比于 iOS 和 Android，Web 前端对技术的需求度确实要高出很多。iOS 和 Android 是为移动端量身定做的系统，移动端的局限性本身就决定了它很难作为主要的生产力工具。虽然这些年有很多移动端 App 致力于将手机变成生产力工具，但诚实地讲，如果自然语言或者其他更先进的人机交互方式不出现，移动设备很难成为「名副其实」的生产力工具。「PC 已死论」、「微软已亡论」流传了好多年，可无论是 PC 还是微软现在都活得很好。这其中一个原因还是在于人类不能只消费，还需要生产，而 PC 作为信息化社会的主要生产力工具，这是移动端无可替代的。

我们在移动端更多的时候是去用眼晴「看」，而我们在 PC 端更多的是用手去「操作」。从信息的角度讲，移动端主要负责信息的输出，而 PC 端主要负责信息的输入。有过开发经验的朋友应该体会到，相对于纯粹的显示，有「输入」操作的应用开发难度和开发成本是要高很多的。目前市场上对于 iOS 和 Android 开发者的需求量已经接近饱和了，而 Web 前端由于其本身的特性，优秀的开发者相对偏少，市场的需求量是巨大的。即使一个公司的产品以 App 为主，也不可能缺少 Web 前端开发者。

1）我们之前讲过，混合式 App 是现在的主流 App，一个 App 很难只用 Objective-C 或者 Java 来开发，必然会有 Web 技术介入。你只看几乎所有应用都有「分享到微信、QQ、微博」（分享的内容大多数都是一个网页）等功能就知道，Web 技术是必不可或缺的。2）大多数移动端应用也都有一个对应的 Web 网站。3）现在的公司做营销和推广都离不开做信，无论是 H5 页面还是做微信服务号、企业号都是纯粹的 Web 技术。

在小程序推出之前，Web 技术在移动端时代更像是一个「黏合剂」，无处不在却又不能够独立地承担移动端的开发。Web 技术和 Web 开发者一直处于移动时代的边缘，不能没有它们，却也无法自成一体。但以 React 为代表的 React Native 和微信小程序的出现，给了 Web 开发者希望。虽然在性能体验上依然不及原生应用，但已经相当地接近了。Web 开发者终于可以在主流的移动平台中占据一席之地了。

笔者常常惊収于 Javascript 顽强的生命力，作为最早的浏览器交互语言，当初仅仅被当作一个玩具。这个玩具却经历了漫长的 Web 时代，抗住了 Adobe 的 FIex 和微软 Silverlight 这些所谓「富客户端应用程序」技术的猛烈攻势，不仅在移动端时代没有消亡，反而「溜到」了「后台」，以 Nodes 的形式开始了自己的服务器之旅，现在又不「甘心」蜗居在 Web 的两端（浏览器和服务器），反而以混合式的技术形态强攻移动端。这个被 Brendan Eich 用了 10 天设计出来的脚本语言，以惊人的生命力横贯 Web 和移动时代，甚至还可以以「寄宿」的方式成为一个桌面应用程序。Javascript 在很长一段时间，由于设计时间太短，细节考虑的不够严谨，导致 Javascript 都是「程序混乱」的代名词，但即使这样，也无法阻挡它前进的脚步。

随着 ES2015 的普及，Javascript 変得更加完善与强大。而现在 Web 前端的发展呈现出的是一种百花齐放的姿态，发展与更新速度远超服务器技术的更迭速度。好事还是坏事，大家各抒己见，没有定论。但有一点可以确定，Web 前端开发将是一个非常具有挑战和想象力的工作，如果你刚好走在前端开发的路上，那么恭喜你，你正行走于时代的技术浪潮上。

有没有可能未来会出现小程序开发者工程师这个职位？除了专业做微信开发的公司，小程序工程师这个职位在短期之内不会成为独立的一类职位，绝大多数的小程序将由 Web 前端工程师来开发。未来，你将看到的 Web 前端岗位要求会添加一句话：熟悉微信小程序开发者优先。正如现在的 Web 前端职位都要求应聘者精通 jquery、熟悉 AngularJS、Grunts 等一样，小程序也将是 Web 前端职位的一项加分项。微信小程序更多的是 App 或者 Web 网页的另一个流量入口，但绝不会替代原生 App 或者 Web 网页（至少很长一段时间内是这样，未来小程序怎么发展还有待观察）。正如我们描述的微信对现在公司莒销的重要性，小程序也将成为 Web 前端开发者应该掌握的一门技术。

笔者认为，每个 Web 前端开发者都应该至少了解一下小程序，可以不精通，但至少应该写一个简单的 Demo，跑一跑，完善一下自己的技术栈和知识体系。你完全不需要把小程序当作一个平台或者是生态，你只需要把小程序当作和 jquery、AngularJS 一样的一个 Javascript 类库或者框架来学习即可。反正现在的前端框架多得泛滥。

MINA 框架与微信小程序。MINA 是官方小程序的内部开发代号，也是小程序运行框架的别名。据说 MINA 有 MINA s Not App 的意思。到目前为止，许多开发者并没有正确理解什么是微信小程序，它和我们在网页开发中常用的 Angularjs 和 vue 又有什么区别？微信小程序并不是一项技术或者一个框架，微信小程序是一个生态，与之对应的应该是 iOS 生态和 Android 生态，其中微信小程序又与 iOS 生态极为相似，它们都非常封闭，而且审核非常严格微信小程序的审核比苹果还要严格。而 MINA 是小程序的一个框架，它提供了小程序运行所需要的接口、模型和机制。

## 02. 小程序环境搭建与开发工具介绍

### 1. 逻辑脉络

编辑选项卡、调试选项卡、项目选项卡以及正上方顶部的工具栏。

### 2. 摘录及评论

『勾选「不使用云服务」（注意: 你要选择一个空的目录才可以创建项目）』

在主界面最左侧垂直分布着 5 个选项卡：编辑、调试、项目、编译和关闭。当点击（调试后，左側下半部分还会出现「后台」和「缓存」这 2 个选项卡。下面依次来介绍这 7 个选项卡。

如图 2-6 所示的界面就是编辑选项卡的主界面。编辑界面分为左、中、右 3 部分。左边是模拟器的预览视图，中间是代码的树状目录，右边是代码编辑区（也就是写代码的地方）。

可以在（区域 3) 中点击每行代码前的行号设置断点。当代码运行到断点处后，将停止。常用快捷键有 F10 单步执行，F11 进入方法，F8 继续运行到下ー个断点。更多快捷键可自行在（区域 4) 中查看。在整个调试选项卡中，最重要的部分还是（区域 2) 和（区域 3）顶部的 6 个功能模块。

1）Sources Panel 是默认的 panel，用于显示当前项目的脚本文件。如图 2-13 所示区域 2、区域 3、区域 4 就是 Sources Panel 的内容。2）Console Panell 用于调试和输出信息，开发者也可以在这里输入代码。这个 panel 在 Sources 模块中同样存在，如图 2-13 中的区域 5。当点击 Console 后，console Panel 将变大，使开发者可以浏览到更多信息，如图 2-15 所示。3）Network Panel 主要用于观察和显示网络连接的相关情况。这里的 Network Panel 和 Chrome 浏览器里的 Network Panel 几乎一样。如图 2-16 所示。

4）Storage Panela 用于显示当前项目的数据缓存情况，如图 2-17 所示。关于数据缓存将在项目开发中具体讲解。5）Appdata Panel 用于显示项目中被激活的所有页面的数据情况，这些数据主要是用来做数据绑定，如图 2-18 所示，关于数据绑定我们同样放在项目开发中具体讲解。在这里不仅可以查看数据情况，还可以更改数据，小程序框架会实时地将数据的变更情况反馈到 U 界面上。6）Wxml Panel 是非常重要的一个功能模块，如图 2-19 所示。这个模块类似于 Chrome 调试工具下的 Elements 模块，主要用于调试 wxml 标签和相关 CSS 样式，调试方法同 Chrome 一样。如果你是一个前端新手，那么建议好好地摸索一下这个功能模块的调试技巧，绝大多数和样式、标签相关的问题，都需要依靠这个 Panel 来调试。

以上的 6 个模块功能对我们开发非常有帮助。如果你在开发中遇到一些稀奇古怪的问题，那么最好的解决办法就是使用这 6 个 panel 来解決。我们在后面的章节中也会经常回过头来讲解这些 panel 的使用技巧，并使用这些 panel 解决我们的问题。以上 6 个 panl 包含的功能非常多，不需要现在就把每个 panell 的细节了解的非常清楚。笔者的建议是知道以上 6 个 panel 是做什么的以及它们简单的使用方式即可，在后续的内容中将会用实际的数据来演示如何使用这些 panel，开发者无须担心。

1『新版本多个好几个模块。（2020-02-20）』

项目选项卡主要有 3 大功能：显示当前项目细节、预览及上传项目以及项目配置。在目前版本中，项目配置总计有 5 个配置选顼。

1）开启 ES6 转 ES5。小程序支持使用 ES6 来编写代码。如果使用 ES6 来编写代码，框架会默认使用 babel 将开发者的代码转化为 ES5 代码（这样做的主要原因是为了保持对三端：iOS、Androidi 和开发工具模拟器的良好兼容性）。开发者可以在项目中关闭这个选项。2）开启上传代码时样式自动补全。开启此选项，开发工具会自动检测并补全缺失样式，保证在 iOS 8 上的正常显示。3）开启代码压缩上传。开启此选项，开发工具在上传代码时将会帮助开发者压缩 Javascript 代码，减小代码包体积。

4）监听文件变化，自动刷新开发者工具。开启此选项后，如果代码发生了改变（需要 CtrI+S 先保存），小程序开发工具会自动帮助开发者刷新调试模拟器，从而提高开发效率。也就是说，开发者不再需要手动地点击编译按键即可实时预览小程序运行效果，这是非常好用的一个功能。5）开发环境不校验请求域名以及 TLS 版本。开启此选顼，开发工具将不会校验安全域名以及 TLS 版本，帮助在开发过程中更好地完成调试工作。我们前面提到过，在开发工具里如果选取了「无 APPID」模式，那么开发工具的安全限制级别非常低，不需要使用 https 访问服务器，也不会校验 TLS 版本。但如果我们填入了「APPID」，那么默认情况下开发工具的校验行为会和真机环境保持一致，比如，必须使用 https 访问服务器且服务器域名必须加入到微信小程序账号中的可信任域名列表中。如果我们不想接受这样的限制，又想使用「APPID模式」，那么需要把「开发环境不校验请求域名以及 TLS 版本」这一项给勾选上。

ES6 转 ES5 的转換，只会帮助开发者处理语法上的问题，新的 ES6 的 API 例如 Promise 等需要开发者自行引入 Polyfill 或者别的类库。同时，为了提高代码质量，在开启 ES6 转換功能的情況下，默认启用 Javascript 严格模式。开发者可以自己査阅资料了解什么是 Javascript 的严格模式。

1『新版已经改成右上角的「详情」面板里了。』

同「编译」选项，「后台」也是一个功能按键，可以在模拟器中模拟应用程序的前后台切換操作。以 iphone 为例，当我们运行一个应用程序时，点击 iphone 的「Home」键，应用程序将被切换到后台，但并没有关。具体的功能作用我们会在后面章节介绍小程序生命周期时讲解。

缓存是非常重要的一个功能选项。点击「缓存」会出现一个子菜单，包括 4 个选项：清除数据存储、清除文件存储、清除工具授权数据和清除手机授权数据。缓存选项是开发工具提供给我们用来进行数据存的小工具。关于数据缓存和文件缓存我们将在后面的项目章节中深入讲解。

官方 API 文档除了用于经常查阅 API 外，推荐大家在版本更新后第一时间去查看更新内容。最新的更新内容对我们开发者来说尤其重要，更新内容通常会出现在官方 API 文档的「历史更新日志」里。

## 03. 从第一个简单的「Welcome」页面开始小程序之旅

### 1. 逻辑脉络

小程序的基本文件结构、CSS 的使用限制、自适应单位 rpx、全局样式、App.json 配置文件以及 Flex 布局等小程序开发的必备知识。

### 2. 摘录及评论

认识小程序的基本文件结构。我们看到根目录下面有 3 个文件：app.js、app.json 和 app.wxss。一个小程序项目必须有这 3 个描述 App 的文件，它们必须放在应用程序的根目录下，否则小程序会提示找不到 app.json 文件。app.js 是小程序逻辑文件（必填）；app.json 小程序配置文件（必填）；app.wxss 全局公共样式文件（非必填）。这 3 个文件是应用程序级别的文件。

接着是和这 3 个应用程序级别文件平行的 pages 文件夹。一个小程序由若干个页面文件构成，如图 3-1 中 pages 文件夹下就有 2 个页面，分别是 indexI 页面和 ogs 页面。每个页面可以由 4 个文件构成，分别是：js、xml、wxss 和 json 文件。js 是页面逻辑（必填）；wxml 是页面结构（必填）；wxss 是页面样式表（非必填）；json 是页面配置（非必填）。其实，这 4 个文件的作用大家并不陌生。我们可以和熟悉的 Web 前端开发技术做一个对比。

1）wxml 文件类似于我们熟悉的 HTML 文件，用来编写页面的标签和骨架，不同的是 wxml 文件里的标签元素不可以使用 HTML 标签，只能使用小程序自己封装的一些组件，这些组件也是我们后面要重点学习的知识。2）wxss 文件的作用类似于我们熟悉的 CSS 文件，用于编写小程序的样式，实际上小程序的样式编写语言就是 CSS，只是把 CSS 文件换成了、wxss 文件。3）json 文件用来配置页面的样式与行为。4）js 文件类似于我们前端编程中的 Javascript 文件，用来编写小程序的页面逻辑。以上 4 种类型的页面文件的文件名称必须相同，这是要注意的一个地方。

我们可以看到，小程序的 4 种页面级别文件同 3 个应用程序级別文件相比，多出了ー个 wxml 顶面标签文件，其他 3 个的作用基本相似，只不过页面文件作用于页面本身而应用程序文件作用于应用程序整体。除了 pages 文件夹外，官方的示例项目中还有一个 utils 文件夹，这个文件夹用来存放一些公共的 js 文件，如 utls 下面的 uti.js。我们可以任意定义类似于 utils 文件夹的目录，并放在小程序的任意位置，小程序对此并没有任何限制。

每个项目都有一个自己的名字，比如 Google 的 Tensor Flow（一个机器学习项目）、淘宝的 Ocean Base（一个分布式数据库）、微软的 Azure（云计算「蔚蓝」），还有大家写代码使用的各类框架：Flask、Spring、jquery。

在 pages 文件夹下新建一个名为 welcome 的文件夹，接着再在 welcome 文件夹下新建 4 个页面文件：welcome.js、welcome.wxml、welcome. wxss 和 welcome.json。新建后的文件目录结构如图 3-3 所示。

要显示 welcome 这个页面，必须让小程序的 MINA 框架知道这个页面的「存在」以及这个页面的具体位置（文件路径）。所以，我们需要在某个应用程序级别配置文件中注册这个 welcome 页面。那么哪个文件是用来做应用程序级别的配置的呢？回顾上ー小节中所讲的内容就应该知道，app.json 文件就是小程序提供给我们的全局配置文件。如何在 app.json 中注册 welcome 页面。在 app.json 中加入如下代码：

```
{
  "pages": [
    "pages/index/index",
    "pages/logs/logs",
    "pages/welcome/welcome"
  ],
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#fff",
    "navigationBarTitleText": "WeChat",
    "navigationBarTextStyle": "black"
  },
  "style": "v2",
  "sitemapLocation": "sitemap.json"
}
```

上面这段代码将 welcome 页面注册到了小程序中。代码是一个典型的 json 对象。这个对象的第一个属性 pages 接受一个数组，数组的每一项是一个字符串，用来指定我们的小程序将由哪些页面组成。每一项由对应页面的「路径 + 文件名」组成。比如上面这段代码中的 pages/welcome/welcome，就指定了 welcome 页面的页面路径。注意，页面路径前面不要加「/」。形如「/pages/ welcome/welcome」这样的路径是错误的。如果加入了「/」，小程序会提示错误：无法找到 welcome 页面。

这里要特别强调，路径最后一段 welcome，不需要指定具体的文件扩展名，无须写成 pages/welcome/ welcome.wxml。MINA 框架将会自动去寻找页面路径，并将页面的 json、js、wxml 和 wxss 这 4 个文件进行整合。如果有多个页面，需要将每个页面的路径加入到 bages 这个数组下，否则小程序不会加载这些页面。

页面的添加或者删除都需要在 pages 数组下面增减对应的页面路径，否则小程序会报错。当然现在只有一个 welcome 页面，那么 pages 下面先加入一个页面就可以了。随着 Drange Can 项目的不断开发，我们将在 pages 下面加入越来越多的页面路径。

出现这个错误的主要原因是，welcome.js 文件是一个空文件，这是小程序所不允许的。即使我们门的 welcome 页面中没有任何 Javascript 代码，依然需要在 welcome.js 中主动调用一下 Page() 方法。我们在 welcome.js 文件中加入以下代码：

```
Page({

}
```

关于 Page() 方法的用法，我们将在编写 welcome.js 页面的 Javascript 代码时具体讲解，现在只需要知道页面的 js 文件是不可以完全为空白的，否则小程序会报错。这个时候，我们的「Welcome，桔子罐头」这段文本还是没有在小程序中正确显示。那么试着在 welcome.json 中加入如下代码。

```
{

}
```

是的，正如 welcome. Js 文件不能为空一样，welcome json 文件同样不可以为空，即使你目前不想在 json 文件中配置任何属性，也需要加入ー个空的，以保证小程序能正确执行。当我们完成以上所有的操作后，Ctrl+S 保存一下项目。此时，我们的小程序应该不会再报错了同时在模拟器中也应该能够正确地显示出「Welcome，桔子罐头」这段文本。这说明 welcome 页面已经被 MINA 框架正确地加载和运行了。

我们每次创建一个新页面时，都需要手动地新建一个目录 + 4 个文件，这是相当麻烦的事儿。这里告诉大家一个一次创建 4 个页面文件的小技巧（官方文档里没有提到过，开发工具也没有显示的标识）。如果 app.json 文件下 pages 数组里的页面路径，指向的是一个不存在的文件，那么 MINA 框架会自动创建这个页面的 4 个文件。我们可以试一下，在 app.json 文件的 pages 数组里添加一项「pages/orange/orange」，然后保存项目，会发生什么呢？通过这样的方式新建的页面文件将自动补全每个页面文件里必须的基本代码，不会出现错误。本小节讲解手动创建文件的例子，是为了向开发者展示一些常见的错误提示并解释错误的原因。后续页面文件的创建将采取这种比较方便的方式。

1『注意，是在小程序的 IDE 里选上 app.json，然后按 Ctrl+S 保存。而且自动生成的文件里都有基本的代码，哈哈，这是个好技巧。』

构建 welcome 页面的元素和样式。在本节中，将尝试为 welcome 页面添加一些标签元素。首先编写 welcome.wxml 文件，在该文件中键入以下代码，这段代码将 welcome 页面所需要的标签元素全部填入到页面源文件中。

```
<view class="container">
  <image></image>
  <text class="motto">Hello, 大龙</text>
  <view class="hi">
    <text>开启小程序之旅</text>
  </view>
</view>
```

1『小程序的代码跟 HTML 的代码一样，缩进都是 2 个空格，这个在 vscode 里直接点右下角的「空格」选项设置，不要太方便。』

这段代码总共使用了 3 个微信小程序的组件，分别是 view、text 和 image 组件。view 组件通常作为容器来使用，类似于 HTML 中的 dⅳ 标签；text 组件用来显示一段文本，类似于 HTML 中的 span 标签，本例中第一个 text 组件用来显示一段文本「Hello，桔子罐头」；而 image 组件用来显示一张图片，类似于 HTML 中的 img 标签。

1『HTML 里与其称为标签不如称为「元素」更合适。』

大家应该注意到了，笔者在描述这些元素时的用词区别。描述 wxml 元素使用的是「组件」，而描述 HTML 元素使用的是「标签」，这是符合规范称呼的。HTML 是标记语言，它的标签主要是用来标记页面骨架，标签的属性也比较少。但组件不同，组件除了标记的作用，它的属性一般也是非常丰富的。小程序官方文档中也将 view、text、image 称为组件，而并没有称为标签。

同 HTML 中的 img 标签一样，images 组件需要设置一个 src 属性，该属性指向长图片的路径，用来显示该图片。我们在项目的根目录下新建一个名为 images 的目录，用来存放 Orange Can 的所有图片资源。在 images 目录下新建 avatar 目录，然后将一些适合做头像的图片拷贝到 avatar 目录中。

如何将图片放入到小程序的目录中？微信 Web 开发者工具无法通过 Ctrl+C/Ctrl+V 的功能复制粘贴图片，也没有提供导入图片的功能。我们需要在操作系统中打开项目的目录，并将图片拷贝到对应的 avatar 文件夹中，小程序会自动刷新目录，并在开发工具中显示这些图片。

当保存项目后，模拟器立刻会出现这张图片，但图片显示的高宽并不是图片本身的高宽。它被 MINA 框架设置成了宽度 300 px、高度 225 px，这也是小程序默认的图片高宽。如果我们不显示地指定图片高宽，所有图片都将保持这个默认值。

相对路径与绝对路径。在小程序中同样有相对路径和绝对路径的区别。上面我们在设置 image 组件的 src 属性时，使用的是绝对路径，它以「/」开头，「/」代表根目录。我们也可以使用相对路径来为 image 指定图片路径，比如，将代码中 image 组件的 src 属性改写为相对路径：

    <image src="../../images/avatar/avatar-1.png"></image>

路径中的「..」表示向上一级。这里由于使用绝对路径更加简洁，所以我们使用绝对路径。代码中间部分使用一个 view 组件包裏一个「开启小程序之旅」的 text 组件来实现按钮部分。由于还没有编写样式，所以暂时它还不能呈现为一个按钮的形状。

1『

显示错误：

VM673:1 Failed to load local image resource /images/avatar/avatar-1.png 
the server responded with a status of 500 (HTTP/1.1 500 Internal Server Error) 

被书的源码坑了，下面的绝对路径还是识别不了。

      <image src="/images/avatar/avatar-1.png"></image>

改为相对路径：

    <image src="../images/avatar/avatar-1.png"></image>

复核：最后发现是自己弄错了，把 images 文件夹放到了 pages 文件夹下面，应该是放在根目录下的，跟 pages 文件夹是平行关系，作者的源码没问题。

』

现在来编写 welcome 页面的样式。小程序编写样式的语言就是 CSS，我们应该将 CSS 代码写在页面的 wxss 文件中。在编写 welcome.wxss 文件之前，首先在 welcome.wxml 文件中给每个需要样式的组件加入样式名称 class name。就和我们在 HTML 中编写 CSS 名称一样，不是吗？接着我们将下面这段 CSS 代码加入到 welcome.wxss 文件中。

```
<view class="container">
  <image class="avatar" src="../images/avatar/avatar-1.png"></image>
  <text class="motto">Hello, 大龙</text>
  <view class="journey-container">
    <text class="journey">开启小程序之旅</text>
  </view>
</view>
```

让我们保存一下，看看页面发生了什么变化，如图 3-7 所示。

```
.container{
  display: flex;
  flex-direction: column;
  align-items: center;
}

.avatar{
  width: 200rpx;
  height: 200rpx;
  margin-top: 160rpx;
}

.motto{
  margin-top: 100rpx;
  font-size: 80rpx;
  margin-top: 100rpx;
  color: aqua; 
}

.journey-container{
  margin-top: 200rpx;
  border: 1px springgreen;
  width: 200rpx;
  height: 80rpx;
  border-radius: 5px;
  text-align: center;
}

.journey{
  font-size:22rpx;
  font-weight: bold;
  line-height:80rpx;
  color: blueviolet;
}
```

下面简单介绍一下这些 CSS 代码的作用：1）container 是所有组件元素的容器样式。这里使用 Flex 布局的方式，来控制容器下子元素的排布规则。关于 FIex 将在下个小节里具体讲解。2）avatar 设置头像图片的大小和位置。3）motto 设置「Hello，桔子罐头」这段文本的样式。4）journey-container 设置了「开启小程序之旅」的外边框，使它们看起来更像一个按钮。border-radius 让这个外边框変成一个「圆角」的矩形。5）journey 则设置了圆角矩形内的文本样式。

本书的主要目的是讲解小程序的核心知识，并不是一本 CSS 和 Javascript 的基础语法书。限于书籍的篇幅，我们只对 CSS 样式中的核心内容作较为深入的讲解。下个小节，我们来学习小程序官方推荐的布局方式：FIex 布局。真实项目中，图片资源尽量不要存储在小程序的目录中，因为小程序的大小不能超过 1 MB，超过则无法真机运行和发布项目。应该将图片都存放在服务器上，让小程序通过网络来加载图片资源。

2『图片放在服务器上，这点很重要，因为小程序的大小不能超过 1 MB。』

小程序所支持的 CSS 选择器。需要特别注意的是，小程序中的 CSS 只支持表 3-3 所示 6 种 CSS 选择器。虽然 CSS1、CSS2 和 CSS3 的选择器种类加起来总计几十种，但在小程序中只能支持以上几种。同时需要注意的是，本地资源在 wxss 中是无法使用的。比如 background-image，如果使用的是本地图片，则无法显示，可以使用网络图片来代替本地图片。

Flex 布局。welcome.wxss 文件中的 container 样式使用了一个 display: flex 的样式。那么，什么是 FIex？FIex 布局是 W3C 组织在 2009 年提出的一个新的布局方案，其宗旨是让页面的样式布局更加简单，并且可以很好地支持响应式布局。这并不是小程序所独有的技术，它本身是 CSS 语法的一部分。只不过早期时候，主流的浏览器对 Flex 布局的支持并不完善，造成了很多开发者不知道有这种布局的存在或者使用非常少，我们还是习惯使用传统的 position 和 foat 属性来布局。但传统的布局方式有它的缺陷，比如像垂直居中就不是那么容易实现，Flex 可以很好地解決这些问题。

小程序能够非常好地支持 Flex 布局，并且这也是官方推荐的布局方式。FIex 也称为「弹性布局」，主要作用在容器上，比如代码清单 3-7 中样式为 container 的 view 组件，就是一个容器，它将页面中所有的元素都包裏起来。我们使用 display: flexy 将这个 view 変成了一个弹性盒子。设置 display: flex 是应用一切弹性布局属性的先决条件，如果不设置 display: flex，那么后续的其他相关弹性布局属性都将无效。

接着我们使用 flex-direction 这个属性指定 view 内元素的排列方向。这个属性可能的值有 4 个：1）row；2）column；3）row-reverse；4）column-reverse。要理解这 4 个属性，首先要了解一个 Flex 布局非常重要的概念：轴。我们知道，在一个平面直角坐标系里，轴有两个方向（就是 X、Y），分别是水平方向和垂直方向。一个弹性盒子，需要确定一个主轴。这个主轴到底是水平方向还是垂直方向，就由 flex-direction 这个属性的值来确定。如果 flex-direction 值为 row 或者 row-reverse，那么主轴的方向为水平方向，相反，如果值为 column 或者 column-reverse，那么主轴为垂直方向。选定主轴的方向后，另外一个方向的轴我们成为「交叉轴」。也就是说，主轴并不ー定就是水平方向，交叉轴也并不ー定就是垂直方向，主轴的方向由 flex-direction 的取值来決定。理解这一点尤其重要。

图 3-8 到图 3-11 显示了当 flex-direction 取不同值时，主轴方向及子元素排布的情况。注意观察每张图里 3 个小 item 的排布顺序，主轴方向不同，子元素排布的方向也不同。1）flex-direction: row 时，主轴水平，方向为自左向右。2）flex-direction: row-reverse 时，主轴水平，但方向为自右向左。3）flex-direction: column 时，主轴垂直，方向自上而下。4）flex-direction: column-reverse 时，主轴垂直，方向自下而上。

虽然 welcome 页面的 3 个元素已经呈现出了垂直排列，但他们还没有居中显示。container 样式中的属性 align-items: center，可以让三元素水平居中。align-items 属性定义子元素在交叉轴上如何对齐。这里特别要注意，align-items 定义的是「交叉轴」这个方向上子元素的对齐方式。比如，由于我们在 container 样式中设置了垂直方向为主轴，那么交叉轴就是水平方向，所以 align-items: center。将设置三元素在水平方向上的对齐方式为居中。当然，align-items 属性值不是只有 center 这一种，还有其他若干种取值。本书主要讲解小程序相关知识，限于篇幅这里就不再展开赘述这些 CSS 的相关知识。由于 Flex 布局在小程序里地位相当之高，本小节权当抛砖引玉，各位读者可以自行查找资料，更详细深入的学习 Flex 布局。

这里推荐一个学习方法。编程里的知识点是非常细小而琐碎的，学习不同的知识应该掌握不同的方法。对于学习 CSS 这类知识，笔者认为较好的学习方法应该是在实践中学习，而不是像我们上学时那样先把理论知识认真的学习一遍，甚至要求全部记住，这一点是不可取的。比如 Fex 布局的学习，我们首先应当大致浏览一下整个 Flex 的知识树，知道 Fex 解決了什么问题，有什么特点，大致有几类属性就够了。当我们在做项目遇到布局问题时，脑海里就能意识到 FIex 可能可以解決这个问题。接着我们抱着试试看的心态，带着目的去查找 Flex 布局的相关资料，即解決了问题，又能在实践中加深对 Flex 布局的理解，这比单纯死记硬背效果要好很多。人脑总是对形象化的东西记忆特别深刻，所以我们应当尽量在实践中学习知识。当然，也有可能 Flex 不能解决问题，但你查找和尝试解決问题的这个过程本身就是很好的学习手段。

小程序自适应单位 rpx 简介。我们绝大多数的长度单位都设置的是 rpx 这个全新的单位，比如 margin-top: 100 rpx。在小程序里，长度单位既可以使用 rpx，也可以使用 px。使用 rpx 可以使组件自适应屏幕的高度和宽度，但使用 px 不会。要透彻地理解 rpⅹ 需要对移动端分辨率有一定的了解，比如物理分辨率 px、逻辑分辦率 pt 等概念。这里只需要记住结论即可，并不影响我们的开发。

建议以 iphone 6 的宽度 750 个物理像素作为标准，来做设计图。在此宽度下，这张设计图里每元素的尺寸转换到小程序样式时，转换比例为 1 物理像素 = 1rpx = 0.5px。rpx 和 px 就是小程序样式里可以使用的两种长度单位。举个例子，我们的 welcome 页面设计图的宽度总长是 750 像素，它是以 iphone 6 的尺寸来设计的，而其中的头像图片高宽为 200x200 像素。如果想在 iphone 6 里正确地显示这张 200x200 像素的图片，那么相应地 image 组件的高宽应该设置为多少呢？

答案是要不就设置为高 200 rpx，宽 200 rpx，要不就设置为高 100 px，宽 100 p×。这两个单位，在 Phone 6 下显示效果一样，但如果我们将模拟器切换到其他机型，这两种不同的单位就会出现差异。rpx 将随着屏幕尺寸的变化而变化，但 px 不会。那么到底选择 rpx 还是选择 pⅹ 呢？这取決于你需要元素随着移动设备尺寸的变化而变化，还是让元素始终保持不变，需要具体问题具体分析。对于 margin-top 或者是 image 组件的高宽，很多时候，需要他们随着设备的尺寸不同动态地变化，以保持页面元素之间的分布可以保持「一定的比例关系」，这种情况下应该使用 rpx。

那是不是 rpx 就是万能的，我们可以将页面里的所有元素的长度单位都换成 rpx 呢？来看看下面这个例子，在 welcome.xxss 里有一段这样的代码；Journey-container 设置了「开启小程序之旅」这段文本的外边框。为什么其他的元素我们都使用 rpx 为单位而唯独 border 这个属性使用的是 1 px 呢？因为我们讲过，rpx 是自适应单位，它通常非常适合用来控制图片的高宽和元素之间的间距（通常这些元素需要随着屏幕尺寸的不同而动态变化）。但我们考虑一下，border 这个属性需要动态变化吗？不需要。如果 border 动态变化，那么它会在屏幕尺寸较大的手机上变得很粗，这并不是我们想要的效果。所以这里应当将 border 的单位设置为 px。同理，使用 px 作为 border-radius 的单位。

最后，我们为什么要强调最好是在 iphone 6 的尺寸下做设计图呢？因为只有在 iphone 6 的尺寸下，设计图里的 1 个像素才满足下面的转换关系：1 物理像素 = 1rpx = 0.5px。

如果不以 iphone 6 的标准来做设计图，也是可以的。但非 iphone 6 的尺寸下，设计图与 rpx、px 的转换关系就不是整数倍的，计算起来比较麻烦，所以建议设计图最好以 iphone 6 的尺寸标准来设计，这样换算起来很方便。这也是官方建议的一个设计标准。如果我们足够细心，可以看到小程序的模拟器选择项下，给出了每种机型的分辨率。要强调的是，这里的分辨率指的是逻辑分辦率 pt，而非物理分辨率。以 iphone 6 为例，模拟器里给出的分辨率是：375x667；Dpr：2。

它的意思是：iphone 6 的水平方向有 375 个逻辑像素点，而竖直方向有 667 个逻辑像素点，每个逻辑像素点包含 2 个物理像素点。开发者一定要注意逻辑像素和物理像素的区别。我们通常在 PS 里做的设计图，它的像素可以简单理解为物理像素。再次提醒开发者，1 物理像素不等于 1 px。假设有一张图片在操作系统下显示宽度为 750 个像素，我们现在想让这个图片水平方向充满整个页面。如果你直接在页面里（iphone 6 模拟机型下）将图片宽度设置为 750 px，这是不对的。正确的设置方法为 750 rpx 或者 375 px，才能让图片水平填满小程序。因为，iphone 6 下 1 物理像素 = 1 rpx = 0.5 px。

全局样式文件 app.wxss。到目前为止，welcome 欢迎页面和实际图相比还有一些不一样的地方，比如字体。设计图里的字体使用的是微软雅黑，而目前的字体还是小程序默认的字体。最简单的更改字体的方法是在 WXSS 页面中加入如下代码；代码会将 Welcome 页面中的所有 text 组件的字体更改为微软雅黑。那我们思考一个问题，假如现在有 100 个页面，而 100 个页面里几乎所有的字体都应该是微软雅黑。在 100 个页面里重复设置字体这并不是一个很好的解决方案。所以，我们需要有一个全局样式表，可以为所有页面设置「默认」样式。小程序为我们提供了这样的样式表文件，就是前面提到过的 app.wxss 文件。

我们将代码清单 3-10 的代码，复制到项目根目录下的 app.wxss 文件中。虽然这段代码不在 welcome.wxss 页面样式表中，但依然可以使 welcome 页面的 text 组件字体更改为「微软雅黑」。还可以在这里设置一些其他的公共样式，比如字体大小 font-size、字体颜色 color 等。如果不想在某个页面中使用全局默认样式，那么只需要在相应页面的 wxss 文件中重新定义这个样式即可。小程序会优先选择页面的 wxss 文件，而不是 app.wxss 文件。

页面的根元素 page。到目前为止，我们的 welcome 页面已经像那么回事儿了。但页面的样式和设计图还不太一样，设计图中整个页面呈现的是橘红色，而现在的页面还是白色。那么，来修改一下页面的背景颜色吧。要修改页面整体的背景色，需要寻找一个包裹所有页面元素的容器，并设置这个容器的背景色。那么，首先尝试给页面最外层 view (class=" container" 的这个 view）一个背景色。在 welcome.wxss 文件中的 container 样式里新增属性 background-color: #ECC0A8。

接着保存预览一下增加样式后的页面，它将呈现如图 3-18 所示的效果。并不是整个页面都呈现出橘红色，只是有元素占据的地方才呈现出橘红色。原因是因为最外层的 container view 没有固定的高度，它的高度由其内部子元素决定，所以橘红色部分的下边刚好和按钮的下边重合。如何解決这个问题呢？可以通过给 container view 一个固定的高度来解决这个问题，但这并不是最好的办法。因为在不同的机型上，屏幕的尺寸是不ー样的，固定的高度无法去适配不同的机型，可能出现滚动条，也可能橘红色无法覆盖整个页面。

当然，用我们前面学到的 rpx 是可以解決这个问题的，将 container view 的高度单位设置为 rpx，就可以让它随着不同的机型进行自适应调整。但这看起来很蠢，高度具体设置多少，还需要我们了解 iphone 6 的屏幕分辨率。所以，这依然不是一个很好的解决方案。其实，在 container view 的外边，小程序还有一个默认的容器元素：page。我们可以在开发工具中的 Wxm 这个 Pannell 中看一下 welcome 页面的页面结构，如图 3-19 所示。

在 class="container" 这个 view 的外边还有一个容器元素：page。这是 MINA 框架为大家默认添加的。每个小程序页面的最外层都有这个 page 元素。page 元素代表着页面这个整体，所以只需要对 page 设置背景色即可实现设计图里的效果。在 welcome.wxss 文件的尾部追加以下样式。保存后，页面将呈现出如图 3-20 所示的效果。Page 代表着整个页面的容器，如果想对页面整体做样式或者属性设置，那么应该考虑 page 这个页面的根元素。

app.json 中的 window 配置项。图 3-20 的顶部黑色长条是小程序默认的导航栏。很遗憾这个导航栏不可以隐藏或者取消，它必须存在。我们之所以说小程序无论从开发还是设计上都比较简单，有很大一部分原因是因为小程序做了很多这样的「强制性约束」，不给开发者很大的自由度，自然简单。这固然是因为小程序设计初衷就是用来快速开发轻量级应用的，但也有一部分原因是因为小程序目前还处于生态的早期阶段，官方没有那么多精力支持非常丰富的组件接口。

既然这个导航栏无法取消，如何让整个页面只有一种颜色呢？下面我们考虑将导航栏的颜色和页面的背景色设置成同一个颜色。还记不记得在 3.2 小节中，我们使用了 app.json 的一个配置项 pages，用来注册小程序页面文件？app.json 的另外一个配置项 window。window 配置可项用来设置小程序的状态栏、导航栏、标题和窗口的背景色。配置项下能够更改导航栏颜色的属性：navigationBarbackgroundcolor。在 app.json 文件中加入一个 window 配置项，并设置 window 的属性 navigationbarbackgroundcolor 值为 #ECC0A8。更改后的 app.json 文件代码如下：

```
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#ecc0a8",
    "navigationBarTitleText": "WeChat",
    "navigationBarTextStyle": "black"
  }
```

小程序顶部的导航栏已经被「隐藏」了。当然这不是真的被隐藏，导航栏依然存在于小程序中，只不过我们通过设置导航栏和页面的颜色模拟了这种效果。window 这个选项下并不是只有 navigationbarbackgroundColor 这一个属性，它还有以下几种属性：1）navigationbarTextstyle 配置导航栏文字颜色，只支持 black/white。2）navigationBartitleText 配置导航栏文字内容。3）backgroundColor 配置窗口颜色。4）backgroundtextstyle 下拉背景字体，仅支持 dark/light。5）enablepulldownRefresh 是否开启下拉刷新。

读者朋友应该关注本书章节的标题，每个标题代表着小程序的一个重要知识点，整本书的标题将构成小程序的知识体系框架。但每个知识点下有很多的属性，本书并不会一一列举，因为这些属性的使用方式都可以通过本书的案例并结合官方的文档一目了然。对于每个小程序的知识点，我们在学习阶段最需要关心的只有两点 一一 有什么用和怎么用。比如 window 这个配置项，我们只需要关心以下两点即可：1）window 是做什么的？2）怎么使用 window 这个配置项？

至于 window 下面的属性值，建议具体问题具体对待，不需要现在就搞明白。把这些属性值放到实际的工作项目中学习，不仅节约时间而且印象更加深刻。比如，我们这里需要用到 navigationbarBackgroundColor，把这个属性配置到项目后，就知道 navigationBackgroundColor 的意义了。

书籍绝大多数是用来引导入门和分享思想的，它不应该替代官方的 API 文档。API 文档不同于 tutorial 或者 get started（优秀的开发文档都有这两个部分），它一般用于査，是工具而非教程，通常都非常简洁。这里分享一个学习 API 的方法，就是「试」。对于 window 这个配置项，你只需要将其他几个属性加入到 window 中，再更改几个可能的属性值，就可以立刻即时地预览到属性值的效果。如果属性值的效果不符合你的预期，就具体去分析为什么会出现这种情況。不知不觉中，你对整个 API 就会越来越熟悉。

## 04. 文章列表页面

### 1. 逻辑脉络

使用 swiper 组件构建 banner；image 组件的 4 种缩放模式与 9 种裁剪模式；数据绑定，几乎所有和数据相关的操作都只能使用数据绑定来完成；重温在传统网页中经常使用到的「事件」。

### 2. 摘录及评论

文章列表部分展示了一个 banner 轮播图与一组文章。在编写此部分功能时，我们会介绍使用 swiper 组件构建 banner！轮播图以及 Swiper 组件的其他属性；详细介绍 image 组件的 4 种缩放模式与 9 种裁剪模式。除此之外，小程序最重要的数据绑定将出现在本章中。数据绑定是小程序中最重要的概念，它是和传统的 Web 网页编程相比最大的不同。在小程序中，几乎所有和数据相关的操作都只能使用数据绑定来完成。本章我们还会重温在传统网页中经常使用到的「事件」，一起来看看小程序中的事件和传统网页中的事件有什么异同。

文章列表页面元素分析及准备工作。本章我们来构建第二页面：文章页面。文章页面主体部分由两部分构成，上半部分是一个轮播图，下半部分是文章列表。轮播图每隔几秒钟图片会自动更换一张。在小程序中，我们不需要自己编写代码来实现这样的轮播图效果，小程序已经提供了一个现成的组件 —— Swiper。下半部分是多篇文章构成的文章列表。每篇文章包含文章标题、文章头图、文章概要、评论数和阅读数。我们依然只需要使用在上一章中介绍的 3 个组件：view、image 和 text，即可实现这个文章列表。

先来创建文章列表页面的相关文件。在 pages 目录下新建一个名为 post 的目录，然后依次在 post 目录下新建阅读页面所需要的 4 个文件。现在有个问题，我们要编写阅读页面，但我们的启动页面已经设置成了 welcome 欢迎页面。在不编写「开启小程序之旅」这个 button 跳转页面功能之前，我们没办法看到文章页面。实现 button 跳转页面的功能，需要用到小程序事件和 Javascript 代码，我们先尽可能地熟悉小程序页面骨架的编写，稍微复杂一些的事件和 Javascript 代码留在后面的章节讲解。

先做一个调整。在之前章节里我们提到过，小程序启动后显示的首页，由 app.json 文件里 pages 数组的第一个元素決定。我们暂时先将首页调整成 post 页面。在 app.json 的 pages 数组里加入 post 页面路径，注意它必须是 pages 数组的第一个元素，位于 welcome 页面之前。代码清单如下；更改完成后，现在保存或者重新编译项目，启动页面将不再是 welcome 页面，而变成了 post 页面。在小程序的 images 目录下新建一个子目录 post，并将阅读页面所需要的图片素材拷贝到该目录下。图片的像素大小要大于或者等于 750（宽）和 600（高），过小的图片会出现「留白」的情况。

小程序提供的滑动视图容器 —— swiper 组件，在 post.wxml 中加入以下代码：

```
<view >
<swiper >
<swiper-item >
<image src="/images/post/post-1@text.jpg" />
</swiper-item>
<swiper-item >
<image src="/images/post/post-2@text.jpg" />
</swiper-item>
<swiper-item >
<image src="/images/post/post-3@text.jpg" />
</swiper-item>
</swiper>
</view>
```

最外层的 \<view>\</view> 将作为整个页面的容器，在 view 的内部，我们加入了ー个 swiper 组件，swiper 组件主要由多个 swiper-item 组成，可以定义任意多个 swiper-item。同时，需要注意的是，swiper 组件的直接子元素只可以是 swiper-item，如果放置其他组件，则会被自动删除。但 swiper-item 下是可以放置其他组件或者元素的。swiper-item 元素仅仅只是一个容器，如果要显示内容，需要在 swiper-item 容器下再添加元素内容。如代码清单 4-2 所显示的一样，我们在每个 swiper-item 内都加入了一个 image 组件，用来显示 UI 效果图中的轮播图片，图片路径请根据自己顼目的实际情况做出相应的修改。

swiper 组件的第一个 swiper-item 元素图片已经显示出来了。在动手设置 swiper 组件的样式前首先在 post.wxss 文件内，将 swiper 组件的宽度和高度设置好。添加完代码后，保存预览，发现图片的显示尺寸依然不正确。宽度没有呈现 100%，高度也不是期望的 600 rpx。还需要对 image 组件设置同样的样式，在 post.wxss 中添加 image 组件的样式，添加完成后的页面代码如代码清单 4-4。这里需要同时设置 swiper 组件和 image 组件的高宽，才能达到预期的效果。如果只设置 image 组件的高度同样是不可以的。

```
swiper{
  width: 100%;
  height: 600rpx;
}

swiper image{
  width: 100%;
  height: 600rpx;
}
```

要实现轮播效果，还要为 swiper 组件添加一些属性，分别是：indicator-dots、autoplay、interval，如代码清单 4-5 所示。

```
<view >
<swiper indicator-dots="{{true}}" autoplay="{{true}}" interval="5000">
<swiper-item >
<image src="/images/post/post-1@text.jpg" />
</swiper-item>
<swiper-item >
<image src="/images/post/post-2@text.jpg" />
</swiper-item>
<swiper-item >
<image src="/images/post/post-3@text.jpg" />
</swiper-item>
</swiper>
</view>
```

3『

[微信小程序学习笔记 - 简书](https://www.jianshu.com/p/e66f9e1cd078)

[小程序 bindtap 和 catchtap，target 和 currentTarget - 简书](https://www.jianshu.com/p/897f9c8ec847)

源码里额外设置了一个属性：catch:tap="onSwiperTap"，查了下资料说：冒泡机制就是如果点击 image 组件，会依次触发 swiper-item→swiper→view。catchtap 可以阻止冒泡，在 swiper 中用 catchtap 绑定事件，就不用继续往 view 那一层冒泡了，bindtap 是不会阻止冒泡的，在 image 组件中用 bindtap 绑定事件，在代码执行过程中，点击 image 组件，不仅会触发 onSwiperItemTap，还会向上一步触发 onSwiperTap。现在还无法理解，mark 下。

』

保存后预览一下效果。图片开始了轮播，每隔 5 秒钟更换一张。同时 swiper 组件上出现了 3 个小圆点，用来指示当前图片。

简单介绍一下这 3 个属性。1）indicator-dots，Boolean 类型。用来指示是否显示面板指示点（上文提到的 3 个小圆点就是面板指示点，默认为 false。2）autoplay，Boolean 类型。用来决定是否自动播放，默认为 false。3）interval，Number 类型。用来设置 swiper-item 的切换时间间隔，默认为 5000 毫秒。

除了自动切换图片，swiper 组件还可以通过拖动图片来进行切换，也可以通过点击面板指示点来切换。官方在 0.11.12210 版本中为 swiper 组件新增了一个 circular 属性，这个属性可以使轮播图循环滚动。如果 circular 为 false，那么当 swiper 组件滚动到第三张图片后就无法继续滚动了；但如果增加一个 circular 为 true 的属性，则当 Swiper 组件滚动到第三张图片后，会继续向第一张图片滚动，从而形成循环滚动。swiper 组件的属性使用方式都比较简单，更多属性请参考官方 API 文档。

Boolean 值的陷阱。这里介绍一个文档里没有提到的属性：vertical。这个属性将指明 swiper 组件面板指示点的排布方向是水平还是垂直，将 vertical="true"，加入到 swiper 的属性中。保存后，我们发现 swiper 组件的面板指示点由原来的水平排布更改为垂直排布，出现在组件的右侧。

那如果把 vertica 属性改为 False！呢？形如，vertical-="false"。此时，面板指示点如何排列？它依然和 vertical="true" 时的排列方向一样，呈垂直排布。为什么会出现这样的情况？我们可以把 vertical 的属性值更改为任何字符串，再看看效果。形如 vertical="aaa"、vertical-="bb" 等属性值都会让指示面板呈垂直分布。而 vertical=" " 则呈水平分布。我们应该可以从上面的属性举例中找出原因了。即使我们将 vertical 的值设置为 false，但这里的 false 并不是 Boolean 类型，而是一个字符串。只要不是空字符串，那么在 Javascript 里都会认为这是一个 true。所以，设置效果是一样的，vertical 属性被认为设置成了 true。

如果想让面板指示点水平排列，有以下几种方式：1）不加入 vertical 属性。2）vertical=" "。3）vertical="{{false}}"。以上几种写法，小程序都会认为你将 vertical 属性设置成了 false。第三种写法，是我们后面要学习到的核心知识：数据绑定。这种写法，让 "{{false}}" 里的 false 被认为是一个 Boolean 类型的变量，而不是一个字符串，从而实现 false 即是假，true 即是真的效果。

当然，swiper 的 vertical 属性如果设置错误，一眼就能看出问题来。但如果是其他无法直接在 UI 上表现的属性出现了真假错误，就不是那么容易排查了，可能会浪费掉我们大量的时间。所有组件的 Boolean 类型属性都有这样的 Boolean 陷阱，比如，本例中的 indicator-dots 和 autoplay 也存在这个问题。

构建文章列表的骨架和样式。构建文章列表依然只需要我们熟悉 3 个组件：view、text 和 image。保存后，效果如图 4-6 所示。由于还没有加入 CSS 代码，所以整个页面的布局乱七八糟，但文章列表所有的元素都已经呈现在了页面中。将代码清单 4-7 的代码加入到 post.wxss 文件中。保存预览一下，效果将如图 4-7 所示。还有些小小的问题：「Jan 28 2017」和「108、92」这几个文本的字体大小与颜色都不太好看。我们可以将一些默认的字体样式放在 app.wxss 全局样式表里。保存后，日期和数量都呈现出 app.wxss 里设置的样式。

image 组件的 4 种缩放模式与 9 种裁剪模式。4 种缩放模式和 9 种裁剪模式如果从理论上完全精确理解，还是有稍许的难度的。但这里笔者建议各位开发者，没有必要完全从理论上搞清楚这些模式。当遇到具体问题时，尝试多去更换几个属性，找到最适合自己需求的属性即可。

来看看上个小节中雪糕图片的显示问题，很明显整个图片被压缩变形了。这并不是我们想要的结果。post-image 这个元素的高宽分别被设置成 340 rpx 和 100% (iphone 6 下就是 750 rpx），而雪糕图片素材原始高宽分别为 600 px 和 750 px。在现实的项目中，我们经常要面对原始图片的尺寸和设计图里的尺寸不一样的情況（尤其是原始图片高宽是未知和不固定的情况，比如动态从网络获取图片）。在这种情况下，我们必须要有所舍弃，或放弃等比例，或裁剪掉图片的一部分。接受不完美，也是编程中很重要的心态，如何选择，需要看业务上的需求。具体到文章列表图片，我们需要的是保持宽高比，接受部分裁剪（现实项目中，绝大多数情况下，图片保持比例、允许裁切是最普遍的需求）。

4 种缩放模式：1）scaleToFill 不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素。2）aspectFit 保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。3）aspectfill 保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。4）widthFis 宽度不变，高度自动变化，保持原图宽高比不变（0.11.122100 版本新增）。

9 种裁剪模式：1）top 不缩放图片，只显示图片的顶部区域。2）bottom 不缩放图片，只显示图片的底部区域。3）center 不缩放图片，只显示图片的中间区域。4）left 不缩放图片，只显示图片的左边区域。5）right 不缩放图片，只显示图片的右边区域。6）top left 不缩放图片，只显示图片的左上边区域。7）top right 不缩放图片，只显示图片的右上边区域。8）bottom left 不缩放图片，只显示图片的左下边区域。9）bottom right 不缩放图片，只显示图片的右下边区域。

scaleToFill。保存预览一下，文章图片好像并没有发生任何变化。这是因为 scale ofill 模式是缩放的默认模式，如果缺省了 mode，则小程序也会以 scaletofilll 的模式来缩放图片。scaletof 模式将改变图片的高宽比，强行让图片更改为样式指定的尺寸，使图片变形（如果原始图片的宽高比例和要缩放的目标宽高比例相同，则不会变形，只是整体上放大或者缩小了）。

mode= aspectFit 的情况。同样不是我们要的效果。官方文档的解释：aspectFit 模式保持纵横比缩放图片，使图片的长边能完全显示出来。这个解释从字面上来看，并不是很容易理解，我们可以这样理解这种模式，假想有一个容器，这个容器的高宽等同于 image 将要被缩放的目标尺寸。比如在当前的事例中，这个容器的高宽就是样式 post-image，所设置的高 320 rpx，宽 100%（iphone6 下为 750 rpx）。aspectfite 的特点就是保持图片不变形，且容器要「刚好」将这个图片装进去。注意是「刚好」。如果原始图片比容器大，就要被等比例缩小；而原始图片如果比容器小，则要被等比例放大。一直放大或者缩小到图片的某一条边刚好和容器的一条边重合，而另一条边不能超出容器，也不能小于容器太多。

再回头看看图 4-8，宽刚好和容器相贴合，而高则刚好能被容器装进去，既没有超出容器，也没有比容器矮太多。同时整个图片保持了原始图片的宽高比，没有変形。所以官方文档的解释，没有把这种模式的特点完全描述出来。事例里用到的图片是大于容器的，所以图片会被缩小；开发者们可以尝试着用一张小于容器的图片替换这张雪糕图，试试 aspectFit 的效果如图 4-9 和图 4-10 所示。

aspectFill 同样保持图片的高宽比不会变形。但它有个特点，它会让图片完全填满整个容器，类似于 scaletofill 这种模式。不同的是 scaletofill 会改变图片的高宽比，而 aspectfill 不会。用我们上面提到的「容器」的观点来理解 aspectFill，既然 aspectFill 定要填满整个容器，那么首先要让这张图片的整体尺寸是大于这个容器的，不能留下任何的空白。对于原始尺寸小于容器的，就等比例放大图片（任意一边小于容器都需要放大，否则就会留下空白），让图片的某一边刚好接触容器的一边，同时另外一边又不会小于容器（可以超出，因为这边会被截取）。

如果原始尺寸大于容器，则需要等比例缩小，缩小的要求同样是一边刚好接触容器，另外一边要等于或者超出容器。这样就保证了图片可以完全填满整个容器，但某一边要发生截取。那么问是题来了，如何截取？在超出容器的这一边上，是保留图片的上部、中部还是下部？答案是：中部。注意观察图中的雪糕和原始图片，发现正中间部分被保留了下来。开发者可以自行多換几张素材图看看截取的效果。

widthFix 属性是小程序 0.11.122100 版本中新增的属性。这个属性的最大特点是，图片将不会按照设定的尺寸呈现，比如设置 image 宽度为 750 rpx，高度为 340 rpx，如果设置 mode= widthFix，则图片最终不会按照 750 rpx 和 340 rpx 呈现，除非原始图片恰好是这个尺寸。这个属性让宽缩放至指定尺寸，再动态计算高度，如图 4-12 所示。虽然宽度按照我们设定的尺寸呈现，但高度突破了 340 rpx。

9 种裁剪模式非常容易理解，我们举例看看其中的几种。同样建议开发者参考上ー小节中，我们想象的一个容器，这个容器用来裁剪图片的不同部位。将 post-image 的 mode 属性设置为 top，效果如图 4-13 所示。top 模式只保留图片的上部，裁剪掉了剩余部分。注意，这种模式不会缩放图片。我们可以仔细地再观察一下图中的图片，不仅仅是裁剪掉了图片的下部，上部水平方向也发生了裁剪。因为图片不会缩放，我们所设置的容器不能够在水平方向上完全把图片装进去，所以水平方向也发生了裁剪。这点是大家要注意的。

不同于 4 种缩放模式，裁剪模式是不会缩放图片的。用一张小图片来替换上面的大图，比如用 avatar 头像图片，替换后的效果如图 4-14 所示。明显可以看到，由于图片的原始尺寸小于容器的尺寸，裁剪模式也不会使图片发生缩放，所以结果就是不会裁剪图片。接着我们再将 mode 设置为 bottom right，效果如图 4-15 所示，图片只被保留了右下角部分，其余部分全部被裁剪掉了。其他几种裁剪类型从字面意思上都非常好理解，就不在这里 一一 列举了。

完成静态文章列表。先把上节更改的 post-image 的 mode 属性恢复成我们需要的 mode=aspectFill，现在，文章列表还只有 1 篇文章。1 篇文章如何叫做文章列表？为了多几篇文章，我们将代码清单 4-6 的代码再复制几份，依次加入到 post.wxml 文件中。这里再复制两份，形成一个有 3 篇文章的文章列表。如果 CSS 代码编写足够健壮，无须更改 CSS 代码，重复复制 post.wxm 中的文章代码即可迅速新增文章，且样式不会错乱。保存后，模拟器将呈现出 3 篇一模一样的文章来。效果如图 4-16 所。开发者可任意复制若干数量的文章，让页面看起来更像是一个文章列表。

js 文件的代码结构与 Page 页面的生命周期。是时候来学习一下小程序逻辑层代码的编写了。如果开发者是使用 3.2 小节中介绍的快速新建页面文件的方法来创建的 post 页面，那么由开发工具生成的 post.js。文件内默认将包含代码清单 4-11 所示的代码。

页面 js 文件默认代码包含了我们可能使用到的代码结构，整个页面执行了ー个 Page (..) 方法，参数是一个 Object 对象，用来指定页面的初始数据（data）、生命周期函数（on 开头的函数）、事件处理函数等。本节主要介绍页面的生命周期。

什么是页面的生命周期？如同人的成长需要分为出生、童年、青年、中年、老年一样，一个页面从创建到卸载，同样会经历以下 5 个周期：1）加载。2）显示。3）渲染。4）隐藏。5）卸载。MINA 框架分别提供了 5 个生命周期函数来监听这 5 个特定的生命周期，以方便开发者可以在这些特定的时刻执行一些自己的代码逻辑，它们分别是：1）onload 监听页面加载，一个页面只会调用一次。2）onshow 监听页面显示，每次打开页面都会调用。3）onReady 监听页面初次渲染完成，一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。4）onHide 监听页面隐藏。5）onUnload 监听页面卸载。

可以看到，一个页面要正常显示，必须经历以上 3 个生命周期：加载、显示、渲染。注意这 3 个生命周期函数的执行顺序，首先是 onLoad，其次是 onShow，最后才是 onReady。这里要特别提醒各位开发者，onShow 的执行时刻是在 onReady 之前的，但官方文档在编写时，将 onReady 放置在 onShow 之前（截止 0.11.122100 版本）。虽然只是顺序不同，但极容易让开发者误以为 onReady 是在 onShow 之前的，但这是不正确的。

那么 onHide 和 onUnload 呢？这两个函数的触发需要执行一些 API 的操作，比如当页面执行 navigateTo 方法或者使用小程序 tab 栏切换页面时会执行 onHide 函数；而当页面执行 redirectTo 或 navigateBack 的时候会执行 onUnload 函数。除了以上 5 个生命周期函数外，还有以下 3 个小程序特定事件的处理函数：1）onPullDownRefresh 监听用户下拉动作的事件处理函数。2）onReachBottom 页面上拉触底事件的处理函数。3）onShareAppMessage 用户点击右上角分享。开发者还可以添加任意的函数或数据到这个 Page 方法的 Object 参数中，在页面的函数中用 this 即可访问这些自定义函数或者数据。

关于 onHide 和 onUnload 以及 3 个特定事件的处理函数，我们将在后面介绍到导航、tab 栏、刷新、分享等项目需求时，再具体演示和讲解。放在具体的示例里演示，效果远比用文字理论描述要好。

官方文档中，还给出了ー个较为全面的 Page 实例生命周期图解，如图 4-18 所示。我们大概可以看到整个图分为左右两侧，左侧是视图层，右侧是服务逻辑层。整个页面的生命周期都是围绕着这两个层来进行的。他们之间不是孤立的，而是有很多的事件与通知交互的。目前，我们所学的知识还不足以完全解释页面的整个生命周期。我们所讲的 5 个生命周期函数就在图 4-18 右侧多次出现，如果仔细观察，会发现以下几个特点：1）onload、onshow 和 onready 确实是按照前面所讲到执行顺序依次执行。2）onload 与 onready 在整个页面的生命周期中只会执行 1 次，除非这个页面被执行了 onunload 载掉了（卸载掉后这个页面的生命周期就结束了）。3）onhide 与 onshow 在一次生命周期内可能会执行多次。

除了 First Render 第一次渲染，页面还有可能会 Rerender 再次渲染多次。数据更新会造成页面的重新渲染。开发者还要注意，小程序仅在第一次 First Render 完成后，提供了监听函数 onready，对于以后的 Rerender 并没有提供相应的监听函数。所以，onReady 仅用来监听「第一渲染」完成。

3『学爬虫的时候，动态网页里的数据涉及到客户端里 JS 的 Render，原来 Render 是指渲染，哈哈。』

现在无法看明白这张图是很正常的事情，开发者不需要太过于担心。正如官方文档中所说：「此图你不需要立马完全弄明白，不过以后它会有帮助」。笔者的建议是，当遇到问题或者业务需要时，再回过头来研究这张完整的生命周期图更有意义。

事实上，如果开发者只想单纯的开发业务项目，只需要理解 5 个生命周期函数发生的时机与意义即可。通过大量的编码，可以让经验来弥补一些知识上的缺陷，这就是所谓的熟能生巧。但如果开发者想去做一些与小程序编译相关的框架时，深入了解这张图就很有必要了。当然，无论你想做什么，能够完全看懂和理解这张图，自然是再好不过了。我们会在后面的项目实践中，不断验证这些生命周期的特性，开发者只需要记得到时侯回过头来看看即可。

1『看来这张小程序的页面生命周期图真的很重要。』

数据绑定。在真实的项目中，业务数据通常都放置在自己的服务器中，然后通过 HTTP 请求来访问服务器提供的 RESTFU API，从而实现数据获取。现在我们的 post 面里的内容，全是一些被直接编码在 wxml 里的数据，这样的代码写法我们通常称为「硬编码」。这当然是一种非常不好的编码方法。我们现在尝试将编码在 post.wxml 文件里的数据移植到 post.js 中，在 post.js 中加入一个临时变量 postData 用来模拟文章数据，并将上ー小节中测试生命周期的代码移除。编写完成后的代码如下：

那么如何将 data 中的这些数据「填充」到页面中，并显示这些数据呢？如果是开发传统的网页，肯定会使用以下思路：首先获取到 HTML 文档的 DOM，然后对 DOM 标签进行赋值，从而实现数据的显示。但在小程序中，是没有 DOM 结构的，所以这个思路行不通。在许多流行的 MVC 或者 MVVM 框架中，比如 AngularJs、Vue.js 中，都有数据绑定的概念。小程序也借鉴了这些流行框架的思想，采用数据绑定的机制来做数据的初始化和更新。

只不过小程序做得更加决绝。AngularJs 中，虽然官方不推荐使用 DOM，但至少还有一个内置的 jQLite 用来支持获取 DOM（虽然有很多的限制），开发者也可以自行集成 jQuery。但小程序的腳本逻辑是运行在 JSCore 中，JSCore 是一个没有 DOM 的环境，它完全抛弃了 DOM 结构，我们只能使用数据绑定来做数据的相关操作。不同于 AngularJs 的双向数据绑定，小程序仅实现了单向数据绑定，即只支持从逻辑层传递到渲染层的数据绑定，反之则不可以。小程序使用 Page 方法参数里的 data 变量作为数据绑定的桥梁。如代码清单 4-13 所示，data 里已经被我们放置了一些数据，这些直接写在 data 里的数据，被称为数据绑定的初始化数据。

注意，数据绑定有以下两种：一种是初始化数据的数据绑定，通常将这些数据直接写在 Page 方法参数的 data 对象下面；另外一种是使用 setData 方法来做数据绑定，这种方式也可以理解为数据更新。这样的数据更新将引起页面的 Rerender（重新渲染），参考图 4-18 中的 Rerender。

先来看看初始化数据绑定的写法。代码清单 4-13 中，我们已经为 Page 方法的 data 对象填充了一些属性数据。现在，只需要对 post.wxml 文件做一些改动，即可让 wxml 能够「接收」这些初始化数据。小程序使用 Mustache 语法双大括号 {{}} 在 wxml 组件里进行数据的绑定。我们试着用数据绑定的方式来显示《小时候的冰棍儿与雪糕》这篇文章，更改这篇文章的 wxml 代码，如代码清单 4-14 所示。注意，post.wxml 文件里总共有 3 篇文章，但我们只更改了第一篇文章的相关代码，其他两篇文章依然使用硬编码的方式来填充数据。

保存后可以看到，页面并没有变化，第一篇文章的数据正常地显示了出来，这说明数据绑定成功了。可以看到双大括号中写入了一些变量名。细心的开发者应该发现 {{}} 里的变量名称同 js 文件里 data 对象的属性名称是相同的。可见，数据绑定非常简单，只要将 data 对象的属性名填入到双大括号中即可。MINA 框架会自动在运行时用 data 数据替换这些 {{}}。比如 {{date}｝，在运行后将被替换为「Jan 28 2017」，而 {{readingNum} 将被替换为「92」。

我们用图 4-18 页面生命周期图解这张图，解释一下初始化数据绑定的过程。

可以看到双大括号中写入了一些变量名。细心的开发者应该发现 {{}} 里的变量名称同 js 文件里 data 对象的属性名称是相同的。可见，数据绑定非常简单，只要将 data 对象的属性名填入到双大括号中即可。MINA 框架会自动在运行时用 data 数据替换这些 {{}}。比如 {{date}｝，在运行后将被替换为「Jan 28 2017」，而 {{readingNum} 将被替换为「92」。

我们用图 4-18 页面生命周期图解这张图，解释一下初始化数据绑定的过程。当页面执行了 onshow 函数后，逻辑层会收到一个通知（Notify）；随后逻辑层会将 data 对象以 json 的形式发送到 View 视图层（Send Initial Data），视图层接收初始化数据后，开始渲染并示初始化数据（First Render），最终将数据呈现在开发者的眼前。这里需要注意，如果数据绑定是作用在组件的属性中，比如 \<image src="{{avatar}}"/>，则定要在 {{}} 外边加上双引号，否则小程序会报错。如果是内容型的数据绑定，则不需要加双引号，比如 \<text>{{date}}\</text。












